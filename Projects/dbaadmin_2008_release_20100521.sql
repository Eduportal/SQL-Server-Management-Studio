
/****************************************************
CHANGE DATABASE OWNER for Database: dbaadmin
****************************************************/
USE master;
GO
 
ALTER AUTHORIZATION ON DATABASE::dbaadmin TO sa;
GO


/**************************************************************
Set Database Options: dbaadmin
**************************************************************/
USE master;
GO


ALTER DATABASE [dbaadmin] SET AUTO_CLOSE OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET AUTO_SHRINK OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET MULTI_USER WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET TORN_PAGE_DETECTION ON WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET RECOVERY SIMPLE WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET ANSI_NULL_DEFAULT OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET ANSI_NULLS OFF WITH NO_WAIT
go
 
ALTER DATABASE [dbaadmin] SET ANSI_PADDING OFF WITH NO_WAIT
go
 
ALTER DATABASE [dbaadmin] SET ANSI_WARNINGS OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET ARITHABORT OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET AUTO_CREATE_STATISTICS ON WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET AUTO_UPDATE_STATISTICS ON WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET CONCAT_NULL_YIELDS_NULL OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET CURSOR_CLOSE_ON_COMMIT OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET DB_CHAINING OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET CURSOR_DEFAULT GLOBAL WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET NUMERIC_ROUNDABORT OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET QUOTED_IDENTIFIER OFF WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET READ_WRITE  WITH NO_WAIT
go

ALTER DATABASE [dbaadmin] SET RECURSIVE_TRIGGERS OFF WITH NO_WAIT
go


























/**************************************************************
General Mods: dbaadmin
**************************************************************/

use [msdb]
go


If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - SQL Perf Log Process'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - SQL Perf Log Process', @enabled = 0
   end
go


If exists (Select * from msdb.dbo.sysjobs where (name = N'DBA - Test LogParser'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'DBA - Test LogParser', @enabled = 0
   end
go



USE master;
GO
EXEC sp_configure 'show advanced option', '1';
RECONFIGURE WITH OVERRIDE;
go







use dbaadmin
go



--  create new dbaperf DB  -------------------------------------------------
If not exists(select 1 from master.sys.databases where name = 'dbaperf')
   begin
	declare 
		 @mdf_path	sysname
		,@ldf_path	sysname
		,@cmd		nvarchar(4000)
		,@charpos	int

	Select @mdf_path = (select filename from dbaadmin.sys.sysfiles where filename like '%mdf%')
	Select @mdf_path = reverse(@mdf_path)
	Select @charpos = charindex('\', @mdf_path)
	IF @charpos <> 0
	   begin
		Select @mdf_path = substring(@mdf_path, @charpos+1, len(@mdf_path))
	   end
	Select @mdf_path = reverse(@mdf_path)


	Select @ldf_path = (select filename from dbaadmin.sys.sysfiles where filename like '%ldf%')
	Select @ldf_path = reverse(@ldf_path)
	Select @charpos = charindex('\', @ldf_path)
	IF @charpos <> 0
	   begin
		Select @ldf_path = substring(@ldf_path, @charpos+1, len(@ldf_path))
	   end
	Select @ldf_path = reverse(@ldf_path)


	--  Create the new DB
	select @cmd = 'use Master CREATE DATABASE [dbaperf]
	ON
	PRIMARY
	( NAME = ''dbaperf''
	 ,FILENAME = ''' + @mdf_path + '\dbaperf.mdf''
	 ,SIZE = 4096KB
	 ,MAXSIZE = N''Unlimited''
	 ,FILEGROWTH = 1024KB )
	LOG ON
	( NAME = ''dbaperf_log''
	 ,FILENAME = ''' + @ldf_path + '\dbaperf_log.ldf''
	 ,SIZE = 2048KB
	 ,MAXSIZE = N''Unlimited''
	 ,FILEGROWTH = 1024KB )'
	print @cmd
	print ''
	exec(@cmd)


	--  Update DB owner
	Select @cmd = 'use master ALTER AUTHORIZATION ON DATABASE::dbaperf TO sa;'
	print @cmd
	print ''
	exec(@cmd)


	--  Add DB roles
	Select @cmd = 'use dbaperf CREATE ROLE [role_poweruser] AUTHORIZATION [dbo];'
	print @cmd
	print ''
	exec(@cmd)

	Select @cmd = 'use dbaperf CREATE ROLE [role_guest] AUTHORIZATION [dbo];'
	print @cmd
	print ''
	exec(@cmd)


	--  Add build table
	Select @cmd = 'CREATE TABLE dbaperf.[dbo].[Build] (
		[iBuildID] [int] IDENTITY(1,1) PRIMARY KEY ,
		[vchName] [nvarchar] (40) NOT NULL ,
		[vchLabel] [nvarchar] (100) NOT NULL ,
		[dtBuildDate] [datetime] DEFAULT GETDATE() NOT NULL ,
		[vchNotes] [nvarchar] (255) NULL 
	) ON [PRIMARY]'
	exec (@cmd)
   end
go




































/**************************************************************
Database Deletes: dbaadmin
**************************************************************/

use dbaadmin
go

delete from dbo.Compress_BackupInfo where sqlname <> @@servername
go


USE master
go





USE msdb
go

--*************************************************************************************************
-- Delete job: UTIL - DBA Archive process
--**************************************************************************************************
declare @job_id uniqueidentifier

select @job_id = (select top 1 job_id from msdb.dbo.sysjobs where name like '%UTIL - DBA Archive process%')

if @job_id is not null
   begin
	EXEC msdb.dbo.sp_delete_job @job_name = N'UTIL - DBA Archive process'
   end
go


































/**************************************************************
Alerts: dbaadmin
**************************************************************/

--  Add dbaadmin related messages
USE master
go




If not exists (select * from master.sys.messages where message_id = 67015)
   begin
	exec sp_addmessage 67015, 1, "DBA Warning:  %s" , us_english, TRUE, REPLACE
   end
go


If not exists (select * from master.sys.messages where message_id = 67016)
   begin
	exec sp_addmessage 67016, 16, "ERROR: 67016 DBA Error:  %s" , us_english, TRUE, REPLACE
   end
go


If not exists (select * from master.sys.messages where message_id = 67020)
   begin
	exec sp_addmessage 67020, 1, "DBA Warning:  Extended blocking has been detected on server %s." , us_english, TRUE, REPLACE
   end
go


If not exists (select * from master.sys.messages where message_id = 67021)
   begin
	exec sp_addmessage 67021, 1, "DBA Warning:  SQL REPLICATION error detected from source %s.  Error code is %s.  Error text is: %s" , us_english, TRUE, REPLACE
   end
go


If not exists (select * from master.sys.messages where message_id = 67022)
   begin
	exec sp_addmessage 67022, 1, "DBA Warning:  SQL MAINT job step failure detected.  %s %s" , us_english, TRUE, REPLACE
   end
go
 

If not exists (select * from master.sys.messages where message_id = 67023)
   begin
	exec sp_addmessage 67023, 1, "ERROR: 67023 DBA Warning: SQL job step failure detected.  %s %s" , us_english, TRUE, REPLACE
   end
go


If not exists (select * from master.sys.messages where message_id = 67024)
   begin
	exec sp_addmessage 67024, 1, "DBA Warning:  SQL mail (SMTP) failure detected.  %s %s" , us_english, TRUE, REPLACE
   end
go


If not exists (select * from master.sys.messages where message_id = 67025)
   begin
	exec sp_addmessage 67025, 1, "DBA Warning:  Application related warning.  %s " , us_english, TRUE, REPLACE
   end
go


If not exists (select * from master.sys.messages where message_id = 68001)
   begin
	exec sp_addmessage 68001, 1, "DBA Filescan:  %s" , us_english, TRUE, REPLACE
   end
go



--  Add dbaadmin related alerts
USE msdb
go
 
If not exists (select * from msdb.dbo.sysalerts where name = N'Extended Blocking')
   begin
 exec sp_add_alert @name = 'Extended Blocking'
                       ,@message_id = 67020
                       ,@severity = 0
                       ,@enabled = 1
                       ,@delay_between_responses = 60
                       ,@include_event_description_in = 5
                       ,@category_name = '[Uncategorized]'
   end
Else
   begin
      Print 'Warning: Alert ''Extended Blocking'' already exists'
   end
go
 



If not exists (select * from msdb.dbo.sysalerts where name = N'Replication Error')
   begin
 exec sp_add_alert @name = 'Replication Error'
                       ,@message_id = 67021
                       ,@severity = 0
                       ,@enabled = 1
                       ,@delay_between_responses = 60
                       ,@include_event_description_in = 5
                       ,@category_name = '[Uncategorized]'
   end
Else
   begin
      Print 'Warning: Alert ''Replication Error'' already exists'
   end
go
 


If not exists (select * from msdb.dbo.sysalerts where name = N'MAINT job step failure')
   begin
 exec sp_add_alert @name = 'MAINT job step failure'
                       ,@message_id = 67022
                       ,@severity = 0
                       ,@enabled = 1
                       ,@delay_between_responses = 60
                       ,@include_event_description_in = 5
                       ,@category_name = '[Uncategorized]'
   end
Else
   begin
      Print 'Warning: Alert ''MAINT job step failure'' already exists'
   end
go


 
If not exists (select * from msdb.dbo.sysalerts where name = N'SQL job step failure')
   begin
 exec sp_add_alert @name = 'SQL job step failure'
                       ,@message_id = 67023
                       ,@severity = 0
                       ,@enabled = 1
                       ,@delay_between_responses = 60
                       ,@include_event_description_in = 5
                       ,@category_name = '[Uncategorized]'
   end
Else
   begin
      Print 'Warning: Alert ''SQL job step failure'' already exists'
   end
go
 


If not exists (select * from msdb.dbo.sysalerts where name = N'SQL Mail SMTP failure')
   begin
 exec sp_add_alert @name = 'SQL Mail SMTP failure'
                       ,@message_id = 67024
                       ,@severity = 0
                       ,@enabled = 1
                       ,@delay_between_responses = 60
                       ,@include_event_description_in = 5
                       ,@category_name = '[Uncategorized]'
   end
Else
   begin
      Print 'Warning: Alert ''SQL Mail SMTP failure'' already exists'
   end
go





































/**************************************************************
Tables and Data: dbaadmin
**************************************************************/
Use dbaadmin
go




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[Local_ServerEnviro]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
   begin
	CREATE TABLE [dbo].[Local_ServerEnviro] (
	[env_type] [sysname] NOT NULL ,
	[env_detail] [sysname] NOT NULL 
	) ON [PRIMARY]
   end
GO

if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[No_Check]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[No_Check](
	[nocheckID] [int] IDENTITY(1,1) NOT NULL,
        [NoCheck_type] [nvarchar](128) NULL,
	[detail01] [nvarchar](128) NULL,
	[detail02] [nvarchar](128) NULL,
	[detail03] [nvarchar](128) NULL,
	[detail04] [nvarchar](128) NULL,
	[addedby] [sysname] NOT NULL DEFAULT (suser_sname()),
	[createdate] [datetime] NULL DEFAULT (getdate()),
	[moddate] [datetime] NULL DEFAULT (getdate()),
 CONSTRAINT [PK_DBA_NoCheck] PRIMARY KEY CLUSTERED 
	(
		[nocheckID] ASC
	)
) ON [PRIMARY]
GO
if not exists (select * from sys.sysobjects where id = object_id(N'[dbo].[DisabledJobs]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DisabledJobs] (
	[Job_ID] [varchar] (50) NOT NULL,
	[JobName] [sysname] NOT NULL,
	[Disable_date] [datetime] NOT NULL DEFAULT GETDATE()
) ON [PRIMARY] 
GO
if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[defrag_table_info]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[defrag_table_info] (
	[defrag_dbname] [sysname] NOT NULL ,
	[defrag_tablename] [sysname] NOT NULL ,
	[defrag_indexname] [sysname] NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[fragmentation_LOG]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[fragmentation_LOG] (
	[frag_DBname] [sysname] NOT NULL ,
	[frag_TBLname] [sysname] NOT NULL ,
	[frag_IDXname] [sysname] NOT NULL ,
	[frag_IDX_ID] [int] NULL ,
	[frag_pages] [int] NULL ,
	[frag_frag_pct] [DECIMAL] NULL ,
	[frag_sdensity_pct] [DECIMAL] NULL ,
	[frag_recdate] [datetime] NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[fragmentation_override]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[fragmentation_override] (
	[frag_DBname] [sysname] NOT NULL ,
	[frag_TBLname] [sysname] NOT NULL ,
	[frag_MaxFrag] [DECIMAL] NULL
) ON [PRIMARY] 
GO

if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[fragmentation_nocheck]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[fragmentation_nocheck] (
	[frag_DBname] [sysname] NOT NULL ,
	[frag_TBLname] [sysname] NOT NULL ,
	[frag_ProcessFlag] [nchar] (1) NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[Build]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[Build] (
	[iBuildid] [int] IDENTITY(1,1) NOT NULL,
	[vchName] [varchar] (40) NOT NULL,
	[vchLabel] [varchar] (100) NOT NULL,
	[dtBuildDate] [datetime] NOT NULL DEFAULT GETDATE(), 
	[vchNotes] [varchar] (255) NULL,
	CONSTRAINT PKCL_Build
	 PRIMARY KEY CLUSTERED (iBuildID)
) ON [PRIMARY] 
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[UTIL_Servers]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[UTIL_Servers] (
	[SQLServerID] [int] IDENTITY(1,1) NOT NULL,
	[SQLServerName] [sysname] NOT NULL,
	[SQLServerENV] [sysname] NULL,
	[Active] [char] (1) NOT NULL,
	[Filescan] [char] (1) NOT NULL,
	[SQLmail] [char] (1) NOT NULL,
	[UsageRpts] [char] (1) NOT NULL,
	[SecurityRpts] [char] (1) NOT NULL,
	[modDate] [datetime] NULL,
	[SQL_Version] [nvarchar] (500) NULL,
	[dbaadmin_Version] [sysname] NULL,
	[number_of_userDBs] [int] NULL,
	[size_of_userDBs_MB] [int] NULL,
	[SQL_install_date] [datetime] NULL,
	[backup_type] [sysname] NULL,
	[LiteSpeed_Version] [sysname] NULL,
	[RedGate_version] [sysname] NULL,
	[DomainName] [sysname] NULL,
	[SQLrecycle_date] [sysname] NULL,
	[awe_enabled] [char] (1) NULL,
	[MAXdop_value] [nvarchar] (5) NULL,
	[SQLmax_memory] [nvarchar] (20) NULL,
	[tempdb_filecount] [nvarchar] (10) NULL,
	[iscluster] [char] (1) NULL,
	[Port] [nvarchar] (10) NULL,
	[IPnum] [sysname] NULL,
	[CPUnum] [sysname] NULL,
	[CPUtype] [sysname] NULL,
	[Memory] [sysname] NULL,
	[OSname] [sysname] NULL,
	[OSver] [sysname] NULL,
	[OSuptime] [sysname] NULL,
	[boot_3gb] [char] (1) NULL,
	[boot_pae] [char] (1) NULL,
	[boot_userva] [char] (1) NULL,
	[Pagefile_size] [sysname] NULL,
	[SystemModel] [sysname] NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.sysindexes where name = 'IX_clust_UTIL_Servers')
   begin
	CREATE  UNIQUE  INDEX [IX_clust_UTIL_Servers] ON [dbo].[UTIL_Servers]([SQLServerName]) ON [PRIMARY]
   end
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_ServerInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_ServerInfo] (
	[SQLServerID] [int] IDENTITY(1,1) NOT NULL,
	[ServerName] [sysname] NOT NULL,
	[ServerType] [sysname] NULL,
	[SQLName] [sysname] NOT NULL,
	[SQLEnv] [sysname] NULL,
	[Active] [char] (1) NOT NULL,
	[Filescan] [char] (1) NOT NULL,
	[SQLmail] [char] (1) NOT NULL,
	[modDate] [datetime] NULL,
	[SQLver] [nvarchar] (500) NULL,
	[SQLinstallDate] [datetime] NULL,
	[SQLinstallBy] [sysname] NULL,
	[SQLrecycleDate] [sysname] NULL,
	[SQLSvcAcct] [sysname] NULL,
	[SQLAgentAcct] [sysname] NULL,
	[SQLStartupParms] [sysname] NULL,
	[SQLScanforStartupSprocs] [char] (1) NULL,
	[dbaadmin_Version] [sysname] NULL,
	[dbaperf_Version] [sysname] NULL,
	[DEPLinfo_Version] [sysname] NULL,
	[backup_type] [sysname] NULL,
	[LiteSpeed] [char] (1) NULL,
	[RedGate] [char] (1) NULL,
	[awe_enabled] [char] (1) NULL,
	[MAXdop_value] [nvarchar] (5) NULL,
	[Memory] [sysname] NULL,
	[SQLmax_memory] [nvarchar] (20) NULL,
	[tempdb_filecount] [nvarchar] (10) NULL,
	[FullTextCat] [char] (1) NULL,
	[Assemblies] [char] (1) NULL,
	[Mirroring] [char] (1) NULL,
	[Repl_Flag] [char] (1) NULL,
	[LogShipping] [char] (1) NULL,
	[LinkedServers] [char] (1) NULL,
	[ReportingSvcs] [char] (1) NULL,
	[LocalPasswords] [char] (1) NULL,
	[DEPLstatus] [char] (1) NULL,
	[OracleClient] [sysname] NULL,
	[TNSnamesPath] [sysname] NULL,
	[DomainName] [sysname] NULL,
	[iscluster] [char] (1) NULL,
	[SAN] [char] (1) NULL,
	[Port] [nvarchar] (10) NULL,
	[Location] [sysname] NULL,
	[IPnum] [sysname] NULL,
	[CPUphysical] [sysname] NULL,
	[CPUcore] [sysname] NULL,
	[CPUlogical] [sysname] NULL,
	[CPUtype] [sysname] NULL,
	[OSname] [sysname] NULL,
	[OSver] [sysname] NULL,
	[OSinstallDate] [sysname] NULL,
	[OSuptime] [sysname] NULL,
	[MDACver] [sysname] NULL,
	[IEver] [sysname] NULL,
	[AntiVirus_type] [sysname] NULL,
	[AntiVirus_Excludes] [char] (1) NULL,
	[boot_3gb] [char] (1) NULL,
	[boot_pae] [char] (1) NULL,
	[boot_userva] [char] (1) NULL,
	[Pagefile_maxsize] [sysname] NULL,
	[Pagefile_available] [sysname] NULL,
	[Pagefile_inuse] [sysname] NULL,
	[Pagefile_path] [sysname] NULL,
	[TimeZone] [sysname] NULL,
	[SystemModel] [sysname] NULL,
	[MOMverifyDate] [datetime] NULL
) ON [PRIMARY] 
GO

if not exists (select * from sys.sysindexes where name = 'IX_clust_DBA_ServerInfo')
   begin
	CREATE  UNIQUE  INDEX [IX_clust_DBA_ServerInfo] ON [dbo].[DBA_ServerInfo]([SQLName]) ON [PRIMARY]
   end
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_DBInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_DBInfo](
	[SQLName] [sysname] NOT NULL,
	[DBName] [sysname] NOT NULL,
	[status] [sysname] NULL,
	[CreateDate] [datetime] NULL,
	[ENVname] [sysname] NULL,
	[ENVnum] [sysname] NULL,
	[Appl_desc] [sysname] NULL,
	[BaselineFolder] [sysname] NULL,
	[BaselineServername] [sysname] NULL,
	[BaselineDate] [sysname] NULL,
	[build] [sysname] NULL,
	[data_size_MB] [nvarchar](18) NULL,
	[log_size_MB] [nvarchar](18) NULL,
	[row_count] [bigint] NULL,
	[RecovModel] [sysname] NULL,
	[FullTextCat] [char](1) NULL,
	[Assemblies] [char](1) NULL,
	[Mirroring] [char](1) NULL,
	[Repl_Flag] [char](1) NULL,
	[LogShipping] [char](1) NULL,
	[ReportingSvcs] [char](1) NULL,
	[StartupSprocs] [char](1) NULL,
	[modDate] [datetime] NULL,
	[DBCompat] [nvarchar](10) NULL,
	[DEPLstatus] [char] (1) Null
) ON [PRIMARY]
GO

if not exists (select * from sys.sysindexes where name = 'IX_clust_DBA_DBInfo')
   begin
	CREATE  UNIQUE  INDEX [IX_clust_DBA_DBInfo] ON [dbo].[DBA_DBInfo]([SQLName], [DBName]) ON [PRIMARY]
   end
GO


if not exists (select 1 from information_schema.columns where table_name='DBA_DBInfo' and column_name='DEPLstatus')
   begin
	ALTER TABLE dbo.DBA_DBInfo ADD DEPLstatus char(1) Null
   end
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_DeplInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_DeplInfo](
	[DeplInfoId] [bigint] IDENTITY(1,1) NOT NULL,
	[Domain] [varchar](50) NULL,
	[Enviro_Type] [varchar](50) NULL,
	[ServerName] [varchar](50) NULL,
	[SQLName] [varchar](50) NULL,
	[DBName] [varchar](50) NULL,
	[Build_Number] [varchar](50) NULL,
	[Build_Date] [varchar](20) NULL,
	[Baseline_Date] [varchar](20) NULL,
	[Record_Date] [varchar](20) NULL,
 CONSTRAINT [PK_DBA_DeplInfo] PRIMARY KEY CLUSTERED 
(
	[DeplInfoId] ASC
)
) ON [PRIMARY]

GO

if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_ClusterInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_ClusterInfo] (
	[SQLName] [sysname] NOT NULL,
	[ClusterName] [sysname] NULL,
	[ClusterIP] [sysname] NULL,
	[ClusterVer] [sysname] NULL,
	[ClusterSvcAcct] [sysname] NULL,
	[modDate] [datetime] NULL,
	[Quorumgroup] [sysname] NULL,
	[Quorumgroup_node] [sysname] NULL,
	[Quorumgroup_status] [sysname] NULL,
	[DTCgroup] [sysname] NULL,
	[DTCgroup_node] [sysname] NULL,
	[DTCgroup_status] [sysname] NULL,
	[VirtSrv01] [sysname] NULL,
	[VirtSrv01_node] [sysname] NULL,
	[VirtSrv01_status] [sysname] NULL,
	[VirtSrv02] [sysname] NULL,
	[VirtSrv02_node] [sysname] NULL,
	[VirtSrv02_status] [sysname] NULL,
	[VirtSrv03] [sysname] NULL,
	[VirtSrv03_node] [sysname] NULL,
	[VirtSrv03_status] [sysname] NULL,
	[VirtSrv04] [sysname] NULL,
	[VirtSrv04_node] [sysname] NULL,
	[VirtSrv04_status] [sysname] NULL,
	[VirtSrv05] [sysname] NULL,
	[VirtSrv05_node] [sysname] NULL,
	[VirtSrv05_status] [sysname] NULL,
	[clustNode01] [sysname] NULL,
	[clustNode01_IP] [sysname] NULL,
	[clustNode01_status] [sysname] NULL,
	[clustNode02] [sysname] NULL,
	[clustNode02_IP] [sysname] NULL,
	[clustNode02_status] [sysname] NULL,
	[clustNode03] [sysname] NULL,
	[clustNode03_IP] [sysname] NULL,
	[clustNode03_status] [sysname] NULL,
	[clustNode04] [sysname] NULL,
	[clustNode04_IP] [sysname] NULL,
	[clustNode04_status] [sysname] NULL,
	[clustNode05] [sysname] NULL,
	[clustNode05_IP] [sysname] NULL,
	[clustNode05_status] [sysname] NULL
) ON [PRIMARY] 
GO

if not exists (select * from sys.sysindexes where name = 'IX_clust_DBA_ClusterInfo')
   begin
	CREATE  UNIQUE  INDEX [IX_clust_DBA_ClusterInfo] ON [dbo].[DBA_ClusterInfo]([SQLName]) ON [PRIMARY]
   end
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_CommentInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_CommentInfo] (
	[SQLName] [sysname] NOT NULL,
	[CommentNum] [int] IDENTITY (1, 1) NOT NULL ,
	[CommentTitle] [nvarchar] (128) NULL ,
	[CommentText] [ntext] NULL 
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO

if not exists (select * from sys.sysindexes where name = 'IX_DBA_CommentInfo')
   begin
	CREATE  UNIQUE  INDEX [IX_DBA_CommentInfo] ON [dbo].[DBA_CommentInfo] 
	(
		[SQLName],
		[CommentNum]
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
   end
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_DiskInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_DiskInfo](
	[SQLName] [sysname] NOT NULL,
	[Active] [char] (1) NOT NULL,
	[DriveName] [sysname] NOT NULL,
	[DriveSize] [int] NULL,
	[DriveFree] [int] NULL,
	[DriveFree_pct] [int] NULL,
	[modDate] [datetime] NULL
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_DiskPerfinfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_DiskPerfinfo](
	[SQLname] [sysname] NOT NULL,
	[MasterPath] [nvarchar](500) NULL,
	[Master_Push_BytesSec] bigint NULL,
	[Master_Pull_BytesSec] bigint NULL,
	[MDFPath] [nvarchar](500) NULL,
	[MDF_Push_BytesSec] bigint NULL,
	[MDF_Pull_BytesSec] bigint NULL,
	[LDFPath] [nvarchar](500) NULL,
	[LDF_Push_BytesSec] bigint NULL,
	[LDF_Pull_BytesSec] bigint NULL,
	[TempdbPath] [nvarchar](500) NULL,
	[Tempdb_Push_BytesSec] bigint NULL,
	[Tempdb_Pull_BytesSec] bigint NULL,
	[CreateDate] [datetime] NOT NULL
) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBA_UserLoginInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DBA_UserLoginInfo](
	[SQLName] [sysname] NOT NULL,
	[Active] [char] (1) NOT NULL,
	[ULname] [sysname] NULL,
	[ULtype] [sysname] NULL,
	[ULsubname] [sysname] NULL,
	[DBname] [sysname] NULL,
	[SYSadmin] [char](1) NULL,
	[DBOflag] [char](1) NULL,
	[DirectGrants] [char](1) NULL,
	[SQL_createDate] [datetime] NULL,
	[modDate] [datetime] NULL
) ON [PRIMARY]
GO





if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[Local_Control]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[Local_Control] (
	[Subject] [sysname] NOT NULL,
	[Detail01] [sysname] NULL,
	[Detail02] [sysname] NULL,
	[Detail03] [sysname] NULL
) ON [PRIMARY] 
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[db_ApplCrossRef]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
   begin
	 CREATE TABLE [dbo].[db_ApplCrossRef] (
	 [seq_id]  [int] IDENTITY (1, 1) NOT NULL ,
	 [db_name] sysname NOT NULL ,
	 [companionDB_name] sysname NULL , 
	 [RSTRfolder] sysname NULL , 
	 [Appl_desc] sysname NULL , 
	 [baseline_srvname] sysname NULL 
	 ) ON [PRIMARY]
   end
go





if not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[FailedJobs]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[FailedJobs] (
	[instance_ID] [int] NOT NULL,
	[Job_ID] [uniqueidentifier] NOT NULL,
	[run_status] [int] NOT NULL,
	[run_date] [int] NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[filescan_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[filescan_current] (
	[fulltext] [nchar] (256)  NULL
) ON [PRIMARY]
GO

--if not exists (select * from sys.sysindexes where name = 'IX_filescan_current')
--   begin
--	CREATE INDEX [IX_filescan_current] ON [dbo].[filescan_current]([fulltext]) ON [PRIMARY]
--   end
--GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[filescan_central]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[filescan_central](
	[fc_ID] [int] IDENTITY(1,1) NOT NULL,
        [fulltext] [nchar] (256)  NULL,
	[reported] [char](1) NULL
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[filescan_temp]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[filescan_temp] (
	[fulltext] [nchar] (256)  NULL 
) ON [PRIMARY]
GO

if not exists (select * from sys.sysindexes where name = 'IX_filescan_temp')
   begin
	CREATE INDEX [IX_filescan_temp] ON [dbo].[filescan_temp]([fulltext]) ON [PRIMARY]
   end
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[filescan_exclude]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[filescan_exclude] (
	[scantext] [nchar] (125)  NULL ,
	[useflag] [nchar] (1)  NOT NULL 
) ON [PRIMARY]
GO

if not exists (select * from sys.sysindexes where name = 'IX_filescan_exclude')
   begin
	CREATE INDEX [IX_filescan_exclude] ON [dbo].[filescan_exclude]([scantext]) ON [PRIMARY]
   end
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[filescan_strings]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[filescan_strings](
	[fs_ID] [int] IDENTITY(1,1) NOT NULL,
        [fs_type] sysname  NOT NULL,
	[fs_string] sysname NOT NULL
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[depl_server_db_list]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[depl_server_db_list] (
	[TBL_ID] [int] IDENTITY(1,1) NOT NULL ,
	[Parent_name] sysname NOT NULL , 
	[App_name] sysname NOT NULL , 
	[depl_servername] sysname NOT NULL , 
	[depl_ENVname] sysname NOT NULL ,
	[depl_ENVnum] sysname NOT NULL ,
	[depl_restore_folder] sysname NOT NULL ,
	[depl_DBname] sysname NOT NULL ,
	[Active] [nvarchar] (10) NOT NULL ,
	[push_to_nxt] [nchar] (1) NOT NULL ,
	[depl_Baseline_servername] sysname NOT NULL ,
	[modDate] [datetime] NULL,
	CONSTRAINT PKCL_depl_servername
	 PRIMARY KEY CLUSTERED (depl_servername, TBL_ID)
) ON [PRIMARY] 



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[FileTransit_LOG]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[FileTransit_LOG] (
	[ftFileName] [nvarchar] (2000) NOT NULL ,
	[ftSourceDomain] [sysname] NOT NULL ,
	[ftStatus] [sysname] NOT NULL ,
	[ftProcessDate] [datetime] NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[check_contention]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[check_contention] (
	[CCID] [int] IDENTITY(1,1) NOT NULL,
	[CreateDate] [datetime] NOT NULL DEFAULT GETDATE(), 
	[spid] smallint NOT NULL,
	[Headblocker] [nchar] (1) NOT NULL,
	[VictimBlockCount] int NOT NULL,
	[VictimMaxWaittime] bigint NULL,
	[kpid] smallint NOT NULL,
	[Blocked] smallint NOT NULL,
	[waittype] [binary] (2) NULL ,
	[Waittime] bigint NULL,
	[Lastwaittype] [nvarchar] (2000) NULL,
	[Waitresource] [nvarchar] (2000) NULL,
	[Status] [nvarchar] (30) NULL,
	[OpenTran] smallint NOT NULL,
	[Dbid] smallint NOT NULL,
	[Hostname] sysname NULL,
	[Loginame] sysname NULL,
	[ProgramName] sysname NULL,
	[Cmd] [nvarchar] (16) NULL,
	[InputBuffer] [varchar] (8000) NULL,
	CONSTRAINT PKCL_check_contention2
	 PRIMARY KEY CLUSTERED (CCID)
) ON [PRIMARY] 
GO


if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'check_contention'
  and so.id = sc.id
  and sc.name = 'VictimMaxWaittime'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.check_contention ALTER COLUMN VictimMaxWaittime bigint ;
   end

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'check_contention'
  and so.id = sc.id
  and sc.name = 'VictimBlockCount'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.check_contention ALTER COLUMN VictimBlockCount int ;
   end

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'check_contention'
  and so.id = sc.id
  and sc.name = 'Waittime'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.check_contention ALTER COLUMN Waittime bigint ;
   end

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'check_contention'
  and so.id = sc.id
  and sc.name = 'InputBuffer'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.check_contention ALTER COLUMN InputBuffer varchar(8000) ;
   end

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'check_contention'
  and so.id = sc.id
  and sc.name = 'Lastwaittype'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.check_contention ALTER COLUMN Lastwaittype nvarchar(2000) ;
   end

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'check_contention'
  and so.id = sc.id
  and sc.name = 'Waitresource'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.check_contention ALTER COLUMN Waitresource nvarchar(2000) ;
   end

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[check_contention]') AND name = N'check_contention_ix3')
CREATE NONCLUSTERED INDEX [check_contention_ix3] ON [dbo].[check_contention] 
(
	[CreateDate] ASC,
	[Headblocker] DESC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[block_temp_buffer]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[block_temp_buffer] (
	[EventType] [varchar] (20) NULL ,
	[Parameters] [int] NULL ,
	[EventInfo] [varchar] (255) NULL 
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBAperf_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DBAperf_current] (
	[rundate] datetime NOT NULL , 
	[connections] [int] NULL ,
	[cpu_busy] [int] NULL ,
	[total_read] [int] NULL ,
	[total_write] [int] NULL ,
	[TransPerSec] [numeric](16,2) NULL,
	[LockWaitSec] [numeric](16,2) NULL,
	[LatchWaitSec] [numeric](16,2) NULL,
	[BatchReqSec] [numeric](16,2) NULL,
	[ComplSec] [numeric](16,2) NULL,
	[ReComplSec] [numeric](16,2) NULL,
	constraint pk_DBAperf_current primary key (rundate)
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DBAperf_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DBAperf_log] (
	[rundate] datetime NOT NULL , 
	[spidcount] [int] NOT NULL ,
	[connections] [int] NULL ,
	[cpu_busy] [int] NULL ,
	[total_read] [int] NULL ,
	[total_write] [int] NULL ,
	[TransPerSec] [numeric](12,2) NULL,
	[LockWaitSec] [numeric](12,2) NULL,
	[BuffCacheHitRatio] [float] NULL,
	[LatchWaitSec] [numeric](12,2) NULL,
	[BatchReqSec] [numeric](12,2) NULL,
	[ComplSec] [numeric](12,2) NULL,
	[ReComplSec] [numeric](12,2) NULL,
	[mem_BuffDist_Stolen] [bigint] NULL,
	[mem_BuffDist_Free] [bigint] NULL,
	[mem_BuffCount_Hashed] [bigint] NULL,
	[mem_BuffCount_IntResv] [bigint] NULL,
	[mem_BuffCount_ExtResv] [bigint] NULL,
	[mem_QMemObj_AvalBuffs] [bigint] NULL ,
	constraint pk_DBAperf_log primary key (rundate)
) ON [PRIMARY]
GO

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'DBAperf_log'
  and so.id = sc.id
  and sc.name = 'mem_BuffDist_Stolen'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.DBAperf_log ALTER COLUMN mem_BuffDist_Stolen bigint ;
   end
go

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'DBAperf_log'
  and so.id = sc.id
  and sc.name = 'mem_BuffDist_Free'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.DBAperf_log ALTER COLUMN mem_BuffDist_Free bigint ;
   end
go

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'DBAperf_log'
  and so.id = sc.id
  and sc.name = 'mem_BuffCount_Hashed'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.DBAperf_log ALTER COLUMN mem_BuffCount_Hashed bigint ;
   end
go

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'DBAperf_log'
  and so.id = sc.id
  and sc.name = 'mem_BuffCount_IntResv'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.DBAperf_log ALTER COLUMN mem_BuffCount_IntResv bigint ;
   end

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'DBAperf_log'
  and so.id = sc.id
  and sc.name = 'mem_BuffCount_ExtResv'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.DBAperf_log ALTER COLUMN mem_BuffCount_ExtResv bigint ;
   end

if exists (select 1 from sys.sysobjects so, sys.syscolumns sc
where so.name = 'DBAperf_log'
  and so.id = sc.id
  and sc.name = 'mem_QMemObj_AvalBuffs'
  and sc.xtype <> 127)
   begin
	ALTER TABLE dbo.DBAperf_log ALTER COLUMN mem_QMemObj_AvalBuffs bigint ;
   end
go



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[Periodic_Errors]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[Periodic_Errors] (
	[error_id] [int] IDENTITY(1,1) NOT NULL,
	[alert_num] [int] NOT NULL,
	[Message_text] [varchar] (4000) NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[table_stats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[table_stats_log] (
	[rundate] [datetime] NOT NULL ,
	[dbname] [sysname] NOT NULL ,
	[tblname] [sysname] NOT NULL ,
	[rows] [bigint] NOT NULL ,
	[rowmodctr] [int] NOT NULL ,
	[reserved_space] [varchar] (18) NULL ,
	[data_space_used] [varchar] (18) NULL ,
	[index_size_used] [varchar] (18) NULL ,
	[unused_space] [varchar] (18) NULL
) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[table_stats_log]') AND name = N'table_stats_log_ix1')
CREATE CLUSTERED INDEX [table_stats_log_ix1] ON [dbo].[table_stats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[table_stats_log]') AND name = N'table_stats_log_ix2')
CREATE NONCLUSTERED INDEX [table_stats_log_ix2] ON [dbo].[table_stats_log] 
(
	[dbname] ASC,
	[tblname] ASC,
	[rows] ASC,
	[rowmodctr] ASC,
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO

if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[index_stats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[index_stats_log] (
	[rundate] [datetime] NOT NULL ,
	[dbname] [sysname] NOT NULL ,
	[tblname] [sysname] NOT NULL ,
	[index_id] [int] NOT NULL ,
	[partition_number] [int] NOT NULL ,
	[index_type_desc] [nvarchar] (60) NOT NULL ,
	[alloc_unit_type_desc] [nvarchar] (60) NOT NULL ,
	[index_depth] [tinyint] NOT NULL ,
	[index_level] [tinyint] NOT NULL ,
	[avg_fragmentation_in_percent] [float] NULL ,
	[fragment_count] [bigint] NULL ,
	[avg_fragment_size_in_pages] [float] NULL ,
	[page_count] [bigint] NULL ,
	[avg_page_space_used_in_percent] [float] NULL ,
	[record_count] [bigint] NULL ,
	[ghost_record_count] [bigint] NULL ,
	[version_ghost_record_count] [bigint] NULL ,
	[min_record_size_in_bytes] [int] NULL ,
	[max_record_size_in_bytes] [int] NULL ,
	[avg_record_size_in_bytes] [float] NULL ,
	[forwarded_record_count] [bigint] NULL
    ) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[db_stats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[db_stats_log] (
	[ServerName] [sysname] NOT NULL ,
	[DatabaseName] [sysname] NOT NULL ,
	[rundate] [datetime] NOT NULL ,
	[database_size_MB] [varchar] (18) NULL ,
	[unallocated space_MB] [varchar] (18) NULL ,
	[reserved_space_KB] [varchar] (18) NULL ,
	[data_space_used_KB] [varchar] (18) NULL ,
	[index_size_used_KB] [varchar] (18) NULL ,
	[unused_space_KB] [varchar] (18) NULL ,
	[log_size_MB] [varchar] (18) NULL ,
	[log_space_used_pct] [varchar] (18) NULL
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[fixeddisk_stats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[fixeddisk_stats_log] (
	[ServerName] [varchar] (30)  NULL ,
	[rundate] [datetime] NULL ,
	[Drive01name] [char] (10)  NULL ,
	[Drive01free] [int] NULL ,
	[Drive02name] [char] (10)  NULL ,
	[Drive02free] [int] NULL ,
	[Drive03name] [char] (10)  NULL ,
	[Drive03free] [int] NULL ,
	[Drive04name] [char] (10)  NULL ,
	[Drive04free] [int] NULL ,
	[Drive05name] [char] (10)  NULL ,
	[Drive05free] [int] NULL ,
	[Drive06name] [char] (10)  NULL ,
	[Drive06free] [int] NULL ,
	[Drive07name] [char] (10)  NULL ,
	[Drive07free] [int] NULL ,
	[Drive08name] [char] (10)  NULL ,
	[Drive08free] [int] NULL 
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_IOfile_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_IOfile_current] (
	[rundate] datetime NOT NULL , 
	[database_id] [smallint] NOT NULL ,
	[file_id] [smallint] NOT NULL ,
	[io_stall_read_ms] [bigint] NULL ,
	[num_of_reads] [bigint] NULL ,
	[io_stall_write_ms] [bigint] NULL ,
	[num_of_writes] [bigint] NULL
) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_IOfile_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_IOfile_log] (
	[rundate] datetime NOT NULL , 
	[database_id] [smallint] NOT NULL ,
	[file_id] [smallint] NOT NULL ,
	[io_stall_read_ms] [bigint] NULL ,
	[num_of_reads] [bigint] NULL ,
	[avg_read_stall_ms] [numeric](10,1) NULL ,
	[io_stall_write_ms] [bigint] NULL ,
	[num_of_writes] [bigint] NULL ,
	[avg_write_stall_ms] [numeric](10,1) NULL ,
	[io_stalls_ms] [bigint] NULL ,
	[total_io] [bigint] NULL ,
	[avg_io_stall_ms] [numeric](10,1) NULL
	constraint pk_DMV_IOfile_log primary key (rundate, database_id, file_id)
) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_QueryOpt_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_QueryOpt_current] (
	[rundate] datetime NOT NULL , 
	[counter] [nvarchar] (300) NOT NULL ,
	[occurrence] [bigint] NULL 
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_QueryOpt_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_QueryOpt_log] (
	[rundate] datetime NOT NULL , 
	[counter] [nvarchar] (300) NOT NULL ,
	[occurrence] [bigint] NULL ,
	[value] [float] NULL 
	constraint pk_DMV_QueryOpt_log primary key (rundate, counter)
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_QueryStats_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_QueryStats_current] (
	[qs_id] [int] IDENTITY(1,1) NOT NULL,
	[rundate] [datetime] NOT NULL ,
	[sql_handle] [varbinary] (64) NOT NULL ,
	[plan_handle] [varbinary] (64) NOT NULL ,
	[plan_generation_num] [bigint] NOT NULL ,
	[statement_start_offset] [int] NOT NULL ,
	[total_worker_time] [bigint] NULL ,
	[total_elapsed_time] [bigint] NULL ,
	[total_physical_reads] [bigint] NULL ,
	[total_logical_reads] [bigint] NULL ,
	[total_logical_writes] [bigint] NULL ,
	[execution_count] [bigint] NULL ,
	[dbid] [smallint] NULL ,
	[objectid] [int] NULL
) ON [PRIMARY]
GO

IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_QueryStats_current]') AND name = N'DMV_QueryStats_current_ix1')
drop index [DMV_QueryStats_current_ix1] ON [dbo].[DMV_QueryStats_current]
go

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_QueryStats_current]') AND name = N'DMV_QueryStats_current_ix1')
CREATE CLUSTERED INDEX [DMV_QueryStats_current_ix1] ON [dbo].[DMV_QueryStats_current] 
(
	[rundate] ASC,
	[sql_handle] ASC,
	[plan_handle] ASC,
	[plan_generation_num] ASC,
	[statement_start_offset] ASC,
	[dbid] ASC,
	[objectid] ASC ,
	[qs_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_QueryStats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_QueryStats_log] (
	[rundate] [datetime] NOT NULL ,
	[intrvl_time_S] [bigint] NULL ,
	[dbid] [smallint] NULL ,
	[objectid] [int] NULL ,
	[delta_worker_time] [bigint] NULL ,
	[Avg_CPU_Time_MS] [bigint] NULL ,
	[delta_elapsed_time] [bigint] NULL ,
	[Avg_Elapsed_Time_MS] [bigint] NULL ,
	[delta_physical_reads] [bigint] NULL ,
	[delta_logical_reads] [bigint] NULL ,
	[Avg_Logical_Reads] [bigint] NULL ,
	[delta_logical_writes] [bigint] NULL ,
	[Avg_Logical_Writes] [bigint] NULL ,
	[execution_count] [bigint] NULL ,
	[QueryText] [nvarchar] (max) NULL
) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_QueryStats_log]') AND name = N'DMV_QueryStats_log_ix1')
CREATE CLUSTERED INDEX [DMV_QueryStats_log_ix1] ON [dbo].[DMV_QueryStats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_SpclSprocStats_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_SpclSprocStats_current] (
	[qs_id] [int] IDENTITY(1,1) NOT NULL,
	[rundate] [datetime] NOT NULL ,
	[sql_handle] [varbinary] (64) NOT NULL ,
	[plan_handle] [varbinary] (64) NOT NULL ,
	[plan_generation_num] [bigint] NOT NULL ,
	[statement_start_offset] [int] NOT NULL ,
	[total_worker_time] [bigint] NULL ,
	[total_elapsed_time] [bigint] NULL ,
	[total_physical_reads] [bigint] NULL ,
	[total_logical_reads] [bigint] NULL ,
	[total_logical_writes] [bigint] NULL ,
	[execution_count] [bigint] NULL ,
	[dbid] [smallint] NULL ,
	[objectid] [int] NULL
) ON [PRIMARY]
GO

IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_SpclSprocStats_current]') AND name = N'DMV_SpclSprocStats_current_ix1')
drop index [DMV_SpclSprocStats_current_ix1] ON [dbo].[DMV_SpclSprocStats_current]
go

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_SpclSprocStats_current]') AND name = N'DMV_SpclSprocStats_current_ix1')
CREATE CLUSTERED INDEX [DMV_SpclSprocStats_current_ix1] ON [dbo].[DMV_SpclSprocStats_current] 
(
	[rundate] ASC,
	[sql_handle] ASC,
	[plan_handle] ASC,
	[plan_generation_num] ASC,
	[statement_start_offset] ASC,
	[dbid] ASC,
	[objectid] ASC,
	[qs_id] ASC 
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO





if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_SpclSprocStats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_SpclSprocStats_log] (
	[rundate] [datetime] NOT NULL ,
	[intrvl_time_S] [bigint] NULL ,
	[dbid] [smallint] NULL ,
	[objectid] [int] NULL ,
	[delta_worker_time] [bigint] NULL ,
	[Avg_CPU_Time_MS] [bigint] NULL ,
	[delta_elapsed_time] [bigint] NULL ,
	[Avg_Elapsed_Time_MS] [bigint] NULL ,
	[delta_physical_reads] [bigint] NULL ,
	[delta_logical_reads] [bigint] NULL ,
	[Avg_Logical_Reads] [bigint] NULL ,
	[delta_logical_writes] [bigint] NULL ,
	[Avg_Logical_Writes] [bigint] NULL ,
	[execution_count] [bigint] NULL ,
	[QueryText] [nvarchar] (max) NULL
) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_SpclSprocStats_log]') AND name = N'DMV_SpclSprocStats_log_ix1')
CREATE CLUSTERED INDEX [DMV_SpclSprocStats_log_ix1] ON [dbo].[DMV_SpclSprocStats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_QueryDaily_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_QueryDaily_current] (
	[qs_id] [int] IDENTITY(1,1) NOT NULL,
	[rundate] [datetime] NOT NULL ,
	[sql_handle] [varbinary] (64) NOT NULL ,
	[plan_handle] [varbinary] (64) NOT NULL ,
	[plan_generation_num] [bigint] NOT NULL ,
	[statement_start_offset] [int] NOT NULL ,
	[total_worker_time] [bigint] NULL ,
	[total_elapsed_time] [bigint] NULL ,
	[total_physical_reads] [bigint] NULL ,
	[total_logical_reads] [bigint] NULL ,
	[total_logical_writes] [bigint] NULL ,
	[execution_count] [bigint] NULL ,
	[dbid] [smallint] NULL ,
	[objectid] [int] NULL
	constraint pk_DMV_QueryDaily_current primary key (sql_handle, plan_handle, plan_generation_num, statement_start_offset)
) ON [PRIMARY]
GO

if exists (select * from sys.objects where object_id = object_id(N'[dbo].[pk_DMV_QueryDaily_current]') and OBJECTPROPERTY(object_id, N'IsConstraint') = 1)
ALTER TABLE [DMV_QueryDaily_current] DROP CONSTRAINT pk_DMV_QueryDaily_current
go

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_QueryDaily_current]') AND name = N'DMV_QueryDaily_current_ix1')
CREATE CLUSTERED INDEX [DMV_QueryDaily_current_ix1] ON [dbo].[DMV_QueryDaily_current] 
(
	[rundate] ASC,
	[sql_handle] ASC,
	[plan_handle] ASC,
	[plan_generation_num] ASC,
	[statement_start_offset] ASC,
	[qs_id] ASC  
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_QueryDaily_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_QueryDaily_log] (
	[rundate] [datetime] NOT NULL ,
	[intrvl_time_S] [bigint] NULL ,
	[dbid] [smallint] NULL ,
	[objectid] [int] NULL ,
	[delta_worker_time] [bigint] NULL ,
	[Avg_CPU_Time_MS] [bigint] NULL ,
	[delta_elapsed_time] [bigint] NULL ,
	[Avg_Elapsed_Time_MS] [bigint] NULL ,
	[delta_physical_reads] [bigint] NULL ,
	[delta_logical_reads] [bigint] NULL ,
	[Avg_Logical_Reads] [bigint] NULL ,
	[delta_logical_writes] [bigint] NULL ,
	[Avg_Logical_Writes] [bigint] NULL ,
	[execution_count] [bigint] NULL ,
	[QueryText] [nvarchar] (max) NULL
) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_Memory_Objects_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_Memory_Objects_log] (
	[rundate] [datetime] NOT NULL ,
	[type] [sysname] NOT NULL ,
	[Total_Pages_Allocated_Count] [bigint] NULL 
) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_Memory_Clerks_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_Memory_Clerks_log] (
	[rundate] [datetime] NOT NULL ,
	[type] [sysname] NOT NULL ,
	[Overall_Used_Kb] [bigint] NULL ,
	[Overall_Used_withAWE_Kb] [bigint] NULL ,
	[Single_Pages_Kb] [bigint] NULL ,
	[Multi_Pages_Kb] [bigint] NULL ,
	[AWE_Allocated_Kb] [bigint] NULL
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_WaitStats_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_WaitStats_current] (
	[rundate] [datetime] NOT NULL ,
	[wait_type] [nvarchar] (60) NULL ,
	[waiting_tasks_count] [bigint] NULL ,
	[wait_time_ms] [bigint] NULL ,
	[max_wait_time_ms] [bigint] NULL ,
	[signal_wait_time_ms] [bigint] NULL 
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_WaitStats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_WaitStats_log] (
	[rundate] [datetime] NOT NULL ,
	[intrvl_time_S] [bigint] NULL ,
	[wait_type] [nvarchar] (60) NULL ,
	[waiting_tasks_count] [bigint] NULL ,
	[wait_time_ms] [bigint] NULL ,
	[max_wait_time_ms] [bigint] NULL ,
	[signal_wait_time_ms] [bigint] NULL 
) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_WaitStats_log]') AND name = N'DMV_WaitStats_log_ix1')
CREATE CLUSTERED INDEX [DMV_WaitStats_log_ix1] ON [dbo].[DMV_WaitStats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_IOwaitStats_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_IOwaitStats_current] (
	[rundate] [datetime] NOT NULL ,
	[database_id] [smallint] NULL ,
	[object_id] [int] NULL ,
	[index_id] [int] NULL ,
	[page_io_latch_wait_count] [bigint] NULL ,
	[page_io_latch_wait_in_ms] [bigint] NULL ,
	[range_scan_count] [bigint] NULL ,
	[singleton_lookup_count] [bigint] NULL  
) ON [PRIMARY]
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_IOwaitStats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_IOwaitStats_log] (
	[rundate] [datetime] NOT NULL ,
	[intrvl_time_S] [bigint] NULL ,
	[database_id] [smallint] NULL ,
	[object_id] [int] NULL ,
	[index_id] [int] NULL ,
	[page_io_latch_wait_count] [bigint] NULL ,
	[page_io_latch_wait_in_ms] [bigint] NULL ,
	[range_scan_count] [bigint] NULL ,
	[singleton_lookup_count] [bigint] NULL  
) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_IOwaitStats_log]') AND name = N'DMV_IOwaitStats_log_ix1')
CREATE CLUSTERED INDEX [DMV_IOwaitStats_log_ix1] ON [dbo].[DMV_IOwaitStats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_Blocks]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[DMV_Blocks] (
	[blocks_id] [int] IDENTITY(1,1) NOT NULL,
	[rundate] [datetime] NOT NULL, 
	[head_wait_resource] [nvarchar] (512) NULL,
	[database_name] [sysname] NULL ,
	[object_name] [sysname] NULL ,
	[object_type] [nvarchar] (10) NULL ,
	[session_id] [smallint] NULL,
	[request_id] [smallint] NULL,
	[blocking_session_id] [int] NULL,
	[program_name] [nvarchar] (128) NULL,
	[tree_level] [int] NULL,
	[QueryText] [nvarchar] (max) NULL,
	[sql_handle] [nvarchar] (max) NULL,
	[plan_handle] [nvarchar] (max) NULL,
	[statement_start_offset] [int] NULL,
	[statement_end_offset] [int] NULL,
	[session_or_request_status] [nvarchar] (60) NULL,
	[wait_type] [nvarchar] (60) NULL,
	[wait_time] [int] NULL,
	[wait_resource] [nvarchar] (512) NULL,
	[transaction_id] [bigint] NULL,
	[transaction_isolation_level] [smallint] NULL,
	[open_transaction_count] [int] NULL,
	[seconds_active_idle] [bigint] NULL,
	[transaction_name] [nvarchar] (64) NULL,
	[transaction_begin_time] [datetime] NULL, 
	[transaction_type] [int] NULL,
	[transaction_state] [int] NULL,
	[dtc_state] [int] NULL,
	[dtc_isolation_level] [int] NULL,
	[enlist_count] [int] NULL,
	[is_user_transaction] [bit] NULL,
	[is_local] [bit] NULL,
	[is_enlisted] [bit] NULL,
	[is_bound] [bit] NULL,
	CONSTRAINT PKCL_DMV_Blocks
	 PRIMARY KEY CLUSTERED (blocks_id)
) ON [PRIMARY] 
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_Blocks]') AND name = N'DMV_Blocks_ix2')
CREATE NONCLUSTERED INDEX [DMV_Blocks_ix2] ON [dbo].[DMV_Blocks] 
(
	[rundate] ASC,
	[blocks_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_Indexusage_current]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_Indexusage_current] (
	[rundate] [datetime] NOT NULL ,
	[database_id] [smallint] NOT NULL ,
	[object_id] [int] NOT NULL ,
	[index_id] [int] NOT NULL ,
	[user_seeks] [bigint] NOT NULL ,
	[user_scans] [bigint] NOT NULL ,
	[user_lookups] [bigint] NOT NULL ,
	[user_updates] [bigint] NOT NULL ,
	[system_seeks] [bigint] NOT NULL ,
	[system_scans] [bigint] NOT NULL ,
	[system_lookups] [bigint] NOT NULL ,
	[system_updates] [bigint] NOT NULL
) ON [PRIMARY]
GO

IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_Indexusage_current]') AND name = N'DMV_Indexusage_current_ix1')
drop index [DMV_Indexusage_current_ix1] ON [dbo].[DMV_Indexusage_current]
go

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_Indexusage_current]') AND name = N'DMV_Indexusage_current_ix1')
CREATE CLUSTERED INDEX [DMV_Indexusage_current_ix1] ON [dbo].[DMV_Indexusage_current] 
(
	[rundate] ASC,
	[database_id] ASC,
	[object_id] ASC,
	[index_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_Indexusage_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_Indexusage_log] (
	[rundate] [datetime] NOT NULL ,
	[intrvl_time_S] [bigint] NULL ,
	[database_name] [sysname] NOT NULL ,
	[object_name] [sysname] NULL ,
	[object_type] [char] (2) NULL ,
	[index_name] [sysname] NULL ,
	[user_seeks] [bigint] NOT NULL ,
	[user_scans] [bigint] NOT NULL ,
	[user_lookups] [bigint] NOT NULL ,
	[user_updates] [bigint] NOT NULL ,
	[last_user_seek] [datetime] null ,
	[last_user_scan] [datetime] null ,
	[last_user_lookup] [datetime] null ,
	[last_user_update] [datetime] null ,
	[system_seeks] [bigint] NOT NULL ,
	[system_scans] [bigint] NOT NULL ,
	[system_lookups] [bigint] NOT NULL ,
	[system_updates] [bigint] NOT NULL ,
	[last_system_seek] [datetime] null ,
	[last_system_scan] [datetime] null ,
	[last_system_lookup] [datetime] null ,
	[last_system_update] [datetime] null 
) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_Indexusage_log]') AND name = N'DMV_Indexusage_log_ix1')
CREATE CLUSTERED INDEX [DMV_Indexusage_log_ix1] ON [dbo].[DMV_Indexusage_log] 
(
	[rundate] ASC,
	[database_name] ASC,
	[object_name] ASC,
	[index_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_Tran_Locks]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_Tran_Locks] (
	[rundate] [datetime] NOT NULL ,
	[dbname] [sysname] NULL ,
	[resource_type] [sysname] NULL ,
	[blocked_object] [bigint] NULL ,
	[blocked_ObjectId] [int] NULL ,
	[blocked_ObjectName] [sysname] NULL ,
	[waiting_request_mode] [nvarchar] (60) NULL ,
	[waiting_user_id] [sysname] NULL ,
	[waiting_session_id] [int] NULL ,
	[waiting_Text] [text] NULL ,
	[blocking_user_id] [sysname] NULL ,
	[blocking_session_id] [int] NULL ,
	[blocking_Text] [text] NULL ,
	[sessionPlan] [XML] NULL
) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_Tran_Locks]') AND name = N'DMV_Tran_Locks_ix1')
CREATE CLUSTERED INDEX [DMV_Tran_Locks_ix1] ON [dbo].[DMV_Tran_Locks] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[DMV_always_track_these_objects]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table [dbo].[DMV_always_track_these_objects] (
	[DBname] [sysname] NOT NULL , 
	[ObjectName] [sysname] NOT NULL 
) ON [PRIMARY]
GO





if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[UserDB_Access_Ctrl]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[UserDB_Access_Ctrl] (
	[DBname] [sysname] NOT NULL ,
	[Loginname] [sysname] NOT NULL ,
	[Username] [sysname] NOT NULL ,
	[DBrole] [sysname] NOT NULL ,
	[DfltDB] [sysname] NOT NULL 
	) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[pong_return]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[pong_return] (
	[pong_ID] [int] IDENTITY(1,1) NOT NULL ,
	[pong_stamp] sysname NOT NULL , 
	[pong_servername] sysname NOT NULL , 
	[pong_detail01] sysname NOT NULL ,
	[pong_detail02] sysname NULL
) ON [PRIMARY] 
go


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[Base_Skip_sqb2nxt]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[Base_Skip_sqb2nxt] (
	[SQBname] [sysname] NOT NULL ,
	[modDate] [datetime] NULL 
) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[Compress_BackupInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[Compress_BackupInfo] (
	[servername] [sysname] NOT NULL ,
	[SQLname] [sysname] NOT NULL ,
	[CompType] [sysname] NOT NULL ,
	[Version] [sysname] NULL ,
	[VersionType] [sysname] NULL ,
	[License] [sysname] NULL ,
	[InstallDate] [datetime] NULL ,
	[modDate] [datetime] NULL 
) ON [PRIMARY]
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[Backup_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[Backup_log] (
	[BLid] [int] IDENTITY(1,1) NOT NULL,
	[BackupDate] [datetime] NOT NULL,
	[DBname] [sysname] NOT NULL,
	[Backup_filename] [sysname] NOT NULL,
	[Backup_path] [sysname] NOT NULL,
	[Backup_notes] [sysname] NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[db_sequence]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
   begin
	 CREATE TABLE [dbo].[db_sequence] (
	 [seq_id] [int] NOT NULL ,
	 [db_name] sysname NOT NULL 
	 ) ON [PRIMARY]
   end
go


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[tempdb_filestats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table dbo.tempdb_filestats_log
                                     (    
					  rundate [datetime] not null 
					, phys_data_file_size_KB int
					, phys_log_file_size_KB  int
					, int_alloc_space_used_KB  int
					, int_alloc_space_free_KB  int
					, int_percentage_used decimal(18,2)
					, phys_max_size_KB  varchar(20)
					, phys_num_data_files  int
					, phys_disk_free_space_KB int
					, phys_tempdb_path varchar(255)
					, isShared bit
					, isPreAllocated bit
    	    
				     ) 


GO

if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[tempdb_pagestats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE dbo.tempdb_pagestats_log
	     (	 rundate datetime
	       , logicalfilename sysname
	       , unallocated_extent_page_count bigint 
	       , version_store_reserved_page_count bigint 
	       , user_object_reserved_page_count bigint
	       , internal_object_reserved_page_count bigint
               , mixed_extent_page_count bigint
	     )
GO

if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[tempdb_sessionstats_log]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE dbo.tempdb_sessionstats_log
	     (	 rundate datetime
	       , sessionid int
	       , command sysname
	       , hostname nvarchar(128)
	       , sqlstatement nvarchar(max)
	       , User_Obj_UsedSpace_kb int 
	       , User_Obj_FreeSpace_kb int 
	       , Int_Obj_UsedSpace_kb int
	       , Int_Obj_FreeSpace_kb int
	     )
go



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[WEB_ServerInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[WEB_ServerInfo] (
	[WebServerID] [int] IDENTITY(1,1) NOT NULL,
	[ServerName] [sysname] NOT NULL,
	[ServerType] [sysname] NULL,
	[EnvName] [sysname] NULL,
	[Active] [char] (1) NOT NULL,
	[modDate] [datetime] NOT NULL,
	[OSname] [sysname] NULL,
	[OSver] [sysname] NULL,
	[OSinstallDate] [sysname] NULL,
	[OSuptime] [sysname] NULL,
	[MemoryPhysical_Total] [sysname] NULL,
	[MemoryPhysical_Avail] [sysname] NULL,
	[MemoryVirtual_Total] [sysname] NULL,
	[MemoryVirtual_Avail] [sysname] NULL,
	[Domain] [sysname] NULL,
	[Logon_Server] [sysname] NULL,
	[SAN] [char] (1) NULL,
	[Location] [sysname] NULL,
	[CPUnumber] [sysname] NULL,
	[CPUtype] [sysname] NULL,
	[BiosVer] [sysname] NULL,
	[SMBiosVer] [sysname] NULL,
	[MDACver] [sysname] NULL,
	[IEver] [sysname] NULL,
	[AntiVirus_Type] [sysname] NULL,
	[AntiVirus_Ver] [sysname] NULL,
	[Boot_Loader] [sysname] NULL,
	[Boot_OppSystems] [sysname] NULL,
	[Pagefile_Maxsize] [sysname] NULL,
	[Pagefile_Avail] [sysname] NULL,
	[Pagefile_InUse] [sysname] NULL,
	[Pagefile_path] [sysname] NULL,
	[Path] [nvarchar] (2000) NULL,
	[SystemManufacture] [sysname] NULL,
	[SystemModel] [sysname] NULL,
	[SystemType] [sysname] NULL,
	[MOMverifyDate] [datetime] NULL,
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[WEB_IPconfig]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[WEB_IPconfig] (
	[WebIPID] [int] IDENTITY(1,1) NOT NULL,
	[ServerName] [sysname] NOT NULL,
	[Adapter_name] [sysname] NOT NULL,
	[Adapter_driver] [sysname] NOT NULL,
	[MACaddress] [sysname] NOT NULL,
	[IPtype] [sysname] NULL,
	[IPaddress] [sysname] NULL,
	[IPorder] [int] NULL,
	[Active] [char] (1) NULL,
	[modDate] [datetime] NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[WEB_Driveinfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[WEB_Driveinfo] (
	[WebDRID] [int] IDENTITY(1,1) NOT NULL,
	[ServerName] [sysname] NOT NULL,
	[Drive_name] [nvarchar] (5) NOT NULL,
	[Drive_Size] [sysname] NULL,
	[Drive_Freespace] [sysname] NULL,
	[File_System] [nvarchar] (10) NULL,
	[Compressed] [nvarchar] (10) NULL,
	[Description] [sysname] NULL,
	[Active] [char] (1) NULL,
	[modDate] [datetime] NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[WEB_HOTfix]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[WEB_HOTfix] (
	[WebHFID] [int] IDENTITY(1,1) NOT NULL,
	[ServerName] [sysname] NOT NULL,
	[Hotfix_name] [sysname] NULL,
	[Active] [char] (1) NULL,
	[modDate] [datetime] NOT NULL
) ON [PRIMARY] 
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[WEB_REGinfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[WEB_REGinfo] (
	[WebREGID] [int] IDENTITY(1,1) NOT NULL,
	[ServerName] [sysname] NOT NULL,
	[KEYpath01] [nvarchar] (500) NULL,
	[KEYpath02] [nvarchar] (500) NULL,
	[KEYname] [sysname] NULL,
	[KEYtype] [sysname] NULL,
	[KEYdata] [sysname] NULL,
	[Active] [char] (1) NULL,
	[modDate] [datetime] NOT NULL
) ON [PRIMARY] 
GO



if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[filescan_bcpin]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
create table dbo.filescan_bcpin (fulltext nvarchar (MAX) NULL)
GO


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[LicenseInfo]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[LicenseInfo] (
	[LI_ID] [int] IDENTITY(1,1) NOT NULL,
	[VendorName] [sysname] NULL,
	[Product] [sysname] NULL,
	[Version] [sysname] NULL,
	[Type] [sysname] NULL,
	[LicenseKey] [sysname] NULL,
	[LicenseNum] [int] NULL,
	[Support_ExpDate] [datetime] NULL,
	[active] [char] (1) NULL
) ON [PRIMARY] 
GO





if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[IndexMaintenancePhysicalStats]') and OBJECTPROPERTY(object_id, N'IsTable') = 1)
   begin
	CREATE TABLE [dbo].[IndexMaintenancePhysicalStats](
		[imPhysicalStatsId] [bigint] IDENTITY(1,1) NOT NULL,
		[insert_date] [datetime] NULL,
		[scan_started] [datetime] NULL,
		[database_id] [int] NULL,
		[object_id] [int] NULL,
		[tablename] [nvarchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
		[index_id] [int] NULL,
		[partition_number] [int] NULL,
		[index_depth] [tinyint] NULL,
		[index_level] [tinyint] NULL,
		[avg_fragmentation_in_percent] [float] NULL,
		[page_count] [bigint] NULL,
		[avg_page_space_used_in_percent] [float] NULL,
		[record_count] [bigint] NULL,
		[min_record_size_in_bytes] [int] NULL,
		[max_record_size_in_bytes] [int] NULL,
		[avg_record_size_in_bytes] [float] NULL,
		[user_seeks] [bigint] NULL,
		[user_scans] [bigint] NULL,
		[user_lookups] [bigint] NULL,
		[user_updates] [bigint] NULL,
		[system_seeks] [bigint] NULL,
		[system_scans] [bigint] NULL,
		[system_lookups] [bigint] NULL,
		[system_updates] [bigint] NULL,
		[ActionTaken] [varchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
		[ActionStarted] [datetime] NULL,
		[ActionCompleted] [datetime] NULL,
		[Splits] [int] NULL
	) ON [PRIMARY]

	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Sequential number to identify the row.', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'imPhysicalStatsId'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Datetime at which the object scan started', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'insert_date'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Datetime at which the job run pulling the data started', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'scan_started'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'System Database_Id in which the physical stats are located.', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'database_id'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'System object_id', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'object_id'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Schema + . + tablename on which the index lives', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'tablename'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'System id for the index on the table. 1= clustered index.', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'index_id'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'1-based partition number within the owning object; a table, view, or index. .', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'partition_number'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Number of levels in the given index.', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'index_depth'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Number of level for this row of data. 0= leaf level.', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'index_level'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Level of fragmentation', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'avg_fragmentation_in_percent'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Number of pages at this level of this index.', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'page_count'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Avg page fill-- null if Limited scan was run', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'avg_page_space_used_in_percent'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'Records in this level of this index -- null if Limited scan was run', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'record_count'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'lowest record size for this level of this index-- null if Limited scan was run', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'min_record_size_in_bytes'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'max record size for this level of this index-- null if Limited scan was run', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'max_record_size_in_bytes'
	EXEC sys.sp_addextendedproperty @name=N'description', @value=N'avg record size for this level of this index-- null if Limited scan was run', @level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'IndexMaintenancePhysicalStats', @level2type=N'COLUMN', @level2name=N'avg_record_size_in_bytes'
   end
GO
 

 
------------------------------------------------------------------------------------------------------- 
-- IndexMaintenanceLastRunDetails
------------------------------------------------------------------------------------------------------- 
if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[IndexMaintenanceLastRunDetails]') and OBJECTPROPERTY(object_id, N'IsTable') = 1)
CREATE TABLE [dbo].[IndexMaintenanceLastRunDetails](
        [DatabaseName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
        [TableName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
        [IndexName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
        [Process] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
        [Reason] [varchar](8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[createdate] [datetime] NULL DEFAULT (getdate())
) ON [PRIMARY]
GO











-----------------------------------------
--  indexes
-----------------------------------------
use dbaadmin
go

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[check_contention]') AND name = N'check_contention_ix3')
CREATE NONCLUSTERED INDEX [check_contention_ix3] ON [dbo].[check_contention] 
(
	[CreateDate] ASC,
	[Headblocker] DESC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_QueryStats_log]') AND name = N'DMV_QueryStats_log_ix1')
CREATE CLUSTERED INDEX [DMV_QueryStats_log_ix1] ON [dbo].[DMV_QueryStats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


if exists (select * from sys.objects where object_id = object_id(N'[dbo].[pk_DMV_QueryStats_current]') and OBJECTPROPERTY(object_id, N'IsConstraint') = 1)
ALTER TABLE [DMV_QueryStats_current] DROP CONSTRAINT pk_DMV_QueryStats_current
go

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_QueryStats_current]') AND name = N'DMV_QueryStats_current_ix1')
CREATE CLUSTERED INDEX [DMV_QueryStats_current_ix1] ON [dbo].[DMV_QueryStats_current] 
(
	[rundate] ASC,
	[sql_handle] ASC,
	[plan_handle] ASC,
	[plan_generation_num] ASC,
	[statement_start_offset] ASC 
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO

if exists (select * from sys.objects where object_id = object_id(N'[dbo].[pk_DMV_QueryDaily_current]') and OBJECTPROPERTY(object_id, N'IsConstraint') = 1)
ALTER TABLE [DMV_QueryDaily_current] DROP CONSTRAINT pk_DMV_QueryDaily_current
go

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_QueryDaily_current]') AND name = N'DMV_QueryDaily_current_ix1')
CREATE CLUSTERED INDEX [DMV_QueryDaily_current_ix1] ON [dbo].[DMV_QueryDaily_current] 
(
	[rundate] ASC,
	[sql_handle] ASC,
	[plan_handle] ASC,
	[plan_generation_num] ASC,
	[statement_start_offset] ASC 
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_WaitStats_log]') AND name = N'DMV_WaitStats_log_ix1')
CREATE CLUSTERED INDEX [DMV_WaitStats_log_ix1] ON [dbo].[DMV_WaitStats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_IOwaitStats_log]') AND name = N'DMV_IOwaitStats_log_ix1')
CREATE CLUSTERED INDEX [DMV_IOwaitStats_log_ix1] ON [dbo].[DMV_IOwaitStats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO



IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[table_stats_log]') AND name = N'table_stats_log_ix1')
CREATE CLUSTERED INDEX [table_stats_log_ix1] ON [dbo].[table_stats_log] 
(
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[table_stats_log]') AND name = N'table_stats_log_ix2')
CREATE NONCLUSTERED INDEX [table_stats_log_ix2] ON [dbo].[table_stats_log] 
(
	[dbname] ASC,
	[tblname] ASC,
	[rows] ASC,
	[rowmodctr] ASC,
	[rundate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[DMV_Blocks]') AND name = N'DMV_Blocks_ix2')
CREATE NONCLUSTERED INDEX [DMV_Blocks_ix2] ON [dbo].[DMV_Blocks] 
(
	[rundate] ASC,
	[blocks_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[Compress_BackupInfo]') AND name = N'Compress_BackupInfo_ix1')
CREATE CLUSTERED INDEX [Compress_BackupInfo_ix1] ON [dbo].[Compress_BackupInfo] 
(
	[servername] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO



--  Data Update Section

delete from fragmentation_override
go

If not exists(select 1 from dbaadmin.dbo.fragmentation_override where frag_DBname = 'gssearch' and frag_TBLname = 'imageindex')
   begin
	If @@servername = 'GINSSQLA\A'
	   begin
		insert dbaadmin.dbo.fragmentation_override values('gssearch', 'imageindex', 2)
	   end
	Else
	   begin
		insert dbaadmin.dbo.fragmentation_override values('gssearch', 'imageindex', 15)
	   end
   end
go

If not exists(select 1 from dbaadmin.dbo.fragmentation_override where frag_DBname = 'wcds' and frag_TBLname = 'address')
   begin
	If @@servername = 'g1sqla\a'
	   begin
		insert dbaadmin.dbo.fragmentation_override values('wcds', 'address', 5)
	   end
	Else
	   begin
		insert dbaadmin.dbo.fragmentation_override values('wcds', 'address', 15)
	   end
   end
go

If not exists(select 1 from dbaadmin.dbo.fragmentation_override where frag_DBname = 'wcds' and frag_TBLname = 'DownloadDetail')
   begin
	If @@servername = 'g1sqla\a'
	   begin
		insert dbaadmin.dbo.fragmentation_override values('wcds', 'DownloadDetail', 1)
	   end
	Else
	   begin
		insert dbaadmin.dbo.fragmentation_override values('wcds', 'DownloadDetail', 15)
	   end
   end
go



If (select count(*) from dbo.DMV_Indexusage_current) = 0
   begin
	insert into dbo.DMV_Indexusage_current values(getdate(),0,0,0,0,0,0,0,0,0,0,0)
   end
go






--  =============================================
--  DATA IMPORT for filescan_strings
--  =============================================
Use dbaadmin
go

delete from dbo.filescan_strings
go

insert into dbo.filescan_strings values('exclude_joblogs', 'server name is')
insert into dbo.filescan_strings values('exclude_joblogs', 'Block Detected')
insert into dbo.filescan_strings values('exclude_joblogs', 'read_db_hdr: Read failure on backup device ''nul''')
insert into dbo.filescan_strings values('exclude_joblogs', 'error code 0x8009030c')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 50900')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 50902')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 50907')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 50912')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 50914')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 50921')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 1608')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error: 17207')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error: 17806')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 17824')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 17825')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 17832')
insert into dbo.filescan_strings values('exclude_joblogs', 'Error : 17951')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.9')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.8')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.7')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.6')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.5')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.4')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.3')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.2')
insert into dbo.filescan_strings values('exclude_joblogs', 'errorlog.1')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.1')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.2')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.3')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.4')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.5')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.6')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.7')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.8')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLAGENT.9')
insert into dbo.filescan_strings values('exclude_joblogs', 'wcds_individual_out')
insert into dbo.filescan_strings values('exclude_joblogs', 'wcds_creditcard_out')
insert into dbo.filescan_strings values('exclude_joblogs', 'wcds_orders_out')
insert into dbo.filescan_strings values('exclude_joblogs', 'sqlHardgoodsOut.txt')
insert into dbo.filescan_strings values('exclude_joblogs', 'Don''t try to create if stats')
insert into dbo.filescan_strings values('exclude_joblogs', 'Login failed for user')
insert into dbo.filescan_strings values('exclude_joblogs', 'Awaiting')
insert into dbo.filescan_strings values('exclude_joblogs', 'failed: 0.')
insert into dbo.filescan_strings values('exclude_joblogs', 'FileMgr::StartLogFiles')
insert into dbo.filescan_strings values('exclude_joblogs', 'NT AUTHORITY\ANONYMOUS LOGON')
insert into dbo.filescan_strings values('exclude_joblogs', 'Waiting for SQL Server to recover databases...')
insert into dbo.filescan_strings values('exclude_joblogs', 'Orphaned principal')
insert into dbo.filescan_strings values('exclude_joblogs', 'No mail profile defined')
insert into dbo.filescan_strings values('exclude_joblogs', 'Retrying Job Step now')
insert into dbo.filescan_strings values('exclude_joblogs', 'Mismatch    FAILED    Extras')
insert into dbo.filescan_strings values('exclude_joblogs', 'Processing table: FailedJobs')
insert into dbo.filescan_strings values('exclude_joblogs', 'server    SQL Server is starting at priority class ''normal''(4 CPUs detected)')
insert into dbo.filescan_strings values('exclude_joblogs', 'SQLSERVERAGENT starting under Windows NT service control')
insert into dbo.filescan_strings values('exclude_joblogs', 'DBA WARNING')
insert into dbo.filescan_strings values('exclude_joblogs', 'already exists')
insert into dbo.filescan_strings values('exclude_joblogs', 'has been created')
insert into dbo.filescan_strings values('exclude_joblogs', 'findstr "ERROR: NativeError failed terminated"')
insert into dbo.filescan_strings values('exclude_joblogs', '\StoredProcedure\')
insert into dbo.filescan_strings values('exclude_joblogs', 'FailedJobs')
insert into dbo.filescan_strings values('exclude_joblogs', '\SQLdump')
insert into dbo.filescan_strings values('exclude_joblogs', '.trc')
insert into dbo.filescan_strings values('exclude_joblogs', 'Subject: Metadata Export Failed')
insert into dbo.filescan_strings values('exclude_joblogs', 'Job: APPL - CheckLongRunningJobs')
insert into dbo.filescan_strings values('exclude_joblogs', '_Failed')
insert into dbo.filescan_strings values('exclude_joblogs', '_UnixFailed')
insert into dbo.filescan_strings values('exclude_joblogs', '_TraceFailed')


insert into dbo.filescan_strings values('excludeall', 'server name is')
insert into dbo.filescan_strings values('excludeall', 'Block Detected')
insert into dbo.filescan_strings values('excludeall', 'read_db_hdr: Read failure on backup device ''nul''')
insert into dbo.filescan_strings values('excludeall', 'SET @UserError')
insert into dbo.filescan_strings values('excludeall', 'Error : 50900')
insert into dbo.filescan_strings values('excludeall', 'Error : 50902')
insert into dbo.filescan_strings values('excludeall', 'Error : 50907')
insert into dbo.filescan_strings values('excludeall', 'Error : 50912')
insert into dbo.filescan_strings values('excludeall', 'Error : 50914')
insert into dbo.filescan_strings values('excludeall', 'Error : 50921')
insert into dbo.filescan_strings values('excludeall', 'Error : 1608')
insert into dbo.filescan_strings values('excludeall', 'Error: 17207')
insert into dbo.filescan_strings values('excludeall', 'Error : 17824')
insert into dbo.filescan_strings values('excludeall', 'Error : 17825')
insert into dbo.filescan_strings values('excludeall', 'Error : 17832')
insert into dbo.filescan_strings values('excludeall', 'Error : 17951')
insert into dbo.filescan_strings values('excludeall', 'errorlog.9')
insert into dbo.filescan_strings values('excludeall', 'errorlog.8')
insert into dbo.filescan_strings values('excludeall', 'errorlog.7')
insert into dbo.filescan_strings values('excludeall', 'errorlog.6')
insert into dbo.filescan_strings values('excludeall', 'errorlog.5')
insert into dbo.filescan_strings values('excludeall', 'errorlog.4')
insert into dbo.filescan_strings values('excludeall', 'errorlog.3')
insert into dbo.filescan_strings values('excludeall', 'errorlog.2')
insert into dbo.filescan_strings values('excludeall', 'errorlog.1')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.1')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.2')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.3')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.4')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.5')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.6')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.7')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.8')
insert into dbo.filescan_strings values('excludeall', 'SQLAGENT.9')
insert into dbo.filescan_strings values('excludeall', 'wcds_individual_out')
insert into dbo.filescan_strings values('excludeall', 'wcds_creditcard_out')
insert into dbo.filescan_strings values('excludeall', 'wcds_orders_out')
insert into dbo.filescan_strings values('excludeall', 'sqlHardgoodsOut.txt')
insert into dbo.filescan_strings values('excludeall', 'Don''t try to create if stats already exist')
insert into dbo.filescan_strings values('excludeall', 'determine the exact reason the connection')
insert into dbo.filescan_strings values('excludeall', 'The @WAIT parameter allows the filtering for activity')
insert into dbo.filescan_strings values('excludeall', 'Awaiting')
insert into dbo.filescan_strings values('excludeall', 'failed: 0.')
insert into dbo.filescan_strings values('excludeall', 'in failed for user')
insert into dbo.filescan_strings values('excludeall', 'Errorlog has been reinitialized')
insert into dbo.filescan_strings values('excludeall', 'FileMgr::StartLogFiles')
insert into dbo.filescan_strings values('excludeall', 'NT AUTHORITY\ANONYMOUS LOGON')
insert into dbo.filescan_strings values('excludeall', 'Waiting for SQL Server to recover databases...')
insert into dbo.filescan_strings values('excludeall', 'Orphaned principal')
insert into dbo.filescan_strings values('excludeall', 'No mail profile defined')
insert into dbo.filescan_strings values('excludeall', 'No Full Backup exists for Database')
insert into dbo.filescan_strings values('excludeall', 'No Backups of any kind exist for Database')
insert into dbo.filescan_strings values('excludeall', 'No Full or Differential Backup exists for Database')
insert into dbo.filescan_strings values('excludeall', '_Failed')
insert into dbo.filescan_strings values('excludeall', '_UnixFailed')
insert into dbo.filescan_strings values('excludeall', '_TraceFailed')
insert into dbo.filescan_strings values('excludeall', 'Mismatch    FAILED    Extras')
insert into dbo.filescan_strings values('excludeall', '\StoredProcedure\')
insert into dbo.filescan_strings values('excludeall', 'findstr "ERROR: NativeError failed terminated"')
insert into dbo.filescan_strings values('excludeall', 'FailedJobs')
insert into dbo.filescan_strings values('excludeall', '\SQLdump')
insert into dbo.filescan_strings values('excludeall', '.trc')
insert into dbo.filescan_strings values('excludeall', 'Subject: Metadata Export Failed')
insert into dbo.filescan_strings values('excludeall', 'No defrag has been run in the last seven days for server (SEAFRESQLMOMRP)')
insert into dbo.filescan_strings values('excludeall', 'Job: APPL - CheckLongRunningJobs')
insert into dbo.filescan_strings values('excludeall', 'It is passed the threshold time for this index rebuild process')
insert into dbo.filescan_strings values('excludeall', 'There was a forced exit of the index rebuild process')
insert into dbo.filescan_strings values('excludeall', 'DBA Note: WCDS is not online at this time')
insert into dbo.filescan_strings values('excludeall', 'for databases to come online')
insert into dbo.filescan_strings values('excludeall', 'dm_os_waiting')


insert into dbo.filescan_strings values('includescan02', 'Cannot open input file')
insert into dbo.filescan_strings values('includescan02', 'table corrupt')
insert into dbo.filescan_strings values('includescan02', 'Database Corrupt')
insert into dbo.filescan_strings values('includescan02', 'Unable to start mail session')
insert into dbo.filescan_strings values('includescan02', 'no email session')
insert into dbo.filescan_strings values('includescan02', 'DBPROCESS is dead')
insert into dbo.filescan_strings values('includescan02', 'Waiting')
insert into dbo.filescan_strings values('includescan02', 'parameter may be too low')
insert into dbo.filescan_strings values('includescan02', 'fatal')
insert into dbo.filescan_strings values('includescan02', 'symptom dump')
insert into dbo.filescan_strings values('includescan02', 'starvation')
insert into dbo.filescan_strings values('includescan02', 'Connection broken')
insert into dbo.filescan_strings values('includescan02', 'operating system error')
insert into dbo.filescan_strings values('includescan02', 'ODBC Error: 0, Timeout expired')
insert into dbo.filescan_strings values('includescan02', 'backup was not performed')
insert into dbo.filescan_strings values('includescan02', 'Allocation Discrepancy')
insert into dbo.filescan_strings values('includescan02', 'terminating')
insert into dbo.filescan_strings values('includescan02', 'abnormally')
insert into dbo.filescan_strings values('includescan02', 'server name is')
insert into dbo.filescan_strings values('includescan02', 'not recognized')
insert into dbo.filescan_strings values('includescan02', 'Incorrect syntax')
insert into dbo.filescan_strings values('includescan02', 'Scripting Error')
insert into dbo.filescan_strings values('includescan02', 'system cannot find the path')
insert into dbo.filescan_strings values('includescan02', 'Error 267')
insert into dbo.filescan_strings values('includescan02', 'Error 1105')
insert into dbo.filescan_strings values('includescan02', 'Error 1205')
insert into dbo.filescan_strings values('includescan02', 'Error 1311')
insert into dbo.filescan_strings values('includescan02', 'Error 3202')
insert into dbo.filescan_strings values('includescan02', 'Error 4209')
insert into dbo.filescan_strings values('includescan02', 'Error 4213')
insert into dbo.filescan_strings values('includescan02', 'Error 17902')
insert into dbo.filescan_strings values('includescan02', 'Error 17966')
insert into dbo.filescan_strings values('includescan02', 'Error 18456')
insert into dbo.filescan_strings values('includescan02', 'Msg 137')
insert into dbo.filescan_strings values('includescan02', 'Msg 156')
insert into dbo.filescan_strings values('includescan02', 'Msg 170')
insert into dbo.filescan_strings values('includescan02', 'Msg 605')
insert into dbo.filescan_strings values('includescan02', 'Msg 921')
insert into dbo.filescan_strings values('includescan02', 'Severity: 16')
insert into dbo.filescan_strings values('includescan02', 'Severity: 17')
insert into dbo.filescan_strings values('includescan02', 'Severity: 18')
insert into dbo.filescan_strings values('includescan02', 'Severity: 19')
insert into dbo.filescan_strings values('includescan02', 'Severity: 20')
insert into dbo.filescan_strings values('includescan02', 'Severity: 21')
insert into dbo.filescan_strings values('includescan02', 'Severity: 22')
insert into dbo.filescan_strings values('includescan02', 'Severity: 23')
insert into dbo.filescan_strings values('includescan02', 'Severity: 24')
insert into dbo.filescan_strings values('includescan02', 'Severity: 25')
insert into dbo.filescan_strings values('includescan02', 'level 16')
insert into dbo.filescan_strings values('includescan02', 'level 17')
insert into dbo.filescan_strings values('includescan02', 'level 18')
insert into dbo.filescan_strings values('includescan02', 'level 19')
insert into dbo.filescan_strings values('includescan02', 'level 20')
insert into dbo.filescan_strings values('includescan02', 'level 21')
insert into dbo.filescan_strings values('includescan02', 'level 22')
insert into dbo.filescan_strings values('includescan02', 'level 23')
insert into dbo.filescan_strings values('includescan02', 'level 24')
insert into dbo.filescan_strings values('includescan02', 'level 25')


insert into dbo.filescan_strings values('includescan', 'SQL Server is starting')
insert into dbo.filescan_strings values('includescan', 'SQLServerAgent starting')
insert into dbo.filescan_strings values('includescan', 'SQLSERVERAGENT starting')
insert into dbo.filescan_strings values('includescan', 'system cannot find the path')
insert into dbo.filescan_strings values('includescan', 'WARNING:')
insert into dbo.filescan_strings values('includescan', 'WCDS WARNING')
insert into dbo.filescan_strings values('includescan', 'Cannot open input file')
insert into dbo.filescan_strings values('includescan', 'table corrupt')
insert into dbo.filescan_strings values('includescan', 'Database Corrupt')
insert into dbo.filescan_strings values('includescan', 'Unable to start mail session')
insert into dbo.filescan_strings values('includescan', 'no email session')
insert into dbo.filescan_strings values('includescan', 'DBPROCESS is dead')
insert into dbo.filescan_strings values('includescan', 'Waiting')
insert into dbo.filescan_strings values('includescan', 'parameter may be too low')
insert into dbo.filescan_strings values('includescan', 'fatal')
insert into dbo.filescan_strings values('includescan', 'symptom dump')
insert into dbo.filescan_strings values('includescan', 'starvation')
insert into dbo.filescan_strings values('includescan', 'Connection broken')
insert into dbo.filescan_strings values('includescan', 'system error')
insert into dbo.filescan_strings values('includescan', 'ODBC Error: 0, Timeout expired')
insert into dbo.filescan_strings values('includescan', 'backup was not performed')
insert into dbo.filescan_strings values('includescan', 'Allocation Discrepancy')
insert into dbo.filescan_strings values('includescan', 'terminating')
insert into dbo.filescan_strings values('includescan', 'abnormally')
insert into dbo.filescan_strings values('includescan', 'server name is')
insert into dbo.filescan_strings values('includescan', 'not recognized')
insert into dbo.filescan_strings values('includescan', 'Incorrect syntax')
insert into dbo.filescan_strings values('includescan', 'Invalid object')
insert into dbo.filescan_strings values('includescan', 'Invalid filename')
insert into dbo.filescan_strings values('includescan', 'spawn')
insert into dbo.filescan_strings values('includescan', 'Unable to delete')
insert into dbo.filescan_strings values('includescan', 'is already in use')
insert into dbo.filescan_strings values('includescan', 'Failed')
insert into dbo.filescan_strings values('includescan', 'no longer available')
insert into dbo.filescan_strings values('includescan', 'Error 267')
insert into dbo.filescan_strings values('includescan', 'Error 1105')
insert into dbo.filescan_strings values('includescan', 'Error 1205')
insert into dbo.filescan_strings values('includescan', 'Error 1311')
insert into dbo.filescan_strings values('includescan', 'Error 3202')
insert into dbo.filescan_strings values('includescan', 'Error 4209')
insert into dbo.filescan_strings values('includescan', 'Error 4213')
insert into dbo.filescan_strings values('includescan', 'Error 17902')
insert into dbo.filescan_strings values('includescan', 'Error 17966')
insert into dbo.filescan_strings values('includescan', 'Error: 267')
insert into dbo.filescan_strings values('includescan', 'Error: 1105')
insert into dbo.filescan_strings values('includescan', 'Error: 1205')
insert into dbo.filescan_strings values('includescan', 'Error: 1311')
insert into dbo.filescan_strings values('includescan', 'Error: 3202')
insert into dbo.filescan_strings values('includescan', 'Error: 4209')
insert into dbo.filescan_strings values('includescan', 'Error: 4213')
insert into dbo.filescan_strings values('includescan', 'Error: 17902')
insert into dbo.filescan_strings values('includescan', 'Error: 17966')
insert into dbo.filescan_strings values('includescan', 'Error: 18486')
insert into dbo.filescan_strings values('includescan', 'Msg 137')
insert into dbo.filescan_strings values('includescan', 'Msg 156')
insert into dbo.filescan_strings values('includescan', 'Msg 170')
insert into dbo.filescan_strings values('includescan', 'Msg 605')
insert into dbo.filescan_strings values('includescan', 'Msg 921')
insert into dbo.filescan_strings values('includescan', 'Severity: 16')
insert into dbo.filescan_strings values('includescan', 'Severity: 17')
insert into dbo.filescan_strings values('includescan', 'Severity: 18')
insert into dbo.filescan_strings values('includescan', 'Severity: 19')
insert into dbo.filescan_strings values('includescan', 'Severity: 20')
insert into dbo.filescan_strings values('includescan', 'Severity: 21')
insert into dbo.filescan_strings values('includescan', 'Severity: 22')
insert into dbo.filescan_strings values('includescan', 'Severity: 23')
insert into dbo.filescan_strings values('includescan', 'Severity: 24')
insert into dbo.filescan_strings values('includescan', 'Severity: 25')
insert into dbo.filescan_strings values('includescan', 'level 16')
insert into dbo.filescan_strings values('includescan', 'level 17')
insert into dbo.filescan_strings values('includescan', 'level 18')
insert into dbo.filescan_strings values('includescan', 'level 19')
insert into dbo.filescan_strings values('includescan', 'level 20')
insert into dbo.filescan_strings values('includescan', 'level 21')
insert into dbo.filescan_strings values('includescan', 'level 22')
insert into dbo.filescan_strings values('includescan', 'level 23')
insert into dbo.filescan_strings values('includescan', 'level 24')
insert into dbo.filescan_strings values('includescan', 'level 25')

go

--  =============================================
--  DATA IMPORT for db_ApplCrossRef
--  =============================================
Use dbaadmin
go

delete from dbo.db_ApplCrossRef
go

insert into dbo.db_ApplCrossRef values('WCDSarchive', 'WCDS', 'GMSA', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('WCDS', 'WCDSwork', 'GMSA', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('WCDSwork', 'WCDS', 'GMSA', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('CRMexport', 'WCDS', 'GMSA', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('DataExtract', 'WCDS', 'GMSA', 'Legacy Creative', 'SQLDEPLOYER02')

insert into dbo.db_ApplCrossRef values('Hardgood_Assets', '', 'HGA', 'Legacy HardGoods', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('PriceUpdate', 'Hardgood_Assets', 'HGA', 'Legacy HardGoods', 'SQLDEPLOYER02')

insert into dbo.db_ApplCrossRef values('PriceUpdate', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('Product', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('ArtistListing', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('RightsPrice', 'Product', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('ChangeME', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('ImageAdmin', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('nextbigidea', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('Community', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')
insert into dbo.db_ApplCrossRef values('DataExtract', 'RightsPrice', 'GMSB', 'Legacy Creative', 'SQLDEPLOYER02')

insert into dbo.db_ApplCrossRef values('GSSearch', '', 'GINS', 'Legacy Editorial', 'SQLDEPLOYER03')
insert into dbo.db_ApplCrossRef values('DataExtract', 'GSSearch', 'GINS', 'Legacy Editorial', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('CommerceService', '', 'CWS', 'Legacy Commerce Service', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('DeliveryLog', '', 'DS', 'Legacy Delivery', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('DAP', '', 'DAP', 'DAP', 'SQLDEPLOYER03')
insert into dbo.db_ApplCrossRef values('DAPwork', '', 'DAP', 'DAP', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('ACAT', '', 'ACAT', 'ACAT', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('DataWarehouse', '', 'COG', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('DWStage', '', 'COG', 'DataWarehouse', 'SQLDEPLOYER01')

insert into dbo.db_ApplCrossRef values('Gandalf', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('UserData', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('Staging', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('GettyDW', 'Gandalf', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('MercuryDM', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('AdHocDM', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('AssetAuditDM', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('ArchiveDM', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('RoyaltyDM', 'GettyDW', 'DW', 'DataWarehouse', 'SQLDEPLOYER01')

insert into dbo.db_ApplCrossRef values('RM_Integration', '', 'ALNT', 'Alliant', 'SQLDEPLOYER03')
insert into dbo.db_ApplCrossRef values('getty_master', '', 'ALNT', 'Alliant', 'SQLDEPLOYER03')
insert into dbo.db_ApplCrossRef values('gins_master', '', 'ALNT', 'Alliant', 'SQLDEPLOYER03')
insert into dbo.db_ApplCrossRef values('ContractMaintenanceControl', '', 'ALNT', 'Alliant', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('BundledProduct', 'Reports_Work', 'ALNT', 'Alliant Integration', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('Subscription', 'Reports_Work', 'ALNT', 'Alliant', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('iLoc', '', 'TOOLS', 'Tools', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('GimBroker', '', 'GIMB', 'MediaManager Creative Link (MMS)', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('Discovery', '', 'ASP', 'WebVision Newsmaker (ASP)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('Getty_Artists', '', 'ASP', 'WebVision Newsmaker (ASP)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('ASPState*', 'Discovery', 'ASP', 'WebVision Newsmaker (ASP)', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('Bundle', '', 'BNDL', 'Bundle', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('SoundTrackDB', '', 'PUMP', 'PumpAudio', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('PACueSheet', '', 'PUMP', 'PumpAudio', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('PumpAudio_Live', '', 'PUMP', 'PumpAudio', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('PumpAudioWeb', '', 'PUMP', 'PumpAudio', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('LocalMusicPlatform', '', 'PUMP', 'PumpAudio', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('ASPState*', 'PumpAudio_Live', 'PUMP', 'PumpAudio', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('KeywordLookup', '', 'PC', 'WebVision Newsmaker', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('LocalizationLookup', '', 'PC', 'WebVision Newsmaker', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('ProductCatalog', '', 'PC', 'WebVision Newsmaker', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('DynamicSortOrder', '', 'PC', 'WebVision Newsmaker', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('MessageQueue', '', 'PC', 'WebVision Newsmaker', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('DataExtract', 'ProductCatalog', 'PC', 'WebVision Newsmaker', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('AssetKeyword', '', 'MRT', 'Search Data Tools (AKS, MRT)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('MetadataRevisionTool', '', 'MRT', 'Search Data Tools (AKS, MRT)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('DataExtract', 'AssetKeyword', 'MRT', 'Search Data Tools (AKS, MRT)', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('VocabularyTool', '', 'VMT', 'Search Data Tools (VMT)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('StackFactors', '', 'VMT', 'Search Data Tools (VMT)', 'sqldeployer05')


insert into dbo.db_ApplCrossRef values('Tal_Integration', '', 'TAL', 'Talisma', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('Getty_Images_US_Inc_Custom', '', 'CRM', 'CRM', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('Getty_Images_US_Inc__MSCRM', '', 'CRM', 'CRM', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('Getty_Images_US_Inc__METABASE', '', 'CRM', 'CRM', 'SQLDEPLOYER01')
insert into dbo.db_ApplCrossRef values('MSCRM_CONFIG', '', 'CRM', 'CRM', 'SQLDEPLOYER01')

insert into dbo.db_ApplCrossRef values('mercury', '', 'MERC', 'Mercury', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('viewImages', '', 'VWIMG', 'ViewImages', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('Unauth', '', 'UNA', 'UNAdatabases', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('TransCoder', '', 'TXC', 'Transcoder (Rhozet)', 'SQLDEPLOYER02')

insert into dbo.db_ApplCrossRef values('GIMTV08', '', 'MS', 'Barbarian/Moodstream', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('ChannelFeed', '', 'CF', 'Channel Feeds', 'SQLDEPLOYER02')

insert into dbo.db_ApplCrossRef values('CreativeSearch', '', 'CS', 'Creative Search Order (CS)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('CSO20', '', 'CS', 'Creative Search Order (CS)', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('MG_DB', '', 'DEWDS', 'DEWDS (Picture Desk)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('MG_DB_RPT', '', 'DEWDS', 'DEWDS (Picture Desk)', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('DewdsReporting', '', 'DEWDS', 'DEWDS (Picture Desk)', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('EcoraAuditorDB%', '', 'ECORA', 'Ecora', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('Feeds', '', 'FEEDS', 'Feeds', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('Gestalt', '', 'GST', 'Gestalt', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('GPDB', '', 'GPD', 'GetPaid', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('GettyImagesICM', '', 'ICM', 'Varicent', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('OnePoint', '', 'MOM', 'MOM', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('DRMS*', '', 'SPT', 'SharePoint', 'SQLDEPLOYER03')
insert into dbo.db_ApplCrossRef values('GettyMAI2*', '', 'SPT', 'SharePoint', 'SQLDEPLOYER03')
insert into dbo.db_ApplCrossRef values('SPS01*', '', 'SPT', 'SharePoint', 'SQLDEPLOYER03')

insert into dbo.db_ApplCrossRef values('Cert', '', 'CERT', 'SSL Tool Manager', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('Tfs*', '', 'TFS', 'TFS', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('VCentral', '', 'VC', 'View Central', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('WSLogDB', '', 'WBSNS', 'Websense', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('SUSDB', '', 'WSUS', 'WSUS', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('RunBook', '', 'DBA', 'SQL DBA Tools', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('RunBook*', '', 'DBA', 'SQL DBA Tools', 'sqldeployer05')

insert into dbo.db_ApplCrossRef values('AdminDB', 'DenaliDB', 'ED', 'ED', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('ContourDB', '', 'ED', 'ED', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('DataLogDB', 'DenaliDB', 'ED', 'ED', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('DenaliDB', '', 'ED', 'ED', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('EditorialSiteDB', '', 'ED', 'ED', 'sqldeployer05')
insert into dbo.db_ApplCrossRef values('EventServiceDB ', '', 'ED', 'ED', 'sqldeployer05')


insert into dbo.db_ApplCrossRef values('AdminDB', 'FeedsDB', 'EF', 'EF', 'sqldeployer04')
insert into dbo.db_ApplCrossRef values('DataLogDB', 'FeedsDB', 'EF', 'EF', 'sqldeployer04')
insert into dbo.db_ApplCrossRef values('DeliveryDB', '', 'EF', 'EF', 'sqldeployer04')
insert into dbo.db_ApplCrossRef values('FeedsDB', '', 'EF', 'EF', 'sqldeployer04')
insert into dbo.db_ApplCrossRef values('IngestionDB ', '', 'EF', 'EF', 'sqldeployer04')


go




--  =============================================
--  DATA IMPORT for db_sequence
--  =============================================
Use dbaadmin
go

delete from dbo.db_sequence
go


insert into dbo.db_sequence values(5, 'Hardgood_Assets')

insert into dbo.db_sequence values(10, 'Product')
insert into dbo.db_sequence values(11, 'ArtistListing')
insert into dbo.db_sequence values(12, 'PriceUpdate')
insert into dbo.db_sequence values(13, 'RightsPrice')
insert into dbo.db_sequence values(14, 'ChangeME')
insert into dbo.db_sequence values(15, 'ImageAdmin')
insert into dbo.db_sequence values(16, 'nextbigidea')
insert into dbo.db_sequence values(17, 'Community')

insert into dbo.db_sequence values(21, 'WCDSarchive')
insert into dbo.db_sequence values(22, 'WCDS')
insert into dbo.db_sequence values(23, 'WCDSwork')
insert into dbo.db_sequence values(24, 'CRMexport')


insert into dbo.db_sequence values(27, 'GSSearch')

insert into dbo.db_sequence values(30, 'CommerceService')
insert into dbo.db_sequence values(31, 'DeliveryLog')

insert into dbo.db_sequence values(40, 'DAP')
insert into dbo.db_sequence values(41, 'DAPwork')
insert into dbo.db_sequence values(42, 'ACAT')

insert into dbo.db_sequence values(45, 'DWStage')
insert into dbo.db_sequence values(46, 'DataWarehouse')

insert into dbo.db_sequence values(50, 'Gandalf')
insert into dbo.db_sequence values(51, 'UserData')
insert into dbo.db_sequence values(52, 'Staging')
insert into dbo.db_sequence values(53, 'GettyDW')
insert into dbo.db_sequence values(54, 'MercuryDM')
insert into dbo.db_sequence values(55, 'AdHocDM')
insert into dbo.db_sequence values(56, 'AssetAuditDM')
insert into dbo.db_sequence values(57, 'ArchiveDM')
insert into dbo.db_sequence values(58, 'RoyaltyDM')

insert into dbo.db_sequence values(70, 'Subscription')
insert into dbo.db_sequence values(71, 'RM_Integration')
insert into dbo.db_sequence values(72, 'BundledProduct')

insert into dbo.db_sequence values(80, 'iLoc')
insert into dbo.db_sequence values(81, 'Users')
insert into dbo.db_sequence values(82, 'TicketingArchive')


insert into dbo.db_sequence values(90, 'GimBroker')

insert into dbo.db_sequence values(93, 'GPDB')

insert into dbo.db_sequence values(100, 'Discovery')
insert into dbo.db_sequence values(101, 'Bundle')
insert into dbo.db_sequence values(103, 'Getty_Artists')
insert into dbo.db_sequence values(105, 'ASPState')
insert into dbo.db_sequence values(106, 'SoundTrackDB')
insert into dbo.db_sequence values(107, 'PumpAudio_Live')
insert into dbo.db_sequence values(108, 'PumpAudioWeb')
insert into dbo.db_sequence values(109, 'LocalMusicPlatform')
insert into dbo.db_sequence values(110, 'PACueSheet')

insert into dbo.db_sequence values(115, 'KeywordLookup')
insert into dbo.db_sequence values(116, 'LocalizationLookup')
insert into dbo.db_sequence values(117, 'ProductCatalog')
insert into dbo.db_sequence values(118, 'DynamicSortOrder')
insert into dbo.db_sequence values(119, 'MessageQueue')

insert into dbo.db_sequence values(120, 'VocabularyTool')
insert into dbo.db_sequence values(121, 'StackFactors')

insert into dbo.db_sequence values(130, 'AssetKeyword')
insert into dbo.db_sequence values(131, 'MetadataRevisionTool')

insert into dbo.db_sequence values(140, 'Tal_Integration')

insert into dbo.db_sequence values(145, 'Getty_Images_US_Inc_Custom')
insert into dbo.db_sequence values(146, 'Getty_Images_US_Inc__MSCRM')
insert into dbo.db_sequence values(147, 'Getty_Images_US_Inc__METABASE')
insert into dbo.db_sequence values(148, 'MSCRM_CONFIG')

insert into dbo.db_sequence values(150, 'mercury')

insert into dbo.db_sequence values(160, 'viewImages')

insert into dbo.db_sequence values(170, 'Unauth')

insert into dbo.db_sequence values(180, 'TransCoder')

insert into dbo.db_sequence values(184, 'AdminDB')
insert into dbo.db_sequence values(185, 'ContourDB')
insert into dbo.db_sequence values(186, 'DataLogDB')
insert into dbo.db_sequence values(187, 'DenaliDB')
insert into dbo.db_sequence values(188, 'EditorialSiteDB')
insert into dbo.db_sequence values(189, 'EventServiceDB')

insert into dbo.db_sequence values(190, 'DeliveryDB')
insert into dbo.db_sequence values(191, 'FeedsDB')
insert into dbo.db_sequence values(192, 'IngestionDB')

insert into dbo.db_sequence values(299, 'DataExtract')

go





--  =============================================
--  DATA IMPORT for LicenseInfo
--  =============================================
Use dbaadmin
go

delete from dbo.LicenseInfo
go

insert into LicenseInfo values('RedGate', 'SQLbackup', '5', 'Professional', '010-010-072953-AF44', 10, '11-13-2008', 'y')
insert into LicenseInfo values('RedGate', 'SQLbackup', '5', 'Professional', '010-010-075100-985E', 10, '12-24-2008', 'y')
insert into LicenseInfo values('RedGate', 'SQLbackup', '5', 'Professional', '010-020-077940-3D17', 20, '02-19-2009', 'y')
insert into LicenseInfo values('RedGate', 'SQLbackup', '6', 'Professional', '010-050-089520-94D8', 50, '08-29-2009', 'y')
insert into LicenseInfo values('RedGate', 'SQLbackup', '6', 'Professional', '010-020-097053-6F7C', 20, '01-27-2010', 'y')
insert into LicenseInfo values('RedGate', 'SQLbackup', '5', 'Lite', '010-050-066098-399C', 0, '01-01-1900', 'n')
insert into LicenseInfo values('RedGate', 'SQLbackup', '6', 'Lite', '010-050-069326-8916', 50, '08-29-2009', 'y')
go





































/**************************************************************
BusWare Section: dbaadmin
**************************************************************/
Use dbaadmin
go


if not exists (select * from sys.objects where object_id = object_id(N'[dbo].[BusWare_cntl]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
CREATE TABLE [dbo].[BusWare_cntl] (
	[cmptName] [sysname] NOT NULL ,
	[cmptType] [sysname] NOT NULL ,
	[Version] [sysname] NULL 
) ON [PRIMARY]
GO


Delete from dbo.BusWare_cntl
go


--  Insert Data
INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gins_integration', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('rm_integration', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('tal_integration', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('image_prod', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('royalty_prod', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dap', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dapwork', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('podmeta', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('delivery', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('deliverylog', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('artistlisting', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('product', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('rightsprice', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('wcds', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gssearch', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('MSGMSearch', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('MSSISearch', 'database', '')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqlrmdb', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqlrgdb', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafrerylwdb01', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafrerylwdb02', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafrerylwdb03', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafrerylwdb04', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqltal04', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqltaltst', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqltaldev', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqltals01', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqlrft01', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqlrf01', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dapsqldev01', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dapsqldev02', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dapsqltest01', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dapsqltest02', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqlstgdap', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqldap01', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('mpsqldev01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('mpsqltest01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dlvrsqldev01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dlvrsqldev01\a02', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dlvrsqltest01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dlvrsqltest01\a02', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dlvrsqlload01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('dlvrsqlstg01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seaexstgdelsql', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seaexdelsqla\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev02\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev03\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev04\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest02\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest03\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest04\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqlload01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gonessqla\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('g1sqla\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev01\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev02\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev03\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqldev04\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest01\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest02\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest03\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqltest04\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gmssqlload01\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('gonessqlb\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('g1sqlb\b', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqldev01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqldev02\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqldev03\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqldev04\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqltest01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqltest02\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqltest03\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqltest04\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqlload01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginsstgsqla\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('ginssqla\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('mssqltest01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('mdsstgsql01\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('mdssqla\a', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('SEAFRESQLTST01\TEST', 'server', '10_11_2007')
go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('SEAFRESQLTST01\DEV', 'server', '10_11_2007')
Go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('SEAFRESQLTST01\stage', 'server', '10_11_2007')
Go

INSERT INTO dbo.BusWare_cntl (cmptName, cmptType, Version) VALUES ('seafresqlcsod01\Dev', 'server', '10_11_2007')
Go
























/**************************************************************
Sprocs Section: dbaadmin
**************************************************************/
 
/**************************************************************
Generated SQL - script_DBsprocs For Database dbaadmin
For Server: SQLDEPLOYER04 on May 21 2010  5:28:57:720PM
**************************************************************/
 
/*********************************************************
ADD STORED PROCEDURES FOR DATABASE dbaadmin
*********************************************************/
 
USE dbaadmin
go
 
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_add_Base_Skip_sqb2nxt
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_add_Base_Skip_sqb2nxt]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_add_Base_Skip_sqb2nxt]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



create procedure dbo.dbasp_add_Base_Skip_sqb2nxt  @SQBname sysname = NULL

/*********************************************************
 **  Stored Procedure dbasp_add_Base_Skip_sqb2nxt                  
 **  Written by Jim Wilson, Getty Images                
 **  May 27, 2008                                      
 **
 **  This proc requires one input parm for a Baseline SQB file name.
 **
 **  This procedure inserts a row to the dbaadmin.dbo.Base_Skip_sqb2nxt
 **  table.  This table is used in the 'Base - Local Process' SQL job.
 **  That process will not create a local NXT file for any SQB file
 **  listed in the table.
 ***************************************************************/
AS
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	05/27/2008	Jim Wilson		New Process
--	======================================================================================

/***
declare @SQBname sysname

select @SQBname = 'rightsprice'
--***/

	
Declare @error_count int

Select @error_count = 0


-- VALIDATE SQB input value:
If @SQBname is null or @SQBname = '' or @SQBname not like '%_prod.sqb%'
   begin
	raiserror('DBA WARNING: Invalid input for @SQBname.  Try ''DBname_prod.sqb''.',-1,-1)
	Select @error_count = @error_count + 1
	goto label99
   end

-- VALIDATE SQB input value - NOT IN TARGET TABLE:
If exists(select * from dbaadmin.dbo.Base_Skip_sqb2nxt where sqbname = @SQBname)
   begin
	raiserror('DBA WARNING: SQB name already in dbaadmin.dbo.Base_Skip_sqb2nxt',-1,-1)
	Select @error_count = @error_count + 1
	goto label99
   end

-- INSERT SQB NAME INTO THE TARGET TABLE:
INSERT INTO dbaadmin.dbo.Base_Skip_sqb2nxt VALUES (@SQBname, getdate())
	
-- FINALIZATION: RETURN SUCCESS/FAILURE --
label99:

Print ''
Print 'Current rows in dbo.Base_Skip_sqb2nxt'

Select * from dbaadmin.dbo.Base_Skip_sqb2nxt


if @error_count > 0
   begin
	return (1)
   end
Else
   begin
	return  (0)
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_add_nocheck
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_add_nocheck]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_add_nocheck]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



create procedure dbo.dbasp_add_nocheck  (@nocheck_type sysname = null
					,@detail01 sysname = null
					,@detail02 sysname = null
					,@detail03 sysname = null
					,@detail04 sysname = null
					,@delete_flag char(1) = 'n'
					,@nocheckID int = null
					)

/*********************************************************
 **  Stored Procedure dbasp_add_nocheck                  
 **  Written by Jim Wilson, Getty Images                
 **  January 13, 2009                                      
 **
 **  This proc requires the following input parms;
 **
 **  Note: The database name must be a vaild database name  
 **        on the local server.
 **
 **  This procedure inserts a row to the dbaadmin.dbo.No_Check
 **  table.  This table is accessed by several processes to
 **  determine if anything should be skipped or "not checked".
 ***************************************************************/
  AS
  set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	01/13/2009	Jim Wilson		Revised old process (re-write)
--	03/11/2009	Jim Wilson		Added DEPL_RD_Skip type.
--	07/13/2009	Jim Wilson		Added code for login type.
--	08/10/2009	Jim Wilson		Modified Filescan_noreport example.
--	======================================================================================

/***
declare @nocheck_type sysname
declare @detail01 sysname
declare @detail02 sysname
declare @detail03 sysname
declare @detail04 sysname
declare @delete_flag char(1)
declare @nocheckID int

select @nocheck_type = 'backupx'
select @detail01 = 'aaa'
select @detail02 = ''
select @detail03 = ''
select @detail04 = ''
select @delete_flag = 'n'
--select @nocheckID = 3
--***/

--  Valid types:  backup, maint, Filescan_noreport, prerestore, DEPL_RD_Skip, Post_Jobscript, login


-----------------  declares  ------------------
Declare 
	 @miscprint		varchar(500)
	,@cmd			varchar(4000)
	,@error_count		int


----------------  initial values  -------------------
Select @error_count = 0



----------------  Verify Input Parms  -------------------
if @nocheck_type is null
   BEGIN
	Select @error_count = @error_count + 1
	goto label99
   END

if @nocheck_type not in ('backup', 'maint', 'Filescan_noreport', 'prerestore', 'DEPL_RD_Skip', 'Post_Jobscript', 'login')
   BEGIN
	Select @miscprint = '--DBA WARNING: Invalid input for @nocheck_type.  ' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

If @nocheck_type in ('backup', 'prerestore') and @delete_flag = 'n' and not exists(select 1 from master.sys.databases where name = @detail01)
   begin
	Select @miscprint = '--DBA WARNING: Database name not found in master.sys.databases.  ' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end

If @nocheck_type = 'backup' and @delete_flag = 'n' and exists(select 1 from dbaadmin.dbo.no_check where nocheck_type = 'backup' and detail01 = @detail01)
   begin
	Select @miscprint = '--DBA WARNING: Database name already in dbaadmin.dbo.No_Check.  ' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end

If @nocheck_type = 'DEPL_RD_Skip' and @detail01 <> 'all' and not exists(select 1 from master.sys.databases where name = @detail01)
   begin
	Select @miscprint = '--DBA WARNING: Database name not found in master.sys.databases.  ' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end


If @nocheckID is not null
   begin
	If not exists (select 1 from dbaadmin.dbo.no_check where nocheckid = @nocheckID)
	   begin
		Select @miscprint = '--DBA WARNING: Delete request - row for @nocheckID does not exist. ' 
		raiserror(@miscprint,-1,-1) with log
		Select @error_count = @error_count + 1
		goto label99
	   end
   end

If @delete_flag not in ('n', 'y')
   begin
	Select @miscprint = '--DBA WARNING: Invalid input for @delete_flag.  Must be ''n'' or ''y''.  ' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end





----------------  Main Process  -------------------

If @delete_flag = 'y'
   begin
	goto delete_sec
   end

--  Process backup type
If @nocheck_type = 'backup'
   begin
	INSERT INTO dbaadmin.dbo.no_check (NoCheck_type, detail01, createdate, moddate)
	    VALUES ('backup', @detail01, getdate(), getdate())

	goto label99
   end


--  Process maint type
If @nocheck_type = 'maint'
   begin
	INSERT INTO dbaadmin.dbo.no_check (NoCheck_type, detail01, createdate, moddate)
	    VALUES ('maint', 'skip_check', getdate(), getdate())

	goto label99
   end


--  Process Filescan_noreport type
If @nocheck_type = 'Filescan_noreport'
   begin
	INSERT INTO dbaadmin.dbo.no_check (NoCheck_type, detail01, detail02, detail03, detail04, createdate, moddate)
	    VALUES ('Filescan_noreport', @detail01, @detail02, @detail03, @detail04, getdate(), getdate())

	goto label99
   end


--  Process prerestore type
If @nocheck_type = 'prerestore'
   begin
	INSERT INTO dbaadmin.dbo.no_check (NoCheck_type, detail01, createdate, moddate)
	    VALUES ('prerestore', @detail01, getdate(), getdate())

	goto label99
   end


--  Process DEPL_RD_Skip type
If @nocheck_type = 'DEPL_RD_Skip'
   begin
	INSERT INTO dbaadmin.dbo.no_check (NoCheck_type, detail01, createdate, moddate)
	    VALUES ('DEPL_RD_Skip', @detail01, getdate(), getdate())

	goto label99
   end


--  Process Post_Jobscript type
If @nocheck_type = 'Post_Jobscript'
   begin
	INSERT INTO dbaadmin.dbo.no_check (NoCheck_type, detail01, createdate, moddate)
	    VALUES ('Post_Jobscript', 'DEPL_RD', getdate(), getdate())

	goto label99
   end


--  Process login type
If @nocheck_type = 'login'
   begin
	INSERT INTO dbaadmin.dbo.no_check (NoCheck_type, detail01, createdate, moddate)
	    VALUES ('login', @detail01, getdate(), getdate())

	goto label99
   end



--  Delete Section  ------------------------------------------------------------------
delete_sec:

If @delete_flag <> 'y'
   begin
	goto label99
   end

If @nocheckID is not null
   begin
	If exists (select 1 from dbaadmin.dbo.no_check where nocheckid = @nocheckID)
	   begin
		delete from dbaadmin.dbo.no_check where nocheckID = @nocheckID 
		goto label99
	   end
   end

--  Process backup type delete
If @nocheck_type = 'backup'
   begin
	delete from dbaadmin.dbo.no_check where NoCheck_type = 'backup' and detail01 = @detail01
	goto label99
   end


--  Process maint type delete
If @nocheck_type = 'maint'
   begin
	delete from dbaadmin.dbo.no_check where NoCheck_type = 'maint'

	goto label99
   end


--  Process Filescan_noreport type delete
If @nocheck_type = 'Filescan_noreport'
   begin
	delete from dbaadmin.dbo.no_check where NoCheck_type = 'Filescan_noreport' 
					    and detail01 = @detail01 
	goto label99
   end


--  Process prerestore type delete
If @nocheck_type = 'prerestore'
   begin
	delete from dbaadmin.dbo.no_check where NoCheck_type = 'prerestore' and detail01 = @detail01
	goto label99
   end


--  Process DEPL_RD type delete
If @nocheck_type = 'DEPL_RD_Skip'
   begin
	delete from dbaadmin.dbo.no_check where NoCheck_type = 'DEPL_RD_Skip' and detail01 = @detail01
	goto label99
   end


--  Process Post_Jobscript type delete
If @nocheck_type = 'Post_Jobscript'
   begin
	delete from dbaadmin.dbo.no_check where NoCheck_type = 'Post_Jobscript' and detail01 = 'DEPL_RD'
	goto label99
   end




--  Finalization  -------------------------------------------------------------------

label99:

If @error_count > 0
   begin
	If @delete_flag is null or @delete_flag = 'n'
	   begin
		Print  ' '
		Select @miscprint = '--Here are sample execute commands for this sproc:'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @nocheck_type = ''backup''                 -- Backup type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''wcdswork''                   -- DB name'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @nocheck_type = ''login''                 -- Backup type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''sql_test''                  -- Login name'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @nocheck_type = ''maint''                  -- Maint type'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @nocheck_type = ''Filescan_noreport''      -- Filescan_noreport type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''%Error: 67015%''             -- Include Text string 1'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail02 = ''%Severity: 16, State: 1.%''  -- Include Text string 2 (optional)'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail03 = ''%APPL%''                     -- Exclude Text string 1 (optional)'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail04 = ''5''                          -- Threshold number (use "0" to show no rows of this type)'
		Print  @miscprint
		Select @miscprint = '                                                                               -- Note: Rows of this type will be suppressed unless there are more than this number.'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @nocheck_type = ''prerestore''             -- prerestore type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''wcdswork''                   -- DB name'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @nocheck_type = ''DEPL_RD_Skip''           -- DEPL_RD_Skip type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''all''                        -- SQL instance will be marked for no DEPL_RD deployments'
		Print  @miscprint
		Select @miscprint = '                                   --,@detail01 = ''DBname''                   -- DBname instance will be marked for no DEPL_RD deployments'
		Print  @miscprint
		Select @miscprint = '                                   --,@delete_flag = ''n''                     -- Delete request parm'
		Print  @miscprint
		Print  ' '
		Print  ' '
		Select @miscprint = '--Current Contents of the No_Check Table:'
		Print  @miscprint
		Select nocheckID
		    , convert(char(20), NoCheck_type) as NoCheck_type
		    , convert(char(30), detail01) as Detail01
		    , convert(char(40), detail02) as Detail02
		    , convert(char(20), detail03) as Detail03
		    , convert(char(20), detail04) as Detail04
		    , convert(char(20), addedby) as addedby
		    , createdate 
		    , moddate
		    from dbaadmin.dbo.No_Check
	   end
	Else
	   begin
		Print  ' '
		Select @miscprint = '--Here are sample execute (delete) commands for this sproc:'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @delete_flag = ''y''                       -- Delete request by row ID'
		Print  @miscprint
		Select @miscprint = '                                   ,@nocheckID = 5                           -- Row ID'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @delete_flag = ''y''                       -- Delete request for backup'
		Print  @miscprint
		Select @miscprint = '                                   ,@nocheck_type = ''backup''                 -- Backup type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''wcdswork''                   -- DB name'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @delete_flag = ''y''                       -- Delete request for maint'
		Print  @miscprint
		Select @miscprint = '                                   ,@nocheck_type = ''maint''                  -- Maint type'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @delete_flag = ''y''                       -- Delete request for Filescan_noreport'
		Print  @miscprint
		Select @miscprint = '                                   ,@nocheck_type = ''Filescan_noreport''      -- Filescan_noreport type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''%Error: 67015%''             -- Include Text string 1'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @delete_flag = ''y''                       -- Delete request for prerestore'
		Print  @miscprint
		Select @miscprint = '                                   ,@nocheck_type = ''prerestore''             -- prerestore type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''wcdswork''                   -- DB name'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'exec dbaadmin.dbo.dbasp_add_nocheck @delete_flag = ''y''                       -- Delete request for DEPL_RD_Skip'
		Print  @miscprint
		Select @miscprint = '                                   ,@nocheck_type = ''DEPL_RD_Skip''           -- DEPL_RD_Skip type'
		Print  @miscprint
		Select @miscprint = '                                   ,@detail01 = ''all''                        -- DBname or All'
		Print  @miscprint
		Print  ' '
		Print  ' '
		Select @miscprint = '--Current Contents of the No_Check Table:'
		Print  @miscprint
		Select nocheckID
		    , convert(char(20), NoCheck_type) as NoCheck_type
		    , convert(char(30), detail01) as Detail01
		    , convert(char(40), detail02) as Detail02
		    , convert(char(20), detail03) as Detail03
		    , convert(char(20), detail04) as Detail04
		    , convert(char(20), addedby) as addedby
		    , createdate 
		    , moddate
		    from dbaadmin.dbo.No_Check
	   end
   end
Else
   begin
	Print  ' '
	Select @miscprint = '--Current Contents of the No_Check Table:'
	Print  @miscprint
	Select nocheckID
	    , convert(char(20), NoCheck_type) as NoCheck_type
	    , convert(char(30), detail01) as Detail01
	    , convert(char(40), detail02) as Detail02
	    , convert(char(20), detail03) as Detail03
	    , convert(char(20), detail04) as Detail04
	    , convert(char(20), addedby) as addedby
	    , createdate 
	    , moddate
	    from dbaadmin.dbo.No_Check
   end





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Auto_Zipper
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Auto_Zipper]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Auto_Zipper]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Auto_Zipper (@source_path varchar(200) = null
					,@files_starttext sysname = null
					,@files_midtext sysname = null
					,@files_extension sysname = null
					,@ZipFile_name sysname = null
					,@delete_source_files char(1) = 'y'
					,@timestamp_on_zipfile char(1) = 'y'
					,@retention_days smallint = 7)

/*********************************************************
 **  Stored Procedure dbasp_Auto_Zipper                  
 **  Written by Jim Wilson, Getty Images                
 **  June 26, 2003                                      
 **  
 **  This procedure is used to compress multiple files located
 **  at a specific path, and either retain or remove the
 **  source files.  This is for local paths only, and the
 **  winzip command line feature must be installed locally.  
 **
 **  This proc accepts several input parms (outlined below):
 **
 **  - @source_path is the drive letter path or the local share
 **    that holds the source files which are to be compressed.
 **
 **  - @files_starttext (optional) is the starting text of the 
 **    file names you will be compressing. (i.e. al files that 
 **    start with 'bac').  Do not use an * in this field.
 **
 **  - @files_midtext (optional) is the mid text of the file names
 **    you will be compressing.  (i.e. all files which have '_trn_'
 **    somewhere in the name).  Do not use an * in the field.
 **
 **  - @files_extension is the file extension, a wild card or a 
 **    combination of the two.  Enter '*all*' in this field to 
 **    compress all files in the directory.
 **
 **  - @ZipFile_name is the name of the output file.  A date/time
 **    stamp will be added to the file name along with a file
 **    extension of '.zip'.
 **
 **  - @delete_source_files is a flag for deleting the source
 **    files.  The default is to delete the files once they are 
 **    compressed.  Specifiy 'n' to retain the source files in place.
 **
 **  - @timestamp_on_zipfile is a flag for suppressing the timestamp that
 **    is normally added to the output zip file name.  Specifiy 'n' to 
 **    create a result zip file without the added timestamp as part of the
 **    file name.
 **
 ***************************************************************/
  as

SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	06/26/2003	Jim Wilson		New process 
--	07/18/2003	Jim Wilson		Added purge process and check for files to zip 
--	04/21/2004	Jim Wilson		Added info to DBA Warnings 
--	11/07/2006	Jim Wilson		Modified for SQL 2005. 
--	04/11/2008	Jim Wilson		Added support for share sub-folders. 
--	======================================================================================

/***
Declare 
	 @source_path varchar(200)
	,@files_starttext sysname
	,@files_midtext sysname
	,@files_extension sysname
	,@ZipFile_name sysname
	,@delete_source_files char(1)
	,@timestamp_on_zipfile char(1)
	,@retention_days smallint

Select @source_path = 'seadcdwdmsppa_DBASQL\dba_reports'
--Select @source_path = 'd:\'
Select @files_starttext = 'ImageRankReport'
Select @files_midtext = ''
Select @files_extension = 'csv'
Select @ZipFile_name = 'test_zip01'
Select @delete_source_files = 'n'
Select @timestamp_on_zipfile = 'n'
Select @retention_days = 7
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint		    nvarchar(4000)
	,@cmd			    nvarchar(4000)
	,@charpos		    int
	,@BkUpDateStmp 		    char(14)
	,@save_datestmp		    datetime
	,@save_ZipFile_name 	    sysname
	,@save_zip_path		    sysname
	,@save_source_path_extra    sysname
	,@Hold_hhmmss		    nvarchar(8)
	,@error_count		    int
	,@parm01		    nvarchar(100)
	,@outpath 		    nvarchar(255)
	,@zip_path 		    nvarchar(200)
	,@zip_path_name		    nvarchar(200)
	,@zip_action 		    nvarchar(5)
	,@selection		    sysname
	,@zip_selection		    sysname


----------------  initial values  -------------------
Select @error_count = 0



--  Verify imput parms
if @source_path is null or (@files_starttext is null and @files_midtext is null and @files_extension is null)
   BEGIN
	Select @miscprint = 'DBA WARNING: dbasp_Auto_Zipper - Invalid input parm(s)' 
--print @miscprint
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


--  Verify/Set ZipFile Name
if @ZipFile_name is null or @ZipFile_name = '' 
   BEGIN
	Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
	Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 
	If @timestamp_on_zipfile = 'y'
	   begin
		Select @ZipFile_name = 'DBAzip_' +  @BkUpDateStmp + '.zip'
	   end
	Else
	   begin
		Select @ZipFile_name = 'DBAzip.zip'
	   end
   END
Else
   BEGIN
	Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
	Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 
	If @timestamp_on_zipfile = 'y'
	   begin
		Select @ZipFile_name = @ZipFile_name + '_' + @BkUpDateStmp + '.zip'
	   end
	Else
	   begin
		Select @ZipFile_name = @ZipFile_name + '.zip'
	   end
   END



--  Verify @delete_source_files flag
if @delete_source_files not in ('n','y')
   BEGIN
	Select @miscprint = 'DBA WARNING: dbasp_Auto_Zipper - Invalid input parm for @delete_source_files.  Must be ''y'' or ''n''.' 
--print @miscprint
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


/****************************************************************
 *                MainLine
 ***************************************************************/

--  check to see if the source path is a full path or a local share
--  and either way, set the output path variable
Select @charpos = charindex(':\', @source_path)
IF @charpos <> 0
   begin
	select @zip_path = @source_path
   end	
Else
   begin
	--  Get the path to the source file share
	Select @parm01 = @source_path
	Select @save_source_path_extra = ''

	Select @charpos = charindex('\', @parm01)
	IF @charpos <> 0
	   begin
		Select @save_source_path_extra = substring(@parm01, @charpos, 255)
		Select @parm01 = substring(@parm01, 1, @charpos-1)
	   end

	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	If @outpath is null
	   begin
		Select @miscprint = 'DBA WARNING: dbasp_Auto_Zipper - Unable to find file share for given source path.  Check input parameter.' 
		--print @miscprint
		raiserror(@miscprint,-1,-1) with log
		Select @error_count = @error_count + 1
		goto label99
	   end
	Else
	   begin
		select @zip_path = @outpath + @save_source_path_extra
	   end
   end

print @zip_path



--  Verify source path existance
create table #fileexists ( 
	doesexist smallint,
	fileindir smallint,
	direxist smallint)

Insert into #fileexists exec master.sys.xp_fileexist @zip_path

--select * from #fileexists

If not exists (select fileindir from #fileexists where fileindir = 1)
   begin
	Select @miscprint = 'DBA WARNING: dbasp_Auto_Zipper - Source Path does not exist.  Check input parameter.' 
--print @miscprint
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end


--  Set output file name
If @zip_path like '%\'
   begin
	Select @zip_path_name = @zip_path + @ZipFile_name
   end
Else
   begin
	Select @zip_path_name = @zip_path + '\' + @ZipFile_name
   end



--  Build the zip command string

--  First we build the selection string
Select @selection = '*.'

If @files_midtext is not null and @files_midtext <> ''
   begin
	Select @selection = '*' + rtrim(@files_midtext) + @selection
   end

If @files_starttext is not null and @files_starttext <> ''
   begin
	Select @selection = rtrim(@files_starttext) + @selection
   end

If @files_extension is not null and @files_extension <> ''
   begin
	Select @selection = @selection + rtrim(@files_extension)
   end
Else
   begin
	Select @selection = @selection + '*'
   end


--  Code for special case to zip everything
If @files_extension = '*all*'
   begin
	Select @selection = '*.*'
   end


--  Set output file name
If @zip_path like '%\'
   begin
	Select @zip_selection = @zip_path + @selection
   end
Else
   begin
	Select @zip_selection = @zip_path + '\' + @selection
   end


--  Set zip action variable
If @delete_source_files = 'y'
   begin
	Select @zip_action = '-m'
   end
Else
   begin
	Select @zip_action = '-a'
   end


--  Check to see if there are files to zip
create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

select @cmd = 'dir ' + @zip_selection

insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd

If (select count(*) from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%File Not Found%') > 0
   begin
	Select @miscprint = 'DBA WARNING: dbasp_Auto_Zipper - No files found for the requested zip process (' + @zip_selection + ')' 
--print @miscprint
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label89
   end



--  Set the command variable
Select @cmd = 'wzzip ' + @zip_action + ' ' + @zip_path_name + ' ' + @zip_selection

Print 'The following wzzip command will be used.'
Print @cmd
Print ' '

EXEC master.sys.xp_cmdshell @cmd 



label89:

--  Purge Section  -------------------------------------------------------------------

If @zip_path like '%\'
   begin
	Select @save_zip_path = @zip_path
   end
Else
   begin
	Select @save_zip_path = @zip_path + '\'
   end	


If @timestamp_on_zipfile = 'y'
   begin
	Select @save_datestmp = left(@BkUpDateStmp, 8)
	Select @save_datestmp = Dateadd(day, -@retention_days, @save_datestmp)

	Select @save_ZipFile_name = STUFF (@ZipFile_name , len(@ZipFile_name)-17 , 18 , convert(varchar(8), @save_datestmp, 112) + '*.zip' ) 
	Select @cmd = 'del ' + @save_zip_path + @save_ZipFile_name
	Print 'The following delete command will be used.'
	Print @cmd
	Print ' '
	EXEC master.sys.xp_cmdshell @cmd


	Select @save_datestmp = Dateadd(day, -1, @save_datestmp)
	Select @save_ZipFile_name = STUFF (@ZipFile_name , len(@ZipFile_name)-17 , 18 , convert(varchar(8), @save_datestmp, 112) + '*.zip' ) 
	Select @cmd = 'del ' + @save_zip_path + @save_ZipFile_name
	Print 'The following delete command will be used.'
	Print @cmd
	Print ' '
	EXEC master.sys.xp_cmdshell @cmd


	Select @save_datestmp = Dateadd(day, -1, @save_datestmp)
	Select @save_ZipFile_name = STUFF (@ZipFile_name , len(@ZipFile_name)-17 , 18 , convert(varchar(8), @save_datestmp, 112) + '*.zip' ) 
	Select @cmd = 'del ' + @save_zip_path + @save_ZipFile_name
	Print 'The following delete command will be used.'
	Print @cmd
	Print ' '
	EXEC master.sys.xp_cmdshell @cmd


	Select @save_datestmp = Dateadd(day, -1, @save_datestmp)
	Select @save_ZipFile_name = STUFF (@ZipFile_name , len(@ZipFile_name)-17 , 18 , convert(varchar(8), @save_datestmp, 112) + '*.zip' ) 
	Select @cmd = 'del ' + @save_zip_path + @save_ZipFile_name
	Print 'The following delete command will be used.'
	Print @cmd
	Print ' '
	EXEC master.sys.xp_cmdshell @cmd


	Select @save_datestmp = Dateadd(day, -1, @save_datestmp)
	Select @save_ZipFile_name = STUFF (@ZipFile_name , len(@ZipFile_name)-17 , 18 , convert(varchar(8), @save_datestmp, 112) + '*.zip' ) 
	Select @cmd = 'del ' + @save_zip_path + @save_ZipFile_name
	Print 'The following delete command will be used.'
	Print @cmd
	Print ' '
	EXEC master.sys.xp_cmdshell @cmd
   end


--  Finalization  -------------------------------------------------------------------

label99:


If (object_id('tempdb..#fileexists') is not null)
   begin
	drop table #fileexists
   end

If (object_id('tempdb..#DirectoryTempTable') is not null)
   begin
	drop table #DirectoryTempTable
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_autorestore
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_autorestore]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_autorestore]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_autorestore ( @full_path nvarchar(500) = null, 
					@dbname sysname = null,
					@ALTdbname sysname = null,
					@backupname sysname = null, 
					@backmidmask sysname = '_db_2', 
					@diffmidmask sysname = '_dfntl_2', 
					@datapath nvarchar(100) = null, 
					@data2path nvarchar(100) = null, 
					@logpath nvarchar(100) = null, 
					@sourcepath char(1) = 'n',
					@force_newldf char(1) = 'n',
					@drop_dbFlag char(1) = 'n',
					@differential_flag char(1) = 'n',
					@db_norecovOnly_flag char(1) = 'n',
					@db_diffOnly_flag char(1) = 'n',
					@post_shrink char(1) = 'n',
					@complete_on_diffOnly_fail char(1) = 'n',
					@script_out char(1) = 'y',
					@DTstmp_in_DBfilenames char(1) = 'n',
					@partial_flag char(1) = 'n',
		 			@filegroup_name sysname = '',
		 			@file_name nvarchar(500) = '')

/*********************************************************
 **  Stored Procedure dbasp_autorestore                  
 **  Written by Jim Wilson, Getty Images                
 **  September 21, 2001                                      
 **  
 **  This procedure is used for automated database
 **  restore processing.
 **
 **  This proc accepts the following input parms:
 **  - @full_path is the path where the backup file can be found
 **    example - "\\seafresqlwcds\seafresqlwcds_dbasql"
 **  - @dbname is the name of the database being restored.
 **  - @ALTdbname is the "new" name of the database being restored (if you need a different DB name).
 **  - @backupname is the name pattern of the backup file to be restored.
 **  - @backmidmask is the mask for the midpart of the backup file name (i.e. '_db_2')
 **  - @diffmidmask is the mask for the midpart of the differential file name (i.e. '_dfntl_2')
 **  - @datapath is the target path for the data files (optional)
 **  - @logpath is the target path for the log files (optional)
 **  - @sourcepath is a flag to force the usage of the file paths
 **    designated in the source backup.  Specify "y" to set on.
 **  - @force_newldf is a flag to force the creation of a new ldf file
 **  - @drop_dbFlag is a flag to force a drop of the DB prior to restore.
 **  - @differential_flag is a flag to indicate a recovery for a 
 **    DB backup followed by a differential backup.
 **  - @db_norecovOnly_flag indicates a DB recovery with the norecovery parm,
 **    which should be followed later by a differential only restore.
 **  - @db_diffOnly_flag indicates a differential only restore. 
 **  - @post_shrink is for a post restore file shrink (y or n)
 **  - @complete_on_diffOnly_fail will finish the restore of a DB after a failed 
 **    differential restore'
 **  - @script_out will either script out the restore commands or run the restore
 **    within the context of the sproc.
 **  - @DTstmp_in_DBfilenames will add a time stamp to the DB physical file names (y or n).  
 **  - @partial_flag = 'y' if you want to restore just a single file group.  
 **  - @filegroup_name if a file group restore is requested.  
 **  - @file_name if a file name restore is requested.  
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	06/10/2002	Jim Wilson		Changed isql to osql
--	07/29/2002	Jim Wilson		Set default path by looking at the path for the 
--						master DB files.
--	09/24/2002	Jim Wilson		Modified output share example 
--	12/23/2002	Jim Wilson		Added backup name parm 
--	01/08/2003	Jim Wilson		Added flag for forcing a new ldf file 
--	04/14/2003	Jim Wilson		Fixed shrink ldf file process (detach and reatach) 
--	10/13/2003	Jim Wilson		The process will now still work if multiple backup
--						files are found.  Newest file is used.  The default 
--						backup name was chaged so that dbname_DB anywhere in
--						the backup file name will work. 
--						Added drop DB flag.
--	06/14/2004	Jim Wilson		Added differential restore process
--	07/20/2004	Jim Wilson		New split processing (DB restore with norecovery or
--						differential only)
--	08/10/2004	Jim Wilson		New set standard mdf file name process
--	08/16/2004	Jim Wilson		Fixed time stamp for just after midnight(12am to 00am)
--	08/18/2005	Jim Wilson		Added code for LiteSpeed processing.
--	08/19/2005	Jim Wilson		Added retry for the 'dir' command.
--	12/13/2005	Jim Wilson		Removed order by for differential files in the cursor.
--	06/22/2006	Jim Wilson		Updated for SQL 2005.
--	07/28/2006	Jim Wilson		Change filelist table for Litespeed backup header.
--	12/06/2006	Jim Wilson		Added 2 masks for non-standard backup and differentail file names.
--	03/23/2007	Jim Wilson		Leading underscore for input parm @diffmidmask was missing.
--	07/25/2007	Jim Wilson		Added code for RedGate processing.
--	11/12/2007	Jim Wilson		Added support for type 'F' files.
--	05/27/2008	Jim Wilson		New shrink DB process using @force_newldf = 'x'
--	05/27/2008	Jim Wilson		Added data2path and post_restore shrink.
--	07/23/2008	Jim Wilson		Major revisions; added input parms @complete_on_diffOnly_fail and
--						@script_out.  Now retores can be done within the context of this sproc.
--	07/28/2008	Jim Wilson		Added if scriptout='n' at end.
--	08/05/2008	Jim Wilson		Modified error checking for Redgate restores.
--	08/06/2008	Jim Wilson		Post file shrink is now just for LDF files.  Also
--						added time stamp to data file names, new ability to
--						restore to alternate DBname, and alter DB options after restore.
--	03/30/2009	Jim Wilson		Change path to \\localhost for local restores to unc.
--	04/16/2009	Jim Wilson		Removed \\localhostcode and added code to get the driveletter path.
--	05/19/2009	Jim Wilson		Added @partial_flag and @filegroup_name input parms.
--	05/28/2009	Jim Wilson		Added @file_name input parms.
--	06/16/2009	Jim Wilson		Fixed bug with standard restore for RESTORE DATABASE line.
--	07/07/2009	Jim Wilson		Removed filegroup parm from redgate diff restore syntax.
--	05/04/2010	Jim Wilson		SQL2008 changes start here.
--	05/04/2010	Jim Wilson		Added TDEThumbprint column to filelist temp table.
--	======================================================================================


/***
Declare @full_path nvarchar(100)
Declare @dbname sysname
Declare @ALTdbname sysname
Declare @backupname sysname
Declare @backmidmask sysname
Declare @diffmidmask sysname 
Declare @datapath nvarchar(100)
Declare @data2path nvarchar(100)
Declare @logpath nvarchar(100)
Declare @sourcepath char(1)
Declare @force_newldf char(1)
Declare @drop_dbFlag char(1)
Declare @differential_flag char(1)
Declare @db_norecovOnly_flag char(1)
Declare @db_diffOnly_flag char(1)
Declare @post_shrink char(1)
Declare @complete_on_diffOnly_fail char(1)
Declare @script_out char(1)
Declare @DTstmp_in_DBfilenames char(1)
Declare @partial_flag char(1)
Declare @filegroup_name sysname
Declare @file_name nvarchar(500)


select @full_path = '\\SQLDEPLOYER04\SQLDEPLOYER04_restore\BNDL'
select @dbname = 'Bundle'
--select @ALTdbname = 'ArtistListing_new'
--Select @backupname = 'dbaadmin_db'
Select @backmidmask = '_db_2' 
Select @diffmidmask = '_dfntl_2' 
select @datapath = 'd:\mssql.1\data'
--select @data2path = 'e:\mssql.1\data'
select @logpath = 'd:\mssql.1\data'
select @sourcepath = 'n' 
select @force_newldf = 'n' 
select @drop_dbFlag = 'n'
select @differential_flag = 'n'
select @db_norecovOnly_flag = 'n'
select @db_diffOnly_flag = 'n'
Select @post_shrink = 'n'
Select @complete_on_diffOnly_fail = 'n'
Select @script_out = 'y'
Select @DTstmp_in_DBfilenames = 'y'
Select @partial_flag = 'n'
Select @filegroup_name = ''
Select @file_name = ''
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@error_count			int
	,@retry_count			int
	,@cmd 				nvarchar(4000)
	,@Restore_cmd			nvarchar(4000)
	,@retcode 			int
	,@filecount			smallint
	,@filename_wild			nvarchar(100)
	,@diffname_wild			nvarchar(100)
	,@charpos			int
	,@query 			nvarchar(4000)
	,@mssql_data_path		nvarchar(255)
	,@savePhysicalNamePart		nvarchar(260)
	,@savefilepath			nvarchar(260)
	,@hold_filedate			nvarchar(12)
	,@save_filedate			nvarchar(12)
	,@save_fileYYYY			nvarchar(4)
	,@save_fileMM			nvarchar(2)
	,@save_fileDD			nvarchar(2)
	,@save_fileHH			nvarchar(2)
	,@save_fileMN			nvarchar(2)
	,@save_fileAMPM			nvarchar(1)
	,@save_LogicalName		sysname
	,@save_cmdoutput		nvarchar(255)
	,@save_subject			sysname
	,@save_message			nvarchar(500)
	,@hold_ldfpath			nvarchar(260)
	,@hold_backupfilename		sysname
	,@hold_diff_file_name		sysname
	,@fileseq			smallint
	,@fileseed			smallint
	,@diffname			sysname
	,@BkUpMethod			nvarchar(5)
	,@detach_cmd			sysname
	,@deleteLDF_cmd			sysname
	,@attach_cmd			sysname
	,@DateStmp 			nvarchar(15)
	,@Hold_hhmmss			nvarchar(8)
	,@drop_dbname			sysname
	,@check_dbname 			sysname
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_localservername_mask	sysname
	,@save_alt_full_path		nvarchar(500)
	,@outpath			nvarchar(500)
	,@save_fg_name			nvarchar(500)
	,@save_fn_name			nvarchar(500)


	
DECLARE
	 @cu11cmdoutput			nvarchar(255)

DECLARE
	 @cu12fileid			smallint
	,@cu12name			nvarchar(128)
	,@cu12filename			nvarchar(260)

DECLARE
	 @cu21LogicalName		nvarchar(128)
	,@cu21PhysicalName		nvarchar(260)
	,@cu21Type			char(1)
	,@cu21FileGroupName		nvarchar(128)

DECLARE
	 @cu22LogicalName		nvarchar(128)
	,@cu22PhysicalName		nvarchar(260)
	,@cu22Type			char(1)
	,@cu22FileGroupName		nvarchar(128)

DECLARE
	 @cu25cmdoutput			nvarchar(255)



----------------  initial values  -------------------
Select @retry_count = 0
Select @error_count = 0
Select @hold_filedate = '200001010001'
Select @BkUpMethod = 'MS'
select @filename_wild = ''
select @diffname_wild = ''
select @DateStmp = ''

Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_localservername_mask = '\\' + @save_servername + '%'


If @ALTdbname is not null and @ALTdbname <> ''
   begin
	Select @check_dbname = @ALTdbname 
   end
Else
   begin
	Select @check_dbname = @dbname 
   end



If @DTstmp_in_DBfilenames = 'y'
   begin
	Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
	Set @DateStmp = '_' + convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 
   end


create table #db_files(fileid smallint
			,name nvarchar(128)
			,filename nvarchar(260))


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)
create table #filelist(LogicalName nvarchar(128) null, 
						PhysicalName nvarchar(260) null, 
						Type char(1), 
						FileGroupName nvarchar(128) null, 
						Size numeric(20,0), 
						MaxSize numeric(20,0),
						FileId bigint,
						CreateLSN numeric(25,0),
						DropLSN numeric(25,0),
						UniqueId uniqueidentifier,
						ReadOnlyLSN numeric(25,0),
						ReadWriteLSN numeric(25,0),
						BackupSizeInBytes bigint,
						SourceBlockSize int,
						FileGroupId int,
						LogGroupGUID uniqueidentifier null,
						DifferentialBaseLSN numeric(25,0),
						DifferentialBaseGUID uniqueidentifier,
						IsReadOnly bit,
						IsPresent bit,
						TDEThumbprint varbinary(32) null
						)

create table #filelist_ls (LogicalName nvarchar(128) null, 
						PhysicalName nvarchar(260) null, 
						Type char(1), 
						FileGroupName nvarchar(128) null, 
						Size numeric(20,0), 
						MaxSize numeric(20,0)
						)

create table #filelist_rg(LogicalName nvarchar(128) null, 
						PhysicalName nvarchar(260) null, 
						Type char(1), 
						FileGroupName nvarchar(128) null, 
						Size numeric(20,0), 
						MaxSize numeric(20,0),
						FileId bigint,
						CreateLSN numeric(25,0),
						DropLSN numeric(25,0),
						UniqueId uniqueidentifier,
						ReadOnlyLSN numeric(25,0),
						ReadWriteLSN numeric(25,0),
						BackupSizeInBytes bigint,
						SourceBlockSize int,
						FileGroupId int,
						LogGroupGUID sysname null,
						DifferentialBaseLSN numeric(25,0),
						DifferentialBaseGUID uniqueidentifier,
						IsReadOnly bit,
						IsPresent bit
						)



--  Check input parms
if @full_path is null or @full_path = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_autorestore - @full_path must be specified.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @dbname is null or @dbname = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_autorestore - @dbname must be specified.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @db_norecovOnly_flag = 'y' and @db_diffOnly_flag = 'y'
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters - @db_norecovOnly_flag and @db_diffOnly_flag cannot both be selected' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @db_diffOnly_flag = 'y' and @differential_flag <> 'y'
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters - @differential_flag must = ''y'' if @db_diffOnly_flag is selected' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

If @force_newldf = 'y' and @db_norecovOnly_flag = 'y'
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters - @force_newldf and @db_diffOnly_flag cannot both be selected' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


If @script_out <> 'y'
   begin
	select @miscprint = 'DBA Message:  This restore will be done within the context of the stored procedure execution for database [' + @check_dbname + ']'
	print  @miscprint
	print  ''
   end

If @backupname is null or @backupname = ''
   begin
	select @filename_wild = @filename_wild + @dbname + @backmidmask + '*'
	select @diffname_wild = @diffname_wild + @dbname + @diffmidmask + '*'
   end
Else
   begin
	Select @diffname = REPLACE(@backupname, '_db_', '_dfntl_')
	select @filename_wild = @filename_wild + @backupname
	select @diffname_wild = @diffname_wild + @diffname
   end



If @data2path is null
   begin
	select @data2path = @datapath
   end

--  Set path for local restores
If @full_path like @save_localservername_mask and @full_path like '\\%' and @full_path not like '%$%'
   begin
	--  Get the path to the source file share
	Select @save_alt_full_path = replace(@full_path, '\\', '')
	 

	Select @charpos = charindex('\', @save_alt_full_path)
	IF @charpos <> 0
	   begin
		Select @save_alt_full_path = substring(@save_alt_full_path, @charpos+1, 255)
		Select @save_alt_full_path = ltrim(rtrim(@save_alt_full_path))
	   end

	exec dbaadmin.dbo.dbasp_get_share_path @save_alt_full_path, @outpath output
	If @outpath is not null
	   begin
		select @full_path = @outpath
	   end

   end



/****************************************************************
 *                MainLine
 ***************************************************************/

If @script_out = 'y'
   begin
	select @miscprint = 'Use Master'
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	print  ' '
   end

--  If this is for a differential only restore, jump to that section
If @db_diffOnly_flag = 'y'
   begin
	goto label12
   end

select @cmd = 'dir ' + @full_path + '\' + @filename_wild
--print @cmd

start_dir:
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where cmdoutput like '%<DIR>%'
delete from #DirectoryTempTable where cmdoutput like '%Directory of%'
delete from #DirectoryTempTable where cmdoutput like '% File(s) %'
delete from #DirectoryTempTable where cmdoutput like '% Dir(s) %'
delete from #DirectoryTempTable where cmdoutput like '%Volume in drive%'
delete from #DirectoryTempTable where cmdoutput like '%Volume Serial Number%'
--select * from #DirectoryTempTable

select @filecount = (select count(*) from #DirectoryTempTable)

If @filecount < 1
   BEGIN
	If @retry_count < 5
	   begin
		Select @retry_count = @retry_count + 1
		Waitfor delay '00:00:10'
		delete from #DirectoryTempTable
		goto start_dir
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: No files found for dbasp_autorestore at ' + @full_path + ' using mask "' + @filename_wild + '"'
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   END
Else
   BEGIN
	Start_cmdoutput01:
	Select @save_cmdoutput = (Select top 1 cmdoutput from #DirectoryTempTable order by cmdoutput)
	Select @cu11cmdoutput = @save_cmdoutput

	select @save_fileYYYY = substring(@cu11cmdoutput, 7, 4)
	select @save_fileMM = substring(@cu11cmdoutput, 1, 2)
	select @save_fileDD = substring(@cu11cmdoutput, 4, 2)
	select @save_fileHH = substring(@cu11cmdoutput, 13, 2)
	Select @save_fileAMPM = substring(@cu11cmdoutput, 18, 1)
	If @save_fileAMPM = 'a' and @save_fileHH = '12'
	   begin
		Select @save_fileHH = '00'
	   end
	Else If @save_fileAMPM = 'p' and @save_fileHH <> '12'
	   begin
		Select @save_fileHH = @save_fileHH + 12
	   end
	select @save_fileMN = substring(@cu11cmdoutput, 16, 2)
	Select @save_filedate = @save_fileYYYY + @save_fileMM + @save_fileDD + @save_fileHH + @save_fileMN

	If @hold_filedate < @save_filedate
	   begin
		select @hold_backupfilename = ltrim(rtrim(substring(@cu11cmdoutput, 40, 200)))
	   end

	Delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto Start_cmdoutput01
	   end
   END


--  Check file name to determin if we can process the file
If @hold_backupfilename like '%.bkp'
   begin
	If exists (select 1 from master.sys.objects where name = 'xp_backup_database' and type = 'x')
	   begin
		Print '--  Note:  LiteSpeed Syntax will be used for this request'
		Print ' '
		Select @BkUpMethod = 'LS'
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: LiteSpeed backups cannot be processed by dbasp_autorestore on this server. ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   end

If @hold_backupfilename like '%.SQB%'
   begin
	If exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
	   begin
		Print '--  Note:  RedGate Syntax will be used for this request'
		Print ' '
		Select @BkUpMethod = 'RG'
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: RedGate backups cannot be processed by dbasp_autorestore on this server. ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   end



If @drop_dbFlag = 'y'
   begin
	If @ALTdbname is not null and @ALTdbname <> ''
	   begin
		Select @drop_dbname = @ALTdbname 
	   end
	Else
	   begin
		Select @drop_dbname = @ALTdbname 
	   end

	If @script_out = 'y'
	   begin
		select @miscprint = 'DROP DATABASE ' + @drop_dbname 
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		print  ' '
		select @miscprint = 'Waitfor delay ''00:00:10'''
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print  ' '
		Print  ' '
	   end
	Else
	   begin
		If exists (select 1 from master.sys.databases where name = @drop_dbname)
		   begin
			Select @cmd = 'drop database [' + @drop_dbname + ']'
			Print  @cmd
			Exec(@cmd)

			waitfor delay '00:00:05'
		   end

		--  Verify the DB no longer exists
		If exists (select 1 from master.sys.databases where name = @drop_dbname)
		   BEGIN
			Select @miscprint = 'DBA ERROR: Unable to drop database ' + @drop_dbname + '.  The autorestore process is not able to continue.' 
			Print  @miscprint
			Select @error_count = @error_count + 1
			goto label99
		   END
	   end
   end
	
	
If @BkUpMethod = 'LS'
   begin
	select @miscprint = 'EXEC master.dbo.xp_restore_database'
	print  @miscprint
	If @ALTdbname is not null and @ALTdbname <> ''
	   begin
		select @miscprint = '  @database =  ''' + @ALTdbname + ''''
		print  @miscprint
	   end
	Else
	   begin
		select @miscprint = '  @database =  ''' + @dbname + ''''
		print  @miscprint
	   end
	select @miscprint = ', @filename = ''' + @full_path + '\' + @hold_backupfilename + ''''
	print  @miscprint

	select @Restore_cmd = ''
	select @Restore_cmd = @Restore_cmd + 'EXEC master.dbo.xp_restore_database'
	select @Restore_cmd = @Restore_cmd + '  @database =  ''' + @check_dbname + ''''
	select @Restore_cmd = @Restore_cmd + ', @filename = ''' + @full_path + '\' + @hold_backupfilename + ''''


	If @differential_flag = 'y' or @db_norecovOnly_flag = 'y'
	   begin
		select @miscprint = ', @with = NORECOVERY'
		print  @miscprint
		select @miscprint = ', @with = ''REPLACE'''
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ', @with = NORECOVERY'
		select @Restore_cmd = @Restore_cmd + ', @with = ''REPLACE'''
	   end	
	Else
	   begin
		select @miscprint = ', @with = RECOVERY'
		print  @miscprint
		select @miscprint = ', @with = ''REPLACE'''
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ', @with = RECOVERY'
		select @Restore_cmd = @Restore_cmd + ', @with = ''REPLACE'''
	   end	

	delete from #filelist_ls

	Select @query = 'EXEC master.dbo.xp_restore_filelistonly @filename = ''' + rtrim(@full_path) + '\' + rtrim(@hold_backupfilename) + ''''
	insert into #filelist_ls exec (@query)
	If (select count(*) from #filelist_ls) = 0
	   begin
		Select @miscprint = 'DBA Error: Unable to process LiteSpeed filelistonly for file ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end

	--  set the default path just in case we need it
	Select @mssql_data_path = (select filename from master.sys.sysfiles where fileid = 1)
	select @charpos = charindex('master', @mssql_data_path)
	select @mssql_data_path = left(@mssql_data_path, @charpos-1)
	select @fileseq = 1


	EXECUTE('DECLARE cu21_cursor Insensitive Cursor For ' +
	  'SELECT f.LogicalName, f.PhysicalName, f.Type, f.FileGroupName
	   From #filelist_ls   f ' +
	  'for Read Only')

	OPEN cu21_cursor
	
	WHILE (21=21)
	 Begin
		FETCH Next From cu21_cursor Into @cu21LogicalName, @cu21PhysicalName, @cu21Type, @cu21FileGroupName
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu21_cursor
		      BREAK
	           end


		select @savePhysicalNamePart = @cu21PhysicalName
		label01:

		select @charpos = charindex('\', @savePhysicalNamePart)
		IF @charpos <> 0
		   begin
  		    select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
		   end	
	
		select @charpos = charindex('\', @savePhysicalNamePart)
		IF @charpos <> 0
		   begin
		    goto label01
 		   end


		If @DTstmp_in_DBfilenames = 'y'
		   begin
			If @savePhysicalNamePart like '%.mdf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.mdf', @DateStmp + '.mdf')
			   end
			Else If @savePhysicalNamePart like '%.ndf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ndf', @DateStmp + '.ndf')
			   end
			Else If @savePhysicalNamePart like '%.ldf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ldf', @DateStmp + '.ldf')
			   end
			Else
			   begin		
				Select @savePhysicalNamePart = @savePhysicalNamePart + @DateStmp
			   end
		   end


		If @sourcepath = 'y'
		   begin
			Select @savefilepath = @cu21PhysicalName
		   end
		Else If @datapath is not null and @cu21Type in ('D', 'F')
		   begin
			If @savePhysicalNamePart not like '%mdf' and @data2path is not null
			   begin
				Select @savefilepath = @data2path + '\' + @savePhysicalNamePart
			   end
			Else
			   begin
				Select @savefilepath = @datapath + '\' + @savePhysicalNamePart
			   end
		   end
		Else IF @logpath is not null and @cu21Type = 'L'
		   begin
			Select @savefilepath = @logpath + '\' + @savePhysicalNamePart
		   end
		Else
		   begin
			Select @savefilepath = @mssql_data_path + @savePhysicalNamePart
		   end


		select @miscprint = ', @with = ''MOVE "' + @cu21LogicalName + '" to "' + @savefilepath + '"'''
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ', @with = ''MOVE "' + @cu21LogicalName + '" to "' + @savefilepath + '"'''


		--  capture ldf info if needed
		If @force_newldf = 'y'
		   begin
			select @charpos = charindex('.ldf', @savefilepath)
			IF @charpos <> 0
			   begin
				select @hold_ldfpath = @savefilepath
			   end
			Else
			   begin
				insert #db_files values (@fileseq, @cu21LogicalName, @savefilepath)
			   end
		   end

		select @fileseq = @fileseq + 1



	End  -- loop 21
	DEALLOCATE cu21_cursor



	select @miscprint = ', @with = ''stats'''
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @Restore_cmd = @Restore_cmd + ', @with = ''stats'''


	If @script_out <> 'y'
	   begin
		-- Restore the database
		select @cmd = @Restore_cmd
		Print 'Here is the restore command being executed;'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec (@cmd)

		If @@error<> 0
		   begin
			Print 'DBA Error:  Restore Failure (LiteSpeed) for command ' + @cmd
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end



	If @db_norecovOnly_flag = 'y'
	   begin
		Print ' '
		select @miscprint = '--  Note:  This will leave the database in recovery pending mode.'
		print  @miscprint
		goto label99
	
	   end
   end



If @BkUpMethod = 'RG'
   begin
	select @miscprint = 'Declare @cmd nvarchar(4000)'
	print  @miscprint

	select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @check_dbname + ']'

	If @partial_flag = 'y' and @filegroup_name is not null and @filegroup_name <> ''
	   begin
		Select @charpos = charindex(',', @filegroup_name)
		IF @charpos <> 0
		   begin
			start_fg_multi:
			select @save_fg_name = substring(@filegroup_name, 1, @charpos-1)
			Select @save_fg_name = ltrim(rtrim(@save_fg_name))
			Select @filegroup_name = substring(@filegroup_name, @charpos+1, 500)

			select @miscprint = @miscprint + ' FILEGROUP=''''' + @filegroup_name + ''''''

			Select @charpos = charindex(',', @filegroup_name)
			IF @charpos <> 0
			   begin
				select @miscprint = @miscprint + ','
				goto start_fg_multi
			   end
		   end
		Else
		   begin
			select @miscprint = @miscprint + ' FILEGROUP=''''' + @filegroup_name + ''''''
		   end
	   end

	If @partial_flag = 'y' and @file_name is not null and @file_name <> ''
	   begin
		If @miscprint like '%FILEGROUP=%'
		   begin
			select @miscprint = @miscprint + ','
		   end

		Select @charpos = charindex(',', @file_name)
		IF @charpos <> 0
		   begin
			start_fn_multi:
			select @save_fn_name = substring(@file_name, 1, @charpos-1)
			Select @save_fn_name = ltrim(rtrim(@save_fn_name))
			Select @file_name = substring(@file_name, @charpos+1, 500)

			select @miscprint = @miscprint + ' FILE=''''' + @file_name + ''''''

			Select @charpos = charindex(',', @file_name)
			IF @charpos <> 0
			   begin
				select @miscprint = @miscprint + ','
				goto start_fn_multi
			   end
		   end
		Else
		   begin
			select @miscprint = @miscprint + ' FILE=''''' + @file_name + ''''''
		   end
	   end

	print  @miscprint

	select @miscprint = '	 FROM DISK = ''''' + @full_path + '\' + @hold_backupfilename + ''''''
	print  @miscprint



	select @Restore_cmd = '-SQL "RESTORE DATABASE [' + @check_dbname + ']'

	If @partial_flag = 'y' and @filegroup_name is not null and @filegroup_name <> ''
	   begin
		Select @charpos = charindex(',', @filegroup_name)
		IF @charpos <> 0
		   begin
			start_fg_multi02:
			select @save_fg_name = substring(@filegroup_name, 1, @charpos-1)
			Select @save_fg_name = ltrim(rtrim(@save_fg_name))
			Select @filegroup_name = substring(@filegroup_name, @charpos+1, 500)

			select @Restore_cmd = @Restore_cmd + ' FILEGROUP=''' + @filegroup_name + ''''

			Select @charpos = charindex(',', @filegroup_name)
			IF @charpos <> 0
			   begin
				select @Restore_cmd = @Restore_cmd + ','
				goto start_fg_multi02
			   end
		   end
		Else
		   begin
			select @Restore_cmd = @Restore_cmd + ' FILEGROUP=''' + @filegroup_name + ''''
		   end
	   end


	If @partial_flag = 'y' and @file_name is not null and @file_name <> ''
	   begin
		If @miscprint like '%FILEGROUP=%'
		   begin
			select @Restore_cmd = @Restore_cmd + ','
		   end

		Select @charpos = charindex(',', @file_name)
		IF @charpos <> 0
		   begin
			start_fn_multi02:
			select @save_fn_name = substring(@file_name, 1, @charpos-1)
			Select @save_fn_name = ltrim(rtrim(@save_fn_name))
			Select @file_name = substring(@file_name, @charpos+1, 500)

			select @Restore_cmd = @Restore_cmd + ' FILE=''' + @file_name + ''''

			Select @charpos = charindex(',', @file_name)
			IF @charpos <> 0
			   begin
				select @Restore_cmd = @Restore_cmd + ','
				goto start_fn_multi02
			   end
		   end
		Else
		   begin
			select @Restore_cmd = @Restore_cmd + ' FILE=''' + @file_name + ''''
		   end
	   end


	select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_backupfilename + ''''


	If @differential_flag = 'y' or @db_norecovOnly_flag = 'y'
	   begin
		If @partial_flag = 'y' and @filegroup_name is not null and @filegroup_name <> ''
		   begin
			select @miscprint = '	 WITH PARTIAL, NORECOVERY'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH PARTIAL, NORECOVERY'
		   end
		Else
		   begin
			select @miscprint = '	 WITH NORECOVERY'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH NORECOVERY'
		   end
	   end	
	Else
	   begin
		If @partial_flag = 'y' and @filegroup_name is not null and @filegroup_name <> ''
		   begin
			select @miscprint = '	 WITH PARTIAL, RECOVERY'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH PARTIAL, RECOVERY'
		   end
		Else
		   begin
			select @miscprint = '	 WITH RECOVERY'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH RECOVERY'
		   end
	   end


	-- Get file header info from the SQB backup file
	delete from #filelist_rg

	Select @query = 'Exec master.dbo.sqlbackup ''-SQL "RESTORE FILELISTONLY FROM DISK = ''''' + rtrim(@full_path) + '\' + rtrim(@hold_backupfilename) + '''''"'''
	insert into #filelist_rg exec (@query)
	If (select count(*) from #filelist_rg) = 0
	   begin
		Select @miscprint = 'DBA Error: Unable to process RedGate filelistonly for file ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end

	--  set the default path just in case we need it
	Select @mssql_data_path = (select filename from master.sys.sysfiles where fileid = 1)
	select @charpos = charindex('master', @mssql_data_path)
	select @mssql_data_path = left(@mssql_data_path, @charpos-1)
	select @fileseq = 1


	EXECUTE('DECLARE cu21_cursor Insensitive Cursor For ' +
	  'SELECT f.LogicalName, f.PhysicalName, f.Type, f.FileGroupName
	   From #filelist_rg   f ' +
	  'for Read Only')

	OPEN cu21_cursor
	
	WHILE (21=21)
	 Begin
		FETCH Next From cu21_cursor Into @cu21LogicalName, @cu21PhysicalName, @cu21Type, @cu21FileGroupName
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu21_cursor
		      BREAK
	           end


		select @savePhysicalNamePart = @cu21PhysicalName
		label02:
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
	  		    select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
			   end	
	
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
			    goto label02
	 		   end


		If @DTstmp_in_DBfilenames = 'y'
		   begin
			If @savePhysicalNamePart like '%.mdf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.mdf', @DateStmp + '.mdf')
			   end
			Else If @savePhysicalNamePart like '%.ndf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ndf', @DateStmp + '.ndf')
			   end
			Else If @savePhysicalNamePart like '%.ldf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ldf', @DateStmp + '.ldf')
			   end
			Else
			   begin		
				Select @savePhysicalNamePart = @savePhysicalNamePart + @DateStmp
			   end
		   end



		If @sourcepath = 'y'
		   begin
			Select @savefilepath = @cu21PhysicalName
		   end
		Else If @datapath is not null and @cu21Type in ('D', 'F')
		   begin
			If @savePhysicalNamePart not like '%mdf' and @data2path is not null
			   begin
				Select @savefilepath = @data2path + '\' + @savePhysicalNamePart
			   end
			Else
			   begin
				Select @savefilepath = @datapath + '\' + @savePhysicalNamePart
			   end
		   end
		Else IF @logpath is not null and @cu21Type = 'L'
		   begin
			Select @savefilepath = @logpath + '\' + @savePhysicalNamePart
		   end
		Else
		   begin
			Select @savefilepath = @mssql_data_path + @savePhysicalNamePart
		   end


		select @miscprint = '	,MOVE ''''' + rtrim(@cu21LogicalName) + ''''' to ''''' + rtrim(@savefilepath) + ''''''
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ', MOVE ''' + rtrim(@cu21LogicalName) + ''' to ''' + rtrim(@savefilepath) + ''''



		--  capture ldf info if needed
		If @force_newldf = 'y'
		   begin
			select @charpos = charindex('.ldf', @savefilepath)
			IF @charpos <> 0
			   begin
				select @hold_ldfpath = @savefilepath
			   end
			Else
			   begin
				insert #db_files values (@fileseq, @cu21LogicalName, @savefilepath)
			   end
		   end

		select @fileseq = @fileseq + 1



	End  -- loop 21
	DEALLOCATE cu21_cursor



	select @miscprint = '	,REPLACE"'''
	print  @miscprint
	select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
	print  @miscprint
	select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
	print  @miscprint
	select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @Restore_cmd = @Restore_cmd + ' ,REPLACE"'


	If @script_out <> 'y'
	   begin
		-- Restore the database
		select @cmd = 'Exec master.dbo.sqlbackup ' + @Restore_cmd
		Print 'Here is the restore command being executed;'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec master.dbo.sqlbackup @Restore_cmd

		If @db_norecovOnly_flag = 'y' and DATABASEPROPERTYEX (@check_dbname,'status') <> 'RESTORING'
		   begin
			select @miscprint = 'DBA Error:  Restore Failure (Redgate partial restore) for command ' + @cmd
			print  @miscprint
			Select @error_count = @error_count + 1
			goto label99
		   end
		Else If @db_norecovOnly_flag <> 'y' and @differential_flag = 'n' and DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
		   begin
			select @miscprint = 'DBA Error:  Restore Failure (Redgate complete restore) for command ' + @cmd
			print  @miscprint
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end


	If @db_norecovOnly_flag = 'y'
	   begin
		Print ' '
		select @miscprint = '--  Note:  This will leave the database in recovery pending mode.'
		print  @miscprint
		goto label99
	   end
   end


--  If not a LiteSpeed or RedGate file ----
If @BkUpMethod = 'MS'
   begin
	select @miscprint = 'RESTORE DATABASE ' + @check_dbname

	select @Restore_cmd = ''
	select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname

	If @partial_flag = 'y' and @filegroup_name is not null and @filegroup_name <> ''
	   begin
		Select @charpos = charindex(',', @filegroup_name)
		IF @charpos <> 0
		   begin
			start_fg_multi03:
			select @save_fg_name = substring(@filegroup_name, 1, @charpos-1)
			Select @save_fg_name = ltrim(rtrim(@save_fg_name))
			Select @filegroup_name = substring(@filegroup_name, @charpos+1, 500)

			select @miscprint = @miscprint + ' FILEGROUP=''' + @filegroup_name + ''''
			select @Restore_cmd = @Restore_cmd + ' FILEGROUP=''' + @filegroup_name + ''''

			Select @charpos = charindex(',', @filegroup_name)
			IF @charpos <> 0
			   begin
				select @miscprint = @miscprint + ','
				select @Restore_cmd = @Restore_cmd + ','
				goto start_fg_multi03
			   end
		   end
		Else
		   begin
			select @miscprint = @miscprint + ' FILEGROUP=''' + @filegroup_name + ''''
			select @Restore_cmd = @Restore_cmd + ' FILEGROUP=''' + @filegroup_name + ''''
		   end
	   end

	If @partial_flag = 'y' and @file_name is not null and @file_name <> ''
	   begin
		If @miscprint like '%FILEGROUP=%'
		   begin
			select @miscprint = @miscprint + ','
			select @Restore_cmd = @Restore_cmd + ','
		   end

		Select @charpos = charindex(',', @file_name)
		IF @charpos <> 0
		   begin
			start_fn_multi04:
			select @save_fn_name = substring(@file_name, 1, @charpos-1)
			Select @save_fn_name = ltrim(rtrim(@save_fn_name))
			Select @file_name = substring(@file_name, @charpos+1, 500)

			select @miscprint = @miscprint + ' FILE=''''' + @file_name + ''''''
			select @Restore_cmd = @Restore_cmd + ' FILE=''''' + @file_name + ''''''

			Select @charpos = charindex(',', @file_name)
			IF @charpos <> 0
			   begin
				select @miscprint = @miscprint + ','
				select @Restore_cmd = @Restore_cmd + ','
				goto start_fn_multi04
			   end
		   end
		Else
		   begin
			select @miscprint = @miscprint + ' FILE=''''' + @file_name + ''''''
			select @Restore_cmd = @Restore_cmd + ' FILE=''''' + @file_name + ''''''
		   end
	   end

	print  @miscprint

	select @miscprint = 'FROM DISK = ''' + @full_path + '\' + @hold_backupfilename + ''''
	print  @miscprint

	select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_backupfilename + ''''


	If @differential_flag = 'y' or @db_norecovOnly_flag = 'y'
	   begin
		If @partial_flag = 'y' and @filegroup_name is not null and @filegroup_name <> ''
		   begin
			select @miscprint = 'WITH PARTIAL, NORECOVERY,'
			print  @miscprint
			select @miscprint = 'REPLACE,'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH PARTIAL, NORECOVERY,'
			select @Restore_cmd = @Restore_cmd + ' REPLACE,'
		   end
		Else
		   begin
			select @miscprint = 'WITH NORECOVERY,'
			print  @miscprint
			select @miscprint = 'REPLACE,'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH NORECOVERY,'
			select @Restore_cmd = @Restore_cmd + ' REPLACE,'
		   end
	   end	
	Else
	   begin
		If @partial_flag = 'y' and @filegroup_name is not null and @filegroup_name <> ''
		   begin
			select @miscprint = 'WITH PARTIAL, REPLACE,'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH PARTIAL, REPLACE,'
		   end
		Else
		   begin
			select @miscprint = 'WITH REPLACE,'
			print  @miscprint

			select @Restore_cmd = @Restore_cmd + ' WITH REPLACE,'
		   end
	   end	

	delete from #filelist

	select @query = 'RESTORE FILELISTONLY FROM Disk = ''' + @full_path + '\' + @hold_backupfilename + ''''
	insert into #filelist exec (@query)
	--select * from #filelist
	If (select count(*) from #filelist) = 0
	   begin
		Select @miscprint = 'DBA Error: Unable to process standard filelistonly for file ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  set the default path just in case we need it
	Select @mssql_data_path = (select filename from master.sys.sysfiles where fileid = 1)
	select @charpos = charindex('master', @mssql_data_path)
	select @mssql_data_path = left(@mssql_data_path, @charpos-1)
	select @fileseq = 1


	EXECUTE('DECLARE cu22_cursor Insensitive Cursor For ' +
	  'SELECT f.LogicalName, f.PhysicalName, f.Type, f.FileGroupName
	   From #filelist   f ' +
	  'for Read Only')

	OPEN cu22_cursor
	
	WHILE (22=22)
	 Begin
		FETCH Next From cu22_cursor Into @cu22LogicalName, @cu22PhysicalName, @cu22Type, @cu22FileGroupName
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu22_cursor
		      BREAK
	           end


		select @savePhysicalNamePart = @cu22PhysicalName
		label03:
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
	  		    select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
			   end	
	
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
			    goto label03
	 		   end


		If @DTstmp_in_DBfilenames = 'y'
		   begin
			If @savePhysicalNamePart like '%.mdf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.mdf', @DateStmp + '.mdf')
			   end
			Else If @savePhysicalNamePart like '%.ndf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ndf', @DateStmp + '.ndf')
			   end
			Else If @savePhysicalNamePart like '%.ldf'
			   begin		
				Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ldf', @DateStmp + '.ldf')
			   end
			Else
			   begin		
				Select @savePhysicalNamePart = @savePhysicalNamePart + @DateStmp
			   end
		   end


		If @sourcepath = 'y'
		   begin
			Select @savefilepath = @cu22PhysicalName
		   end
		Else If @datapath is not null and @cu22Type in ('D', 'F')
		   begin
			If @savePhysicalNamePart not like '%mdf' and @data2path is not null
			   begin
				Select @savefilepath = @data2path + '\' + @savePhysicalNamePart
			   end
			Else
			   begin
				Select @savefilepath = @datapath + '\' + @savePhysicalNamePart
			   end
		   end
		Else IF @logpath is not null and @cu22Type = 'L'
		   begin
			Select @savefilepath = @logpath + '\' + @savePhysicalNamePart
		   end
		Else
		   begin
			Select @savefilepath = @mssql_data_path + @savePhysicalNamePart
		   end

		select @miscprint = 'MOVE ''' + @cu22LogicalName + ''' to ''' + @savefilepath + ''','
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ' MOVE ''' + @cu22LogicalName + ''' to ''' + @savefilepath + ''','


		--  capture ldf info if needed
		If @force_newldf = 'y'
		   begin
			select @charpos = charindex('.ldf', @savefilepath)
			IF @charpos <> 0
			   begin
				select @hold_ldfpath = @savefilepath
			   end
			Else
			   begin
				insert #db_files values (@fileseq, @cu22LogicalName, @savefilepath)
			   end
		   end

		select @fileseq = @fileseq + 1



	End  -- loop 22
	DEALLOCATE cu22_cursor


	select @miscprint = 'stats'
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @Restore_cmd = @Restore_cmd + ' stats'


	If @script_out <> 'y'
	   begin
		-- Restore the database
		select @cmd = @Restore_cmd
		Print 'Here is the restore command being executed;'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec (@cmd)

		If @@error<> 0
		   begin
			Print 'DBA Error:  Restore Failure (Standard Restore) for command ' + @cmd
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end



	If @db_norecovOnly_flag = 'y'
	   begin
		Print ' '
		select @miscprint = '--  Note:  This will leave the database in recovery pending mode.'
		print  @miscprint
		goto label99
	
	   end

   end


label12:


-- Differentail Processing
If @differential_flag = 'y'
   begin

	If @db_diffOnly_flag = 'y' and DATABASEPROPERTYEX (@check_dbname,'status') <> 'RESTORING'
	   begin
		select @miscprint = 'DBA ERROR:  A differential only restore was requested but the database is not in ''RESTORING'' mode.'
		print  @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end


	select @cmd = 'dir ' + @full_path + '\' + @diffname_wild
	--print @cmd

	Delete from #DirectoryTempTable
	insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
	delete from #DirectoryTempTable where cmdoutput is null
	delete from #DirectoryTempTable where cmdoutput like '%<DIR>%'
	delete from #DirectoryTempTable where cmdoutput like '%Directory of%'
	delete from #DirectoryTempTable where cmdoutput like '% File(s) %'
	delete from #DirectoryTempTable where cmdoutput like '% Dir(s) %'
	delete from #DirectoryTempTable where cmdoutput like '%Volume in drive%'
	delete from #DirectoryTempTable where cmdoutput like '%Volume Serial Number%'
	--select * from #DirectoryTempTable

	select @filecount = (select count(*) from #DirectoryTempTable)

	if @filecount < 1
	   BEGIN
		Select @miscprint = 'DBA WARNING: No differential files found for dbasp_autorestore at ' + @full_path 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   END


	Start_cmdoutput02:
	Select @save_cmdoutput = (Select top 1 cmdoutput from #DirectoryTempTable order by cmdoutput)
	Select @cu25cmdoutput = @save_cmdoutput

	select @save_fileYYYY = substring(@cu25cmdoutput, 7, 4)
	select @save_fileMM = substring(@cu25cmdoutput, 1, 2)
	select @save_fileDD = substring(@cu25cmdoutput, 4, 2)
	select @save_fileHH = substring(@cu25cmdoutput, 13, 2)
	Select @save_fileAMPM = substring(@cu25cmdoutput, 18, 1)
	If @save_fileAMPM = 'a' and @save_fileHH = '12'
	   begin
		Select @save_fileHH = '00'
	   end
	Else If @save_fileAMPM = 'p' and @save_fileHH <> '12'
	   begin
		Select @save_fileHH = @save_fileHH + 12
	   end
	select @save_fileMN = substring(@cu25cmdoutput, 16, 2)
	Select @save_filedate = @save_fileYYYY + @save_fileMM + @save_fileDD + @save_fileHH + @save_fileMN

	If @hold_filedate < @save_filedate
	   begin
		select @hold_diff_file_name = ltrim(rtrim(substring(@cu25cmdoutput, 40, 200)))
	   end

	Delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto Start_cmdoutput02
	   end



	If @hold_diff_file_name is null or @hold_diff_file_name = ''
	   BEGIN
		Select @miscprint = 'DBA ERROR: Unable to determine differential file for dbasp_autorestore at ' + @full_path 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   END


	If @hold_diff_file_name like '%.DFL'
	   begin
		--  This code is for LiteSpeed files
		select @miscprint = 'EXEC master.dbo.xp_restore_database'
		print  @miscprint
		select @miscprint = '  @database = ''' + @check_dbname + ''''
		print  @miscprint
		select @miscprint = ', @filename = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		print  @miscprint
		select @miscprint = ', @with = RECOVERY'
		print  @miscprint
		select @miscprint = ', @with = ''stats'''
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '

		select @Restore_cmd = ''
		select @Restore_cmd = @Restore_cmd + 'EXEC master.dbo.xp_restore_database'
		select @Restore_cmd = @Restore_cmd + '  @database = ''' + @check_dbname + ''''
		select @Restore_cmd = @Restore_cmd + ', @filename = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		select @Restore_cmd = @Restore_cmd + ', @with = RECOVERY'
		select @Restore_cmd = @Restore_cmd + ', @with = ''stats'''

		If @script_out <> 'y'
		   begin
			-- Restore the differential
			select @cmd = @Restore_cmd
			Print 'Here is the restore command being executed;'
			Print @cmd
			raiserror('', -1,-1) with nowait

			Exec (@cmd)

			If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
			   begin
				If @complete_on_diffOnly_fail = 'y'
				   begin
					--  finish the restore and send the DBA's an email
					Select @save_subject = 'DBAADMIN:  AutoRestore Failure for server ' + @@servername
					Select @save_message = 'Unable to restore the differential file for database ''' + @check_dbname + ''', the restore will be completed without the differential.'
					EXEC dbaadmin.dbo.dbasp_sendmail 
						@recipients = 'jim.wilson@gettyimages.com',  
						--@recipients = 'tssqldba@gettyimages.com',  
						@subject = @save_subject,
						@message = @save_message

					select @Restore_cmd = ''
					select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname + ' WITH RECOVERY'

					select @cmd = @Restore_cmd
					Print 'The differential restore failed.  Completing restore for just the database using the following command;'
					Print @cmd
					raiserror('', -1,-1) with nowait

					Exec (@cmd)

					If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
					   begin
						Print 'DBA Error:  Restore Failure (LiteSpeed DFL restore - Unable to finish restore without the DFL) for command ' + @cmd
						Select @error_count = @error_count + 1
						goto label99
					   end
				   end
				Else
				   begin
					Print 'DBA Error:  Restore Failure (LiteSpeed DFL restore) for command ' + @cmd
					Select @error_count = @error_count + 1
					goto label99
				   end
			   end
		   end
	   end
	Else If @hold_diff_file_name like '%.SQD'
	   begin
		--  This code is for RedGate files
		select @miscprint = 'Declare @cmd nvarchar(4000)'
		print  @miscprint

		select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @check_dbname + ']'
		print  @miscprint
		select @miscprint = ' FROM DISK = ''''' + @full_path + '\' + @hold_diff_file_name + ''''''
		print  @miscprint
		select @miscprint = ' WITH RECOVERY"'''
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
		print  @miscprint
		select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '

		select @Restore_cmd = ''

		select @Restore_cmd = @Restore_cmd + '-SQL "RESTORE DATABASE [' + @check_dbname + ']'
		select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		select @Restore_cmd = @Restore_cmd + ' WITH RECOVERY"'


		If @script_out <> 'y'
		   begin
			-- Restore the differential
			select @cmd = 'Exec master.dbo.sqlbackup ' + @Restore_cmd
			Print 'Here is the restore command being executed;'
			Print @cmd
			raiserror('', -1,-1) with nowait

			Exec master.dbo.sqlbackup @Restore_cmd

			If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
			   begin
				If @complete_on_diffOnly_fail = 'y'
				   begin
					--  finish the restore and send the DBA's an email
					Select @save_subject = 'DBAADMIN:  AutoRestore Failure for server ' + @@servername
					Select @save_message = 'Unable to restore the differential file for database ''' + @check_dbname + ''', the restore will be completed without the differential.'
					EXEC dbaadmin.dbo.dbasp_sendmail 
						@recipients = 'jim.wilson@gettyimages.com',  
						--@recipients = 'tssqldba@gettyimages.com',  
						@subject = @save_subject,
						@message = @save_message

					select @Restore_cmd = ''
					select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname + ' WITH RECOVERY'

					select @cmd = @Restore_cmd
					Print 'The differential restore failed.  Completing restore for just the database using the following command;'
					Print @cmd
					raiserror('', -1,-1) with nowait

					Exec (@cmd)

					If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
					   begin
						Print 'DBA Error:  Restore Failure (Redgate SQD restore - Unable to finish restore without the SQD) for command ' + @cmd
						Select @error_count = @error_count + 1
						goto label99
					   end
				   end
				Else
				   begin
					Print 'DBA Error:  Restore Failure (Redgate SQD restore) for command ' + @cmd
					Select @error_count = @error_count + 1
					goto label99
				   end
			   end
		   end
	   end
	Else
	   begin
		--  This code is for non-LiteSpeed and non-RadGate files
		select @miscprint = 'RESTORE DATABASE ' + @check_dbname
		print  @miscprint
		select @miscprint = 'FROM DISK = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		print  @miscprint
		select @miscprint = 'WITH RECOVERY,'
		print  @miscprint
		select @miscprint = 'stats'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '

		select @Restore_cmd = ''
		select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname
		select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		select @Restore_cmd = @Restore_cmd + ' WITH RECOVERY,'
		select @Restore_cmd = @Restore_cmd + ' stats'


		If @script_out <> 'y'
		   begin
			-- Restore the differential
			select @cmd = @Restore_cmd
			Print 'Here is the restore command being executed;'
			Print @cmd
			raiserror('', -1,-1) with nowait

			Exec (@cmd)

			If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
			   begin
				If @complete_on_diffOnly_fail = 'y'
				   begin
					--  finish the restore and send the DBA's an email
					Select @save_subject = 'DBAADMIN:  AutoRestore Failure for server ' + @@servername
					Select @save_message = 'Unable to restore the differential file for database ''' + @check_dbname + ''', the restore will be completed without the differential.'
					EXEC dbaadmin.dbo.dbasp_sendmail 
						@recipients = 'jim.wilson@gettyimages.com',  
						--@recipients = 'tssqldba@gettyimages.com',  
						@subject = @save_subject,
						@message = @save_message

					select @Restore_cmd = ''
					select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname + ' WITH RECOVERY'

					select @cmd = @Restore_cmd
					Print 'The differential restore failed.  Completing restore for just the database using the following command;'
					Print @cmd
					raiserror('', -1,-1) with nowait

					Exec (@cmd)

					If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
					   begin
						Print 'DBA Error:  Restore Failure (Standard DIF restore - Unable to finish restore without the DIF) for command ' + @cmd
						Select @error_count = @error_count + 1
						goto label99
					   end
				   end
				Else
				   begin
					Print 'DBA Error:  Restore Failure (Standard DIF restore) for command ' + @cmd
					Select @error_count = @error_count + 1
					goto label99
				   end
			   end
		   end
	   end
   end


--  Trun off auto shrink and auto stats for ALTdbname restores
If @ALTdbname is not null and @ALTdbname <> ''
   begin
	select @miscprint = '--  ALTER DATABASE OPTIONS'
	Print @miscprint
	select @miscprint = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_CREATE_STATISTICS OFF WITH NO_WAIT'
	Print @miscprint
	Print ''
	select @miscprint = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_UPDATE_STATISTICS OFF WITH NO_WAIT'
	Print @miscprint
	Print ''
	select @miscprint = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_SHRINK OFF WITH NO_WAIT'
	Print @miscprint
	Print ''


	If @script_out <> 'y'
	   begin
		Print 'Here are the Alter Database Option commands being executed;'
		select @cmd = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_CREATE_STATISTICS OFF WITH NO_WAIT'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec (@cmd)

		select @cmd = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_UPDATE_STATISTICS OFF WITH NO_WAIT'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec (@cmd)

		select @cmd = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_SHRINK OFF WITH NO_WAIT'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec (@cmd)
	   end
   end


-- New LDF if requested
If @force_newldf = 'y' and (@ALTdbname is null or @ALTdbname = '')
   begin
	Print '--NOTE:  New Log file (LDF) was requested'
	Print ' '

	select @miscprint = 'Waitfor delay ''00:00:05'''
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @miscprint = 'exec master.sys.sp_detach_db ''' + rtrim(@dbname) + ''', @skipchecks = ''true'''
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	Select @detach_cmd = 'exec master.sys.sp_detach_db ''' + rtrim(@dbname) + ''', @skipchecks = ''true'''

	select @miscprint = 'Waitfor delay ''00:00:05'''
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @miscprint = 'Declare @cmd varchar(500)'
	print  @miscprint
	select @miscprint = 'Select @cmd = ''Del ' + @hold_ldfpath + ''''
	print  @miscprint
	select @miscprint = 'EXEC master.sys.xp_cmdshell @cmd, no_output'
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	Select @deleteLDF_cmd = 'Del ' + @hold_ldfpath


	select @miscprint = 'Waitfor delay ''00:00:05'''
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '


	Select @miscprint = 'CREATE DATABASE [' + rtrim(@dbname) + '] ON'  
	Print  @miscprint

	Select @attach_cmd = 'CREATE DATABASE [' + rtrim(@dbname) + '] ON'  

	Select @fileseed = 1

	--------------------  Cursor for 12DB  -----------------------
	EXECUTE('DECLARE cu12_file Insensitive Cursor For ' + 
	  'SELECT f.fileid, f.name, f.filename
	   From #db_files  f ' + 
	  'Order By f.fileid For Read Only')

	OPEN cu12_file

	WHILE (12=12)
	   Begin
		FETCH Next From cu12_file Into @cu12fileid, @cu12name, @cu12filename 
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu12_file
		      BREAK
	           end
		

		If @fileseed = 1
		   begin
			Select @miscprint = '     (FILENAME = ''' + rtrim(@cu12filename) + ''')'  
			Print  @miscprint

			Select @attach_cmd = @attach_cmd + ' (FILENAME = ''' + rtrim(@cu12filename) + ''')'

		   end
		Else
		   begin
			Select @miscprint = '    ,(FILENAME = ''' + rtrim(@cu12filename) + ''')'  
			Print  @miscprint

			Select @attach_cmd = @attach_cmd + ' ,(FILENAME = ''' + rtrim(@cu12filename) + ''')'
		   end
	
		Select @fileseed = @fileseed + 1

	   End  -- loop 12
	   DEALLOCATE cu12_file

	Print  'FOR ATTACH;'
	Print  'go'
	Print  ' '
	Print  ' '

	Select @attach_cmd = @attach_cmd + ' FOR ATTACH;'

	If @script_out <> 'y' and DATABASEPROPERTYEX (@dbname,'status') = 'ONLINE'
	   begin
		-- detach the DB
		Print 'Here is the Detach command being executed;'
		Print @detach_cmd
		raiserror('', -1,-1) with nowait

		Exec (@detach_cmd)

		If @@error<> 0
		   begin
			select @miscprint = 'DBA Error:  Detach failure for command ' + @detach_cmd
			print  @miscprint
			Select @error_count = @error_count + 1
			goto label99
		   end

		-- delete the old ldf file
		Print 'Here is the del LDF file command being executed;'
		Print @deleteLDF_cmd
		raiserror('', -1,-1) with nowait

		Exec master.sys.xp_cmdshell @deleteLDF_cmd


		-- reattach the DB
		Print 'Here is the Attach command being executed;'
		Print @attach_cmd
		raiserror('', -1,-1) with nowait

		Exec (@attach_cmd)

		If @@error<> 0
		   begin
			select @miscprint = 'DBA Error:  ReAttach Failure for command ' + @attach_cmd
			print  @miscprint
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
   end


-- Shrink DB LDF Files if requested
If @post_shrink = 'y'
   begin
	Print '--NOTE:  Post Restore LDF file shrink was requested'
	Print ' '

	Select @miscprint = 'exec dbaadmin.dbo.dbasp_ShrinkLDFFiles @DBname = ''' + @check_dbname + ''''
	print  @miscprint
	Select @cmd = 'exec dbaadmin.dbo.dbasp_ShrinkLDFFiles @DBname = ''' + @check_dbname + ''''

	select @miscprint = 'go'
	print  @miscprint
	Print ' '


	If @script_out <> 'y'
	   begin
		If DATABASEPROPERTYEX (@check_dbname,'status') = 'ONLINE'
		   begin
			select @miscprint = 'Shrink file using command: ' + @cmd
			print  @miscprint
			exec(@cmd)
		   end
	   end

   end




-------------------   end   --------------------------

label99:

--  Check to make sure the DB is in 'restoring' mode if requested
If @script_out = 'n'
   begin
	If @db_norecovOnly_flag = 'y' and DATABASEPROPERTYEX (@check_dbname,'status') <> 'RESTORING'
	   begin
		select @miscprint = 'DBA ERROR:  A norecovOnly restore was requested and the database is not in ''RESTORING'' mode.'
		print  @miscprint
		Select @error_count = @error_count + 1
	   end

	If @error_count = 0 and @db_norecovOnly_flag = 'n' and DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
	   begin
		select @miscprint = 'DBA ERROR:  The AutoRestore process has failed for database ' + @check_dbname + '.  That database is not ''ONLINE'' at this time.'
		print  @miscprint
		Select @error_count = @error_count + 1
	   end
   end

drop table #DirectoryTempTable
drop table #db_files
drop table #filelist
drop table #filelist_ls
drop table #filelist_rg






If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Backup_Cleanup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Backup_Cleanup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Backup_Cleanup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Backup_Cleanup (@BkUpPath varchar(100) = null
					,@Retention_DD int = 7
					,@BkUpType varchar(10) = 'tlog'
					,@LiteSpeed_Bypass char(1) = 'n'
					,@RedGate_Bypass char(1) = 'n'
					,@dup_delete char(1) = 'n'
					,@dup_namemask sysname = null)
 
/***************************************************************
 **  Stored Procedure dbasp_Backup_Cleanup                  
 **  Written by Jim Wilson, Getty Images                
 **  March 25, 2002                                      
 **
 **  This proc accepts the followinf input parms:
 **  @BkUpPath      	- Full path where the backup files are 
 **                 	  written to.
 **  @Retention_DD  	- The number of days backup files are retained
 **                 	  on disk.
 **  @BkUpType      	- 'tlog', 'dfntl' or 'db'.
 **  @LiteSpeed_Bypass 	- (y or n) indicates if you want to bypass 
 **                    	  LiteSpeed processing.
 **  @RedGate_Bypass 	- (y or n) indicates if you want to bypass 
 **                  	  RedGate processing.
 **  @dup_delete 	- (y or n) indicates if you want to delete duplicate 
 **                       backup files with different time stamps.
 **
 **  @dup_namemask 	- Name mask for the @dup_delete request (e.g. wcds_db)
 **
 **  This procedure deletes older backup files from disk.  The
 **  length of retention depends on the passed parameter.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==================================================
--	04/26/2002	Jim Wilson		Revision History added
--	08/18/2005	Jim Wilson		Added code for LiteSpeed backups and differentials
--	08/19/2005	Jim Wilson		Added code for LiteSpeed bypass.
--	02/15/2006	Jim Wilson		Modified for sql2005.
--	07/24/2007	Jim Wilson		Added procesing for RedGate.
--	12/26/2008	Jim Wilson		Added duplicate delete section.
--	======================================================================================

/*
Declare @BkUpPath varchar(100)
Declare @Retention_DD int
Declare @BkUpType varchar(10)
Declare @LiteSpeed_Bypass char(1)
Declare @RedGate_Bypass char(1)
Declare @dup_delete char(1)
Declare @dup_namemask sysname

Select @BkUpPath = '\\seafresqldba01\seafresqldba01_restore'
Select @Retention_DD = 7
Select @BkUpType = 'tlog'
Select @LiteSpeed_Bypass = 'y'
Select @RedGate_Bypass = 'y'
Select @dup_delete = 'y'
Select @dup_namemask = 'Getty_Artists_db'
--*/

Declare	 
	 @miscprint		nvarchar(4000)
	,@Del_text 		nvarchar(500)
	,@BkUpMethod		nvarchar(5)
	,@BkUpSufx		nvarchar(10)
	,@BkUpDateStmp 		int
	,@Hold_hhmmss		nvarchar(8)
	,@cmd 			nvarchar(500)
	,@command_text		nvarchar(500)
	,@cursor_text		nvarchar(1000)
	,@Result		int
	,@Error_count		int
	,@scan			int
	,@check_num		int
	,@hold_filename		sysname

DECLARE
	 @cu11FileName		nvarchar(500)

Select @Error_count = 0

--  Check input parameters
If @BkUpPath is null or @BkUpPath = ''
   begin
	If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_path')
	   begin
		Select @BkUpPath = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_path')
	   end
   end

If @BkUpPath is null
   begin
	select @miscprint = 'DBA WARNING: Invaild parameter passed to dbasp_backup_Cleanup - @BkUpPath cannot be null'
	raiserror(@miscprint,-1,-1) with log
	Select @Error_count = @Error_count + 1
	goto label99
   end

--  Set defaults
Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @BkUpDateStmp = convert(varchar(8), getdate()-@Retention_DD, 112) + substring(@Hold_hhmmss, 1, 2)
Set @Error_count = 0
Set @BkUpMethod = 'MS'

If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'LiteSpeed')
   and @LiteSpeed_Bypass = 'n'
  begin
	Set @BkUpMethod = 'LS'
   end

If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'RedGate')
   and @RedGate_Bypass = 'n'
  begin
	Set @BkUpMethod = 'RG'
   end


If @BkUpType = 'tlog' 
   begin
	If @BkUpMethod = 'LS'
	   begin
		Select @BkUpSufx = 'TNL'
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @BkUpSufx = 'SQT'
	   end
	Else
	   begin
		Select @BkUpSufx = 'TRN'
	   end
   end
Else If @BkUpType = 'db' 
   begin
	If @BkUpMethod = 'LS'
	   begin
		Select @BkUpSufx = 'BKP'
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @BkUpSufx = 'SQB'
	   end
	Else
	   begin
		Select @BkUpSufx = 'BAK'
	   end
   end
Else If @BkUpType = 'dfntl' 
   begin
	If @BkUpMethod = 'LS'
	   begin
		Select @BkUpSufx = 'DFL'
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @BkUpSufx = 'SQD'
	   end
	Else
	   begin
		Select @BkUpSufx = 'DIF'
	   end
   end
Else
   begin
	select @miscprint = 'DBA WARNING: Invaild parameter passed to dbasp_backup_Cleanup - @BkUpType must be ''db'',''dfntl'' or ''tlog'''
	raiserror(@miscprint,-1,-1) with log
	Select @Error_count = @Error_count + 1
	goto label99
   end


--  Create temp table for the file information
CREATE TABLE #temp_tbl	(text01	varchar(400))


/****************************************************************
 *                MainLine
 ***************************************************************/
-- If this is a duplicate delete request, go to that section of the code
If @dup_delete = 'y'
   begin
	goto dup_delete_start
   end

--  execute the dir command via cmdshell and drop the results in the temp table
select @cmd = 'dir ' + @BkUpPath + '\*.' + @BkUpSufx
insert #temp_tbl (text01) exec master.sys.xp_cmdshell @cmd
delete from #temp_tbl where text01 is null
--select * from #temp_tbl

--  loop through the dir results looking for files to delete
If (select count(*) from #temp_tbl) > 0
   begin
	start_loop01:

	Select @cu11FileName = (select top 1 text01 From #temp_tbl)


	If @BkUpType = 'tlog'
	   begin
		Select @scan = CHARINDEX('_tlog_', @cu11FileName)

		If @scan > 0
		   begin
			Select @check_num = substring(@cu11FileName, @scan+6, 10)
	
			If @check_num < @BkUpDateStmp
			   begin
				Select @Del_text = @BkUpPath + '\' + substring(@cu11FileName, 40, 50)
				Select @command_text 	= 'Del ' + rtrim(@Del_text)
			
				EXEC @Result = master.sys.xp_cmdshell @command_text 

				IF @Result <> 0 
				   begin
					select @miscprint = 'DBA WARNING: Backup file delete processing failed.  Command was ' + @command_text
					raiserror(@miscprint,-1,-1) with log
					Select @Error_count = @Error_count + 1
				   end
				Else
				   begin
					select @miscprint = 'Deleted file ' + rtrim(@Del_text)
					Print  @miscprint
				   end

			   end
		   end
	   end


	If @BkUpType = 'db'
	   begin
		Select @scan = CHARINDEX('_db_', @cu11FileName)

		If @scan > 0
		   begin
			Select @check_num = substring(@cu11FileName, @scan+4, 10)
	
			If @check_num < @BkUpDateStmp
			   begin
				Select @Del_text = @BkUpPath + '\' + substring(@cu11FileName, 40, 50)
				Select @command_text 	= 'Del ' + rtrim(@Del_text)

				EXEC @Result = master.sys.xp_cmdshell @command_text 

				IF @Result <> 0 
				   begin
					select @miscprint = 'DBA WARNING: Backup file delete processing failed.  Command was ' + @command_text
					raiserror(@miscprint,-1,-1) with log
					Select @Error_count = @Error_count + 1
				   end
				Else
				   begin
					select @miscprint = 'Deleted file ' + rtrim(@Del_text)
					Print  @miscprint
				   end

			   end
		   end
	   end


	If @BkUpType = 'dfntl'
	   begin
		Select @scan = CHARINDEX('_dfntl_', @cu11FileName)

		If @scan > 0
		   begin
			Select @check_num = substring(@cu11FileName, @scan+4, 10)
	
			If @check_num < @BkUpDateStmp
			   begin
				Select @Del_text = @BkUpPath + '\' + substring(@cu11FileName, 40, 50)
				Select @command_text 	= 'Del ' + rtrim(@Del_text)

				EXEC @Result = master.sys.xp_cmdshell @command_text 

				IF @Result <> 0 
				   begin
					select @miscprint = 'DBA WARNING: Backup file delete processing failed.  Command was ' + @command_text
					raiserror(@miscprint,-1,-1) with log
					Select @Error_count = @Error_count + 1
				   end
				Else
				   begin
					select @miscprint = 'Deleted file ' + rtrim(@Del_text)
					Print  @miscprint
				   end

			   end
		   end
	   end

	--  Check for more rows to process
	Delete From #temp_tbl where text01 = @cu11FileName
	If (select count(*) from #temp_tbl) > 0
	   begin
		goto start_loop01
	   end

   end


-----------------------------------------------------------------------------------------------------------------
--  Delete Duplicate Section                                                                                   --
--  Note:  This process will delete duplicate backup files as long as they have different time stamps          --
--         as part of the backup file name.                                                                    --
-----------------------------------------------------------------------------------------------------------------
dup_delete_start:

-- If this is not a duplicate delete request, go to the end
If @dup_delete = 'n'
   begin
	goto label99
   end

--  execute the dir command via cmdshell and drop the results in the temp table
select @cmd = 'dir ' + @BkUpPath + '\' + @dup_namemask + '* /b'
delete from #temp_tbl
insert #temp_tbl (text01) exec master.sys.xp_cmdshell @cmd
delete from #temp_tbl where text01 is null
--select * from #temp_tbl

Select @hold_filename = ''

--  loop through the dir results looking for files to delete
If (select count(*) from #temp_tbl) > 1
   begin
	start_loop02:

	Select @cu11FileName = (select top 1 text01 From #temp_tbl)

	If @hold_filename = ''
	   begin
		Select @hold_filename = @cu11FileName
	   end
	Else If @hold_filename < @cu11FileName
	   begin
		Select @Del_text = @BkUpPath + '\' + rtrim(@hold_filename)
		Select @command_text 	= 'Del ' + @Del_text
		Print @command_text

		EXEC @Result = master.sys.xp_cmdshell @command_text 

		IF @Result <> 0 
		   begin
			select @miscprint = 'DBA WARNING: Backup file delete processing failed.  Command was ' + @command_text
			raiserror(@miscprint,-1,-1) with log
			Select @Error_count = @Error_count + 1
		   end

		Select @hold_filename = @cu11FileName
	   end


	--  Check for more rows to process
	Delete From #temp_tbl where text01 = @cu11FileName
	If (select count(*) from #temp_tbl) > 0
	   begin
		goto start_loop02
	   end

   end






---------------------------  Finalization  -----------------------
label99:

drop table #temp_tbl

If @Error_count > 0
   begin
	select @miscprint = 'DBA WARNING: dbasp_Backup_Cleanup failed with ' + convert(varchar(10), @Error_count) + ' errors'
	raiserror(@miscprint,-1,-1) with log
	return (1)
   end	

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Backup_detach_move
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Backup_detach_move]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Backup_detach_move]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Backup_detach_move (@dbname sysname = null
					, @target_path nvarchar(200) = null
					, @backup_filename sysname = null
					, @backup_to_target char(1) = 'y'
					, @copy_mdf char(1) = 'y'
					, @copy_ldf char(1) = 'n'
					, @delete_source_files char(1) = 'n'
					, @delete_source_backup char(1) = 'n'
					, @source_backup_path nvarchar(200) = null
					, @RG_flag char(1) = 'y'
					, @RG_only_flag char(1) = 'n'
					, @Force_StartFromTop nchar(1) = 'n')


/*********************************************************
 **  Stored Procedure dbasp_Backup_detach_move                  
 **  Written by Jim Wilson, Getty Images                
 **  November 20, 2002                                      
 **  
 **  This procedure is used to backup and detach a database,
 **  and then copy the backup file along with the database
 **  mdf, ndf and (optionaly) the ldf files to a designated
 **  location.  
 **
 **  This proc accepts several input parms (outlined below):
 **
 **  - @dbname is the name of the database being processed.
 **
 **  - @target_path is the full path (unc) where the backup
 **    file and the DB files will be copied.
 **
 **  - @backup_filename is the name of the backup file that
 **    will be created.
 **
 **  - @backup_to_target is a flag to force the backup process
 **    to point directly to the target path provided in @target_path.
 **
 **  - @copy_mdf is a flag for copying the DB mdf and ndf files
 **    to the target path.
 **
 **  - @copy_ldf is a flag for copying the DB ldf file to the
 **    target path.
 **
 **  - @delete_source_files is a flag for deleting the source
 **    DB mdf, ndf and ldf files, along with the local copy
 **    of the backup file.
 **
 **  - @delete_source_backup is a flag for deleting the source
 **    production backup file from the local restore folder.
 **
 **  - @source_backup_path is the full path (unc) to the restore
 **    folder where the source production backup file was copied.
 **
 **  - @RG_flag is a flag for RedGate backup processing (y or n).
 **
 **  - @Force_StartFromTop (y or n) is a flag to allow for a restart 
 **    (from where it left off last time) or force restart from the top.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/20/2002	Jim Wilson		New backup detach and move process 
--	11/25/2002	Jim Wilson		Added code to kill spids 
--	12/02/2002	Jim Wilson		Added waitfor commands after the delete stmtscode to kill spids 
--	03/31/2003	Jim Wilson		Added input parm and code to backup directly to the target path
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	11/26/2003	Jim Wilson		Reset ownership chaining option after reattach.
--	07/22/2005	Jim Wilson		Added insert to the @dbname build table.
--	06/22/2006	Jim Wilson		Updated for SQL 2005.
--	06/22/2006	Jim Wilson		New process to delete source production backup file.
--	06/08/2007	Jim Wilson		Moved delete of old nxt file before rename of new mdf or ldf.
--	07/25/2007	Jim Wilson		Added RedGate processing.
--	07/31/2007	Jim Wilson		Added pre-delete for *.SQB files.
--	10/22/2007	Jim Wilson		Added RedGate-only flag.
--	11/12/2007	Jim Wilson		Added verify for RedGate backup file existence.
--	12/07/2007	Jim Wilson		Fix delete of ldf file after initial detach.
--	01/18/2008	Jim Wilson		Added /mov to robocopy.
--	01/25/2008	Jim Wilson		Added alternate MOVE if source and target are on the same drive.
--	01/28/2008	Jim Wilson		Added 2nd LDF delete just before the attach.
--	01/29/2008	Jim Wilson		Added code for restarting (lots of code for this).
--	02/21/2008	Jim Wilson		Changed single use mode to offline\online.
--	10/01/2008	Jim Wilson		Added /Z /R:3 for robocopy
--	======================================================================================


/***
Declare 
	 @dbname sysname
	,@target_path nvarchar(200)
	,@backup_filename sysname
	,@backup_to_target nchar(1)
	,@copy_mdf nchar(1)
	,@copy_ldf nchar(1)
	,@delete_source_files nchar(1)
	,@delete_source_backup nchar(1)
	,@source_backup_path nvarchar(200)
	,@RG_flag nchar(1)
	,@RG_only_flag nchar(1)
	,@Force_StartFromTop nchar(1)

Select @dbname = 'DataExtract'
Select @target_path = '\\SQLDEPLOYER04\SQLDEPLOYER04_base_gmsh'
Select @backup_filename = 'DataExtract_prod'
Select @backup_to_target ='y'
Select @copy_mdf = 'y'
Select @copy_ldf = 'n'
Select @delete_source_files = 'y'
Select @delete_source_backup = 'n'
Select @source_backup_path = ''
Select @RG_flag = 'y'
Select @RG_only_flag = 'n'
Select @Force_StartFromTop = 'n'
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd			nvarchar(4000)
	,@Restore_cmd		nvarchar(4000)
	,@sqlcmd		nvarchar(4000)
	,@detach_cmd		nvarchar(4000)
	,@attach01_cmd		nvarchar(4000)
	,@dos_command		nvarchar(4000)
	,@parm01		nvarchar(100)
	,@outpath 		nvarchar(255)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@hold_sharename	sysname
	,@central_server	nvarchar(100)
	,@error_count		int
	,@mdf_path 		nvarchar(255)
	,@ldf_path 		nvarchar(255)
	,@filename_wild		nvarchar(100)
	,@command 		nvarchar(512)
	,@filecount		smallint
	,@charpos		int
	,@savepos		int
	,@query 		nvarchar(255)
	,@savePhysicalNamePart	nvarchar(260)
	,@save_file_path	nvarchar(260)
	,@full_backup_path 	nvarchar(100)
	,@save_file_name	nvarchar(260)
	,@save_mdfnxt_name	nvarchar(260)
	,@save_newldf_fullpath	nvarchar(260)
	,@save_oldldf_fullpath	nvarchar(260)
	,@save_newldf_path	nvarchar(260)
	,@save_oldldf_path	nvarchar(260)
	,@save_newldf_name	nvarchar(260)
	,@save_oldldf_name	nvarchar(260)
	,@save_env_type		sysname
	,@save_env_detail	sysname
	,@attach_process_flag	nchar(1)
	,@fileseed		smallint

DECLARE
	 @save_option_cmd	nvarchar(255)
	,@TrueFalse		nvarchar(5)
	,@cursor33		nvarchar(2000)


DECLARE     
	 @iSPID			int
	,@DBID			int
	,@Error			int
	,@vchCommand		nvarchar(255)

DECLARE
	 @cu12fileid		smallint
	,@cu12groupid		smallint
	,@cu12name		nvarchar(128)
	,@cu12filename		nvarchar(260)

DECLARE
	 @cu13fileid		smallint
	,@cu13groupid		smallint
	,@cu13name		nvarchar(128)
	,@cu13filename		nvarchar(260)

DECLARE
	 @cu15fileid		smallint
	,@cu15groupid		smallint
	,@cu15name		nvarchar(128)
	,@cu15filename		nvarchar(260)



----------------  initial values  -------------------
Select @error_count = 0

If not exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
   begin
    Select @RG_flag = 'n'
   end

Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

--  Set target path to drive letter path (if it's a local share)
If @target_path like '\\' + @save_servername + '%'
   begin
	Select @hold_sharename = substring(@target_path, len(@save_servername)+4, len(@target_path)-(len(@save_servername)+3))
	If @hold_sharename not like '%\%'
	   begin
		exec dbaadmin.dbo.dbasp_get_share_path @hold_sharename, @target_path output
	   end
   end



Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

Create table #temp_ldf_fullpath (filename nchar(260))


--  Verify input parm
if @dbname is null or @target_path is null or @backup_filename is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm(s)' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

--  Determine restart option
If @Force_StartFromTop = 'y' or not exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_bdm_' + rtrim(@dbname) + '_status')
   begin
	Print ''
	Print '**************************************************************'
	Print 'Start the Backup Detach and Move process from the TOP.'
	Print '**************************************************************'
	delete from dbaadmin.dbo.Local_ServerEnviro where env_type like 'check_bdm_' + rtrim(@dbname) + '%'
	Select @save_env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
	insert into dbaadmin.dbo.Local_ServerEnviro values(@save_env_type, 'start')
   end
Else
   begin
	Select @save_env_detail = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_bdm_' + rtrim(@dbname) + '_status')
	If @save_env_detail is null 
	  or @save_env_detail not in ('first_detach_before', 'first_detach_after', 'attach_before', 'attach_after', 'backup_before', 'backup_after', 'second_detach_before', 'rename_move_before') 
	   begin
		Print ''
		Print '**************************************************************'
		Print 'Start the Backup Detach and Move process from the TOP.'
		Print '**************************************************************'
		delete from dbaadmin.dbo.Local_ServerEnviro where env_type like 'check_bdm_' + rtrim(@dbname) + '%'
		Select @save_env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
		insert into dbaadmin.dbo.Local_ServerEnviro values(@save_env_type, 'start')
	   end
	Else If @save_env_detail = 'first_detach_before'
	   begin
		If exists (select 1 from master.sys.databases where name = @dbname) and (SELECT DATABASEPROPERTYEX (@dbname,'status')) = 'ONLINE'
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''First_Detach_Before'''
			Print '**************************************************************'
			goto First_Detach_Before
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''First_Detach_Before''.  Database does not exists or is not online.'
			Print  @miscprint
			Print 'Note:  Fix this issue or use the input parm @Force_StartFromTop = ''y''.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
	Else If @save_env_detail = 'first_detach_after'
	   begin
		If not exists (select 1 from master.sys.databases where name = @dbname)
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''First_Detach_After'''
			Print '**************************************************************'
			goto First_Detach_After
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''First_Detach_After''.  The Database still exists.'
			Print  @miscprint
			Print 'Note:  Suggest using input parm @Force_StartFromTop = ''y''.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
	Else If @save_env_detail = 'attach_before'
	   begin
		If not exists (select 1 from master.sys.databases where name = @dbname)
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''Attach_Before'''
			Print '**************************************************************'
			goto Attach_Before
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''attach_Before''.  The Database still exists.'
			Print  @miscprint
			Print 'Note:  Suggest using input parm @Force_StartFromTop = ''y''.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
	Else If @save_env_detail = 'attach_after'
	   begin
		If exists (select 1 from master.sys.databases where name = @dbname) and (SELECT DATABASEPROPERTYEX (@dbname,'status')) = 'ONLINE'
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''Attach_After'''
			Print '**************************************************************'
			goto Attach_After
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''Attach_After''.  Database does not exists or is not online.'
			Print  @miscprint
			Print 'Note:  You may need to attach this DB manually.  If that is not possible, the DB restore will need to be re-run.'
			Print '       A re-run of this process is not possible until the DB exists and is online.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
	Else If @save_env_detail = 'backup_before'
	   begin
		If exists (select 1 from master.sys.databases where name = @dbname) and (SELECT DATABASEPROPERTYEX (@dbname,'status')) = 'ONLINE'
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''Backup_Before'''
			Print '**************************************************************'
			goto Backup_Before
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''Backup_Before''.  Database does not exists or is not online.'
			Print  @miscprint
			Print 'Note:  The DB attach may have failed.'
			Print '       You may need to attach this DB manually.  If that is not possible, the DB restore will need to be re-run.'
			Print '       A re-run of this process is not possible until the DB exists and is online.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
	Else If @save_env_detail = 'backup_after'
	   begin
		If exists (select 1 from master.sys.databases where name = @dbname) and (SELECT DATABASEPROPERTYEX (@dbname,'status')) = 'ONLINE'
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''Backup_After'''
			Print '**************************************************************'
			goto Backup_After
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''Backup_After''.  Database does not exists or is not online.'
			Print  @miscprint
			Print 'Note:  It should not be possible to get to this point in the code (but just in case).'
			Print '       If you are here, you need to check to see if the backups completed properly.  If not, you will need'
			Print '       to either restore the DB or attach the DB.  Then you should modify the status record in the table'
			Print '       dbaadmin.dbo.Local_ServerEnviro to ''backup_before''.'
			Print '       A re-run of this process is not possible until the DB exists and is online.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
	Else If @save_env_detail = 'second_detach_before'
	   begin
		If exists (select 1 from master.sys.databases where name = @dbname) and (SELECT DATABASEPROPERTYEX (@dbname,'status')) = 'ONLINE'
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''Second_Detach_Before'''
			Print '**************************************************************'
			goto Second_Detach_Before
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''Second_Detach_Before''.  Database does not exists or is not online.'
			Print  @miscprint
			Print 'Note:  Possible problem with the Backup process,or even the attach process prior to the backups.'
			Print '       Check the backups and determine why the database is gone.'
			Print '       A re-run of this process is not possible until the DB exists and is online.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
	Else If @save_env_detail = 'rename_move_before'
	   begin
		If not exists (select 1 from master.sys.databases where name = @dbname)
		   begin
			Print ''
			Print '**************************************************************'
			Print 'Start the Backup Detach and Move process at ''Rename_Move_Before'''
			Print '**************************************************************'
			goto Rename_Move_Before
		   end
		Else
		   begin
			Print ''
			Print '**************************************************************'
			Select @miscprint = 'Unable to restart at ''Rename_Move_Before''.  The Database still exists.'
			Print  @miscprint
			Print 'Note:  Determine why the second detach failed.  You should be able to detach the DB'
			Print '       and then re-run this step.'
			Print '**************************************************************'
			raiserror(@miscprint,-1,-1) with log
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
   end



--  Verify database
If not exists (select 1 from master.sys.databases where name = @dbname)
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @dbname.  No such database exists.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END
Else If (SELECT DATABASEPROPERTYEX (@dbname,'status')) <> 'ONLINE' 
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @dbname.  Database exists but is not online.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

if (select name from master.sys.sysdatabases where name = @dbname) in ('master', 'model', 'msdb', 'tempdb')
   BEGIN
	Select @miscprint = 'DBA WARNING: This process is not allowed for a system database' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

--  Verify backup_to_target flag
if @backup_to_target not in ('n','y')
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @backup_to_target.  Must be ''y'' or ''n''.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

--  Verify RG flags
if @RG_flag = 'n' and @RG_only_flag = 'y'
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @RG_flag.  Must be ''y'' if input parm @RG_only_flag = ''y''.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


select @cmd = 'If (object_id(''dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'') is not null)
   begin
	drop table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles
   end'
exec (@cmd)
Select @cmd = 'Create table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles (
		fileid smallint,
		groupid smallint,
		size int,
		maxsize int,
		growth int,
		status int,
		perf int,
		name nchar(128),
		filename nchar(260))'
exec (@cmd)



--  Inset a row into the @dbname build table
Select @cmd = 'If exists (select 1 from ' + @dbname + '.sys.objects where name = ''build'' and type = ''u'')
   begin
	INSERT INTO ' + @dbname + '.dbo.Build (vchName, vchLabel, dtBuildDate, vchNotes) VALUES (''' + @dbname + ''', ''Backup, Detach & Move'', GETDATE(), ''' + @dbname + ' Backup, Detach & Move'')
   end'
Print @cmd
exec (@cmd) 




/****************************************************************
 *                MainLine
 ***************************************************************/


--  Prepare attach and detach commands
Select @cmd = 'Delete from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
exec (@cmd)
Select @cmd = 'Insert into dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  select * from [' + @dbname + '].sys.sysfiles'
exec (@cmd)
--Select @cmd = 'select * from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
--exec (@cmd)


--  Format the detach command
Print ''
Print '**************************************************************'
Print 'Create the detach gsql file for database ' + rtrim(@dbname)
Print '**************************************************************'

SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''master.sys.sp_detach_db ''''' + rtrim(@dbname) + ''''', @skipchecks = ''''true''''''" -E -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_detach.gsql'
PRINT  @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd



--  Format the attach command
Print ''
Print '**************************************************************'
Print 'Create the attach gsql file for database ' + rtrim(@dbname)
Print '**************************************************************'

SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''CREATE DATABASE [' + rtrim(@dbname) + '] ON''" -E >\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
PRINT  @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd


Select @fileseed = 1

--------------------  Cursor for 12DB  -----------------------
select @cmd = 'DECLARE cu12_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.name, f.filename
   From dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  f ' + 
  'Order By f.fileid For Read Only'

EXECUTE(@cmd)

OPEN cu12_file

WHILE (12=12)
   Begin
	FETCH Next From cu12_file Into @cu12fileid, @cu12groupid, @cu12name, @cu12filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_file
	      BREAK
           end
	

	If @fileseed = 1
	   begin
		If @cu12groupid <> 0
		   begin
			SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''  (FILENAME = ''''' + rtrim(@cu12filename) + ''''')''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
			PRINT @sqlcmd
			EXEC master.sys.xp_cmdshell @sqlcmd


			--  parse and save the file path
			Select @save_file_path = ''
			Select @savepos = 1
			label12a:
			Select @charpos = charindex('\', @cu12filename, @savepos)
			IF @charpos <> 0
			   begin
				Select @savepos = @charpos+1
				goto label12a
			   end	

			Select @save_file_path = @save_file_path + substring(@cu12filename, 1, @savepos-2)
  
		   end
	   end
	Else
	   begin
		If @cu12groupid <> 0
		   begin
			SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''  ,(FILENAME = ''''' + rtrim(@cu12filename) + ''''')''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
			PRINT @sqlcmd
			EXEC master.sys.xp_cmdshell @sqlcmd
  
		   end
	   end

	Select @fileseed = @fileseed + 1



   End  -- loop 12
   DEALLOCATE cu12_file


If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 1 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 1
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY ON, DB_CHAINING ON;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 0 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 0
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY OFF, DB_CHAINING OFF;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 1 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 0
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY OFF, DB_CHAINING ON;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 0 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 1
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY ON, DB_CHAINING OFF;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end


--  Make sure all connections to this database are removed
--  Alter the database to offline mode
Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set OFFLINE with ROLLBACK IMMEDIATE '
print @vchCommand
Exec(@vchCommand)
print ' '

--  Pause for a couple seconds
waitfor delay '00:00:01'

--  Alter the database to online mode
Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set ONLINE with ROLLBACK IMMEDIATE '
print @vchCommand
Exec(@vchCommand)
print ' '

--  Pause for a couple seconds
waitfor delay '00:00:01'

Select @vchCommand = 'ALTER DATABASE [' + rtrim(@dbname) + '] SET MULTI_USER WITH ROLLBACK IMMEDIATE'
Print @vchCommand
exec (@vchCommand)

--  Set the dbid value
Select @DBID = dbid FROM master.sys.sysdatabases where name = @dbname

Select @iSPID = 6
WHILE @iSPID IS NOT NULL
   begin

	Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID and spid > @iSPID
	IF @iSPID IS NOT NULL
	   begin
		Select @vchCommand = 'KILL ' + convert(varchar(12), @iSPID )
		Print @vchCommand
		exec(@vchCommand)
		Select @Error = @@ERROR
		IF @error <> 0 
		   begin
			RAISERROR( 'Error Killing Spid', 16, -1 )
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
   end



Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID
If @iSPID is not null
   begin
	Select @miscprint = 'Unable to kill spid related to database ' + rtrim(@dbname) + '.  spid = ' + convert(varchar(10),@iSPID) 
	RAISERROR( @miscprint, 16, -1 )
	Select @error_count = @error_count + 1
	goto label99
   end



--  Detach the database
update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'first_detach_before' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
First_Detach_Before:

Print ''
Print '**************************************************************'
Print 'Detach the database ' + rtrim(@dbname)
Print '**************************************************************'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -u -E -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_detach.gsql'
PRINT   @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd


update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'first_detach_after' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
First_Detach_After:



--  Delete the LDF DB files
--------------------  Cursor for 13  -----------------------
select @cmd = 'DECLARE cu13_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.name, f.filename
   From dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  f ' + 
  'Order By f.fileid For Read Only'
EXECUTE(@cmd)

OPEN cu13_file

WHILE (13=13)
   Begin
	FETCH Next From cu13_file Into @cu13fileid, @cu13groupid, @cu13name, @cu13filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu13_file
	      BREAK
           end
	
	--  Update the file permissions
	Print ''
	Print '**************************************************************'
	Print 'Update file permissions for: ' + rtrim(@cu13filename)
	Print '**************************************************************'

	Select @dos_command = 'XCACLS "' + rtrim(@cu13filename) + '" /G "Administrators":F /Y'
	Print @dos_command
	EXEC master.sys.xp_cmdshell @dos_command, no_output
 
	Select @dos_command = 'XCACLS "' + rtrim(@cu13filename) + '" /E /G "NT AUTHORITY\SYSTEM":R /Y'
	Print @dos_command
	EXEC master.sys.xp_cmdshell @dos_command, no_output


	--  Delete the LDF DB file
	If @cu13groupid = 0
	   begin
		Print ''
		Print '**************************************************************'
		Print 'Delete LDF file: ' + rtrim(@cu13filename)
		Print '**************************************************************'

		Select @save_file_name = rtrim(@cu13filename)
		Select @cmd = 'Del ' + rtrim(@save_file_name)
		Print @cmd		
		EXEC master.sys.xp_cmdshell @cmd--, no_output 
	   end

   End  -- loop 13
   DEALLOCATE cu13_file




--  Delete ldf DB file that might be at the new location
Select @save_file_name = ''
Select @save_file_name = @save_file_path + '\' + rtrim(@dbname) + '*.ldf'
Select @cmd = 'Del ' + rtrim(@save_file_name)
Print @cmd		
EXEC master.sys.xp_cmdshell @cmd--, no_output 



--  Attach the DB and force create a new LDF file

update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'attach_before' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
Attach_Before:


Print ''
Print '**************************************************************'
Print 'Attach the database creating a new LDF file'
Print '**************************************************************'
SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -u -E -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
PRINT @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd


Waitfor delay '00:00:02'

If not exists (select 1 from master.sys.databases where name = @dbname)
   BEGIN
	Select @miscprint = 'DBA WARNING: Attach failed for database ' + @dbname + '.  No such database exists.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END
Else If (SELECT DATABASEPROPERTYEX (@dbname,'status')) <> 'ONLINE' 
   BEGIN
	Select @miscprint = 'DBA WARNING: Attach failed for database ' + @dbname + '  Database exists but is not online.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

Print ''
Print '**************************************************************'
Print 'The database ' + rtrim(@dbname) + ' has now been shrunk (ldf recreated)'
Print '**************************************************************'

update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'attach_after' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
Attach_After:


-- Reset the sysfiles info in the temp table
Select @cmd = 'Delete from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
exec (@cmd)
Select @cmd = 'Insert into dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  select * from [' + @dbname + '].sys.sysfiles'
exec (@cmd)
Select @cmd = 'select * from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
exec (@cmd)



--  Backup the DB to either the target location, or locally

update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'backup_before' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
Backup_Before:


Print ''
Print '**************************************************************'
Print 'Starting the BACKUP section'
Print '**************************************************************'

If @backup_to_target = 'y'
   begin
	--  Backup the DB
	If @RG_only_flag <> 'y'
	   begin
		Select @cmd = 'Backup database [' + @DBname + '] to disk = ''' + rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.BAK'' with init'
		Print @cmd
		Exec(@cmd)

		Print ' '
		Print 'The database ' + rtrim(@dbname) + ' has now been backed up directly to the target location'
		Print ' '
	   end

	If @RG_flag = 'y'
	   begin
		--  Delete any old redgate backup files
		Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.SQB'
		Select @cmd = 'DEL ' + @parm01
		Print @cmd
		Exec master.sys.xp_cmdshell @cmd

		--  Verify the old backup file does not exist at the target
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) = 1
		   begin
			Print 'Error:  The old SQB backup file could not be deleted prior to creation of the new SQB backup. ' + @parm01
			Select @error_count = @error_count + 1
			Goto label99
		   end

		--  Backup the DB via RedGate
		Select @cmd = 'exec master.dbo.sqlbackup ''-SQL "BACKUP DATABASE [' + rtrim(@dbname) + ']' 
				+ ' TO DISK = ''''' + rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.SQB'
				+ ''''' WITH THREADCOUNT = 3, COMPRESSION = 1, MAXTRANSFERSIZE = 1048576, VERIFY"''' 
		Print @cmd
		Exec(@cmd)

		--  Verify the new backup file now exists.
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) <> 1
		   begin
			Print 'Error:  The new SQB backup file was not created as expected. ' + @parm01
			Select @error_count = @error_count + 1
			Goto label99
		   end

		Print ' '
		Print 'The database ' + rtrim(@dbname) + ' has now been backed up via RedGate to the target location'
		Print ' '
	   end
   end
Else
   begin
	--  Get the path to the backup folder
	Select @parm01 = @save_servername2 + '_backup'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output

	If @outpath is null
	   begin
		Print 'Warning:  The standard share to the ''backup'' folder has not been defined.'
		Select @error_count = @error_count + 1
		Goto label99
	   end

	--  Backup the DB
	If @RG_only_flag <> 'y'
	   begin
		Select @cmd = 'Backup database [' + @DBname + '] to disk = ''' + @outpath + '\' + rtrim(@backup_filename) + '.BAK'' with init'
		Print @cmd
		Exec(@cmd)

		Print ' '
		Print 'The database ' + rtrim(@dbname) + ' has now been backed up'
		Print ' '
	   end

	If @RG_flag = 'y'
	   begin
		--  Delete any old redgate backup files
		Select @parm01 = rtrim(@outpath) + '\' + rtrim(@backup_filename) + '.SQB'
		Select @cmd = 'DEL ' + @parm01
		Print @cmd
		Exec master.sys.xp_cmdshell @cmd

		--  Verify the old backup file does not exist at the target
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) = 1
		   begin
			Print 'Error:  The old SQB backup file could not be deleted prior to creation of the new SQB backup. ' + @parm01
			Select @error_count = @error_count + 1
			Goto label99
		   end

		--  Backup the DB via RedGate
		Select @cmd = 'exec master.dbo.sqlbackup ''-SQL "BACKUP DATABASE [' + rtrim(@dbname) + ']' 
				+ ' TO DISK = ''''' + rtrim(@outpath) + '\' + rtrim(@backup_filename) + '.SQB'
				+ ''''' WITH THREADCOUNT = 3, COMPRESSION = 1, MAXTRANSFERSIZE = 1048576, VERIFY"''' 
		Print @cmd
		Exec(@cmd)

		--  Verify the new backup file now exists.
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) <> 1
		   begin
			Print 'Error:  The new SQB backup file was not created as expected. ' + @parm01
			Select @error_count = @error_count + 1
			Goto label99
		   end

		Print ' '
		Print 'The database ' + rtrim(@dbname) + ' has now been backed up via RedGate to the target location'
		Print ' '
	   end
   end



--  If we still need to move the backup file to the target location, check to see if the backup file exists in the target location.  
--  If so, delete the old backup file at the target location.
If @backup_to_target = 'n'
   begin
	If @RG_only_flag <> 'y'
	   begin
		Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.BAK'
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) = 1
		   begin
			Select @cmd = 'Del ' + rtrim(@parm01)
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd--, no_output 
		   end

		Waitfor delay '00:00:02'
	   end

	If @RG_flag = 'y'
	   begin
		Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.SQB'
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) = 1
		   begin
			Select @cmd = 'Del ' + rtrim(@parm01)
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd--, no_output 
		   end

		Waitfor delay '00:00:02'
	   end


	--  Copy the backup file to the central server target
	If @RG_only_flag <> 'y'
	   begin
		Select @cmd = 'move ' + @outpath + '\' + rtrim(@backup_filename) + '.BAK ' + rtrim(@target_path)
		print @cmd
		EXEC master.sys.xp_cmdshell @cmd 

		Print ' '
		Print 'The backup file for database ' + rtrim(@dbname) + ' has now been moved to the target location.'
		Print ' '
	   end

	If @RG_flag = 'y'
	   begin
		--  Copy the RedGate backup file to the central server target
		Select @cmd = 'move ' + @outpath + '\' + rtrim(@backup_filename) + '.SQB ' + rtrim(@target_path)
		print @cmd
		EXEC master.sys.xp_cmdshell @cmd 

		Print ' '
		Print 'The RedGate backup file for database ' + rtrim(@dbname) + ' has now been moved to the target location.'
		Print ' '
	   end
   end


update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'backup_after' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
Backup_After:



--  General wait between backup processing and final detach
Waitfor delay '00:00:02'

update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'second_detach_before' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
Second_Detach_Before:


Print ''
Print '**************************************************************'
Print 'Starting final Detach section'
Print '**************************************************************'

--  Make sure all connections to this database are removed
--  Alter the database to offline mode
Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set OFFLINE with ROLLBACK IMMEDIATE '
print @vchCommand
Exec(@vchCommand)
print ' '

--  Pause for a couple seconds
waitfor delay '00:00:01'

--  Alter the database to online mode
Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set ONLINE with ROLLBACK IMMEDIATE '
print @vchCommand
Exec(@vchCommand)
print ' '

--  Pause for a couple seconds
waitfor delay '00:00:01'

Select @vchCommand = 'ALTER DATABASE [' + rtrim(@dbname) + '] SET MULTI_USER WITH ROLLBACK IMMEDIATE'
Print @vchCommand
exec (@vchCommand)

--  Set the dbid value
Select @DBID = dbid FROM master.sys.sysdatabases where name = @dbname

Select @iSPID = 6
WHILE @iSPID IS NOT NULL
   begin
	Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID and spid > @iSPID
	IF @iSPID IS NOT NULL
	   begin
		Select @vchCommand = 'KILL ' + convert(varchar(12), @iSPID )
		Print @vchCommand
		exec(@vchCommand)
		Select @Error = @@ERROR
		IF @error <> 0 
		   begin
			RAISERROR( 'Error Killing Spid', 16, -1 )
			Select @error_count = @error_count + 1
			goto label99
		   end
	   end
   end

Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID
If @iSPID is not null
   begin
	Select @miscprint = 'Unable to kill spid related to database ' + rtrim(@dbname) + '.  spid = ' + convert(varchar(10),@iSPID) 
	RAISERROR( @miscprint, 16, -1 )
	Select @error_count = @error_count + 1
	goto label99
   end



--  Detach the database again
Print ''
Print '**************************************************************'
Print 'Detach the database ' + rtrim(@dbname)
Print '**************************************************************'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -u -E -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_detach.gsql'
PRINT   @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd

Waitfor delay '00:00:02'


update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'rename_move_before' where env_type = 'check_bdm_' + rtrim(@dbname) + '_status'
Rename_Move_Before:


Print ''
Print '**************************************************************'
Print 'Starting the DB file rename (nxt) and move section'
Print '**************************************************************'


--  Copy all mdf and ndf files to the target location, and delete the local mdf, ndf and ldf files
--------------------  Cursor for 15DB  -----------------------
Select @cmd = 'DECLARE cu15_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.name, f.filename
   From dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  f ' + 
  'Order By f.fileid For Read Only'
EXECUTE(@cmd)

OPEN cu15_file

WHILE (15=15)
   Begin
	FETCH Next From cu15_file Into @cu15fileid, @cu15groupid, @cu15name, @cu15filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu15_file
	      BREAK
           end
	

	--  parse and save the file name
	Select @save_file_name = rtrim(@cu15filename)
	Select @charpos = charindex('\', @save_file_name)
	label15a:
	IF @charpos <> 0
	   begin
		Select @save_file_name = substring(@save_file_name, @charpos + 1, 200)
	   end	
	Select @charpos = charindex('\', @save_file_name)
	IF @charpos <> 0
	   begin
		goto label15a
	   end	

	--  parse and save the file path
	Select @save_file_path = ''
	Select @savepos = 1
	label15c:
	Select @charpos = charindex('\', @cu15filename, @savepos)
	IF @charpos <> 0
	   begin
		Select @savepos = @charpos+1
		goto label15c
	   end	

	Select @save_file_path = @save_file_path + substring(@cu15filename, 1, @savepos-2)



	--  Move the files to the target location if requested
	If @cu15groupid <> 0 and @copy_mdf = 'y'
	   begin
		--  For mdf and ndf files, delete existing file at the target location
		Select @parm01 = rtrim(@target_path) + '\' + rtrim(@save_file_name) + 'nxt'
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) = 1
		   begin
			Select @cmd = 'Del ' + rtrim(@parm01)
			Print @cmd	
			EXEC master.sys.xp_cmdshell @cmd--, no_output 
		   end

		Waitfor delay '00:00:02'

		--  Update the file permissions
		Select @dos_command = 'XCACLS "' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + '" /G "Administrators":F /Y'
		Print @dos_command
		EXEC master.sys.xp_cmdshell @dos_command, no_output
 
		Select @dos_command = 'XCACLS "' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + '" /E /G "NT AUTHORITY\SYSTEM":R /Y'
		Print @dos_command
		EXEC master.sys.xp_cmdshell @dos_command, no_output


		--  Rename the DB file, adding 'nxt' to the extention
		Select @cmd = 'REN ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + ' ' + rtrim(@save_file_name) + 'nxt'
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output 

		Select @save_file_name = rtrim(@save_file_name) + 'nxt'

		Waitfor delay '00:00:02'


		--  copy the file to the target location
		If @target_path not like '\\%' and left(@target_path, 3) = left(@save_file_path, 3)
		   begin
			Select @cmd = 'move ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + ' ' + rtrim(@target_path)
			print @cmd
			EXEC master.sys.xp_cmdshell @cmd 
		   end
		Else
		   begin
			Select @cmd = 'robocopy ' + rtrim(@save_file_path) + ' ' + rtrim(@target_path) + ' ' + rtrim(@save_file_name) + ' /NP /MOV /Z /R:3'
			Print @cmd
	    		EXEC master.sys.xp_cmdshell @cmd 
		   end
	   end
	Else If @cu15groupid = 0 and @copy_ldf = 'y'
	   begin
		--  For ldf files, delete existing file at the target location
		Select @parm01 = rtrim(@target_path) + '\' + rtrim(@save_file_name) + 'nxt'
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @parm01
		If (select doesexist from #fileexists) = 1
		   begin
			Select @cmd = 'Del ' + rtrim(@parm01)
			Print @cmd	
			EXEC master.sys.xp_cmdshell @cmd--, no_output 
		   end

		Waitfor delay '00:00:02'

		--  Update the file permissions
		Select @dos_command = 'XCACLS "' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + '" /G "Administrators":F /Y'
		Print @dos_command
		EXEC master.sys.xp_cmdshell @dos_command, no_output
 
		Select @dos_command = 'XCACLS "' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + '" /E /G "NT AUTHORITY\SYSTEM":R /Y'
		Print @dos_command
		EXEC master.sys.xp_cmdshell @dos_command, no_output


		--  Rename the DB file, adding 'nxt' to the extention
		Select @cmd = 'REN ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + ' ' + rtrim(@save_file_name) + 'nxt'
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output 

		Select @save_file_name = rtrim(@save_file_name) + 'nxt'


		Waitfor delay '00:00:02'


		--  copy the file to the target location
		If @target_path not like '\\%' and left(@target_path, 3) = left(@save_file_path, 3)
		   begin
			Select @cmd = 'move ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + ' ' + rtrim(@target_path)
			print @cmd
			EXEC master.sys.xp_cmdshell @cmd 
		   end
		Else
		   begin
			Select @cmd = 'robocopy ' + rtrim(@save_file_path) + ' ' + rtrim(@target_path) + ' ' + rtrim(@save_file_name) + ' /NP /MOV /Z /R:3 '
			Print @cmd
	    		EXEC master.sys.xp_cmdshell @cmd 
		   end
	   end


	--  Now delete the local copy of this file (in case it is still there)
	If @delete_source_files = 'y'
	   begin
		Select @cmd = 'Del ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name)
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output
	   end


   End  -- loop 15
   DEALLOCATE cu15_file



--  Delete the source production backup file if requested
If @delete_source_backup = 'y' and @source_backup_path <> '' and @source_backup_path is not null
   begin
	Select @cmd = 'Del ' + rtrim(@source_backup_path) + '\' + rtrim(@dbname) + '_db_*.*'
	Print @cmd	
	EXEC master.sys.xp_cmdshell @cmd--, no_output

	Print ' '
	Print 'The source production backup file has been deleted'
	Print ' '
   end



If @copy_mdf = 'y'
   begin
	Print ' '
	Print 'The database files (mdf and ndf) have been moved to the target location'
	Print ' '
   end

If @copy_ldf = 'y'
   begin
	Print ' '
	Print 'The database files (ldf) have been moved to the target location'
	Print ' '
   end

If @delete_source_files = 'y'
   begin
	Print ' '
	Print 'The local database files (mdf, ndf and ldf) have been deleted'
	Print ' '
   end



--  Finalization  -------------------------------------------------------------------

delete from dbaadmin.dbo.Local_ServerEnviro where env_type like 'check_bdm_' + rtrim(@dbname) + '%'

select @cmd = 'If (object_id(''dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'') is not null)
   begin
	drop table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles
   end'
exec (@cmd)



label99:


If (object_id('tempdb.dbo.#temp_ldf_fullpath') is not null)
   begin
	drop table #temp_ldf_fullpath
   end
If (object_id('tempdb.dbo.#fileexists') is not null)
   begin
	drop table #fileexists
   end


If @error_count > 0
   begin
	raiserror('DBA Error',16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Backup_Differential
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Backup_Differential]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Backup_Differential]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Backup_Differential (@PlanName varchar(500) = null
					,@DBName sysname = null
					,@backup_name sysname = null
					,@BkUpPath varchar(255) = null
					,@BkUpExt varchar(10) = null
					,@DeletePrevious varchar(10) = 'after'
					,@DeleteDfntl char(1) = 'y'
					,@LiteSpeed_Bypass char(1) = 'n'
					,@RedGate_Bypass char(1) = 'n'
					,@threads smallint = 3
					,@compressionlevel smallint = 1
					,@maxtransfersize bigint = 1048576
					,@process_mode sysname = 'normal')
 
/***************************************************************
 **  Stored Procedure dbasp_Backup_Differential                  
 **  Written by Jim Wilson, Getty Images                
 **  June 11, 2004                                      
 **
 **  This proc accepts the following input parms (none are required):
 **  @PlanName         - name of the maintenance plan that will specify
 **                      the list of databases to process.
 **
 **  @DBName           - name of the single database that will be processed.
 **
 **  @backup_name      - Force this name for the backup file. (optional)
 **
 **  @BkUpPath         - Full path where the backup files should be 
 **                      written to.
 **
 **  @BkUpExt          - Extension for the backup file (e.g. 'DIF').
 **
 **  @DeletePrevious   - ('before', 'after' or 'none') indicates when you
 **                      want to delete the previous backup file(s).
 **
 **  @DeleteDfntl      - (y or n) Delete all previous differentials. 
 ** 
 **  @LiteSpeed_Bypass - (y or n) indicates if you want to bypass 
 **                      LiteSpeed processing.
 **
 **  @RedGate_Bypass   - (y or n) indicates if you want to bypass 
 **                      RedGate processing.
 **
 **  @process_mode     - (normal, pre_release, pre_calc, mid_calc)
 **                      is for special processing where the backup file is 
 **                      written to a sub folder of the backup share and 
 **                      the backup info is logged in the backup_log table.
 **
 **  If no input parameters are given, all user DB's will be processed.  
 **  The resulting differential backup files will be written to the 
 **  standard backup share location.
 **
 **  Will delete \pre_release backups if > three days old.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	06/11/2004	Jim Wilson		New process
--	07/07/2004	Jim Wilson		Modify delete old backup process
--	08/18/2005	Jim Wilson		Added processing for LiteSpeed.  Also added option
--						delete for previous differentials.
--	08/19/2005	Jim Wilson		Added code for LiteSpeed bypass.
--	10/27/2005	Jim Wilson		Added input parm @DeletePrevious.
--	12/07/2005	Jim Wilson		Changed Litespeed logging to '0'.
--	02/16/2006	Jim Wilson		Modified for sql 2005
--	03/27/2006	Jim Wilson		Added LiteSpeed input parms.
--	07/27/2006	Jim Wilson		Chaged conversion of @maxtransfersize to varchar(10)
--	11/28/2006	Jim Wilson		Added input parm @backup_name.
--	05/03/2007	Jim Wilson		Fixed for paths with imbedded spaces.
--	07/24/2007	Jim Wilson		Added RedGate processing.
--	10/16/2008	Jim Wilson		Added pre_release input parm.
--	10/21/2008	Jim Wilson		Added @process_mode input parm.
--	03/06/2009	Anne Moss		Added section to delete pre_release files
--	03/12/2009	Jim Wilson		Fixed bug in pre_release delete (path)
--	04/14/2009	Jim Wilson		Update error check process for RG.
--	06/05/2009	Jim Wilson		Added display of result temp table for redgate errors.
--	12/01/2009	Jim Wilson		Updated error handeling.
--	======================================================================================

/***
Declare @PlanName varchar(500)
Declare @DBName sysname
Declare @backup_name sysname
Declare @BkUpPath varchar(1000)
Declare @BkUpExt varchar(10)
Declare @DeletePrevious varchar(10)
Declare @DeleteDfntl char(1)
Declare @LiteSpeed_Bypass char(1)
Declare @RedGate_Bypass char(1)
Declare @threads smallint
Declare @compressionlevel smallint
Declare @maxtransfersize int
Declare @process_mode sysname

Select @PlanName = 'Mplan_user_full'
--Select @DBName = 'Runbook'
--Select @backup_name = 'dbaadmin_dfntl_test01'
--Select @BkUpPath = '\\SEAFRERYLGINS02\SEAFRERYLGINS02_backup\SEAFRERYLSQL02'
Select @BkUpExt = null
Select @DeletePrevious = 'before'
Select @DeleteDfntl = 'y'
Select @LiteSpeed_Bypass = 'n'
Select @RedGate_Bypass = 'n'
Select @threads = 3
Select @compressionlevel = 1
Select @maxtransfersize = 1048576
Select @process_mode = 'normal'
--***/



Declare	
	 @miscprint		varchar(500) 
	,@BkUpFile 		varchar(500)
	,@BkUpDateStmp 		char(14)
	,@Hold_hhmmss		varchar(8)
	,@Hold_filename		varchar(500)
	,@Hold_filedate		varchar(14)
	,@cursor_text		varchar(500)
	,@cmd			nvarchar(2000)
	,@cmd2			nvarchar(2000)
	,@tempcount		int
	,@parm01		varchar(100)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_BkUpExt		varchar(10)
	,@charpos		int
	,@error_count		int
	,@plan_flag		char(1)
	,@db_flag		char(1)
	,@backup_log_flag	nchar(1)
	,@BkUpMethod		nvarchar(5)
	,@BkUpPath2		varchar(255)
	,@fileexist_path	nvarchar(255)
	,@BkUpFilename		sysname
	,@delete_flag		char (1)
	,@Pre_Release_Save_Days int
	,@Retention_filedate	varchar(14)


DECLARE
	 @cu11DBName		sysname


DECLARE
	 @cu12DBName		sysname


----------------  initial values  -------------------
Set @error_count = 0
Select @plan_flag = 'n'
Select @db_flag = 'n'
Select @backup_log_flag = 'n'


If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'LiteSpeed')
   and @LiteSpeed_Bypass = 'n'
   begin
	Set @BkUpMethod = 'LS'
	Set @save_BkUpExt = 'DFL'	
   end
Else If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'RedGate')
   and @RedGate_Bypass = 'n'
   begin
	Set @BkUpMethod = 'RG'
	Set @save_BkUpExt = 'SQD'	
   end
Else
   begin
	Set @BkUpMethod = 'MS'
	Set @save_BkUpExt = 'DIF'	
   end

If @BkUpExt is null or @BkUpExt = ''
   begin
	Set @BkUpExt = @save_BkUpExt	
   end


--  Set the backup name extension if not specified with the input backup name.
If @backup_name is not null
   begin
	Select @charpos = charindex('.', @backup_name)
	IF @charpos = 0
	   begin
		Select @backup_name = @backup_name + '.' + rtrim(@BkUpExt)
	   end
   end 


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

create table #resultstring (message varchar (2500) null) 


declare @DBnames table	(name sysname)


Select @save_servername = @@servername
Select @save_servername2 = @@servername

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 


Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Check input parameters
If @PlanName is not null and @PlanName <> ''
   begin
	Select @plan_flag = 'y'
	If not exists (select * from msdb.dbo.sysdbmaintplans Where plan_name = @PlanName)
	   begin
		raiserror('DBA WARNING: Invaild parameter passed to dbasp_backup_differential - @PlanName parm is invalid',-1,-1)
		Select @error_count = @error_count + 1
		goto label99
	   end
   end


If @process_mode not in ('normal', 'pre_release', 'pre_calc', 'mid_calc')
   begin
	Print 'DBA Warning:  Invalid input parameter.  @process_mode parm must be ''normal'', ''pre_release'', ''pre_calc'' or ''mid_calc''.'
	Select @error_count = @error_count + 1
	Goto label99
   end


If @DBName is not null and @DBName <> ''
   begin
	Select @db_flag = 'y'
	If not exists (select * from master.sys.sysdatabases Where name = @DBName)
	   begin
		raiserror('DBA WARNING: Invaild parameter passed to dbasp_backup_differential - @DBName parm is invalid',-1,-1)
		Select @error_count = @error_count + 1
		goto label99
	   end
   end

If @plan_flag = 'y' and @db_flag = 'n' and @backup_name is not null
   begin
	raiserror('DBA Warning:  Invalid input parameters.  A specific backup name can only be set for a single DB backup.',-1,-1)
	Select @error_count = @error_count + 1
	Goto label99
   end



If @BkUpPath is null or @BkUpPath = ''
   begin
	Select @parm01 = @save_servername2 + '_backup'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @BkUpPath output


	If @process_mode = 'pre_release'
	   begin
		--  check to see if the @pre_release folder exists (create it if needed)
		Delete from #fileexists
		Select @fileexist_path = @BkUpPath  + '\pre_release'
		Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
		If (select fileindir from #fileexists) <> 1
		   begin
			Select @cmd = 'mkdir "' + @BkUpPath + '\pre_release"'
			Print 'Creating pre_release folder using command '+ @cmd
			EXEC master.sys.xp_cmdshell @cmd, no_output 
		   end

		--  set @BkUpPath
		Select @BkUpPath = @BkUpPath + '\pre_release'
	   end
	Else If @process_mode = 'pre_calc'
	   begin
		--  check to see if the @pre_calc folder exists (create it if needed)
		Delete from #fileexists
		Select @fileexist_path = @BkUpPath  + '\pre_calc'
		Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
		If (select fileindir from #fileexists) <> 1
		   begin
			Select @cmd = 'mkdir "' + @BkUpPath + '\pre_calc"'
			Print 'Creating pre_calc folder using command '+ @cmd
			EXEC master.sys.xp_cmdshell @cmd, no_output 
		   end

		--  set @BkUpPath
		Select @BkUpPath = @BkUpPath + '\pre_calc'
	   end
	Else If @process_mode = 'mid_calc'
	   begin
		--  check to see if the @mid_calc folder exists (create it if needed)
		Delete from #fileexists
		Select @fileexist_path = @BkUpPath  + '\mid_calc'
		Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
		If (select fileindir from #fileexists) <> 1
		   begin
			Select @cmd = 'mkdir "' + @BkUpPath + '\mid_calc"'
			Print 'Creating mid_calc folder using command '+ @cmd
			EXEC master.sys.xp_cmdshell @cmd, no_output 
		   end

		--  set @BkUpPath
		Select @BkUpPath = @BkUpPath + '\mid_calc'
	   end

   end


--  Set logging flag
If @process_mode in ('pre_release', 'pre_calc', 'mid_calc')
   begin
	select @backup_log_flag = 'y'
   end

--  Do not delete old differentials for mid_calc processing
If @process_mode = 'mid_calc'
   begin
	Select @DeleteDfntl = 'n'
   end



Print 'Backup output path is ' + @BkUpPath


Select @charpos = charindex(' ', @BkUpPath)
IF @charpos <> 0
   begin
	Select @BkUpPath2 = '"' + @BkUpPath + '"'
   end
Else
   begin
	Select @BkUpPath2 = @BkUpPath
   end



/****************************************************************
 *                MainLine
 ***************************************************************/
If @db_flag = 'y'
   begin
	If @backup_name is not null
	   begin
		Select @BkUpFile = @BkUpPath + '\' + rtrim(@backup_name)
		print 'Output file will be: ' + @BkUpFile
	   end
	Else
	   begin
		Select @BkUpFile = @BkUpPath + '\' + rtrim(@DBName) + '_dfntl_' + @BkUpDateStmp + '.' + @BkUpExt
		print 'Output file will be: ' + @BkUpFile
	   end


	--  Process to delete old dfntl backup files (before) -------------------
	If @DeleteDfntl = 'y' and @DeletePrevious <> 'after'
	   begin
		Print 'Starting Delete Processing'
		select @cmd = 'dir ' + @BkUpPath2 + '\' + rtrim(@DBName) + '_dfntl_*.' + @BkUpExt + ' /B'
	
		Delete from #DirectoryTempTable
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		Delete from #DirectoryTempTable where cmdoutput is null

		Select @tempcount = (select count(*) from #DirectoryTempTable)
	
		While (@tempcount > 0)
		   begin
			Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
			Select @charpos = charindex('_dfntl_', @Hold_filename)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
			   end	

			If @Hold_filedate < @BkUpDateStmp
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				select @cmd = 'del ' + @BkUpPath2 + '\' + @Hold_filename
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end
			Else
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
			   end

			Select @tempcount = (select count(*) from #DirectoryTempTable)
		   end
	   end


	--  Process the differential backup
	If @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'Exec master.dbo.xp_backup_database @database = ''' + rtrim(@DBName) 
				+ ''', @filename = ''' + rtrim(@BkUpFile) 
				+ ''', @threads = ' + convert(varchar(10), @threads) 
				+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
				+ ', @maxtransfersize = ' + convert(varchar(10), @maxtransfersize) 
				+ ', @logging = 0, @with = ''DIFFERENTIAL'''
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @cmd = 'master.dbo.sqlbackup' 

		Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@DBName) + ']' 
				+ ' TO DISK = ''' + rtrim(@BkUpFile) 
				+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
				+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
				+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
				+ ', SINGLERESULTSET'
				+ ', DIFFERENTIAL"' 
	   end
	Else
	   begin
		Select @cmd = 'Backup database [' + rtrim(@DBName) + '] to disk = ''' + @BkUpFile + ''' with DIFFERENTIAL, init'
	   end


	If @BkUpMethod <> 'RG'
	   begin
		Print @cmd
		Print ' '
		Exec(@cmd)
	   end
	Else
	   begin
		Print @cmd
		Print @cmd2
		Print ' '
		delete from #resultstring
		Insert into #resultstring exec @cmd @cmd2
		--select * from #resultstring
	   end


	If @@error<> 0 and @BkUpMethod <> 'RG'
	   begin
		Print 'DBA Error:  Differential Backup Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode was not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end
	Else If exists (select 1 from #resultstring where message like '%error%')
	   begin
		Print 'DBA Error:  Differential Backup (RG) Failure for command ' + @cmd + @cmd2
		Print '--***********************************************************'
		Select * from #resultstring
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end



	--  Log the backup info
	If @backup_log_flag = 'y'
	   begin
		Select @BkUpFilename =  rtrim(@DBName) + '_dfntl_' + @BkUpDateStmp + '.' + @BkUpExt

		Insert into dbo.backup_log values(getdate(), @DBName, @BkUpFilename, @BkUpPath, @process_mode)
	   end



	--  Process to delete old dfntl backup files  -------------------
	If @DeleteDfntl = 'y' and @DeletePrevious = 'after'
	   begin
		Print 'Starting Delete Processing'
		select @cmd = 'dir ' + @BkUpPath2 + '\' + rtrim(@DBName) + '_dfntl_*.' + @BkUpExt + ' /B'
	
		Delete from #DirectoryTempTable
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		Delete from #DirectoryTempTable where cmdoutput is null

		Select @tempcount = (select count(*) from #DirectoryTempTable)
	
		While (@tempcount > 0)
		   begin
			Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
			Select @charpos = charindex('_dfntl_', @Hold_filename)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
			   end	

			If @Hold_filedate < @BkUpDateStmp
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				select @cmd = 'del ' + @BkUpPath2 + '\' + @Hold_filename
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end
			Else
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
			   end

			Select @tempcount = (select count(*) from #DirectoryTempTable)
		   end
	   end

   end
Else If @plan_flag = 'y'
   begin
	--  Process for a supplied maintenance plan
	Select @cmd = 'SELECT d.database_name
	   From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s ' + 
	  'Where d.plan_id = s.plan_id
	     and s.plan_name = ''' + @PlanName + ''''

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''
	--select * from @DBnames


	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames:

		Select @cu11DBName = (select top 1 name from @DBnames order by name)


		If databaseproperty(@cu11DBName, 'IsTrunclog') = 0
		   begin
			Select @BkUpFile = @BkUpPath + '\' + @cu11DBName + '_dfntl_' + @BkUpDateStmp + '.' + @BkUpExt
			Print 'Output file will be: ' + @BkUpFile


			--  Process to delete old dfntl backup files (before) -------------------
			If @DeleteDfntl = 'y' and @DeletePrevious <> 'after'
			   begin
				Print 'Starting Delete Processing'
				select @cmd = 'dir ' + @BkUpPath2 + '\' + rtrim(@cu11DBName) + '_dfntl_*.' + @BkUpExt + ' /B'
	
				Delete from #DirectoryTempTable
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null

				Select @tempcount = (select count(*) from #DirectoryTempTable)
	
				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
					Select @charpos = charindex('_dfntl_', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
					   end	

					If @Hold_filedate < @BkUpDateStmp
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @BkUpPath2 + '\' + @Hold_filename
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end

					Select @tempcount = (select count(*) from #DirectoryTempTable)
				   end
			   end


			--  Process the differential backup
			If @BkUpMethod = 'LS'
			   begin
				Select @cmd = 'Exec master.dbo.xp_backup_database @database = ''' + rtrim(@cu11DBName) 
						+ ''', @filename = ''' + rtrim(@BkUpFile) 
						+ ''', @threads = ' + convert(varchar(10), @threads) 
						+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
						+ ', @maxtransfersize = ' + convert(varchar(10), @maxtransfersize) 
						+ ', @logging = 0, @with = ''DIFFERENTIAL'''
			   end
			Else If @BkUpMethod = 'RG'
			   begin
				Select @cmd = 'master.dbo.sqlbackup' 

				Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@cu11DBName) + ']' 
						+ ' TO DISK = ''' + rtrim(@BkUpFile) 
						+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
						+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
						+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
						+ ', SINGLERESULTSET'
						+ ', DIFFERENTIAL"' 
			   end
			Else
			   begin
				Select @cmd = 'Backup database [' + rtrim(@cu11DBName) + '] to disk = ''' + @BkUpFile + ''' with DIFFERENTIAL, init'
			   end



			If @BkUpMethod <> 'RG'
			   begin
				Print @cmd
				Print ' '
				Exec(@cmd)
			   end
			Else
			   begin
				Print @cmd
				Print @cmd2
				Print ' '
				delete from #resultstring
				Insert into #resultstring exec @cmd @cmd2
				--select * from #resultstring
			   end


			If @@error<> 0 and @BkUpMethod <> 'RG'
			   begin
				Print 'DBA Warning:  Differential Backup Failure for command ' + @cmd
				Print '--***********************************************************'
				Print '@@error or @retcode was not zero'
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end
			Else If exists (select 1 from #resultstring where message like '%error%')
			   begin
				Print 'DBA Error:  Differential Backup (RG) Failure for command ' + @cmd + @cmd2
				Print '--***********************************************************'
				Select * from #resultstring
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end




			--  Log the backup info
			If @backup_log_flag = 'y'
			   begin
				Select @BkUpFilename =  rtrim(@cu11DBName) + '_dfntl_' + @BkUpDateStmp + '.' + @BkUpExt
		
				Insert into dbo.backup_log values(getdate(), @cu11DBName, @BkUpFilename, @BkUpPath, @process_mode)
			   end



			--  Process to delete old dfntl backup files  -------------------
			If @DeleteDfntl = 'y' and @DeletePrevious = 'after'
			   begin
				Print 'Starting Delete Processing'
				select @cmd = 'dir ' + @BkUpPath2 + '\' + rtrim(@cu11DBName) + '_dfntl_*.' + @BkUpExt + ' /B'
	
				Delete from #DirectoryTempTable
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null

				Select @tempcount = (select count(*) from #DirectoryTempTable)
	
				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
					Select @charpos = charindex('_dfntl_', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
					   end	

					If @Hold_filedate < @BkUpDateStmp
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @BkUpPath2 + '\' + @Hold_filename
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end

					Select @tempcount = (select count(*) from #DirectoryTempTable)
				   end
			   end

		   end


		--  check for more rows to process
		Delete from @DBnames where name = @cu11DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames
		   end


	   end

   end
Else
   begin
	--  Process for all user databases
	Select @cmd = 'SELECT d.name
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''
	--select * from @DBnames


	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames12:

		Select @cu12DBName = (select top 1 name from @DBnames order by name)


		If databaseproperty(@cu12DBName, 'IsTrunclog') = 0
		   begin
			Select @BkUpFile = @BkUpPath + '\' + @cu12DBName + '_dfntl_' + @BkUpDateStmp + '.' + @BkUpExt
			Print 'Output file will be: ' + @BkUpFile

			--  Process to delete old dfntl backup files (before) -------------------
			If @DeleteDfntl = 'y' and @DeletePrevious <> 'after'
			   begin
				Print 'Starting Delete Processing'
				select @cmd = 'dir ' + @BkUpPath2 + '\' + rtrim(@cu12DBName) + '_dfntl_*.' + @BkUpExt + ' /B'
	
				Delete from #DirectoryTempTable
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null

				Select @tempcount = (select count(*) from #DirectoryTempTable)
	
				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
					Select @charpos = charindex('_dfntl_', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
					   end	

					If @Hold_filedate < @BkUpDateStmp
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @BkUpPath2 + '\' + @Hold_filename
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end

					Select @tempcount = (select count(*) from #DirectoryTempTable)
				   end
			   end


			--  Process the differential backup
			If @BkUpMethod = 'LS'
			   begin
				Select @cmd = 'Exec master.dbo.xp_backup_database @database = ''' + rtrim(@cu12DBName) 
					    + ''', @filename = ''' + rtrim(@BkUpFile) 
					    + ''', @threads = ' + convert(varchar(10), @threads) 
					    + ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
					    + ', @maxtransfersize = ' + convert(varchar(10), @maxtransfersize) 
					    + ', @logging = 0, @with = ''DIFFERENTIAL'''
			   end
			Else If @BkUpMethod = 'RG'
			   begin
				Select @cmd = 'master.dbo.sqlbackup' 

				Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@cu12DBName) + ']' 
						+ ' TO DISK = ''' + rtrim(@BkUpFile) 
						+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
						+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
						+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
						+ ', SINGLERESULTSET'
						+ ', DIFFERENTIAL"' 
			   end
			Else
			   begin
				Select @cmd = 'Backup database [' + rtrim(@cu12DBName) + '] to disk = ''' + @BkUpFile + ''' with DIFFERENTIAL, init'
			   end


			If @BkUpMethod <> 'RG'
			   begin
				Print @cmd
				Print ' '
				Exec(@cmd)
			   end
			Else
			   begin
				Print @cmd
				Print @cmd2
				Print ' '
				delete from #resultstring
				Insert into #resultstring exec @cmd @cmd2
				--select * from #resultstring
			   end


			If @@error<> 0 and @BkUpMethod <> 'RG'
			   begin
				Print 'DBA Error:  Differential Backup Failure for command ' + @cmd
				Print '--***********************************************************'
				Print '@@error or @retcode was not zero'
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end
			Else If exists (select 1 from #resultstring where message like '%error%')
			   begin
				Print 'DBA Error:  Differential Backup (RG) Failure for command ' + @cmd + @cmd2
				Print '--***********************************************************'
				Select * from #resultstring
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end



			--  Log the backup info
			If @backup_log_flag = 'y'
			   begin
				Select @BkUpFilename =  rtrim(@cu12DBName) + '_dfntl_' + @BkUpDateStmp + '.' + @BkUpExt
		
				Insert into dbo.backup_log values(getdate(), @cu12DBName, @BkUpFilename, @BkUpPath, @process_mode)
			   end



			--  Process to delete old dfntl backup files  -------------------
			If @DeleteDfntl = 'y' and @DeletePrevious = 'after'
			   begin
				Print 'Starting Delete Processing'
				select @cmd = 'dir ' + @BkUpPath2 + '\' + rtrim(@cu12DBName) + '_dfntl_*.' + @BkUpExt + ' /B'
	
				Delete from #DirectoryTempTable
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null

				Select @tempcount = (select count(*) from #DirectoryTempTable)
	
				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
					Select @charpos = charindex('_dfntl_', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
					   end	

					If @Hold_filedate < @BkUpDateStmp
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @BkUpPath2 + '\' + @Hold_filename
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end

					Select @tempcount = (select count(*) from #DirectoryTempTable)
				   end
			   end

		   end

		--  check for more rows to process
		Delete from @DBnames where name = @cu12DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames12
		   end

	   end

   end



--  Process to delete old pre release related backup files  -------------------
Print 'Start Delete Old Pre Release Backups Processing'

Set @Pre_Release_Save_Days = 3

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @Retention_filedate = convert(char(8), getdate()-@Pre_Release_Save_Days, 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

select @cmd = 'dir ' + @BkUpPath + '\pre_release\*.* /B'
print @cmd

Delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
Delete from #DirectoryTempTable where cmdoutput is null
Select @tempcount = (select count(*) from #DirectoryTempTable)

While (@tempcount > 0)
   begin
	Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	Select @delete_flag = 'n'

	Select @charpos = charindex('_db_', @Hold_filename)
	IF @charpos <> 0
	   begin
 		Select @delete_flag = 'y'
		Select @Hold_filedate = substring(@Hold_filename, @charpos + 4, 14)
	   end	

	Select @charpos = charindex('_dfntl_', @Hold_filename)
	IF @charpos <> 0
	   begin
		Select @delete_flag = 'y' 		
		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
	   end	

	If @Retention_filedate > @Hold_filedate and @delete_flag = 'y'
	   begin
		select @cmd = 'del ' + @BkUpPath + '\pre_release\' + @Hold_filename
		Print @cmd
		Exec master.sys.xp_cmdshell @cmd
	   end
	
	delete from #DirectoryTempTable where cmdoutput = @Hold_filename
	Select @tempcount = (select count(*) from #DirectoryTempTable)

   end


--  End Processing  ---------------------------------------------------------------------------------------------
	
Label99:

drop table #DirectoryTempTable
drop table #fileexists
drop table #resultstring


If @error_count > 0
   begin
	raiserror('dbasp_Backup_Differential Failure',16,-1) with log
	return(1)
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Backup_Tranlog
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Backup_Tranlog]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Backup_Tranlog]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Backup_Tranlog (@PlanName varchar(500) = null
					,@DBName sysname = null
					,@BkUpPath varchar(255) = null
					,@BkUpExt varchar(10) = null
					,@BkUpSaveDays int = 1
					,@LiteSpeed_Bypass char(1) = 'n'
					,@RedGate_Bypass char(1) = 'n'
					,@threads smallint = 3
					,@compressionlevel smallint = 1
					,@maxtransfersize bigint = 1048576
					)
 
/***************************************************************
 **  Stored Procedure dbasp_Backup_Tranlog                  
 **  Written by Jim Wilson, Getty Images                
 **  March 22, 2002                                      
 **
 **  This proc accepts the following input parms (none are required):
 **  @PlanName      - name of the maintenance plan that will specify
 **                   the list of databases to process.
 **  @DBName        - name of the single database that will be processed.
 **  @BkUpPath      - Full path where the backup files should be 
 **                   written to.
 **  @BkUpExt       - Extension for the backup file (e.g. 'TRN').
 **  @BkUpSaveDays  - Number of days to save the backup files.
 **  @LiteSpeed_Bypass - (y or n) indicates if you want to bypass 
 **                      LiteSpeed processing.
 **  @RedGate_Bypass - (y or n) indicates if you want to bypass 
 **                    RedGate processing.
 **
 **  If no input parameters are given, all user DB's with the Recovery
 **  model set to 'full' will be processed.  The resulting transaction
 **  log backup file will be written to the standard backup share location.
 **
 **  This procedure also deletes older transaction log backup and pre_release files
 **  and will run post tranlog process (via data in the local_control table).
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	07/29/2002	Jim Wilson		Added code to delete older backup files.
--	02/04/2004	Jim Wilson		New process for a single DB or all DB's.
--	08/12/2004	Jim Wilson		Added verification of backup file.
--	08/18/2005	Jim Wilson		Added code for LiteSpeed backup processing.
--	08/19/2005	Jim Wilson		Added code for LiteSpeed bypass.
--	09/19/2005	Jim Wilson		Fixed trailing single quote for normal sql backup processing.
--	12/07/2005	Jim Wilson		Changed Litespeed logging to '0'.
--	02/16/2006	Jim Wilson		Modified for sql 2005
--	03/27/2006	Jim Wilson		Added LiteSpeed input parms.
--	07/27/2006	Jim Wilson		Chaged conversion of @maxtransfersize to varchar(10)
--	05/03/2007	Jim Wilson		Fixed for paths with imbedded spaces.
--	07/24/2007	Jim Wilson		Added RedGate processing.
--	09/21/2007	Jim Wilson		Added Restore script process.
--	02/06/2008	Jim Wilson		Added error checking (@retcode).
--	02/13/2008	Jim Wilson		Fixed error checking for litespeed.
--	04/17/2008	Jim Wilson		Fixed error in single DB redgate syntax.
--	03/06/2009	Anne Moss		Added section to delete pre_release files
--	03/12/2009	Jim Wilson		Fixed bug in pre_release delete (path)
--	04/14/2009	Jim Wilson		Update error check process for RG.
--	12/01/2009	Jim Wilson		Updated error handeling.
--	04/07/2010	Jim Wilson		Added post tranlog backup process from local_control table.
--	======================================================================================

/***
Declare @PlanName varchar(500)
Declare @DBName sysname
Declare @BkUpPath varchar(255)
Declare @BkUpExt varchar(10)
Declare @BkUpSaveDays int
Declare @LiteSpeed_Bypass char(1)
Declare @RedGate_Bypass char(1)
Declare @threads smallint
Declare @compressionlevel smallint
Declare @maxtransfersize bigint

Select @PlanName = 'mplan_user_tranlog'
--Select @DBName = 'ProductCatalog'
Select @BkUpPath = null
Select @BkUpExt = null
Select @BkUpSaveDays = 1
Select @LiteSpeed_Bypass = 'n'
Select @RedGate_Bypass = 'n'
Select @threads = 3
Select @compressionlevel = 1
Select @maxtransfersize = 1048576
--***/


Declare	
	 @miscprint		varchar(500) 
	,@BkUpFile 		varchar(500)
	,@BkUpDateStmp 		char(14)
	,@Hold_hhmmss		varchar(8)
	,@Hold_filename		varchar(500)
	,@Hold_filedate		varchar(14)
	,@Retention_filedate	varchar(14)
	,@cursor_text		varchar(500)
	,@cmd 			nvarchar(512)
	,@cmd2			nvarchar(4000)
	,@retcode		int
	,@result		int
	,@tempcount		int
	,@error_count		int
	,@parm01		varchar(100)
	,@save_BkUpExt		varchar(10)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_servername3	sysname
	,@charpos		int
	,@plan_flag		char(1)
	,@db_flag		char(1)
	,@all_flag		char(1)
	,@BkUpMethod		nvarchar(5)
	,@BkUpPath2		varchar(255)
	,@outpath		nvarchar(500)
	,@sqlcmd		nvarchar(500)
	,@max_ls		int
	,@delete_flag		char (1)
	,@Pre_Release_Save_Days int

DECLARE
	 @cu11DBName		sysname


DECLARE
	 @cu12DBName		sysname


----------------  initial values  -------------------
Set @error_count = 0
Select @plan_flag = 'n'
Select @db_flag = 'n'
Select @all_flag = 'n'
Select @max_ls = @maxtransfersize


If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'LiteSpeed')
   and @LiteSpeed_Bypass = 'n'
   begin
	Set @BkUpMethod = 'LS'
	Set @save_BkUpExt = 'TNL'	
   end
Else If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'RedGate')
   and @RedGate_Bypass = 'n'
   begin
	Set @BkUpMethod = 'RG'
	Set @save_BkUpExt = 'SQT'	
   end
Else
   begin
	Set @BkUpMethod = 'MS'
	Set @save_BkUpExt = 'TRN'	
   end

If @BkUpExt is null or @BkUpExt = ''
   begin
	Set @BkUpExt = @save_BkUpExt	
   end


Select @save_servername		= @@servername
Select @save_servername2	= @@servername
Select @save_servername3	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
	select @save_servername3 = @save_servername3 + ')'
   end

Select @outpath = '\\' + @save_servername + '\' + @save_servername2 + '_dba_archive\' + @save_servername3 + '_RestoreFull_'


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

create table #resultstring (message varchar (2500) null) 


declare @DBnames table	(name sysname)

declare @post_tranlog table (detail01 sysname)


--  Check input parameters
If @PlanName is not null and @PlanName <> ''
   begin
	Select @plan_flag = 'y'
	Select @db_flag = 'n'
	Select @all_flag = 'n'
	If not exists (select * from msdb.dbo.sysdbmaintplans Where plan_name = @PlanName)
	   begin
		Select @miscprint = 'DBA WARNING: Invaild parameter passed to dbasp_backup_tranlog - @PlanName parm is invalid'
		Print @miscprint
		raiserror(@miscprint,-1,-1)
		Select @error_count = @error_count + 1
		goto label99
	   end
	Else
	   begin
		If exists (select * From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s 
			Where d.plan_id = s.plan_id
			and s.plan_name = @PlanName
			and d.database_name = 'All User Databases')
		   begin
			Select @plan_flag = 'n'
			Select @all_flag = 'y'
		   end
	   end
   end

If @DBName is not null and @DBName <> ''
   begin
	Select @db_flag = 'y'
	Select @plan_flag = 'n'
	Select @all_flag = 'n'
	If not exists (select * from master.sys.sysdatabases Where name = @DBName)
	   begin
		Select @miscprint = 'DBA WARNING: Invaild parameter passed to dbasp_backup_tranlog - @DBName parm is invalid'
		Print @miscprint
		raiserror(@miscprint,-1,-1)
		Select @error_count = @error_count + 1
		goto label99
	   end
   end

If @plan_flag = 'n' and @db_flag = 'n'
   begin
	Select @all_flag = 'y'
   end


If @BkUpPath is null or @BkUpPath = ''
   begin
	Select @parm01 = @save_servername2 + '_backup'
	exec dbaadmin..dbasp_get_share_path @parm01, @BkUpPath output
   end


Print 'Backup output path is ' + @BkUpPath


Select @charpos = charindex(' ', @BkUpPath)
IF @charpos <> 0
   begin
	Select @BkUpPath2 = '"' + @BkUpPath + '"'
   end
Else
   begin
	Select @BkUpPath2 = @BkUpPath
   end



/****************************************************************
 *                MainLine
 ***************************************************************/
If @db_flag = 'y'
   begin
	--  Process for a single DB
	If databaseproperty(@DBName, 'IsTrunclog') = 0
	   begin
		Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
		Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) 
					+ substring(@Hold_hhmmss, 7, 2) 
		Select @BkUpFile = @BkUpPath + '\' + rtrim(@DBName) + '_tlog_' + @BkUpDateStmp + '.' + @BkUpExt
		Print 'Output file will be: ' + @BkUpFile

		If @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_backup_log'
					+ ' @database = ''' + rtrim(@DBName) 
					+ ''', @filename = ''' + rtrim(@BkUpFile) 
					+ ''', @threads = ' + convert(varchar(10), @threads) 
					+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
					+ ', @maxtransfersize = ' + convert(varchar(10), @max_ls) + ', @logging = 0'
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_backup_log
					 @database = @DBName 
					,@filename = @BkUpFile 
					,@threads = @threads 
					,@compressionlevel = @compressionlevel 
					,@maxtransfersize = @max_ls
					,@logging = 0
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			Select @cmd = 'master.dbo.sqlbackup' 

			Select @cmd2 = '-SQL "BACKUP LOG [' + rtrim(@DBName) + ']' 
					+ ' TO DISK = ''' + rtrim(@BkUpFile) 
					+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
					+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
					+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
					+ ', SINGLERESULTSET'
					+ ', VERIFY"' 
			Print @cmd
			Print @cmd2
			Print ' '
			delete from #resultstring
			Insert into #resultstring exec @cmd @cmd2
			--select * from #resultstring
		   end
		Else
		   begin
			Select @cmd = 'Backup LOG [' + rtrim(@DBName) + '] to disk = ''' + @BkUpFile + ''''
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


		If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
		   begin
			Print 'DBA Error:  TranLog Backup Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode was not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end
		Else If exists (select 1 from #resultstring where message like '%error%')
		   begin
			Print 'DBA Error:  TranLog Backup (RG) Failure for command ' + @cmd + @cmd2
			Print '--***********************************************************'
			Select * from #resultstring
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end



		--  Verify TranLog Backup
		If @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
		   end
		Else If @BkUpMethod <> 'RG'
		   begin
			select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end

		If @@error <> 0 or @retcode <> 0
		   begin
			Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode was not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end

		--  Create Restore script
		SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdbRestore_singleDB @dbname = ''' + rtrim(@DBName) + '''" -E -o' + @outpath + rtrim(@DBName) + '.gsql'
		Print @sqlcmd
		EXEC @result = master.sys.xp_cmdshell @sqlcmd

	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: Unable to backup the transaction log for database ''' + @DBName 
					+ '''.  Check the Recovery Model setting for this database.'
		Print  @miscprint
	   end
   end
Else If @plan_flag = 'y'
   begin
	--  Process for a supplied maintenance plan
	Select @cmd = 'SELECT d.database_name
	   From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s ' + 
	  'Where d.plan_id = s.plan_id
	     and s.plan_name = ''' + @PlanName + ''''

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''
	--select * from @DBnames


	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames:

		Select @cu11DBName = (select top 1 name from @DBnames order by name)


		If databaseproperty(@cu11DBName, 'IsTrunclog') = 0
		   begin
			Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
			Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 
			Select @BkUpFile = @BkUpPath + '\' + @cu11DBName + '_tlog_' + @BkUpDateStmp + '.' + @BkUpExt
			Print 'Output file will be: ' + @BkUpFile

			If @BkUpMethod = 'LS'
			   begin
				Select @cmd = 'master.dbo.xp_backup_log'
						+ ' @database = ''' + rtrim(@cu11DBName) 
						+ ''', @filename = ''' + rtrim(@BkUpFile) 
						+ ''', @threads = ' + convert(varchar(10), @threads) 
						+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
						+ ', @maxtransfersize = ' + convert(varchar(10), @max_ls) + ', @logging = 0'
				Print @cmd
				Print ' '
				Exec @retcode = master.dbo.xp_backup_log
						 @database = @cu11DBName 
						,@filename = @BkUpFile 
						,@threads = @threads 
						,@compressionlevel = @compressionlevel 
						,@maxtransfersize = @max_ls
						,@logging = 0
			   end
			Else If @BkUpMethod = 'RG'
			   begin
				Select @cmd = 'master.dbo.sqlbackup' 

				Select @cmd2 = '-SQL "BACKUP LOG [' + rtrim(@cu11DBName) + ']' 
						+ ' TO DISK = ''' + rtrim(@BkUpFile) 
						+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
						+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
						+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
						+ ', SINGLERESULTSET'
						+ ', VERIFY"' 
				Print @cmd
				Print @cmd2
				Print ' '
				delete from #resultstring
				Insert into #resultstring exec @cmd @cmd2
				--select * from #resultstring
			   end
			Else
			   begin
				Select @cmd = 'Backup LOG [' + rtrim(@cu11DBName) + '] to disk = ''' + @BkUpFile + ''''
				Print @cmd
				Print ' '
				Exec (@cmd)
			   end

	
			If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
			   begin
				Print 'DBA Errorr:  TranLog Backup Failure for command ' + @cmd
				Print '--***********************************************************'
				Print '@@error or @retcode was not zero'
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end
			Else If exists (select 1 from #resultstring where message like '%error%')
			   begin
				Print 'DBA Error:  TranLog Backup (RG) Failure for command ' + @cmd + @cmd2
				Print '--***********************************************************'
				Select * from #resultstring
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end



			--  Verify TranLog Backup
			If @BkUpMethod = 'LS'
			   begin
				Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
				Print @cmd
				Print ' '
				Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
			   end
			Else If @BkUpMethod <> 'RG'
			   begin
				select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
				Print @cmd
				Print ' '
				Exec (@cmd)
			   end

			If @@error <> 0 or @retcode <> 0
			   begin
				Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
				Print '--***********************************************************'
				Print '@@error or @retcode was not zero'
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end

			--  Create Restore script
			SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdbRestore_singleDB @dbname = ''' + rtrim(@cu11DBName) + '''" -E -o' + @outpath + rtrim(@cu11DBName) + '.gsql'
			Print @sqlcmd
			EXEC @result = master.sys.xp_cmdshell @sqlcmd

		   end


		--  check for more rows to process
		Delete from @DBnames where name = @cu11DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames
		   end

	   end

   end
Else If @all_flag = 'y'
   begin
	--  Process for all user databases
	Select @cmd = 'SELECT d.name
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''
	--select * from @DBnames


	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames12:

		Select @cu12DBName = (select top 1 name from @DBnames order by name)


		If databaseproperty(@cu12DBName, 'IsTrunclog') = 0
		   begin
			Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
			Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 
			Select @BkUpFile = @BkUpPath + '\' + @cu12DBName + '_tlog_' + @BkUpDateStmp + '.' + @BkUpExt
			Print 'Output file will be: ' + @BkUpFile

			If @BkUpMethod = 'LS'
			   begin
				Select @cmd = 'master.dbo.xp_backup_log'
						+ ' @database = ''' + rtrim(@cu12DBName) 
						+ ''', @filename = ''' + rtrim(@BkUpFile) 
						+ ''', @threads = ' + convert(varchar(10), @threads) 
						+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
						+ ', @maxtransfersize = ' + convert(varchar(10), @max_ls) + ', @logging = 0'
				Print @cmd
				Print ' '
				Exec @retcode = master.dbo.xp_backup_log
						 @database = @cu12DBName 
						,@filename = @BkUpFile 
						,@threads = @threads 
						,@compressionlevel = @compressionlevel 
						,@maxtransfersize = @max_ls
						,@logging = 0
			   end
			Else If @BkUpMethod = 'RG'
			   begin
				Select @cmd = 'master.dbo.sqlbackup' 

				Select @cmd2 = '-SQL "BACKUP LOG [' + rtrim(@cu12DBName) + ']' 
						+ ' TO DISK = ''' + rtrim(@BkUpFile) 
						+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
						+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
						+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
						+ ', SINGLERESULTSET'
						+ ', VERIFY"' 
				Print @cmd
				Print @cmd2
				Print ' '
				delete from #resultstring
				Insert into #resultstring exec @cmd @cmd2
				--select * from #resultstring
			   end
			Else
			   begin
				Select @cmd = 'Backup LOG [' + rtrim(@cu12DBName) + '] to disk = ''' + @BkUpFile + ''''
				Print @cmd
				Print ' '
				Exec (@cmd)
			   end

	
			If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
			   begin
				Print 'DBA Error:  TranLog Backup Failure for command ' + @cmd
				Print '--***********************************************************'
				Print '@@error or @retcode was not zero'
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end
			Else If exists (select 1 from #resultstring where message like '%error%')
			   begin
				Print 'DBA Error:  TranLog Backup (RG) Failure for command ' + @cmd + @cmd2
				Print '--***********************************************************'
				Select * from #resultstring
				Print '--***********************************************************'

				Select @error_count = @error_count + 1
				goto label99
			   end


			--  Verify TranLog Backup
			If @BkUpMethod = 'LS'
			   begin
				Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
				Print @cmd
				Print ' '
				Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
			   end
			Else If @BkUpMethod <> 'RG'
			   begin
				select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
				Print @cmd
				Print ' '
				Exec (@cmd)
			   end

			If @@error <> 0 or @retcode <> 0
			   begin
				Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
				Print '--***********************************************************'
				Print '@@error or @retcode was not zero'
				Print '--***********************************************************'
				Select @error_count = @error_count + 1
				goto label99
			   end

			--  Create Restore script
			SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdbRestore_singleDB @dbname = ''' + rtrim(@cu12DBName) + '''" -E -o' + @outpath + rtrim(@cu11DBName) + '.gsql'
			Print @sqlcmd
			EXEC @result = master.sys.xp_cmdshell @sqlcmd

		   end


		--  check for more rows to process
		Delete from @DBnames where name = @cu12DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames12
		   end


	   end

   end



--  Process to delete old tlog backup files  -------------------
Print 'Start Delete Old tlog Processing'
Set @Retention_filedate = convert(char(8), getdate()-@BkUpSaveDays, 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 


select @cmd = 'dir ' + @BkUpPath2 + '\*_tlog_*.' + @BkUpExt + ' /B'

Delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
Delete from #DirectoryTempTable where cmdoutput is null

Select @tempcount = (select count(*) from #DirectoryTempTable)

While (@tempcount > 0)
   begin
	Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

	Select @charpos = charindex('_tlog_', @Hold_filename)
	IF @charpos <> 0
	   begin
 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 6, 14)
	   end	

	If @Retention_filedate > @Hold_filedate
	   begin
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		select @cmd = 'del ' + @BkUpPath2 + '\' + @Hold_filename
		Print @cmd
		Exec master.sys.xp_cmdshell @cmd
	   end
	Else
	   begin
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
	   end

	Select @tempcount = (select count(*) from #DirectoryTempTable)

   end




--  Process to delete old pre release related backup files  -------------------
Print 'Start Delete Old Pre Release Backups Processing'

Set @Pre_Release_Save_Days = 3

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @Retention_filedate = convert(char(8), getdate()-@Pre_Release_Save_Days, 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

select @cmd = 'dir ' + @BkUpPath + '\pre_release\*.* /B'
print @cmd

Delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
Delete from #DirectoryTempTable where cmdoutput is null
Select @tempcount = (select count(*) from #DirectoryTempTable)

While (@tempcount > 0)
   begin
	Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	Select @delete_flag = 'n'

	Select @charpos = charindex('_db_', @Hold_filename)
	IF @charpos <> 0
	   begin
 		Select @delete_flag = 'y'
		Select @Hold_filedate = substring(@Hold_filename, @charpos + 4, 14)
	   end	

	Select @charpos = charindex('_dfntl_', @Hold_filename)
	IF @charpos <> 0
	   begin
		Select @delete_flag = 'y' 		
		Select @Hold_filedate = substring(@Hold_filename, @charpos + 7, 14)
	   end	

	If @Retention_filedate > @Hold_filedate and @delete_flag = 'y'
	   begin
		select @cmd = 'del ' + @BkUpPath + '\pre_release\' + @Hold_filename
		Print @cmd
		Exec master.sys.xp_cmdshell @cmd
	   end
	
	delete from #DirectoryTempTable where cmdoutput = @Hold_filename
	Select @tempcount = (select count(*) from #DirectoryTempTable)

   end



--  Process any post tranlog backup requests from the local_control table  -------------------
Print ''
Print 'Start Post Tranlog Processing (from local_control)'

If exists (select 1 from dbo.local_control where subject = 'tranlog_backup_post')
   begin
	insert into @post_tranlog SELECT detail01 from dbo.local_control where subject = 'tranlog_backup_post'

	If (select count(*) from @post_tranlog) > 0
	   begin
		start_post01:
		Select @cmd = (select top 1 detail01 from @post_tranlog order by detail01)
		Print @cmd
		exec (@cmd)

		delete from @post_tranlog where detail01 = @cmd
		If (select count(*) from @post_tranlog) > 0
		   begin
			goto start_post01
		   end
	   end
   end




--  End Processing  ---------------------------------------------------------------------------------------------
	
Label99:

drop table #DirectoryTempTable
drop table #resultstring

If @error_count > 0
   begin
	RAISERROR( 'DBA Error:  Tranlog Backup failure', 16, -1 )
	return(1)
   end


 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_BackupDBs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_BackupDBs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_BackupDBs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_BackupDBs (@DBname sysname = null
				,@PlanName sysname = null
				,@backup_type sysname = 'db'
				,@backup_name sysname = null
				,@BkUpPath varchar(255) = null
				,@BkUpExt varchar(10) = null
				,@target_path varchar(500) = null
				,@DeletePrevious varchar(10) = 'after'
				,@VerifyBackup char(1) = 'y'
				,@DeleteDfntl char(1) = 'n'
				,@DeleteTran char(1) = 'n'
				,@LiteSpeed_Bypass char(1) = 'n'
				,@RedGate_Bypass char(1) = 'n'
				,@threads smallint = 3
				,@compressionlevel smallint = 1
				,@maxtransfersize bigint = 1048576
				,@process_mode sysname = 'normal'
				,@auto_diff char(1) = 'y')
 
/***************************************************************
 **  Stored Procedure dbasp_BackupDBs                  
 **  Written by Jim Wilson, Getty Images                
 **  October 07, 2003                                      
 **
 **  This procedure is used for various 
 **  database backup processing.
 **
 **  This proc accepts several input parms: 
 **
 **  Either @dbname or @planname is required.
 **
 **  - @dbname is the name of the database to be backed up.
 **    use 'ALL_USER_DBs' to backup all user databases
 **    use 'ALL_SYS_DBs' to backup all system databases
 **    use 'ALL_DBs' to backup all databases
 **
 **  - @PlanName is the maintenance plane name if one is being used.
 **
 **  - @backup_type is the middle node of the backup name.
 **    e.g. 'db', 'predeployment', 'archive' (optional)
 **
 **  - @backup_name can be used to override the backup file name
 **    when backing up a single database. (optional)
 **
 **  - @BkUpPath is the target output path (optional)
 **
 **  - @BkUpExt is the output file extension (optional)
 **
 **  - @target_path is the target output path (optional)
 ** 
 **  - @DeletePrevious ('before', 'after' or 'none') indicates if
 **    and when you want to delete the previous backup file(s).
 **
 **  - @VerifyBackup (y or n) allows the verify backup process to 
 **    be disabled.
 ** 
 **  - @DeleteDfntl (y or n) indicates if you want to delete the 
 **    previous differential file(s).
 ** 
 **  - @DeleteTran (y or n) indicates if you want to delete the 
 **    previous transaction log backup file(s).
 ** 
 **  - @LiteSpeed_Bypass (y or n) indicates if you want to bypass 
 **    LiteSpeed processing.
 ** 
 **  - @RedGate_Bypass (y or n) indicates if you want to bypass 
 **    RedGate processing.
 **
 **  - @process_mode (normal, pre_release, pre_calc, mid_calc)
 **    is for special processing where the backup file is written to a 
 **    sub folder of the backup share and the backup info is logged 
 **    in the backup_log table.
 ** 
 **  - @auto_diff (y or n) creates a differential backup for all
 **    processed databases that are in full recovery mode.
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/07/2003	from systeminfo		New backup process 
--	10/14/2003	JWilson			New optional input parm to set backup name and
--						new parm to set target path.
--	10/20/2003	JWilson			Removed reference to systeminfo sproc.
--	08/02/2004	JWilson			Added maintenance plan and delete previous backup input.
--	08/03/2004	JWilson			Added restore verify only to process.
--	08/11/2004	Jim Wilson		Minor fix to maintenance plan processing 
--						uses Handle.exe to list file contension issues.
--	08/27/2004	Jim Wilson		Added brackets around DBname in backup command
--	09/06/2004	Jim Wilson		Added test for version prior to sp_MSget_file_existence check.
--	10/20/2004	Jim Wilson		Added delete of previous tran and dfntl files.
--	11/09/2004	Jim Wilson		Commented out section for @deleteprevious parm check.
--	08/18/2005	Jim Wilson		Added code for LiteSpeed backup processing.
--	08/19/2005	Jim Wilson		Added code for LiteSpeed bypass.
--	12/07/2005	Jim Wilson		Changed Litespeed logging to '0'.
--	12/13/2005	Jim Wilson		Force a backup filename extention for input backup names
--						that do not list an extention.
--	02/15/2006	Jim Wilson		Modified for sql2005
--	03/27/2006	Jim Wilson		Added LiteSpeed input parms.
--	07/27/2006	Jim Wilson		Chaged conversion of @maxtransfersize to varchar(10)
--	12/05/2006	Jim Wilson		Added input parms @BkUpPath and @BkUpExt.
--	03/22/2007	Jim Wilson		Fixed date parse for after deletes.
--	05/03/2007	Jim Wilson		Fixed for paths with imbedded spaces.
--	05/24/2007	Jim Wilson		Added century for charpos on _db_ charpos (now _db_2).
--	07/24/2007	Jim Wilson		Added RedGate processing.
--	03/13/2008	Jim Wilson		Added error checking.
--	03/13/2008	Jim Wilson		Removed @maxtransfersize for Litespeed backups.
--	04/29/2008	Jim Wilson		Post backup delete of old files if deleteprevious is before or after.
--	09/25/2008	Jim Wilson		New code to skip backup for DB's that have been dropped during this process.
--	10/21/2008	Jim Wilson		Added @process_mode input parm.
--	02/20/2009	David Spriggs		Added funtionality to force System databases to use MS backup only.
--	04/14/2009	Jim Wilson		Update error check process for RG.
--	06/15/2009	Jim Wilson		Added delete from standard backup share when @process_mode <> 'normal'
--	08/10/2009	Jim Wilson		Create a differential for every DB in recovery full mode.
--	12/01/2009	Jim Wilson		Updated error handeling.
--	02/11/2010	Steve Ledridge		Modified the calls to Handle.exe to use the /accepteula switch
--	======================================================================================

/***
Declare @DBname sysname
Declare @PlanName sysname
Declare @backup_type sysname
Declare @backup_name sysname
Declare @BkUpPath varchar(255)
Declare @BkUpExt varchar(10)
Declare @target_path varchar(500)
Declare @DeletePrevious varchar(10)
Declare @VerifyBackup char(1)
Declare @DeleteDfntl char(1)
Declare @DeleteTran char(1)
Declare @LiteSpeed_Bypass char(1)
Declare @RedGate_Bypass char(1)
Declare @threads smallint
Declare @compressionlevel smallint
Declare @maxtransfersize int
Declare @process_mode sysname
Declare @auto_diff char(1)

Select @DBname = 'dbaadmin'
--Select @DBname = 'ALL_USER_DBs'
--Select @DBname = 'ALL_SYS_DBs'
--Select @DBname = 'ALL_DBs'
--Select @PlanName = 'mplan_user_full'
Select @backup_type = 'db'
--Select @backup_name = 'dbaadmin_db_20050818'
Select @BkUpPath = null
Select @BkUpExt = null
--Select @target_path = '\\SEAFRERYLGINSDB\SEAFRERYLGINSDB_backup'
Select @DeletePrevious = 'after'
Select @VerifyBackup = 'y'
Select @DeleteDfntl = 'n'
Select @DeleteTran = 'n'
Select @LiteSpeed_Bypass = 'n'
Select @RedGate_Bypass = 'n'
Select @threads = 3
Select @compressionlevel = 1
Select @maxtransfersize = 1048576
Select @process_mode = 'normal'
Select @auto_diff = 'y'
--***/

DECLARE  
	 @cmd			nvarchar(4000)
	,@cmd2			nvarchar(4000)
	,@retcode		int
	,@date 			nchar(14)
	,@Hold_hhmmss		nvarchar(8)
	,@std_backup_path	nvarchar(255)
	,@std_backup_path2	nvarchar(255)
	,@check_backup_path	nvarchar(255)
	,@outpath 		nvarchar(255)
	,@outpath2 		nvarchar(255)
	,@fileexist_path	nvarchar(255)
	,@BkUpFile 		varchar(500)
	,@error_count		int
	,@parm01		nvarchar(100)
	,@save_backupname	sysname
	,@save_servername	sysname
	,@save_servername2	sysname
	,@charpos		int
	,@exists 		bit
	,@plan_flag		nchar(1)
	,@oneDB_flag		nchar(1)
	,@userDB_flag		nchar(1)
	,@sysDB_flag		nchar(1)
	,@allDB_flag		nchar(1)
	,@backup_log_flag	nchar(1)
	,@tempcount		int
	,@Hold_filename		sysname
	,@Hold_filedate		sysname
	,@BkUpSufx		nvarchar(10)
	,@BkUpSufx_tlog		nvarchar(10)
	,@BkUpSufx_dfntl	nvarchar(10)
	,@BkUpMethod		nvarchar(5)
	,@BkUpFilename		sysname

DECLARE
	 @cu10DBName		sysname

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint
	,@cu11DBStatus		int

DECLARE
	 @cu12DBName		sysname
	,@cu12DBId		smallint
	,@cu12DBStatus		int

DECLARE
	 @cu13DBName		sysname
	,@cu13DBId		smallint
	,@cu13DBStatus		int


----------------  initial values  -------------------
Select @error_count = 0
Select @exists = 0
Select @plan_flag = 'n'
Select @oneDB_flag = 'n'
Select @userDB_flag = 'n'
Select @sysDB_flag = 'n'
Select @allDB_flag = 'n'
Select @backup_log_flag = 'n'


Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'LiteSpeed')
   and @LiteSpeed_Bypass = 'n'
   begin
	Set @BkUpMethod = 'LS'
	Set @BkUpSufx = 'BKP'
	Set @BkUpSufx_tlog = 'TNL'
	Set @BkUpSufx_dfntl = 'DFL'	
   end
Else If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type' and env_detail = 'RedGate')
   and @RedGate_Bypass = 'n'
   begin
	Set @BkUpMethod = 'RG'
	Set @BkUpSufx = 'SQB'
	Set @BkUpSufx_tlog = 'SQT'
	Set @BkUpSufx_dfntl = 'SQD'	
   end
Else
   begin
	Set @BkUpMethod = 'MS'
	Set @BkUpSufx = 'BAK'
	Set @BkUpSufx_tlog = 'TRN'
	Set @BkUpSufx_dfntl = 'DIF'	
   end

If @BkUpExt is not null
   begin
	Select @BkUpSufx = @BkUpExt
   end

--  Set the backup name extension if not specified with the input backup name.
If @backup_name is not null
   begin
	Select @charpos = charindex('.', @backup_name)
	IF @charpos = 0
	   begin
		Select @backup_name = @backup_name + '.' + rtrim(@BkUpSufx)
	   end
   end 


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

create table #resultstring (message varchar (2500) null) 

declare @DBnames table	(name sysname)

declare @DBnames2 table	(name sysname
			,dbid smallint
			,status int
			)


--  Check input parameters and determine backup process
If @DeletePrevious not in ('before', 'after', 'none')
   begin
	Print 'DBA Warning:  Invalid input parameter.  @DeletePrevious parm must be ''before'', ''after'' or ''none''.'
	Select @error_count = @error_count + 1
	Goto label99
   end


If @process_mode not in ('normal', 'pre_release', 'pre_calc', 'mid_calc')
   begin
	Print 'DBA Warning:  Invalid input parameter.  @process_mode parm must be ''normal'', ''pre_release'', ''pre_calc'' or ''mid_calc''.'
	Select @error_count = @error_count + 1
	Goto label99
   end


If @PlanName is not null and @PlanName <> ''
   begin
	If not exists (select * from msdb.dbo.sysdbmaintplans Where plan_name = @PlanName)
	   begin
		Print 'DBA WARNING: Invaild parameter passed to dbasp_backupDBs - @PlanName parm is invalid'
		Select @error_count = @error_count + 1
		Goto label99
	   end
	Else
	   begin
		If exists (select 1  
			From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s 
			Where d.plan_id = s.plan_id
			and s.plan_name = @PlanName
			and d.database_name = 'All User Databases')
		   begin
			Print '-- Process mode is for all User DBs using Maintenance plan [' + @PlanName + ']'
			Select @userDB_flag = 'y'
			goto label05
		   end

		If exists (select 1 
			From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s 
			Where d.plan_id = s.plan_id
			and s.plan_name = @PlanName
			and d.database_name = 'All System Databases')
		   begin
			Print '-- Process mode is for all System DBs using Maintenance plan [' + @PlanName + ']'
			Select @sysDB_flag = 'y'
			goto label05
		   end


		Print 'Process mode is from Maintenance plan ' + @PlanName
		Select @plan_flag = 'y'
		goto label05
	   end
   end


If @DBname is not null
   begin
	If @DBname = 'ALL_USER_DBs' 
	   begin
		Print 'Process mode is for all User DBs.'
		Select @userDB_flag = 'y'
		goto label05
	   end
	Else If @DBname = 'ALL_SYS_DBs' 
	   begin
		Print 'Process mode is for all System DBs.'
		Select @sysDB_flag = 'y'
		goto label05
	   end
	Else If @DBname = 'ALL_DBs' 
	   begin
		Print 'Process mode is for all DBs.'
		Select @allDB_flag = 'y'
		goto label05
	   end
	Else 
	   begin
		If not exists(select 1 from master.sys.sysdatabases where name = @DBname)
		   begin
			Print 'DBA Warning:  Invalid input parameter.  Database ' + @DBname + ' does not exist on this server.'
			Select @error_count = @error_count + 1
			Goto label99
		   end
		Else
		   begin
			Print 'Process mode is for a single DB - ' + @DBname
			Select @oneDB_flag = 'y'
			goto label05
		   end
	   end
   end


If @DBname is null and @PlanName is null
   begin
	Print 'DBA Warning:  Invalid input parameter.  @DBname or @PlanName must be specified'
	Select @error_count = @error_count + 1
	Goto label99
   end



--  Backup process has been determined at this point
label05:


If @oneDB_flag = 'n' and @backup_name is not null
   begin
	Print 'DBA Warning:  Invalid input parameters.  A specific backup name can only be set for a single DB backup.'
	Select @error_count = @error_count + 1
	Goto label99
   end


--  Set backup path
Select @parm01 = @save_servername2 + '_backup'
exec dbaadmin..dbasp_get_share_path @parm01, @std_backup_path output

If @BkUpPath is not null
   begin
	Select @outpath = @BkUpPath
   end
Else If @target_path is not null
   begin
	Select @outpath = @target_path
   end
Else
   begin
	Select @outpath = @std_backup_path
   end



If @process_mode = 'pre_release' and @outpath = @std_backup_path
   begin
	--  check to see if the @pre_release folder exists (create it if needed)
	Delete from #fileexists
	Select @fileexist_path = @std_backup_path + '\pre_release'
	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) <> 1
	   begin
		Select @cmd = 'mkdir "' + @std_backup_path + '\pre_release"'
		Print 'Creating pre_release folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 
	   end

	--  set @outpath
	Select @outpath = @std_backup_path + '\pre_release'
	select @backup_log_flag = 'y'
   end
Else If @process_mode = 'pre_calc' and @outpath = @std_backup_path
   begin
	--  check to see if the @pre_calc folder exists (create it if needed)
	Delete from #fileexists
	Select @fileexist_path = @std_backup_path + '\pre_calc'
	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) <> 1
	   begin
		Select @cmd = 'mkdir "' + @std_backup_path + '\pre_calc"'
		Print 'Creating pre_release folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 
	   end

	--  set @outpath
	Select @outpath = @std_backup_path + '\pre_calc'
	select @backup_log_flag = 'y'
   end
Else If @process_mode = 'mid_calc' and @outpath = @std_backup_path
   begin
	--  check to see if the @mid_calc folder exists (create it if needed)
	Delete from #fileexists
	Select @fileexist_path = @std_backup_path + '\mid_calc'
	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) <> 1
	   begin
		Select @cmd = 'mkdir "' + @std_backup_path + '\mid_calc"'
		Print 'Creating pre_release folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 
	   end

	--  set @outpath
	Select @outpath = @std_backup_path + '\mid_calc'
	select @backup_log_flag = 'y'
   end


Print 'Backup output path is ' + @outpath


Select @charpos = charindex(' ', @outpath)
IF @charpos <> 0
   begin
	Select @outpath2 = '"' + @outpath + '"'
   end
Else
   begin
	Select @outpath2 = @outpath
   end



Select @charpos = charindex(' ', @std_backup_path)
IF @charpos <> 0
   begin
	Select @std_backup_path2 = '"' + @std_backup_path + '"'
   end
Else
   begin
	Select @std_backup_path2 = @std_backup_path
   end



Print ' '

/****************************************************************
 *                MainLine
 ***************************************************************/
--  Maintenance plan used for DB list
If @plan_flag = 'y'
   begin

	Select @cmd = 'SELECT d.database_name
	   From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s ' + 
	  'Where d.plan_id = s.plan_id
	     and s.plan_name = ''' + @PlanName + ''''

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''
        --select * from @DBnames


	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames:

		Select @cu10DBName = (select top 1 name from @DBnames order by name)

		If not exists (select 1 from master.sys.databases where name = @cu10DBName)
		   begin
			Print 'DBA Warning:  Skip backup for missing DB: ' + @cu10DBName
			goto Maint_plan_loop_end
		   end

		If @DeletePrevious = 'before'
		   begin
			Select @cmd = 'del ' + @outpath2 + '\' + @cu10DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx)
			Print ' '
			Print 'The following delete command will be used.'
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd

			--  Check to make sure files were deleted
			--  Skip if this is being run on a sql 7.0 server
			If ( 0 = ( SELECT PATINDEX( '%[7].[00]%', @@version ) ) )
			   begin
				Select @check_backup_path = @outpath + '\' + @cu10DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx)
				exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

				If @exists = 1
				   begin
					Print 'DBA Warning:  File delete error prior to backup processing'
					Select @cmd = 'handle /accepteula -u ' + @outpath
					Print @cmd
					exec master.sys.xp_cmdshell @cmd
				    end
			   end

			If @process_mode <> 'normal'
			   begin
				Select @cmd = 'del ' + @std_backup_path2 + '\' + @cu10DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx)
				Print ' '
				Print 'The following delete command will be used to delete from the standard backup path.'
				Print @cmd
				EXEC master.sys.xp_cmdshell @cmd

				--  Check to make sure files were deleted
				--  Skip if this is being run on a sql 7.0 server
				If ( 0 = ( SELECT PATINDEX( '%[7].[00]%', @@version ) ) )
				   begin
					Select @check_backup_path = @std_backup_path + '\' + @cu10DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx)
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output
	
					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error prior to backup processing'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					    end
				   end
			   end
		   end


		Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
		Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

		Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx
		Print 'Output file will be: ' + @BkUpFile

		If rtrim(@cu10DBName) in ('master', 'model','msdb')

		   begin

			Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'
			Print 'Output file will be: ' + @BkUpFile

			Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end

		Else If @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_backup_database'
					+ ' @database = ''' + rtrim(@cu10DBName) 
					+ ''', @filename = ''' + rtrim(@BkUpFile) 
					+ ''', @threads = ' + convert(varchar(10), @threads) 
					+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
					+ ', @logging = 0'
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_backup_database
					 @database = @cu10DBName 
					,@filename = @BkUpFile 
					,@threads = @threads 
					,@compressionlevel = @compressionlevel 
					,@logging = 0
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			Select @cmd = 'master.dbo.sqlbackup' 

			Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@cu10DBName) + ']' 
					+ ' TO DISK = ''' + rtrim(@BkUpFile) 
					+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
					+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
					+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
					+ ', SINGLERESULTSET'
			If @VerifyBackup = 'y'
			   begin
			    Select @cmd2 = @cmd2 + ', VERIFY'
			   end
			Select @cmd2 = @cmd2 + '"' 

			Print @cmd
			Print @cmd2
			Print ' '
			delete from #resultstring
			Insert into #resultstring exec @cmd @cmd2
			--select * from #resultstring
		   end
		Else
		   begin
			Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


		If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
		   begin
			Print 'DBA Error:  DB Backup Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode was not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end
		Else If exists (select 1 from #resultstring where message like '%error%')
		   begin
			Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
			Print '--***********************************************************'
			Select * from #resultstring
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Verfiy backup
		If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
		   end
		Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
		   begin
			select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end

		If @@error <> 0 or @retcode <> 0
		   begin
			Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode is not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Log the backup info
		If @backup_log_flag = 'y'
		   begin
			Select @BkUpFilename = rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx

			Insert into dbo.backup_log values(getdate(), @cu10DBName, @BkUpFilename, @outpath, @process_mode)
		   end



		If @DeletePrevious in ('before', 'after')
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu10DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			--select * from #DirectoryTempTable

			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos+len(@backup_type)+2, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)


				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					--  Skip if this is being run on a sql 7.0 server
					If ( 0 = ( SELECT PATINDEX( '%[7].[00]%', @@version ) ) )
					   begin
						Select @check_backup_path = @outpath + '\' + @Hold_filename
						exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

						If @exists = 1
						   begin
							Print 'DBA Warning:  File delete error after backup processing complete'
							Select @cmd = 'handle /accepteula -u ' + @outpath
							Print @cmd
							exec master.sys.xp_cmdshell @cmd
						    end
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end


			If @process_mode <> 'normal'
			   begin
				Delete from #DirectoryTempTable
				select @cmd = 'dir ' + @std_backup_path2 + '\' + @cu10DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null
				Select @tempcount = (select count(*) from #DirectoryTempTable)
				--select * from #DirectoryTempTable

				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

					--  Parse the backup file name to get the date info
					Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos+len(@backup_type)+2, 100)
					   end	

					Select @charpos = charindex('_', @Hold_filedate)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
					   end	

					Select @Hold_filedate = left(@Hold_filedate, 12)

	
					If left(@date, 12) > @Hold_filedate
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @std_backup_path2 + '\' + @Hold_filename
						print @cmd
						exec master.sys.xp_cmdshell @cmd

						--  Check to make sure files were deleted
						--  Skip if this is being run on a sql 7.0 server
						If ( 0 = ( SELECT PATINDEX( '%[7].[00]%', @@version ) ) )
						   begin
							Select @check_backup_path = @std_backup_path + '\' + @Hold_filename
							exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

							If @exists = 1
							   begin
								Print 'DBA Warning:  File delete error after backup processing complete'
								Select @cmd = 'handle /accepteula -u ' + @std_backup_path
								Print @cmd
								exec master.sys.xp_cmdshell @cmd
							    end
						   end
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end
				
					Select @tempcount = (select count(*) from #DirectoryTempTable)

				   end

			   end
		   end



		If @DeleteTran = 'y'
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu10DBName + '_tlog_*.' + rtrim(@BkUpSufx_tlog) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_tlog_', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					--  Skip if this is being run on a sql 7.0 server
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing complete'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end
		   end



		If @DeleteDfntl = 'y'
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu10DBName + '_dfntl_*.' + rtrim(@BkUpSufx_dfntl) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_dfntl_', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing complete'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end
		   end

		--  If this DB is set for recovery=full, create a differential
		If @auto_diff = 'y' and databaseproperty(@cu10DBName, 'IsTrunclog') = 0
		   begin
			exec dbaadmin.dbo.dbasp_Backup_Differential @DBName = @cu10DBName
								,@BkUpPath = @BkUpPath
								,@LiteSpeed_Bypass = @LiteSpeed_Bypass
								,@RedGate_Bypass = @RedGate_Bypass
								,@process_mode = @process_mode
		   end


		Maint_plan_loop_end:

		--  check for more rows to process
		Delete from @DBnames where name = @cu10DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames
		   end

	   end

   end
--  Back up a single DB
Else If @oneDB_flag = 'y'
   begin

	Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
	Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

	If @backup_name is null
	   begin
		Select @save_backupname = rtrim(@DBname) + '_' + rtrim(@backup_type) + '_' + rtrim(@date) + '.' + rtrim(@BkUpSufx) + ''
	   end
	Else
	   begin
		Select @save_backupname = @backup_name
	   end


	If @backup_name is null
	   begin
		Select @cmd = 'del ' + @outpath2 + '\' + @DBname + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
		Select @check_backup_path = @outpath + '\' + @DBname + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
	   end
	Else
	   begin
		Select @cmd = 'del ' + @outpath2 + '\' + @backup_name
		Select @check_backup_path = @outpath + '\' + @backup_name
	   end

	If @DeletePrevious = 'before'
	   begin
		Print ' '
		Print 'The following delete command will be used.'
		Print @cmd
		EXEC master.sys.xp_cmdshell @cmd

		--  Check to make sure files were deleted
		exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output
	
		If @exists = 1
		   begin
			Print 'DBA Warning:  File delete error prior to backup processing'
			Select @cmd = 'handle /accepteula -u ' + @outpath
			Print @cmd
			exec master.sys.xp_cmdshell @cmd
		   end

		If @process_mode <> 'normal'
		   begin
			If @backup_name is null
			   begin
				Select @cmd = 'del ' + @std_backup_path2 + '\' + @DBname + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
				Select @check_backup_path = @std_backup_path + '\' + @DBname + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
			   end
			Else
			   begin
				Select @cmd = 'del ' + @std_backup_path2 + '\' + @backup_name
				Select @check_backup_path = @std_backup_path + '\' + @backup_name
			   end

			Print ' '
			Print 'The following delete command will be used.'
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd

			--  Check to make sure files were deleted
			exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output
	
			If @exists = 1
			   begin
				Print 'DBA Warning:  File delete error prior to backup processing'
				Select @cmd = 'handle /accepteula -u ' + @std_backup_path
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end
		   end
	   end


	Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@save_backupname)
	Print 'Output file will be: ' + @BkUpFile

	If rtrim(@cu10DBName) in ('master', 'model','msdb')

		   begin

			Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'
			Print 'Output file will be: ' + @BkUpFile

			Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end

	Else If @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_backup_database'
				+ ' @database = ''' + rtrim(@DBname) 
				+ ''', @filename = ''' + rtrim(@BkUpFile) 
				+ ''', @threads = ' + convert(varchar(10), @threads) 
				+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
				+ ', @logging = 0'
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_backup_database
				 @database = @DBname 
				,@filename = @BkUpFile 
				,@threads = @threads 
				,@compressionlevel = @compressionlevel 
				,@logging = 0
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @cmd = 'master.dbo.sqlbackup' 

		Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@DBName) + ']' 
				+ ' TO DISK = ''' + rtrim(@BkUpFile) 
				+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
				+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
				+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
				+ ', SINGLERESULTSET'
		If @VerifyBackup = 'y'
		   begin
		    Select @cmd2 = @cmd2 + ', VERIFY'
		   end
		Select @cmd2 = @cmd2 + '"' 

		Print @cmd
		Print @cmd2
		Print ' '
		delete from #resultstring
		Insert into #resultstring exec @cmd @cmd2
		select * from #resultstring
	   end
	Else
	   begin
		Select @cmd = 'Backup database [' + rtrim(@DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end


	If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
	   begin
		Print 'DBA Error:  DB Backup Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end
	Else If exists (select 1 from #resultstring where message like '%error%')
	   begin
		Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
		Print '--***********************************************************'
		Select * from #resultstring
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Verfiy backup
	If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
	   end
	Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
	   begin
		select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end

	If @@error <> 0 or @retcode <> 0
	   begin
		Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Log the backup info
	If @backup_log_flag = 'y'
	   begin
		Insert into dbo.backup_log values(getdate(), @DBName, @save_backupname, @outpath, @process_mode)
	   end


	If @DeletePrevious in ('before', 'after')
	   begin
		Delete from #DirectoryTempTable
		select @cmd = 'dir ' + @outpath2 + '\' + @DBname + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		Delete from #DirectoryTempTable where cmdoutput is null
		Select @tempcount = (select count(*) from #DirectoryTempTable)
		While (@tempcount > 0)
		   begin
			Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

			--  Parse the backup file name to get the date info
			Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
			   end	

			Select @charpos = charindex('_', @Hold_filedate)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
			   end	

			Select @Hold_filedate = left(@Hold_filedate, 12)

			If left(@date, 12) > @Hold_filedate
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
				print @cmd
				exec master.sys.xp_cmdshell @cmd

				--  Check to make sure files were deleted
				Select @check_backup_path = @outpath + '\' + @Hold_filename
				exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

				If @exists = 1
				   begin
					Print 'DBA Warning:  File delete error after backup processing completed'
					Select @cmd = 'handle /accepteula -u ' + @outpath
					Print @cmd
					exec master.sys.xp_cmdshell @cmd
				   end
			   end
			Else
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
			   end
		
			Select @tempcount = (select count(*) from #DirectoryTempTable)

		   end


		If @process_mode <> 'normal'
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @std_backup_path2 + '\' + @DBname + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @std_backup_path2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @std_backup_path + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing completed'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end
		   end
	   end


	If @DeleteTran = 'y'
	   begin
		Delete from #DirectoryTempTable
		select @cmd = 'dir ' + @outpath2 + '\' + @DBName + '_tlog_*.' + rtrim(@BkUpSufx_tlog) + ' /B'
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		Delete from #DirectoryTempTable where cmdoutput is null
		Select @tempcount = (select count(*) from #DirectoryTempTable)
		While (@tempcount > 0)
		   begin
			Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

			--  Parse the backup file name to get the date info
			Select @charpos = charindex('_tlog_', @Hold_filename)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
			   end	

			Select @charpos = charindex('_', @Hold_filedate)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
			   end	

			Select @Hold_filedate = left(@Hold_filedate, 12)

			If left(@date, 12) > @Hold_filedate
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
				print @cmd
				exec master.sys.xp_cmdshell @cmd

				--  Check to make sure files were deleted
				Select @check_backup_path = @outpath + '\' + @Hold_filename
				exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

				If @exists = 1
				   begin
					Print 'DBA Warning:  File delete error after backup processing complete'
					Select @cmd = 'handle /accepteula -u ' + @std_backup_path
					Print @cmd
					exec master.sys.xp_cmdshell @cmd
				   end
			   end
			Else
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
			   end
		
			Select @tempcount = (select count(*) from #DirectoryTempTable)

		   end
	   end



	If @DeleteDfntl = 'y'
	   begin
		Delete from #DirectoryTempTable
		select @cmd = 'dir ' + @outpath2 + '\' + @DBname + '_dfntl_*.' + rtrim(@BkUpSufx_dfntl) + ' /B'
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		Delete from #DirectoryTempTable where cmdoutput is null
		Select @tempcount = (select count(*) from #DirectoryTempTable)
		While (@tempcount > 0)
		   begin
			Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

			--  Parse the backup file name to get the date info
			Select @charpos = charindex('_dfntl_', @Hold_filename)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
			   end	

			Select @charpos = charindex('_', @Hold_filedate)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
			   end	

			Select @Hold_filedate = left(@Hold_filedate, 12)

			If left(@date, 12) > @Hold_filedate
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
				print @cmd
				exec master.sys.xp_cmdshell @cmd

				--  Check to make sure files were deleted
				Select @check_backup_path = @outpath + '\' + @Hold_filename
				exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

				If @exists = 1
				   begin
					Print 'DBA Warning:  File delete error after backup processing complete'
					Select @cmd = 'handle /accepteula -u ' + @std_backup_path
					Print @cmd
					exec master.sys.xp_cmdshell @cmd
				   end
			   end
			Else
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
			   end
		
			Select @tempcount = (select count(*) from #DirectoryTempTable)

		   end
	   end


	--  If this DB is set for recovery=full, create a differential
	If @auto_diff = 'y' and databaseproperty(@DBName, 'IsTrunclog') = 0
	   begin
		exec dbaadmin.dbo.dbasp_Backup_Differential @DBName = @DBName
							,@BkUpPath = @BkUpPath
							,@LiteSpeed_Bypass = @LiteSpeed_Bypass
							,@RedGate_Bypass = @RedGate_Bypass
							,@process_mode = @process_mode
	   end
   end
--  Back up all user DBs
Else If @userDB_flag = 'y'
   begin

	Select @cmd = 'SELECT d.name, d.dbid, d.status
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

	delete from @DBnames2

	insert into @DBnames2 (name, dbid, status) exec (@cmd)

	delete from @DBnames2 where name is null or name = ''
	--select * from @DBnames2


	If (select count(*) from @DBnames2) > 0
	   begin
		start_dbnames2:

		Select @cu11DBId = (select top 1 dbid from @DBnames2 order by dbid)
		Select @cu11DBName = (select name from @DBnames2 where dbid = @cu11DBId)
		Select @cu11DBStatus = (select status from @DBnames2 where dbid = @cu11DBId)

		If not exists (select 1 from master.sys.databases where name = @cu10DBName)
		   begin
			Print 'DBA Warning:  Skip backup for missing DB: ' + @cu10DBName
			goto allDBs_loop_end
		   end


		If @DeletePrevious = 'before'
		   begin
			Select @cmd = 'del ' + @outpath2 + '\' + @cu11DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
			Print ' '
			Print 'The following delete command will be used.'
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd

			--  Check to make sure files were deleted
			Select @check_backup_path = @outpath + '\' + @cu11DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
			exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

			If @exists = 1
			   begin
				Print 'DBA Warning:  File delete error prior to backup processing'
				Select @cmd = 'handle /accepteula -u ' + @outpath
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end

			If @process_mode <> 'normal'
			   begin
				Select @cmd = 'del ' + @std_backup_path2 + '\' + @cu11DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
				Print ' '
				Print 'The following delete command will be used.'
				Print @cmd
				EXEC master.sys.xp_cmdshell @cmd

				--  Check to make sure files were deleted
				Select @check_backup_path = @std_backup_path + '\' + @cu11DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
				exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

				If @exists = 1
				   begin
					Print 'DBA Warning:  File delete error prior to backup processing'
					Select @cmd = 'handle /accepteula -u ' + @std_backup_path
					Print @cmd
					exec master.sys.xp_cmdshell @cmd
				   end
			   end
		   end


		Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
		Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

		Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu11DBName) + '_' + rtrim(@backup_type) + '_' + rtrim(@date) + '.' + rtrim(@BkUpSufx) 
		Print 'Output file will be: ' + @BkUpFile

		If rtrim(@cu10DBName) in ('master', 'model','msdb')

		   begin

			Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'
			Print 'Output file will be: ' + @BkUpFile

			Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


		Else If @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_backup_database'
					+ ' @database = ''' + rtrim(@cu11DBName) 
					+ ''', @filename = ''' + rtrim(@BkUpFile) 
					+ ''', @threads = ' + convert(varchar(10), @threads) 
					+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
					+ ', @logging = 0'
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_backup_database
					 @database = @cu11DBName 
					,@filename = @BkUpFile 
					,@threads = @threads 
					,@compressionlevel = @compressionlevel 
					,@logging = 0
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			Select @cmd = 'master.dbo.sqlbackup' 

			Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@cu11DBName) + ']' 
					+ ' TO DISK = ''' + rtrim(@BkUpFile) 
					+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
					+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
					+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
					+ ', SINGLERESULTSET'
			If @VerifyBackup = 'y'
			   begin
			    Select @cmd2 = @cmd2 + ', VERIFY'
			   end
			Select @cmd2 = @cmd2 + '"' 

			Print @cmd
			Print @cmd2
			Print ' '
			delete from #resultstring
			Insert into #resultstring exec @cmd @cmd2
			select * from #resultstring
		   end
		Else
		   begin
			Select @cmd = 'Backup database [' + rtrim(@cu11DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


		If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
		   begin
			Print 'DBA Error:  DB Backup Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode is not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end
		Else If exists (select 1 from #resultstring where message like '%error%')
		   begin
			Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
			Print '--***********************************************************'
			Select * from #resultstring
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Verfiy backup
		If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
		   end
		Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
		   begin
			select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end

		If @@error <> 0 or @retcode <> 0
		   begin
			Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode is not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Log the backup info
		If @backup_log_flag = 'y'
		   begin
			Select @BkUpFilename = rtrim(@cu11DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx

			Insert into dbo.backup_log values(getdate(), @cu11DBName, @BkUpFilename, @outpath, @process_mode)
		   end



		If @DeletePrevious in ('before', 'after')
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu11DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing completed'
						Select @cmd = 'handle /accepteula -u ' + @outpath
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end

				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end


			If @process_mode <> 'normal'
			   begin
				Delete from #DirectoryTempTable
				select @cmd = 'dir ' + @std_backup_path2 + '\' + @cu11DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null
				Select @tempcount = (select count(*) from #DirectoryTempTable)
				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

					--  Parse the backup file name to get the date info
					Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
					   end	

					Select @charpos = charindex('_', @Hold_filedate)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
					   end	

					Select @Hold_filedate = left(@Hold_filedate, 12)

					If left(@date, 12) > @Hold_filedate
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @std_backup_path2 + '\' + @Hold_filename
						print @cmd
						exec master.sys.xp_cmdshell @cmd

						--  Check to make sure files were deleted
						Select @check_backup_path = @std_backup_path + '\' + @Hold_filename
						exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

						If @exists = 1
						   begin
							Print 'DBA Warning:  File delete error after backup processing completed'
							Select @cmd = 'handle /accepteula -u ' + @std_backup_path
							Print @cmd
							exec master.sys.xp_cmdshell @cmd
						   end
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end
		
					Select @tempcount = (select count(*) from #DirectoryTempTable)

				   end
			   end
		   end



		If @DeleteTran = 'y'
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu11DBName + '_tlog_*.' + rtrim(@BkUpSufx_tlog) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_tlog_', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing complete'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end
		   end



		If @DeleteDfntl = 'y'
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu11DBName + '_dfntl_*.' + rtrim(@BkUpSufx_dfntl) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_dfntl_', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing complete'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end
		   end


		--  If this DB is set for recovery=full, create a differential
		If @auto_diff = 'y' and databaseproperty(@cu11DBName, 'IsTrunclog') = 0
		   begin
			exec dbaadmin.dbo.dbasp_Backup_Differential @DBName = @cu11DBName
								,@BkUpPath = @BkUpPath
								,@LiteSpeed_Bypass = @LiteSpeed_Bypass
								,@RedGate_Bypass = @RedGate_Bypass
								,@process_mode = @process_mode
		   end



		allDBs_loop_end:

		--  check for more rows to process
		delete from @DBnames2 where dbid = @cu11DBId
		If (select count(*) from @DBnames2) > 0
		   begin
			goto start_dbnames2
		   end

	   end

   end
--  Back up all system DBs
Else If @sysDB_flag = 'y'
   begin

	Select @cmd = 'SELECT d.name, d.dbid, d.status
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name in (''master'', ''model'', ''msdb'')'

	delete from @DBnames2

	insert into @DBnames2 (name, dbid, status) exec (@cmd)

	delete from @DBnames2 where name is null or name = ''
	--select * from @DBnames2


	If (select count(*) from @DBnames2) > 0
	   begin
		start_dbnames2b:

		Select @cu12DBId = (select top 1 dbid from @DBnames2 order by dbid)
		Select @cu12DBName = (select name from @DBnames2 where dbid = @cu12DBId)
		Select @cu12DBStatus = (select status from @DBnames2 where dbid = @cu12DBId)

		If @DeletePrevious = 'before'
		   begin
			Select @cmd = 'del ' + @outpath2 + '\' + @cu12DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
			Print ' '
			Print 'The following delete command will be used.'
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd

			--  Check to make sure files were deleted
			Select @check_backup_path = @outpath + '\' + @cu12DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
			exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

			If @exists = 1
			   begin
				Print 'DBA Warning:  File delete error prior to backup processing'
				Select @cmd = 'handle /accepteula -u ' + @outpath
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end


			If @process_mode <> 'normal'
			   begin
				Select @cmd = 'del ' + @std_backup_path2 + '\' + @cu12DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
				Print ' '
				Print 'The following delete command will be used.'
				Print @cmd
				EXEC master.sys.xp_cmdshell @cmd

				--  Check to make sure files were deleted
				Select @check_backup_path = @std_backup_path + '\' + @cu12DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
				exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

				If @exists = 1
				   begin
					Print 'DBA Warning:  File delete error prior to backup processing'
					Select @cmd = 'handle /accepteula -u ' + @std_backup_path
					Print @cmd
					exec master.sys.xp_cmdshell @cmd
				   end
			   end
		   end


		Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
		Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

		Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu12DBName) + '_' + rtrim(@backup_type) + '_' + rtrim(@date) + '.' + rtrim(@BkUpSufx) 
		Print 'Output file will be: ' + @BkUpFile
		
		If rtrim(@cu10DBName) in ('master', 'model','msdb')

		   begin

			Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'
			Print 'Output file will be: ' + @BkUpFile

			Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


		Else If @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_backup_database'
					+ ' @database = ''' + rtrim(@cu12DBName) 
					+ ''', @filename = ''' + rtrim(@BkUpFile) 
					+ ''', @threads = ' + convert(varchar(10), @threads) 
					+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
					+ ', @logging = 0'
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_backup_database
					 @database = @cu12DBName 
					,@filename = @BkUpFile 
					,@threads = @threads 
					,@compressionlevel = @compressionlevel 
					,@logging = 0
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			Select @cmd = 'master.dbo.sqlbackup' 

			Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@cu12DBName) + ']' 
					+ ' TO DISK = ''' + rtrim(@BkUpFile) 
					+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
					+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
					+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
					+ ', SINGLERESULTSET'
			If @VerifyBackup = 'y'
			   begin
			    Select @cmd2 = @cmd2 + ', VERIFY'
			   end
			Select @cmd2 = @cmd2 + '"' 

			Print @cmd
			Print @cmd2
			Print ' '
			delete from #resultstring
			Insert into #resultstring exec @cmd @cmd2
			select * from #resultstring
		   end
		Else
		   begin
			Select @cmd = 'Backup database [' + rtrim(@cu12DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end



		If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
		   begin
			Print 'DBA Error:  DB Backup Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode is not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end
		Else If exists (select 1 from #resultstring where message like '%error%')
		   begin
			Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
			Print '--***********************************************************'
			Select * from #resultstring
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Verfiy backup
		If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
		   end
		Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
		   begin
			select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end

		If @@error <> 0 or @retcode <> 0
		   begin
			Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
			Print '--***********************************************************'
			Select * from #resultstring
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Log the backup info
		If @backup_log_flag = 'y'
		   begin
			Select @BkUpFilename = rtrim(@cu12DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx

			Insert into dbo.backup_log values(getdate(), @cu12DBName, @BkUpFilename, @outpath, @process_mode)
		   end



		If @DeletePrevious in ('before', 'after')
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu12DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing completed'
						Select @cmd = 'handle /accepteula -u ' + @outpath
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end


			If @process_mode <> 'normal'
			   begin
				Delete from #DirectoryTempTable
				select @cmd = 'dir ' + @std_backup_path2 + '\' + @cu12DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null
				Select @tempcount = (select count(*) from #DirectoryTempTable)
				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

					--  Parse the backup file name to get the date info
					Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
					   end	

					Select @charpos = charindex('_', @Hold_filedate)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
					   end	

					Select @Hold_filedate = left(@Hold_filedate, 12)

					If left(@date, 12) > @Hold_filedate
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @std_backup_path2 + '\' + @Hold_filename
						print @cmd
						exec master.sys.xp_cmdshell @cmd

						--  Check to make sure files were deleted
						Select @check_backup_path = @std_backup_path + '\' + @Hold_filename
						exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

						If @exists = 1
						   begin
							Print 'DBA Warning:  File delete error after backup processing completed'
							Select @cmd = 'handle /accepteula -u ' + @std_backup_path
							Print @cmd
							exec master.sys.xp_cmdshell @cmd
						   end
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end
		
					Select @tempcount = (select count(*) from #DirectoryTempTable)
				   end
			   end
		   end


		--  check for more rows to process
		delete from @DBnames2 where dbid = @cu12DBId
		If (select count(*) from @DBnames2) > 0
		   begin
			goto start_dbnames2b
		   end


	   end

   end
--  Back up all DBs
Else If @allDB_flag = 'y'
   begin

	Select @cmd = 'SELECT d.name, d.dbid, d.status
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

	delete from @DBnames2

	insert into @DBnames2 (name, dbid, status) exec (@cmd)

	delete from @DBnames2 where name is null or name = ''
	--select * from @DBnames2


	If (select count(*) from @DBnames2) > 0
	   begin
		start_dbnames2c:

		Select @cu13DBId = (select top 1 dbid from @DBnames2 order by dbid)
		Select @cu13DBName = (select name from @DBnames2 where dbid = @cu13DBId)
		Select @cu13DBStatus = (select status from @DBnames2 where dbid = @cu13DBId)

		If @DeletePrevious = 'before'
		   begin
			Select @cmd = 'del ' + @outpath2 + '\' + @cu13DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
			Print ' '
			Print 'The following delete command will be used.'
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd

			--  Check to make sure files were deleted
			Select @check_backup_path = @outpath + '\' + @cu13DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
			exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

			If @exists = 1
			   begin
				Print 'DBA Warning:  File delete error prior to backup processing'
				Select @cmd = 'handle /accepteula -u ' + @outpath
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end

			If @process_mode <> 'normal'
			   begin
				Select @cmd = 'del ' + @std_backup_path2 + '\' + @cu13DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
				Print ' '
				Print 'The following delete command will be used.'
				Print @cmd
				EXEC master.sys.xp_cmdshell @cmd

				--  Check to make sure files were deleted
				Select @check_backup_path = @std_backup_path + '\' + @cu13DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
				exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output
	
				If @exists = 1
				   begin
					Print 'DBA Warning:  File delete error prior to backup processing'
					Select @cmd = 'handle /accepteula -u ' + @std_backup_path
					Print @cmd
					exec master.sys.xp_cmdshell @cmd
				   end
			   end
		   end

		Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
		Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

		Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu13DBName) + '_' + rtrim(@backup_type) + '_' + rtrim(@date) + '.' + rtrim(@BkUpSufx) 
		Print 'Output file will be: ' + @BkUpFile
		
		If rtrim(@cu10DBName) in ('master', 'model','msdb')

		   begin

			Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'
			Print 'Output file will be: ' + @BkUpFile

			Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


		Else If @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_backup_database'
					+ ' @database = ''' + rtrim(@cu13DBName) 
					+ ''', @filename = ''' + rtrim(@BkUpFile) 
					+ ''', @threads = ' + convert(varchar(10), @threads) 
					+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
					+ ', @logging = 0'
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_backup_database
					 @database = @cu13DBName 
					,@filename = @BkUpFile 
					,@threads = @threads 
					,@compressionlevel = @compressionlevel 
					,@logging = 0
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			Select @cmd = 'master.dbo.sqlbackup' 

			Select @cmd2 = '-SQL "BACKUP DATABASE [' + rtrim(@cu13DBName) + ']' 
					+ ' TO DISK = ''' + rtrim(@BkUpFile) 
					+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
					+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
					+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
					+ ', SINGLERESULTSET'
			If @VerifyBackup = 'y'
			   begin
			    Select @cmd2 = @cmd2 + ', VERIFY'
			   end
			Select @cmd2 = @cmd2 + '"' 

			Print @cmd
			Print @cmd2
			Print ' '
			delete from #resultstring
			Insert into #resultstring exec @cmd @cmd2
			select * from #resultstring
		   end
		Else
		   begin
			Select @cmd = 'Backup database [' + rtrim(@cu13DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


		If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
		   begin
			Print 'DBA Error:  DB Backup Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode is not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end
		Else If exists (select 1 from #resultstring where message like '%error%')
		   begin
			Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
			Print '--***********************************************************'
			Select * from #resultstring
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Verfiy backup
		If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
		   begin
			Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
			Print @cmd
			Print ' '
			Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
		   end
		Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
		   begin
			select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end

		If @@error <> 0 or @retcode <> 0
		   begin
			Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
			Print '--***********************************************************'
			Print '@@error or @retcode is not zero'
			Print '--***********************************************************'
			Select @error_count = @error_count + 1
			goto label99
		   end


		--  Log the backup info
		If @backup_log_flag = 'y'
		   begin
			Select @BkUpFilename = rtrim(@cu13DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx

			Insert into dbo.backup_log values(getdate(), @cu13DBName, @BkUpFilename, @outpath, @process_mode)
		   end

	

		If @DeletePrevious in ('before', 'after')
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu13DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing completed'
						Select @cmd = 'handle /accepteula -u ' + @outpath
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end


			If @process_mode <> 'normal'
			   begin
				Delete from #DirectoryTempTable
				select @cmd = 'dir ' + @std_backup_path2 + '\' + @cu13DBName + '_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
				insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
				Delete from #DirectoryTempTable where cmdoutput is null
				Select @tempcount = (select count(*) from #DirectoryTempTable)
				While (@tempcount > 0)
				   begin
					Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

					--  Parse the backup file name to get the date info
					Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
					   end	

					Select @charpos = charindex('_', @Hold_filedate)
					IF @charpos <> 0
					   begin
				 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
					   end	

					Select @Hold_filedate = left(@Hold_filedate, 12)

					If left(@date, 12) > @Hold_filedate
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
						select @cmd = 'del ' + @std_backup_path2 + '\' + @Hold_filename
						print @cmd
						exec master.sys.xp_cmdshell @cmd

						--  Check to make sure files were deleted
						Select @check_backup_path = @std_backup_path + '\' + @Hold_filename
						exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

						If @exists = 1
						   begin
							Print 'DBA Warning:  File delete error after backup processing completed'
							Select @cmd = 'handle /accepteula -u ' + @std_backup_path
							Print @cmd
							exec master.sys.xp_cmdshell @cmd
						   end
					   end
					Else
					   begin
						delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					   end
		
					Select @tempcount = (select count(*) from #DirectoryTempTable)

				   end
			   end

		   end



		If @DeleteTran = 'y'
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu13DBName + '_tlog_*.' + rtrim(@BkUpSufx_tlog) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_tlog_', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing complete'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end
		   end



		If @DeleteDfntl = 'y'
		   begin
			Delete from #DirectoryTempTable
			select @cmd = 'dir ' + @outpath2 + '\' + @cu13DBName + '_dfntl_*.' + rtrim(@BkUpSufx_dfntl) + ' /B'
			insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
			Delete from #DirectoryTempTable where cmdoutput is null
			Select @tempcount = (select count(*) from #DirectoryTempTable)
			While (@tempcount > 0)
			   begin
				Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

				--  Parse the backup file name to get the date info
				Select @charpos = charindex('_dfntl_', @Hold_filename)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
				   end	

				Select @charpos = charindex('_', @Hold_filedate)
				IF @charpos <> 0
				   begin
			 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
				   end	

				Select @Hold_filedate = left(@Hold_filedate, 12)

				If left(@date, 12) > @Hold_filedate
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
					select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
					print @cmd
					exec master.sys.xp_cmdshell @cmd

					--  Check to make sure files were deleted
					Select @check_backup_path = @outpath + '\' + @Hold_filename
					exec dbaadmin.dbo.dbasp_get_file_existence @check_backup_path, @exists output

					If @exists = 1
					   begin
						Print 'DBA Warning:  File delete error after backup processing complete'
						Select @cmd = 'handle /accepteula -u ' + @std_backup_path
						Print @cmd
						exec master.sys.xp_cmdshell @cmd
					   end
				   end
				Else
				   begin
					delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				   end
		
				Select @tempcount = (select count(*) from #DirectoryTempTable)

			   end
		   end


		--  If this DB is set for recovery=full, create a differential
		If @auto_diff = 'y' and databaseproperty(@cu13DBName, 'IsTrunclog') = 0
		   begin
			exec dbaadmin.dbo.dbasp_Backup_Differential @DBName = @cu13DBName
								,@BkUpPath = @BkUpPath
								,@LiteSpeed_Bypass = @LiteSpeed_Bypass
								,@RedGate_Bypass = @RedGate_Bypass
								,@process_mode = @process_mode
		   end



		--  check for more rows to process
		delete from @DBnames2 where dbid = @cu13DBId
		If (select count(*) from @DBnames2) > 0
		   begin
			goto start_dbnames2c
		   end


	   end


	--  delete before system DB backups
	If @DeletePrevious = 'before'
	   begin
		Select @cmd = 'del ' + @outpath2 + '\master_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
		Print ' '
		Print 'The following delete command will be used.'
		Print @cmd
		EXEC master.sys.xp_cmdshell @cmd

		Select @cmd = 'del ' + @outpath2 + '\model_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
		Print ' '
		Print 'The following delete command will be used.'
		Print @cmd
		EXEC master.sys.xp_cmdshell @cmd

		Select @cmd = 'del ' + @outpath2 + '\msdb_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ''
		Print ' '
		Print 'The following delete command will be used.'
		Print @cmd
		EXEC master.sys.xp_cmdshell @cmd
	   end


	Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
	Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

	Select @BkUpFile = rtrim(@outpath) + '\master_' + rtrim(@backup_type) + '_' + rtrim(@date) + '.' + rtrim(@BkUpSufx) 
	Print 'Output file will be: ' + @BkUpFile
	
	If rtrim(@cu10DBName) in ('master', 'model','msdb')

		   begin

			Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'
			Print 'Output file will be: ' + @BkUpFile

			Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
			Print @cmd
			Print ' '
			Exec (@cmd)
		   end


	Else If @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_backup_database'
				+ ' @database = ''master'', @filename = ''' + rtrim(@BkUpFile) 
				+ ''', @threads = ' + convert(varchar(10), @threads) 
				+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
				+ ', @logging = 0'
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_backup_database
				 @database = 'master' 
				,@filename = @BkUpFile 
				,@threads = @threads 
				,@compressionlevel = @compressionlevel 
				,@logging = 0
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @cmd = 'master.dbo.sqlbackup' 

		Select @cmd2 = '-SQL "BACKUP DATABASE [master]' 
				+ ' TO DISK = ''' + rtrim(@BkUpFile) 
				+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
				+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
				+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
				+ ', SINGLERESULTSET'
		If @VerifyBackup = 'y'
		   begin
		    Select @cmd2 = @cmd2 + ', VERIFY'
		   end
		Select @cmd2 = @cmd2 + '"' 

		Print @cmd
		Print @cmd2
		Print ' '
		delete from #resultstring
		Insert into #resultstring exec @cmd @cmd2
		select * from #resultstring
	   end
	Else
	   begin
		Select @cmd = 'Backup database [master] to disk = ''' + @BkUpFile + ''' with init'
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end


	If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
	   begin
		Print 'DBA Error:  DB Backup Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end
	Else If exists (select 1 from #resultstring where message like '%error%')
	   begin
		Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
		Print '--***********************************************************'
		Select * from #resultstring
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Verfiy backup
	If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
	   end
	Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
	   begin
		select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end

	If @@error <> 0 or @retcode <> 0
	   begin
		Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Log the backup info
	If @backup_log_flag = 'y'
	   begin
		Select @BkUpFilename = 'master_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx

		Insert into dbo.backup_log values(getdate(), 'master', @BkUpFilename, @outpath, @process_mode)
	   end



	Select @BkUpFile = rtrim(@outpath) + '\model_' + rtrim(@backup_type) + '_' + rtrim(@date) + '.' + rtrim(@BkUpSufx) 
	Print 'Output file will be: ' + @BkUpFile
	
	If rtrim(@cu10DBName) in ('master', 'model','msdb')

            begin

		Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'

		Print 'Output file will be: ' + @BkUpFile

		Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
		Print @cmd
		Print ' '
		Exec (@cmd)

	    end


	Else If @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_backup_database'
				+ ' @database = ''model'', @filename = ''' + rtrim(@BkUpFile) 
				+ ''', @threads = ' + convert(varchar(10), @threads) 
				+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
				+ ', @logging = 0'
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_backup_database
				 @database = 'model' 
				,@filename = @BkUpFile 
				,@threads = @threads 
				,@compressionlevel = @compressionlevel 
				,@logging = 0
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @cmd = 'master.dbo.sqlbackup' 

		Select @cmd2 = '-SQL "BACKUP DATABASE [model]' 
				+ ' TO DISK = ''' + rtrim(@BkUpFile) 
				+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
				+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
				+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
				+ ', SINGLERESULTSET'
		If @VerifyBackup = 'y'
		   begin
		    Select @cmd2 = @cmd2 + ', VERIFY'
		   end
		Select @cmd2 = @cmd2 + '"' 

		Print @cmd
		Print @cmd2
		Print ' '
		delete from #resultstring
		Insert into #resultstring exec @cmd @cmd2
		select * from #resultstring
	   end
	Else
	   begin
		Select @cmd = 'Backup database [model] to disk = ''' + @BkUpFile + ''' with init'
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end


	If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
	   begin
		Print 'DBA Error:  DB Backup Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end
	Else If exists (select 1 from #resultstring where message like '%error%')
	   begin
		Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
		Print '--***********************************************************'
		Select * from #resultstring
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Verfiy backup
	If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
	   end
	Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
	   begin
		select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end

	If @@error <> 0 or @retcode <> 0
	   begin
		Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Log the backup info
	If @backup_log_flag = 'y'
	   begin
		Select @BkUpFilename = 'model_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx

		Insert into dbo.backup_log values(getdate(), 'model', @BkUpFilename, @outpath, @process_mode)
	   end



	Select @BkUpFile = rtrim(@outpath) + '\msdb_' + rtrim(@backup_type) + '_' + rtrim(@date) + '.' + rtrim(@BkUpSufx) 
	Print 'Output file will be: ' + @BkUpFile
	
	If rtrim(@cu10DBName) in ('master', 'model','msdb')

           begin

		Select @BkUpFile = rtrim(@outpath) + '\' + rtrim(@cu10DBName) + '_' + rtrim(@backup_type) + '_' + @date + '.bak'
		Print 'Output file will be: ' + @BkUpFile

		Select @cmd = 'Backup database [' + rtrim(@cu10DBName) + '] to disk = ''' + @BkUpFile + ''' with init'
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end


	Else If @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_backup_database'
				+ ' @database = ''msdb'', @filename = ''' + rtrim(@BkUpFile) 
				+ ''', @threads = ' + convert(varchar(10), @threads) 
				+ ', @compressionlevel = ' + convert(varchar(5), @compressionlevel) 
				+ ', @logging = 0'
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_backup_database
				 @database = 'msdb' 
				,@filename = @BkUpFile 
				,@threads = @threads 
				,@compressionlevel = @compressionlevel 
				,@logging = 0
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		Select @cmd = 'master.dbo.sqlbackup' 

		Select @cmd2 = '-SQL "BACKUP DATABASE [msdb]' 
				+ ' TO DISK = ''' + rtrim(@BkUpFile) 
				+ ''' WITH THREADCOUNT = ' + convert(varchar(10), @threads) 
				+ ', COMPRESSION = ' + convert(varchar(5), @compressionlevel) 
				+ ', MAXTRANSFERSIZE = ' + convert(varchar(10), @maxtransfersize)
				+ ', SINGLERESULTSET'
		If @VerifyBackup = 'y'
		   begin
		    Select @cmd2 = @cmd2 + ', VERIFY'
		   end
		Select @cmd2 = @cmd2 + '"' 

		Print @cmd
		Print @cmd2
		Print ' '
		delete from #resultstring
		Insert into #resultstring exec @cmd @cmd2
		select * from #resultstring
	   end
	Else
	   begin
		Select @cmd = 'Backup database [msdb] to disk = ''' + @BkUpFile + ''' with init'
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end


	If (@@error <> 0 or @retcode <> 0) and @BkUpMethod <> 'RG'
	   begin
		Print 'DBA Error:  DB Backup Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end
	Else If exists (select 1 from #resultstring where message like '%error%')
	   begin
		Print 'DBA Error:  DB Backup (RG) Failure for command ' + @cmd + @cmd2
		Print '--***********************************************************'
		Select * from #resultstring
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Verfiy backup
	If @VerifyBackup = 'y' and @BkUpMethod = 'LS'
	   begin
		Select @cmd = 'master.dbo.xp_restore_verifyonly @filename = ''' + rtrim(@BkUpFile) + ''''
		Print @cmd
		Print ' '
		Exec @retcode = master.dbo.xp_restore_verifyonly @filename = @BkUpFile
	   end
	Else If @VerifyBackup = 'y' and @BkUpMethod <> 'RG'
	   begin
		select @cmd = 'RESTORE VERIFYONLY FROM disk = ''' + @BkUpFile + ''''
		Print @cmd
		Print ' '
		Exec (@cmd)
	   end

	If @@error <> 0 or @retcode <> 0
	   begin
		Print 'DBA Error:  Backup Verification Failure for command ' + @cmd
		Print '--***********************************************************'
		Print '@@error or @retcode is not zero'
		Print '--***********************************************************'
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  Log the backup info
	If @backup_log_flag = 'y'
	   begin
		Select @BkUpFilename = 'msdb_' + rtrim(@backup_type) + '_' + @date + '.' + @BkUpSufx

		Insert into dbo.backup_log values(getdate(), 'msdb', @BkUpFilename, @outpath, @process_mode)
	   end



	If @DeletePrevious in ('before', 'after')
	   begin
		Delete from #DirectoryTempTable
		select @cmd = 'dir ' + @outpath2 + '\master_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		select @cmd = 'dir ' + @outpath2 + '\model_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		select @cmd = 'dir ' + @outpath2 + '\msdb_' + @backup_type + '_*.' + rtrim(@BkUpSufx) + ' /B'
		insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
		Delete from #DirectoryTempTable where cmdoutput is null

		Select @tempcount = (select count(*) from #DirectoryTempTable)
		While (@tempcount > 0)
		   begin
			Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

			--  Parse the backup file name to get the date info
			Select @charpos = charindex('_' + @backup_type + '_2', @Hold_filename)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filename, @charpos + 1, 100)
			   end	

			Select @charpos = charindex('_', @Hold_filedate)
			IF @charpos <> 0
			   begin
		 		Select @Hold_filedate = substring(@Hold_filedate, @charpos + 1, 100)
			   end	

			Select @Hold_filedate = left(@Hold_filedate, 12)

			If left(@date, 12) > @Hold_filedate
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
				select @cmd = 'del ' + @outpath2 + '\' + @Hold_filename
				print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end
			Else
			   begin
				delete from #DirectoryTempTable where cmdoutput = @Hold_filename
			   end
		
			Select @tempcount = (select count(*) from #DirectoryTempTable)

		   end
	   end


   end	



--  End Processing  ---------------------------------------------------------------------------------------------
	
Label99:

drop table #DirectoryTempTable
drop table #fileexists
drop table #resultstring



If @error_count > 0
   begin
	raiserror('dbasp_BackupDBs Failure',16,-1) with log
	return(1)
   end


 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_BackupFile_mover
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_BackupFile_mover]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_BackupFile_mover]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_BackupFile_mover ( @source_server sysname = '\\10.240.8.6',
				@source_path nvarchar(500) = 'SQLTrans',
				@target_path nvarchar(500) = null,
				@backupsource sysname = null,
				@backupname sysname = null,
				@backup_ext sysname = null,
				@backup_hh_period int = '22',
				@retry_limit smallint = 5,
				@retry_num smallint = 3,
				@wait_num smallint = 30,
				@delete_source char(1) = 'n',
				@pre_delete_target char(1) = 'y')

/*********************************************************
 **  Stored Procedure dbasp_BackupFile_mover                  
 **  Written by Jim Wilson, Getty Images                
 **  August 16, 2004                                      
 **  
 **  This procedure is used for copying files from one server
 **  to another where there is no trust relationship.
 **
 **  This proc accepts several input parms:
 **  - @source_server is the \\servername where files are being copied from.
 **  - @source_path is the path (share or folder name) where files are being copied from.
 **  - @target_path is the path where files are being copied to.
 **  - @backupsource is the name of the server where the file originated.
 **  - @backupname is the name pattern of the backup file to be restored.
 **  - @backup_ext is the extention name for the backup file.
 **  - @backup_hh_period is the number of hours allowed between the date
 **    the backup file was created and the current date/time.
 **  - @retry_limit is the number of retries performed if the file is not available.
 **  - @retry_num is the number of retries performed if the network fails.
 **  - @wait_num is the number of seconds to wait between retries.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/16/2004	Jim Wilson		New process
--	01/11/2005	Jim Wilson		Changed severity or raiserror from -1 to 16
--	05/13/2005	Jim Wilson		Added code to /MOV (delete source) on request.
--	07/11/2005	Jim Wilson		New input parm @source_server to help with file 
--						transfer from production domain.  Added code
--						for new PROD domain account.
--	08/29/2005	Jim Wilson		Modified display for error message of input parm 
--						for @source_server.  Added verification of
--						the delete from target process.  Changed 'seaexdeply01\SQLTransUser'
--						to 'seaexdeploy01\SQLTransUser'.
--	09/07/2005	Jim Wilson		Disable the net use disconnect.  Added support 
--						for server \\seaexdelsqla.
--	10/17/2005	Jim Wilson		Added \\podsqla and \\mdssqla to list of servers. 
--	11/01/2005	Jim Wilson		Changed process for detecting AM or PM in the file date. 
--	01/10/2006	Jim Wilson		Added \\visql01 to list of servers. 
--	01/17/2006	Jim Wilson		Modified %am% and %pm% check to %a% and %p%. 
--	06/21/2006	Jim Wilson		Updated for SQL 2005. 
--	05/15/2007	Jim Wilson		Added support for seadcaspsqla. 
--	06/05/2007	Jim Wilson		Added HANDLE print out for delete file failures. 
--	01/16/2008	Jim Wilson		Added @retry_num. 
--	01/28/2008	Jim Wilson		Added \\seadcshsqla to list of servers. 
--	06/07/2008	Jim Wilson		Added \\seapshlsql0a to list of servers. 
--	09/10/2008	Jim Wilson		Added @wait_num. 
--	10/24/2008	Jim Wilson		Removed passwords. 
--	02/02/2009	Jim Wilson		Added pre_delete_target. 
--	03/26/2009	Jim Wilson		Check local_control table before deleting net use connection. 
--	03/30/2009	Jim Wilson		New delete process.
--	01/04/2010	Jim Wilson		Added input parm @backup_ext.
--	02/11/2010	Steve Ledridge		Modified the calls to Handle.exe to use the /accepteula switch
--	03/23/2010	Jim Wilson		Added code to ignore shortcut files.
--	======================================================================================


/***
Declare @source_server sysname
Declare @source_path nvarchar(500)
Declare @target_path nvarchar(500)
Declare @backupsource sysname
Declare @backupname sysname
Declare @backup_ext sysname
Declare @backup_hh_period int
Declare @retry_limit smallint
Declare @wait_num smallint
Declare @delete_source char(1)
Declare @pre_delete_target char(1)

select @source_server = '\\g1sqla'
select @source_path = 'g1sqla$a_backup'
--select @source_server = '\\ginssqla'
--select @source_path = 'ginssqla$a_backup'
select @target_path = '\\SQLDEPLOYER02\SQLDEPLOYER02_restore\gmsa'
select @backupsource = ''
select @backupname = 'DataExtract_db_'
Select @backup_ext = 'sqb'
select @backup_hh_period = '300'
select @retry_limit = 3
Select @wait_num = 30
Select @delete_source = 'n'
Select @pre_delete_target = 'n'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@error_count		int
	,@command 		nvarchar(512)
	,@retcode 		int
	,@filecount		smallint
	,@filename_wild		nvarchar(100)
	,@charpos		int
	,@counter		smallint
	,@savefilename		sysname
	,@hold_filedate		nvarchar(12)
	,@save_filedate		nvarchar(12)
	,@save_filedate2	nvarchar(20)
	,@save_fileYYYY		nvarchar(4)
	,@save_fileMM		nvarchar(2)
	,@save_fileDD		nvarchar(2)
	,@save_fileHH		nvarchar(2)
	,@save_fileMN		nvarchar(2)
	,@save_fileAMPM		nvarchar(5)
	,@retry_counter		smallint
	,@source_user 		sysname
	,@source_pw 		sysname
	,@dbfilename		sysname
	,@hold_string		sysname
	,@newid 		sysname


DECLARE
	 @cu11cmdoutput		nvarchar(255)


----------------  initial values  -------------------
Select @error_count = 0
Select @hold_filedate = '200001010001'
Select @retry_counter = 0
select @newid = convert(sysname, newid())

select @filename_wild = '%' + @backupname + '%'


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

create table #Handle (HandleInt int identity
		,HandleValue nvarchar (4000))


--  Check input parms
if @backupname is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_BackupFile_mover.  @backupname is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @backupsource is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_BackupFile_mover.  @backupsource is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_BackupFile_mover. @target_path is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


--  Set login and password
If @source_server in ('\\g1sqla', '\\g1sqlb', '\\seapshlsql0a', '\\seadcpcsqla', '\\seadcaspsqla', '\\seadcshsqla') 
   begin
	Select @source_user = 'PRODUCTION\SQLTransSVCAcct'
	Select @hold_string  = 'pw_' + @source_user
	Select @source_pw  = (select top 1 detail01 from dbo.local_control where subject = @hold_string)
	If @source_pw is null or @source_pw = ''
	   begin
		Select @miscprint = 'DBA ERROR: Password not found for ' + @source_user + '.' 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   end
Else
   begin
	Select @miscprint = 'DBA WARNING: Invalid source path.' 
	Print @miscprint
	Select @miscprint = 'Only \\seadcpcsqla, \\seadcaspsqla, \\g1sqla, \\g1sqlb, \\seadcshsqla and \\seapshlsql0a are vaild at this time.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end


select @command = 'net use'
exec master.sys.xp_cmdshell @command--, no_output


--  Connect to the remote server share
select @command = 'net use ' + @source_server + ' /user:' + @source_user + ' xxxxx'
print @command
select @command = 'net use ' + @source_server + ' /user:' + @source_user + ' ' + @source_pw
--print @command
exec master.sys.xp_cmdshell @command--, no_output

If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid)
   begin
	insert into dbo.local_control values ('net_use', @source_server, @newid, '')
   end

select @command = 'net use'
exec master.sys.xp_cmdshell @command--, no_output




/****************************************************************
 *                MainLine
 ***************************************************************/

Label01:
 

If @backup_ext is not null and @backup_ext <> ''
   begin
	select @command = 'dir ' + @source_server + '\' + @source_path + '\*.' + @backup_ext
	print @command
   end
Else
   begin
	select @command = 'dir ' + @source_server + '\' + @source_path + '\*.*'
	print @command
   end


delete from #DirectoryTempTable
exec master.sys.xp_cmdshell @command
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%Shortcut%'
delete from #DirectoryTempTable where cmdoutput is null
select * from #DirectoryTempTable


select @filecount = (select count(*) from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like @filename_wild)

if @filecount < 1
   BEGIN
	Select @miscprint = 'DBA WARNING: No files found for dbasp_BackupFile_mover at ' + @source_server + '\' + @source_path + ' ' + @filename_wild
	If @retry_counter < @retry_limit
	   begin
		Select @retry_counter = @retry_counter + 1
		--Waitfor delay '00:05:00'
		Print 'Retry ' + convert(varchar(10), @retry_counter)
		goto label01
	   end
	Else
	   begin
		Select @error_count = @error_count + 1
		goto label99
	   end
   END
Else
   BEGIN
	EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
	  'SELECT p.cmdoutput
	   From #DirectoryTempTable   p ' +
	  'Where ltrim(rtrim(p.cmdoutput)) like ''' + @filename_wild + '''
	   Order by p.cmdoutput for Read Only')

	OPEN cu11_cursor

	WHILE (11=11)
	 Begin
		FETCH Next From cu11_cursor Into @cu11cmdoutput
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu11_cursor
		      BREAK
	           end

		select @save_fileYYYY = substring(@cu11cmdoutput, 7, 4)
		select @save_fileMM = substring(@cu11cmdoutput, 1, 2)
		select @save_fileDD = substring(@cu11cmdoutput, 4, 2)
		select @save_fileHH = substring(@cu11cmdoutput, 13, 2)
		select @save_fileMN = substring(@cu11cmdoutput, 16, 2)
		select @save_fileAMPM = substring(@cu11cmdoutput, 18, 5)
		If @save_fileAMPM like '%A%' and @save_fileHH = '12'
		   begin
			Select @save_fileHH = '00'
		   end
		Else If @save_fileAMPM like '%P%' and @save_fileHH <> '12'
		   begin
			Select @save_fileHH = @save_fileHH + 12
		   end
		Select @save_filedate = @save_fileYYYY + @save_fileMM + @save_fileDD + @save_fileHH + @save_fileMN
		Select @save_filedate2 = @save_fileYYYY + '-' + @save_fileMM + '-' + @save_fileDD + ' ' + @save_fileHH + ':' + @save_fileMN + ':00'

		If @hold_filedate < @save_filedate
		   begin
			select @savefilename = ltrim(rtrim(substring(@cu11cmdoutput, 40, 200)))
			select @hold_filedate = @save_filedate
		   end

	 End  -- loop 11
	 DEALLOCATE cu11_cursor

   END




-- If the source file is too old...
If @backup_hh_period < DATEDIFF(hour, convert(datetime, @save_filedate2), getdate())
   begin
	Select @miscprint = 'DBA WARNING: File at source is too old (' + @save_filedate2 + ').  Check your @backup_hh_period parm.' 
	Print @miscprint
	If @retry_counter < @retry_limit
	   begin
		Select @retry_counter = @retry_counter + 1
		Waitfor delay '00:05:00'
		goto label01
	   end
	Else
	   begin
		Select @error_count = @error_count + 1
		goto label99
	   end
   end





--  Check to see if this file is already at the target.  If not, delete the file at the target.
Delete from #DirectoryTempTable
Select @command = 'DIR ' + @target_path + '\*' + @backupname + '*.* /b'
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
delete from #DirectoryTempTable where cmdoutput is null

Select @filecount = (select count(*) from #DirectoryTempTable where cmdoutput not like '%File Not Found%')
select * from #DirectoryTempTable

If not exists (select 1 from #DirectoryTempTable where cmdoutput like '%' + @savefilename + '%')
   begin

	Select @counter = 0

	start_file_delete:

	select @command = 'if exist ' + @target_path + '\*' + @backupname + '*.* del ' + @target_path + '\*' + @backupname + '*.*'
	Print @command
	exec master.sys.xp_cmdshell @command

	Delete from #DirectoryTempTable
	Select @command = 'DIR ' + @target_path + '\*' + @backupname + '*.* /b'
	Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
	delete from #DirectoryTempTable where cmdoutput is null

	Select @filecount = (select count(*) from #DirectoryTempTable where cmdoutput not like '%File Not Found%')

	If @filecount > 0 
	   begin
		If @counter < 5
		   begin
			select @counter = @counter + 1
			waitfor delay '00:00:15'
			goto start_file_delete
		   end
		Else
		   begin
			Select * from #DirectoryTempTable
			Select @miscprint = 'Unable to delete file using the following command. ' + @target_path + '\*' + @backupname + '*.*'
			Print @miscprint
			Select @dbfilename = (select top 1  cmdoutput from #DirectoryTempTable where cmdoutput not like '%File Not Found%')

			select @command = 'handle /accepteula ' + @dbfilename
			INSERT #Handle EXEC master..xp_cmdshell @command

			Select @miscprint = 'Here is the HANDLE output for this file. '
			Print @miscprint
			select * from #handle

			Select @error_count = @error_count + 1 
			RAISERROR( 'DBA ERROR: Error Deleting Files.  Check to see what is holding this file (Backup to Tape?).', 16, -1 ) with log
			goto label99
		   end
	   end
   end



--  Perform the copy process
--  Note:  If the file being copied is already at the target, robocopy will skip it.
--         The reason we do it this way is - if the file is damaged, robocopy will overwrite it.
If @delete_source = 'y'
   begin
	select @command = 'robocopy /Z /W:' + convert(nvarchar(10), @wait_num) + ' /R:' + convert(nvarchar(10), @retry_limit) + ' /MOV ' + @source_server + '\' + @source_path + ' ' + @target_path + ' ' + rtrim(@savefilename)
   end
Else
   begin
	select @command = 'robocopy /Z /W:' + convert(nvarchar(10), @wait_num) + ' /R:' + convert(nvarchar(10), @retry_limit) + ' ' + @source_server + '\' + @source_path + ' ' + @target_path + ' ' + rtrim(@savefilename)
   end

Print @command
exec master.sys.xp_cmdshell @command


If rtrim(@savefilename) like '%.zip'
   begin
	select @command = 'wzunzip ' + @target_path + '\' + @backupsource + '_' + @backupname + '*.zip ' + @target_path + '\'
	Print @command
	exec master.sys.xp_cmdshell @command

	select @command = 'if exist ' + @target_path + '\' +  @backupsource + '_' + @backupname + '*.zip del ' + @target_path + '\' + @backupsource + '_' + @backupname + '*.zip'
	Print @command
	exec master.sys.xp_cmdshell @command
   end



-------------------   end   --------------------------

--  Disconnect the remote server connection
If exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid)
   begin
	delete from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid
   end

If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server)
   begin
	select @command = 'net use /DELETE ' + @source_server
	print @command
	exec master.sys.xp_cmdshell @command--, no_output
   end

label99:


drop table #DirectoryTempTable
drop table #Handle


If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_BackupFile_mover_trusted
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_BackupFile_mover_trusted]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_BackupFile_mover_trusted]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_BackupFile_mover_trusted ( @source_server sysname = null,
				@source_path nvarchar(500) = null,
				@target_path nvarchar(500) = null,
				@backupname sysname = null,
				@backup_hh_period int = '22',
				@retry_limit smallint = 5,
				@delete_source char(1) = 'n')

/*********************************************************
 **  Stored Procedure dbasp_BackupFile_mover_trusted                  
 **  Written by Jim Wilson, Getty Images                
 **  August 16, 2004                                      
 **  
 **  This procedure is used for copying files from one server
 **  to another where there is a trust relationship.
 **
 **  This proc accepts several input parms:
 **  - @source_server is the \\servername where files are being copied from.
 **  - @source_path is the path (share or folder name) where files are being copied from.
 **  - @target_path is the path where files are being copied to.
 **  - @backupname is the name pattern of the backup file to be copied.
 **  - @backup_hh_period is the number of hours allowed between the date
 **    the backup file was created and the current date/time.
 **  - @retry_limit is the number of retries performed if the file is not available.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/02/2005	Jim Wilson		New process
--	06/23/2006	Jim Wilson		Updated for SQL 2005.
--	03/30/2009	Jim Wilson		New delete process.
--	03/23/2010	Jim Wilson		Added code to ignore shortcut files.
--	05/04/2010	Jim Wilson		Added '%cannot find the file%' to file delete code.
--	======================================================================================


/***
Declare @source_server sysname
Declare @source_path nvarchar(500)
Declare @target_path nvarchar(500)
Declare @backupname sysname
Declare @backup_hh_period int
Declare @retry_limit smallint
Declare @delete_source char(1)

select @source_server = '\\seadcsqlc01a'
select @source_path = 'seadcsqlc01a_backup'
select @target_path = '\\sqldeployer01\sqldeployer01_restore\crm'
select @backupname = 'MSCRM_CONFIG_db_'
select @backup_hh_period = '3000'
select @retry_limit = 3
Select @delete_source = 'n'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@error_count		int
	,@command 		nvarchar(512)
	,@retcode 		int
	,@filecount		smallint
	,@filename_wild		nvarchar(100)
	,@charpos		int
	,@counter		smallint
	,@savefilename		sysname
	,@hold_filedate		nvarchar(12)
	,@save_filedate		nvarchar(12)
	,@save_filedate2	nvarchar(20)
	,@save_fileYYYY		nvarchar(4)
	,@save_fileMM		nvarchar(2)
	,@save_fileDD		nvarchar(2)
	,@save_fileHH		nvarchar(2)
	,@save_fileMN		nvarchar(2)
	,@save_fileAMPM		nvarchar(1)
	,@retry_counter		smallint
	,@source_user 		sysname
	,@source_pw 		sysname

DECLARE
	 @cu11cmdoutput		nvarchar(255)


----------------  initial values  -------------------
Select @error_count = 0
Select @hold_filedate = '200001010001'
Select @retry_counter = 0

select @filename_wild = '%' + @backupname + '%'

create table #DirectoryTempTable(cmdoutput nvarchar(255) null)


--  Check input parms
if @backupname is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_BackupFile_mover_trusted.  @backupname is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_BackupFile_mover_trusted. @target_path is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END




/****************************************************************
 *             MainLine
 ***************************************************************/

Label01:
 
select @command = 'dir ' + @source_server + '\' + @source_path + '\*.*'
print @command

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%Shortcut%'
delete from #DirectoryTempTable where cmdoutput is null
select * from #DirectoryTempTable


select @filecount = (select count(*) from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like @filename_wild)

if @filecount < 1
   BEGIN
	Select @miscprint = 'DBA WARNING: No files found for dbasp_BackupFile_mover_trusted at ' + @source_server + '\' + @source_path + ' ' + @backupname
	If @retry_counter < @retry_limit
	   begin
		Select @retry_counter = @retry_counter + 1
		--Waitfor delay '00:05:00'
		Print 'Retry ' + convert(varchar(10), @retry_counter)
		goto label01
	   end
	Else
	   begin
		Select @error_count = @error_count + 1
		goto label99
	   end
   END
Else
   BEGIN
	EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
	  'SELECT p.cmdoutput
	   From #DirectoryTempTable   p ' +
	  'Where ltrim(rtrim(p.cmdoutput)) like ''' + @filename_wild + '''
	   Order by p.cmdoutput for Read Only')

	OPEN cu11_cursor

	WHILE (11=11)
	 Begin
		FETCH Next From cu11_cursor Into @cu11cmdoutput
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu11_cursor
		      BREAK
	           end

		select @save_fileYYYY = substring(@cu11cmdoutput, 7, 4)
		select @save_fileMM = substring(@cu11cmdoutput, 1, 2)
		select @save_fileDD = substring(@cu11cmdoutput, 4, 2)
		select @save_fileHH = substring(@cu11cmdoutput, 13, 2)
		Select @save_fileAMPM = substring(@cu11cmdoutput, 18, 1)
		If @save_fileAMPM = 'a' and @save_fileHH = '12'
		   begin
			Select @save_fileHH = '00'
		   end
		Else If @save_fileAMPM = 'p' and @save_fileHH <> '12'
		   begin
			Select @save_fileHH = @save_fileHH + 12
		   end
		select @save_fileMN = substring(@cu11cmdoutput, 16, 2)
		Select @save_filedate = @save_fileYYYY + @save_fileMM + @save_fileDD + @save_fileHH + @save_fileMN
		Select @save_filedate2 = @save_fileYYYY + '-' + @save_fileMM + '-' + @save_fileDD + ' ' + @save_fileHH + ':' + @save_fileMN + ':00'

		If @hold_filedate < @save_filedate
		   begin
			select @savefilename = ltrim(rtrim(substring(@cu11cmdoutput, 40, 200)))
			select @hold_filedate = @save_filedate
		   end

	 End  -- loop 11
	 DEALLOCATE cu11_cursor

   END


-- If the source file is too old...
If @backup_hh_period < DATEDIFF(hour, convert(datetime, @save_filedate2), getdate())
   begin
	Select @miscprint = 'DBA WARNING: File at source is too old (' + @save_filedate2 + ').  Check your @backup_hh_period parm.' 
	Print @miscprint
	If @retry_counter < @retry_limit
	   begin
		Select @retry_counter = @retry_counter + 1
		Waitfor delay '00:05:00'
		goto label01
	   end
	Else
	   begin
		Select @error_count = @error_count + 1
		goto label99
	   end
   end


--  Check to see if this file is already at the target.  If not, delete the file at the target.
Delete from #DirectoryTempTable
Select @command = 'DIR ' + @target_path + '\*' + @backupname + '*.* /b'
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
delete from #DirectoryTempTable where cmdoutput is null

Select @filecount = (select count(*) from #DirectoryTempTable where cmdoutput not like '%File Not Found%')
select * from #DirectoryTempTable

If not exists (select 1 from #DirectoryTempTable where cmdoutput like '%' + @savefilename + '%')
   begin
	Select @counter = 0

	start_file_delete:

	select @command = 'if exist ' + @target_path + '\*' + @backupname + '*.* del ' + @target_path + '\*' + @backupname + '*.*'
	Print @command
	exec master.sys.xp_cmdshell @command

	Delete from #DirectoryTempTable
	Select @command = 'DIR ' + @target_path + '\*' + @backupname + '*.* /b'
	Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
	delete from #DirectoryTempTable where cmdoutput is null

	Select @filecount = (select count(*) from #DirectoryTempTable where cmdoutput not like '%File Not Found%' and cmdoutput not like '%cannot find the file%')

	If @filecount > 0 
	   begin
		If @counter < 5
		   begin
			select @counter = @counter + 1
			waitfor delay '00:00:15'
			goto start_file_delete
		   end
		Else
		   begin
			Select * from #DirectoryTempTable
			Select @miscprint = 'Unable to delete file using the following command. ' + @target_path + '\*' + @backupname + '*.*'
			Print @miscprint
			Select @error_count = @error_count + 1 
			RAISERROR( 'DBA ERROR: Error Deleting Files.  Check to see what is holding this file (Backup to Tape?).', 16, -1 ) with log
			goto label99
		   end
	   end
   end


--  Perform the copy process
--  Note:  If the file being copied is already at the target, robocopy will skip it.
--         The reason we do it this way is - if the file is damaged, robocopy will overwrite it.
If @delete_source = 'y'
   begin
	select @command = 'robocopy /Z /R:3 /MOV ' + @source_server + '\' + @source_path + ' ' + @target_path + ' ' + rtrim(@savefilename)
   end
Else
   begin
	select @command = 'robocopy /Z /R:3 ' + @source_server + '\' + @source_path + ' ' + @target_path + ' ' + rtrim(@savefilename)
   end

Print @command
exec master.sys.xp_cmdshell @command


If rtrim(@savefilename) like '%.zip'
   begin
	select @command = 'wzunzip ' + @target_path + '\' + @backupname + '*.zip ' + @target_path + '\'
	Print @command
	exec master.sys.xp_cmdshell @command

	select @command = 'if exist ' + @target_path + '\' + @backupname + '*.zip del ' + @target_path + '\' + @backupname + '*.zip'
	Print @command
	exec master.sys.xp_cmdshell @command
   end



-------------------   end   --------------------------


label99:


drop table #DirectoryTempTable



If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_base_APPL_JobScripting
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_base_APPL_JobScripting]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_base_APPL_JobScripting]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_base_APPL_JobScripting

/*********************************************************
 **  Stored Procedure dbasp_base_APPL_JobScripting                
 **  Written by Jim Wilson, Getty Images                
 **  February 19, 2009                                      
 **  
 **  Process for baseline APPL job scripting.
 **  Note: This process will script out APPL jobs per
 **        application to the local Backup share.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	03/12/2010	Jim Wilson		New process
--	03/15/2010	Jim Wilson		Removed If stmt for initial insert into #saveAPPL
--	04/12/2010	Jim Wilson		Skip if no local DEPL DBs exist
--	05/03/2010	Jim Wilson		Added more no_check logic for APPLname.
--	05/20/2010	Jim Wilson		Modified Check APPL Jobs for valid description.
--	======================================================================================



-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@charpos			int
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_APPLname			sysname
	,@save_jobname			sysname
	,@save_joblog_share		sysname
	,@joblog_outpath		sysname
	,@savesubject			sysname
	,@appl_name			sysname
	,@sqlcmd			nvarchar(2000)
	,@outpath 			nvarchar(500)
	,@save_baseline_servername	sysname
	,@save_dbname			sysname
	,@save_job_example		sysname

DECLARE 
	 @sourcePath			nvarchar(256)
	,@targetEnv			nvarchar(16)
	,@targetServer			sysname
	,@targetShare			sysname
	,@file_name			sysname


----------------  initial values  -------------------

Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


Create table #saveAPPL (APPLname sysname)
CREATE TABLE #jobinfo (jobname sysname
			,jobdescription nvarchar(512))
			
CREATE TABLE #dbnames (dbname sysname)



Print '-- Script APPL jobs'
Print ' '
Print ' '

--  If not production, skip this process
If (select env_detail from dbo.Local_ServerEnviro where env_type = 'ENVname') <> 'production'
   begin
	Print 'Note:  This process is intended only for production instances.  Skipping this process.'
	Print ' '
	Print ' '
	goto label99
   end


--  If no local DEPL related databases exist, skip this process
If (select count(*) from dbaadmin.dbo.db_sequence s, master.sys.databases d where s.db_name = d.name) = 0
   begin
	Print 'Note:  No local DEPL_RD related databases on the SQL instance.  Skipping this process.'
	Print ' '
	Print ' '
	goto label99
   end


--  If no_check is set for Post_Jobscript, skip this process
If exists(select 1 from dbaadmin.dbo.no_check where nocheck_type = 'Post_Jobscript' and detail01 = 'DEPL_RD')
   begin
	Print 'Note:  This process is being skipped due to no_check.  Skipping this process.'
	Print ' '
	Print ' '
	goto label99
   end


-- Check to see if there are any APPL jobs on this server
If not exists(select 1 from msdb.dbo.sysjobs where name like 'APPL%')
   begin
	Print 'Note:  No APPL jobs to script out for this SQL instance.'
	Print ' '
	Print ' '
	goto label99
   end
   
   
-- Check to see if the DEPLinfo database exists
If not exists(select 1 from master.sys.databases where name = 'DEPLinfo')
   begin
	Print 'Note:  This process requires the DEPLinfo database which is not present on this server.   Skipping this process.'
	Print ' '
	Print ' '
	goto label99
   end



--  Check APPL Jobs for valid description (only for the enable process)

--  First, determine which applications are represented on this SQL instance by looking at the local DB's
delete from #dbnames
insert into #dbnames select b.db_name from master.sys.databases d, dbo.db_sequence b where b.db_name = d.name
delete from #dbnames where dbname is null

--  Now get the list of APPL jobs associated with the local DEPL_RD related DB's
If (select count(*) from #dbnames) > 0
   begin
	delete from #jobinfo

	start_jobinfo_load:
	Select @save_dbname = (select top 1 dbname from #dbnames order by dbname)

	insert into #jobinfo select distinct j.name, j.description
				from msdb.dbo.sysjobs j, msdb.dbo.sysjobsteps s
				where j.name like 'APPL%'
				and j.job_id = s.job_id
				and (s.database_name in (select b.db_name 
							from master.sys.databases d, dbo.db_sequence b 
							where b.db_name = d.name)
				or s.command like ('%' + @save_dbname + '%'))
	--select * from #jobinfo

	--  check for more rows to process
	Delete from #dbnames where dbname = @save_dbname
	If (select count(*) from #dbnames) > 0
	   begin	
		goto start_jobinfo_load
	   end

	select @appl_name = ''
	
	start_appl_job_check:
	If exists(select 1 from DEPLinfo.dbo.db_BaseLocation where RSTRfolder > @appl_name)
	   begin
		Select @appl_name = (select top 1 RSTRfolder from DEPLinfo.dbo.db_BaseLocation where RSTRfolder > @appl_name order by RSTRfolder)
		--Print @appl_name
		delete from #jobinfo where jobdescription like rtrim(@appl_name) + '%'
	
		If exists(select 1 from DEPLinfo.dbo.db_BaseLocation where RSTRfolder > @appl_name)
		   begin
			goto start_appl_job_check
		   end
	   end

	If (select count(*) from #jobinfo) > 0
	   begin
		Select @save_job_example = (select top 1 jobname from #jobinfo order by jobname)
		Select @miscprint = 'DBA WARNING: APPL job(s) found with invalid application name in the job description. (e.g. ' + @save_job_example + ')'
		Print @miscprint

		Select @savesubject = 'DBA WARNING: Baseline Job Scripting Error on server ' + @@servername 

		Exec dbaadmin.dbo.dbasp_sendmail
		@recipients = 'tssqldba@gettyimages.com',
		@subject = @savesubject,
		@message = @miscprint

		goto label99
	   end

   end
   



--  Get the job log output path
Select @save_joblog_share = @save_servername2 + '_SQLjob_logs'
exec dbo.dbasp_get_share_path @save_joblog_share, @joblog_outpath output

If @joblog_outpath is null or @joblog_outpath = ''
   begin
	Select @miscprint = 'DBA WARNING: Job Log output share path was not found.'
	Print @miscprint

	Select @savesubject = 'DBA WARNING: Baseline Job Scripting Error on server ' + @@servername 

	Exec dbaadmin.dbo.dbasp_sendmail
	@recipients = 'tssqldba@gettyimages.com',
	@subject = @savesubject,
	@message = @miscprint

	goto label99
   end



--  Determin the deployment related applications on this sql instance
delete from #saveAPPL
insert into #saveAPPL select distinct baselineFolder from dbo.dba_dbinfo where DEPLstatus = 'y' and baselineFolder <> '' and baselineFolder is not null



--  Delete from #saveAPPL based on the no_check table
select @appl_name = ''
start_nocheck_check:
If exists(select 1 from dbaadmin.dbo.no_check where nocheck_type = 'Post_Jobscript')
   begin
	Select @appl_name = (select top 1 detail01 from dbaadmin.dbo.no_check where nocheck_type = 'Post_Jobscript' and detail01 > @appl_name order by detail01)
	--Print @appl_name

	delete from #saveAPPL where APPLname like rtrim(@appl_name) + '%'	

	If exists(select 1 from dbaadmin.dbo.no_check where nocheck_type = 'Post_Jobscript' and detail01 > @appl_name)
	   begin
		goto start_nocheck_check
	   end
   end
   
   
Select @outpath = '\\' + @save_servername + '\' + @save_servername2 + '_backup'



/****************************************************************
 *                MainLine
 ***************************************************************/

--select * from #saveAPPL


If (select count(*) from #saveAPPL) > 0
   begin
	start01:
	Select @save_APPLname = (select top 1 APPLname from #saveAPPL order by APPLname)
	--print @save_APPLname

	--  Check to make sure Job steps point to master and job log output has been set
	If exists (select 1 from msdb.dbo.sysjobs j, msdb.dbo.sysjobsteps js 
			where j.name like 'APPL%' 
			and j.description like @save_APPLname + '%'
			and j.job_id = js.job_id 
			and js.subsystem = 'TSQL' 
			and js.database_name <> 'master'
			)
	   begin
		Select @save_jobname = (select top 1 j.name from msdb.dbo.sysjobs j, msdb.dbo.sysjobsteps js 
					where j.name like 'APPL%' 
					and j.description like @save_APPLname + '%'
					and j.job_id = js.job_id 
					and js.subsystem = 'TSQL' 
					and js.database_name <> 'master'
					order by j.name)
				
		Select @miscprint = 'DBA WARNING: Skipping baseline job script process for "' + @save_APPLname + '" jobs, due to job ' + @save_jobname + '.  TSQL job step does not point to master.'
		Print @miscprint

		Select @savesubject = 'DBA WARNING: Skipping baseline job script process for "' + @save_APPLname + '" jobs on server ' + @@servername 

		Exec dbaadmin.dbo.dbasp_sendmail
		@recipients = 'tssqldba@gettyimages.com',
		@subject = @savesubject,
		@message = @miscprint

		goto skip_jobscript

	   end


	--  Check to make sure Job Log Output is set for all steps
	If exists (select 1 from msdb.dbo.sysjobs j, msdb.dbo.sysjobsteps js 
			where j.name like 'APPL%' 
			and j.description like @save_APPLname + '%'
			and j.job_id = js.job_id 
			and (js.output_file_name is null or js.output_file_name not like @joblog_outpath + '%')
			)
	   begin
   		Select @save_jobname = (select top 1 j.name from msdb.dbo.sysjobs j, msdb.dbo.sysjobsteps js 
					where j.name like 'APPL%' 
					and j.description like @save_APPLname + '%'
					and j.job_id = js.job_id 
					and (js.output_file_name is null or js.output_file_name not like @joblog_outpath + '%')
					order by j.name)

		Select @miscprint = 'DBA WARNING: Skipping baseline job script process for "' + @save_APPLname + '" jobs, due to job ' + @save_jobname + '.  Job log output files are not set properly.'
		Print @miscprint

		Select @savesubject = 'DBA WARNING: Skipping baseline job script process for "' + @save_APPLname + '" jobs on server ' + @@servername 

		Exec dbaadmin.dbo.dbasp_sendmail
		@recipients = 'tssqldba@gettyimages.com',
		@subject = @savesubject,
		@message = @miscprint

		goto skip_jobscript

	   end


	--  Check to make sure Job Log Output is set for all steps
	If exists (select 1 from msdb.dbo.sysjobs j, msdb.dbo.sysjobsteps js 
			where j.name like 'APPL%' 
			and j.description like @save_APPLname + '%'
			and j.job_id = js.job_id 
			and js.command like '%@recipients%' 
			and (js.command not like '%@stage_recipients%' or js.command not like '%@test_recipients%')
			)
	   begin
      		Select @save_jobname = (select top 1 j.name from msdb.dbo.sysjobs j, msdb.dbo.sysjobsteps js 
					where j.name like 'APPL%' 
					and j.description like @save_APPLname + '%'
					and j.job_id = js.job_id 
					and js.command like '%@recipients%' 
					and (js.command not like '%@stage_recipients%' or js.command not like '%@test_recipients%')
					order by j.name)

		Select @miscprint = 'DBA WARNING: Skipping baseline job script process for "' + @save_APPLname + '" jobs, due to job ' + @save_jobname + '.  DBAsp_Sendmail stage or test recipients not in place.'
		Print @miscprint

		Select @savesubject = 'DBA WARNING: Skipping baseline job script process for "' + @save_APPLname + '" jobs on server ' + @@servername 

		Exec dbaadmin.dbo.dbasp_sendmail
		@recipients = 'tssqldba@gettyimages.com',
		@subject = @savesubject,
		@message = @miscprint

		goto skip_jobscript

	   end


	--  Script out the APPL jobs for this APPLname
	Print 'Scripting out SQL jobs for APPLname ' + @save_APPLname + ' to ' + @outpath + '.'
	SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w2000 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddjobs @jobname = ''APPL'', @appl_name = ''' + @save_APPLname + '''" -E -o' + @outpath + '\' + upper(@save_APPLname) + '_jobs.sql'
	PRINT   @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd


	skip_jobscript:

	--  Check for more APPLnames to process
	delete from #saveAPPL where APPLname = @save_APPLname

	If (select count(*) from #saveAPPL) > 0
	   begin
		goto start01
	   end
   end
Else
   begin
	Select @miscprint = 'DBA NOTE: No deployment related databases for this SQL instance.  Skipping this process.'
	Print @miscprint
   end





/**********************   End Proc  **************************/

label99:

drop table #saveAPPL
drop TABLE #jobinfo
drop TABLE #dbnames


 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Base_AutoRestore_fromSQB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Base_AutoRestore_fromSQB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Base_AutoRestore_fromSQB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Base_AutoRestore_fromSQB

/*********************************************************
 **  Stored Procedure dbasp_Base_AutoRestore_fromSQB                  
 **  Written by Jim Wilson, Getty Images                
 **  March 3, 2004                                      
 **  
 **  This procedure is used to create local *nxt files for
 **  sql deployment restores using local compressed backup files
 **  in the NXT share.
 **
 **  This proc accepts no input parms at this time.
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/03/2008	Jim Wilson		New auto restore process 
--	05/09/2008	Jim Wilson		Altered how we check the size of the restored DB. 
--	05/27/2008	Jim Wilson		Added check of the Base_Skip_sqb2nxt table. 
--	07/17/2008	Jim Wilson		Added skip process if Redgate is not installed. 
--	07/23/2008	Jim Wilson		Fixed raise error issue when skpping process. 
--	10/20/2008	Jim Wilson		Skip DB's with fulltext indexes. 
--	12/05/2008	Jim Wilson		New code to handle failed restores. 
--	12/16/2008	Jim Wilson		New code to drop old (orphaned) *_nxt DB. 
--	08/19/2009	Jim Wilson		Removed systeminfo references. 
--	05/14/2010	Jim Wilson		Added NXT DB cleanup processing. 
--	======================================================================================

/***

--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd			nvarchar(4000)
	,@Restore_cmd		nvarchar(4000)
	,@query			nvarchar(4000)
	,@error_count		int
	,@mdf_path 		nvarchar(255)
	,@nxt_path 		nvarchar(255)
	,@charpos		int
	,@savepos		int
	,@charpos2		int
	,@save_sqb_dirdata	nvarchar(255)
	,@save_sqbfile_date	nchar(8)
	,@save_sqbfile_time	nchar(4)
	,@save_sqbfile_datetime	nchar(12)
	,@save_sqbfile_size	sysname
	,@save_sqbfile_size_num	bigint
	,@save_sqbfile_name	sysname
	,@save_sqbfile_db	sysname
	,@save_nxt_dirdata	nvarchar(255)
	,@save_nxtfile_date	nchar(8)
	,@save_nxtfile_time	nchar(4)
	,@save_nxtfile_datetime	nchar(12)
	,@save_nxtfile_name	sysname
	,@savePhysicalNamePart	nvarchar(260)
	,@save_file_path	nvarchar(260)
	,@save_file_name	nvarchar(260)
	,@save_backup_path 	nvarchar(260)
	,@sv_freespace		nvarchar(255)
	,@parm01		nvarchar(100)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_dbname		sysname
	,@save_skipname		sysname
	,@hold_filename		sysname
	,@hold_fullpath		sysname
	,@hold_DBname		sysname
	,@hold_dbid		int

DECLARE     
	 @iSPID			int
	,@DBID			int
	,@retry_count		smallint

DECLARE
	 @cu15fileid		smallint
	,@cu15groupid		smallint
	,@cu15name		nvarchar(128)
	,@cu15filename		nvarchar(260)

DECLARE
	 @cu22LogicalName	sysname
	,@cu22PhysicalName	nvarchar(260)
	,@cu22Type		char(1)
	,@cu22FileGroupName	sysname


----------------  initial values  -------------------
Select @error_count = 0
Select @retry_count = 0

Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Create temp tables
create table #sqb_TempTable(cmdoutput nvarchar(255) null)

create table #Dbnames(dbname sysname null)

create table #nxt_TempTable(cmdoutput nvarchar(255) null)

create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

create table #filelist_rg(
		 LogicalName nvarchar(128) null
		,PhysicalName nvarchar(260) null 
		,Type char(1)
		,FileGroupName nvarchar(128) null 
		,Size numeric(20,0) 
		,MaxSize numeric(20,0)
		,FileId bigint
		,CreateLSN numeric(25,0)
		,DropLSN numeric(25,0)
		,UniqueId uniqueidentifier
		,ReadOnlyLSN numeric(25,0)
		,ReadWriteLSN numeric(25,0)
		,BackupSizeInBytes bigint
		,SourceBlockSize int
		,FileGroupId int
		,LogGroupGUID sysname null
		,DifferentialBaseLSN numeric(25,0)
		,DifferentialBaseGUID uniqueidentifier
		,IsReadOnly bit
		,IsPresent bit
		)



--  Skip this process if Redgate is not installed
If not exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
   begin
	Select @miscprint = 'DBA WARNING: Restore SQB process skipped because Redgate is not installed.' 
	raiserror(@miscprint,-1,-1) with log
	goto label99
   end

--  Verfiy nxt share and get nxt path
Select @parm01 = @save_servername2 + '_nxt'
exec dbo.dbasp_get_share_path @parm01, @nxt_path output

if @nxt_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: NXT share is not properly in place.  Check utility RMTSHARE.EXE and/or Run sproc dbaadmin.dbo.dbasp_create_NXTshare.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

--  Verfiy mdf share and get mdf path
Select @parm01 = @save_servername2 + '_mdf'
exec dbo.dbasp_get_share_path @parm01, @mdf_path output

if @mdf_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: MDF share is not properly in place.  Check utility RMTSHARE.EXE and/or Run sproc dbaadmin.dbo.dbasp_dba_sqlsetup.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


/****************************************************************
 *                MainLine
 ***************************************************************/



--  Before we start, make sure we have no *_nxt databases
If exists (select 1 from master.sys.databases where name like '%nxt')
   begin
	Delete from #Dbnames
	Insert into #Dbnames select name from master.sys.databases where name like '%nxt'
	Delete from #Dbnames where dbname is null
	--select * from #Dbnames
	
	Start_DBnxt01:
	Select @save_dbname = (select top 1 dbname from #Dbnames order by dbname)
	
	exec dbaadmin.dbo.dbasp_SetStatusForRestore @dbname = @save_dbname, @dropDB = 'y'
   
	Delete from #Dbnames where dbname = @save_dbname
   	If (select count(*) from #Dbnames) > 0
	   begin
		goto Start_DBnxt01
	   end
   end






--  Get a list of the non-SQB files in the nxt share

select @cmd = 'dir ' + @nxt_path

delete from #nxt_TempTable
insert into #nxt_TempTable exec master.sys.xp_cmdshell @cmd
delete from #nxt_TempTable where cmdoutput is null
delete from #nxt_TempTable where cmdoutput like '%<DIR>%'
delete from #nxt_TempTable where cmdoutput like '%Directory of%'
delete from #nxt_TempTable where cmdoutput like '% File(s) %'
delete from #nxt_TempTable where cmdoutput like '% Dir(s) %'
delete from #nxt_TempTable where cmdoutput like '%Volume in drive%'
delete from #nxt_TempTable where cmdoutput like '%Volume Serial Number%'
delete from #nxt_TempTable where cmdoutput like '%.sqb%'
--select * from #nxt_TempTable


--  Get a list of the SQB files in the nxt share

select @cmd = 'dir ' + @nxt_path

delete from #sqb_TempTable
insert into #sqb_TempTable exec master.sys.xp_cmdshell @cmd
delete from #sqb_TempTable where cmdoutput is null
delete from #sqb_TempTable where cmdoutput like '%<DIR>%'
delete from #sqb_TempTable where cmdoutput like '%Directory of%'
delete from #sqb_TempTable where cmdoutput like '% File(s) %'
delete from #sqb_TempTable where cmdoutput like '% Dir(s) %'
delete from #sqb_TempTable where cmdoutput like '%Volume in drive%'
delete from #sqb_TempTable where cmdoutput like '%Volume Serial Number%'
delete from #sqb_TempTable where cmdoutput not like '%.sqb%'
--select * from #sqb_TempTable



--  Process the SQB files one at a time


--
If (select count(*) from #sqb_TempTable) > 0
   begin

	start_sqb:

	Select @save_sqb_dirdata = (select top 1 cmdoutput from #sqb_TempTable order by cmdoutput)
	Print 'Processing file;'
	Print @save_sqb_dirdata
	Print ''

	--  Check the table Base_Skip_sqb2nxt.  If this file is in the table, skip it.
	If (select count(*) from dbo.Base_Skip_sqb2nxt) > 0
	   begin
		Select @save_skipname = ''
		start_skipcheck:
		Select @save_skipname = (select top 1 SQBname from dbo.Base_Skip_sqb2nxt where SQBname > @save_skipname order by SQBname)
		If @save_sqb_dirdata like '%' + @save_skipname + '%'
		   begin
			Print 'DBA Note: Local baseline process skipping SQB file due to entry in the table [Base_Skip_sqb2nxt]'
			Print @save_sqb_dirdata
			Print ''
			goto skip_sqb
		   end

		If exists (select 1 from dbo.Base_Skip_sqb2nxt where SQBname > @save_skipname)
		   begin
			goto start_skipcheck
		   end
	   end


	--  Check for 01/01/1980 (file copy still in process)
	If @save_sqb_dirdata like '%01/01/1980%'
	   begin
		Print 'DBA Warning: Local baseline process skipping SQB file due to 01/01/1980 issue'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end


	--  Test for proper format
	If (substring(@save_sqb_dirdata,3,1)) <> '/' 
	   or (substring(@save_sqb_dirdata,6,1)) <> '/'
	   or (substring(@save_sqb_dirdata,15,1)) <> ':'
	   begin
		Print 'DBA Warning: DIR format does not match expected format.  Skipping SQB file.'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end


	--  Capture sqb file date, time, file size, name and db_name
	Select @save_sqbfile_date = (substring(@save_sqb_dirdata,7,4)) + (substring(@save_sqb_dirdata,1,2)) + (substring(@save_sqb_dirdata,4,2))	

	Select @save_sqbfile_time = (substring(@save_sqb_dirdata,13,2)) + (substring(@save_sqb_dirdata,16,2))
	If (substring(@save_sqb_dirdata,19,2)) = 'PM'
	   begin
		Select @save_sqbfile_time = @save_sqbfile_time + '1200'
	   end

	Select @save_sqbfile_datetime = @save_sqbfile_date + @save_sqbfile_time	

	Select @save_sqbfile_size = ltrim(rtrim(substring(@save_sqb_dirdata,22,17)))
	Select @save_sqbfile_size = replace(@save_sqbfile_size, ',', '')

	Select @save_sqbfile_name = rtrim(substring(@save_sqb_dirdata,40,200))


	select @charpos = charindex('_prod.sqb', @save_sqbfile_name)
	IF @charpos <> 0
	   begin
		select @save_sqbfile_db = substring(@save_sqbfile_name, 1, @charpos-1)
	   end
	Else
	   begin
		Print 'DBA Warning: SQB file name format does not match expected format.  Skipping SQB file.'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end




	--  Determine the file names for this DB (restore header only)
	--  Check to see if new NXT files already exist
	--  Restore database to NXT share using *_nxt dbname
	Select @save_backup_path = @nxt_path + '\' + ltrim(@save_sqbfile_name)

	select @Restore_cmd = ''
	select @Restore_cmd = @Restore_cmd + '-SQL "RESTORE DATABASE [' + @save_sqbfile_db + '_nxt]'
	select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @save_backup_path + ''''
	select @Restore_cmd = @Restore_cmd + ' WITH RECOVERY'

	Print ''
	Print '-- Get file header info from the SQB backup file'
	Select @query = 'Exec master.dbo.sqlbackup ''-SQL "RESTORE FILELISTONLY FROM DISK = ''''' + rtrim(@save_backup_path) + '''''"'''
	Print @query
	delete from #filelist_rg
	insert into #filelist_rg exec (@query)
	--select * from #filelist_rg

	If (select count(*) from #filelist_rg) = 0
	   begin
		Select @miscprint = 'DBA WARNING: Unable to perform filelist only on this backup file:  ' + rtrim(@save_backup_path)
		raiserror(@miscprint,-1,-1) with log
		Print 'DBA Warning: Unable to perform filelist only on SQB file.  Skipping SQB file.'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end

	If (select count(*) from #filelist_rg where type = 'f') > 0
	   begin
		Select @miscprint = 'DBA NOTE: DB has FullText index.  Unable to create NXT file:  ' + rtrim(@save_backup_path)
		raiserror(@miscprint,-1,-1) with log
		Print 'DBA NOTE: DB has FullText index.  Unable to create NXT file.  Skipping SQB file.'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end

	--Select * from #filelist_rg



	--  Look to see how much freespace we have in the nxt share
	select @cmd = 'dir ' + @nxt_path
	delete from #DirectoryTempTable
	insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
	delete from #DirectoryTempTable where cmdoutput is null
	delete from #DirectoryTempTable where cmdoutput not like '% Dir(s) %'
	--select * from #DirectoryTempTable

	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		select @sv_freespace = (select top 1 cmdoutput from #DirectoryTempTable where cmdoutput like '%bytes free%')
		Select @charpos = charindex('Dir(s)', @sv_freespace)
		Select @charpos2 = charindex('bytes free', @sv_freespace)
		select @sv_freespace = ltrim(substring(@sv_freespace, @charpos+6, (@charpos2-@charpos)-7))
		Select @sv_freespace = rtrim(replace(@sv_freespace, ',', ''))
	   end
	Else
	   begin
		Print 'DBA Warning: Cannot determine freespace in the NXT share.  Skipping SQB file.'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end


	--  Get the size of the DB from the backup file header and add 10 percent
	Select @save_sqbfile_size_num = sum(size) from #filelist_rg
	Select @save_sqbfile_size_num = @save_sqbfile_size_num / .9


	--  If we don't have disk space for an NXT file for this DB, skip it
	If @save_sqbfile_size_num > convert(bigint, @sv_freespace)
	   begin
		Print 'DBA Warning: Unable to create NXT file for database ' + @save_sqbfile_db + ' due to lack of free space in the NXT share. Skipping SQB file.'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end


	header_parse01:
	Select @cu22LogicalName = (select top 1 LogicalName from #filelist_rg)
	Select @cu22PhysicalName = (select PhysicalName from #filelist_rg where LogicalName = @cu22LogicalName)
	Select @cu22Type = (select Type from #filelist_rg where LogicalName = @cu22LogicalName)
	Select @cu22FileGroupName = (select FileGroupName from #filelist_rg where LogicalName = @cu22LogicalName)

	Select @savePhysicalNamePart = rtrim(@cu22PhysicalName)
	label41:	
	select @charpos = charindex('\', @savePhysicalNamePart)
	IF @charpos <> 0
	   begin
		select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
	   end	
	
	select @charpos = charindex('\', @savePhysicalNamePart)
	IF @charpos <> 0
	   begin
		goto label41
 	   end

	If @cu22Type in ('D', 'F')
	   begin
		Select @save_file_path = @nxt_path + '\' + @savePhysicalNamePart
	   end
	Else IF @cu22Type = 'L'
	   begin
		Select @save_file_path = @nxt_path + '\' + @savePhysicalNamePart
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: Invalid file type in backup filelist results:  ' + @cu22Type 
		raiserror(@miscprint,-1,-1) with log
		Print 'DBA Warning: Invalid file type in backup filelist results:  ' + @cu22Type + '.  Skipping SQB file.'
		Print @save_sqb_dirdata
		Print ''
		goto skip_sqb
	   end


	--  If the *nxt version of this database exists, drop it
	If exists (select 1 from master.sys.databases where name = @save_sqbfile_db + '_nxt')
	   begin
		Print ''
		Print '-- Drop the current *_nxt version of this database'

		Select @cmd = 'use master alter database [' + rtrim(@save_sqbfile_db) + '_nxt] set OFFLINE with ROLLBACK IMMEDIATE'
		Print @cmd
		exec (@cmd)

		Select @cmd = 'use master drop database [' + rtrim(@save_sqbfile_db) + '_nxt];'
		Print @cmd
		exec (@cmd)
	   end


	--  Check to see if this file (or its *nxt twin) is already in the nxt share
	If exists(select 1 from #nxt_TempTable where cmdoutput like '%' + @savePhysicalNamePart + '%')
	   begin
		Print ''
		Print '--  Check for related files already in the NXT share'
		start_nxtcheck:
		Select @save_nxt_dirdata = (select top 1 cmdoutput from #nxt_TempTable where cmdoutput like '%' + @savePhysicalNamePart + '%')
		Select @save_nxtfile_name = rtrim(substring(@save_nxt_dirdata,40,200))

		If @save_nxt_dirdata like '%nxt%'
		   begin
			Select @save_nxtfile_date = (substring(@save_nxt_dirdata,7,4)) + (substring(@save_nxt_dirdata,1,2)) + (substring(@save_nxt_dirdata,4,2))	

			Select @save_nxtfile_time = (substring(@save_nxt_dirdata,13,2)) + (substring(@save_nxt_dirdata,16,2))
			If (substring(@save_nxt_dirdata,19,2)) = 'PM'
			   begin
				Select @save_nxtfile_time = @save_nxtfile_time + '1200'
			   end

			Select @save_nxtfile_datetime = @save_nxtfile_date + @save_nxtfile_time	
    

			--  if we have a *nxt file that is newer than the sqb file, skip this sqb
			If @save_nxtfile_name = @savePhysicalNamePart + 'nxt' and @save_nxtfile_datetime >= @save_sqbfile_datetime
			   begin
				Print 'DBA Note: New *nxt file found for this database (' + @save_sqbfile_db + ').  Skipping SQB file.'
				Print @save_nxt_dirdata
				Print ''
				goto skip_sqb
			   end
		   end
		Else
		   begin
			If @save_nxtfile_name = @savePhysicalNamePart + 'nxt' or @save_nxtfile_name = @savePhysicalNamePart
			   begin
				--  If this file is connected to a DB in SQL, drop that DB
				Select @hold_fullpath = @nxt_path + '\' + @save_nxtfile_name
				If exists (select 1 from master.sys.master_files where physical_name = @hold_fullpath)
				   begin
					Select @hold_dbid = (select database_id from master.sys.master_files where physical_name = @hold_fullpath)
					Select @hold_DBname = (select name from master.sys.databases where database_id = @hold_dbid)

					Select @cmd = 'use master alter database [' + rtrim(@hold_DBname) + '] set OFFLINE with ROLLBACK IMMEDIATE'
					Print @cmd
					exec (@cmd)

					Select @cmd = 'use master drop database [' + rtrim(@hold_DBname) + '];'
					Print @cmd
					exec (@cmd)

					Waitfor delay '00:00:03'

					-- If this DB still exists, don't go any further with this one
					If exists (select 1 from master.sys.databases where database_id = @hold_dbid)
					   begin
						Print 'DBA Warning: A new *nxt file could not be created for this database (' + @save_sqbfile_db + ') because the target *.MDF file is in use.  Skipping SQB file.'
						Print @save_nxt_dirdata
						Print ''
						goto skip_sqb
					   end
				   end

				Select @cmd = 'del ' + @nxt_path + '\' + @save_nxtfile_name
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end
		   end


		--  check for more rows to process
		delete from #nxt_TempTable where cmdoutput = @save_nxt_dirdata
		If exists(select 1 from #nxt_TempTable where cmdoutput like '%' + @savePhysicalNamePart + '%')
		   begin
			goto start_nxtcheck
		   end
	   end


	select @Restore_cmd = @Restore_cmd + ', MOVE ''' + rtrim(@cu22LogicalName) + ''' to ''' + rtrim(@save_file_path) + ''''


	Delete from #filelist_rg where LogicalName = @cu22LogicalName

	--  check to see if there are more rows to process
	If (select count(*) from #filelist_rg) > 0
	   begin
		goto header_parse01
	   end

	select @Restore_cmd = @Restore_cmd + ' ,REPLACE"'


	--  If the *nxt version of this DB exists, take it offline
	If (DATABASEPROPERTYEX(@save_sqbfile_db + '_nxt', N'Status') = N'ONLINE')
	   begin
		Print ''
		Print '-- An older *_nxt version of this database still exists.  Take it offline.'
		Select @cmd = 'use master alter database ' + rtrim(@save_sqbfile_db) + '_nxt set OFFLINE with ROLLBACK IMMEDIATE'
		Print @cmd
		exec (@cmd)
	  end

	--  Process the restore 
	Print ''
	Print '-- Restore the SQB file to the *_nxt database name.'
	Print @Restore_cmd
	Exec master.dbo.sqlbackup @Restore_cmd

	--  Verify Restore (if restore failed, drop the DB and remove the files from the nxt share)
	If (DATABASEPROPERTYEX(@save_sqbfile_db + '_nxt', N'Status') <> N'ONLINE')
	   begin
		select @miscprint = 'DBA Error:  Restore Failure (Redgate complete restore) for command ' + @Restore_cmd
		print  @miscprint

		--  Drop this *_nxt DB and delete the sqb file from the nxt share
		Select @cmd = 'use master drop database ' + rtrim(@save_sqbfile_db) + '_nxt;'
		Print @cmd
		exec (@cmd)

		Select @cmd = 'del ' + rtrim(@save_backup_path)
		Print @cmd
		exec master.sys.xp_cmdshell @cmd

		--  Delete the DB files if they still exist
		del_nxt_dbfiles_afterfail:
		Select @charpos = charindex(' to ', @Restore_cmd)
		IF @charpos <> 0
		   begin 
			Select @Restore_cmd = substring(@Restore_cmd, @charpos+5, 500)
			Select @hold_filename = @Restore_cmd
			Select @charpos = charindex('''', @hold_filename)
			IF @charpos <> 0
			   begin 
				Select @hold_filename = left(@hold_filename, @charpos-1)
				print @hold_filename

				Select @cmd = 'del ' + rtrim(@hold_filename)
				Print @cmd
				exec master.sys.xp_cmdshell @cmd
			   end

			If @Restore_cmd like '% to %'
			   begin
				goto del_nxt_dbfiles_afterfail
			   end

		   end

		goto skip_sqb
	   end


	
	--  Capture sysfile info for this *nxt database
	Print ''
	Print '-- Capture sysfiles info for this new *_nxt database.'
	select @cmd = 'If (object_id(''dbaadmin.dbo.' + rtrim(@save_sqbfile_db) + '_nxt_temp_sysfiles'') is not null)
	   begin
		drop table dbaadmin.dbo.' + rtrim(@save_sqbfile_db) + '_nxt_temp_sysfiles
	   end'
	exec  (@cmd)
	Select @cmd = 'Create table dbaadmin.dbo.' + rtrim(@save_sqbfile_db) + '_nxt_temp_sysfiles (
			fileid smallint,
			groupid smallint,
			size int,
			maxsize int,
			growth int,
			status int,
			perf int,
			name nchar(128),
			filename nchar(260))'
	exec  (@cmd)

	Select @cmd = 'Delete from dbaadmin.dbo.' + rtrim(@save_sqbfile_db) + '_nxt_temp_sysfiles'
	exec  (@cmd)
	Select @cmd = 'Insert into dbaadmin.dbo.' + rtrim(@save_sqbfile_db) + '_nxt_temp_sysfiles  select * from [' + @save_sqbfile_db + '_nxt].sys.sysfiles'
	exec  (@cmd)
	--Select @cmd = 'select * from dbaadmin.dbo.' + rtrim(@save_sqbfile_db) + '_nxt_temp_sysfiles'
	--exec  (@cmd)


	--  Make sure all connections to this database are removed
	--  Alter the database to offline mode
	retry_kill:
	Print ''
	Print '-- Remove all connections to the new *_nxt database.'

	Select @cmd = 'alter database [' + rtrim(@save_sqbfile_db) + '_nxt] set OFFLINE with ROLLBACK IMMEDIATE '
	print @cmd
	Exec(@cmd)
	print ' '

	--  Pause for a couple seconds
	waitfor delay '00:00:01'

	--  Alter the database to online mode
	Select @cmd = 'alter database [' + rtrim(@save_sqbfile_db) + '_nxt] set ONLINE with ROLLBACK IMMEDIATE '
	print @cmd
	Exec(@cmd)
	print ' '

	--  Pause for a couple seconds
	waitfor delay '00:00:01'

	Select @cmd = 'alter database [' + rtrim(@save_sqbfile_db) + '_nxt] set MULTI_USER with ROLLBACK IMMEDIATE'
	Print @cmd
	exec (@cmd)

	--  Set the dbid value
	Select @DBID = dbid FROM master.sys.sysdatabases where name = @save_sqbfile_db + '_nxt'

	Select @iSPID = 50
	WHILE @iSPID IS NOT NULL
	   begin
		Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID and spid > @iSPID
		IF @iSPID IS NOT NULL
		   begin
			Select @cmd = 'KILL ' + convert(varchar(12), @iSPID )
			Print @cmd
			exec(@cmd)
		   end
	   end

	Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID
	If @iSPID is not null
	   begin
		Select @miscprint = 'Unable to kill spid related to database ' + @save_sqbfile_db + '_nxt.  spid = ' + convert(varchar(10),@iSPID) 
		Print  @miscprint
		waitfor delay '00:05:00'
		Select @retry_count = @retry_count + 1
		If @retry_count < 5
		   begin
			goto retry_kill
		   end
	   end

	--  Create datach gsql file
	Print ''
	Print '-- Detach the new *_nxt database.'
	Select @cmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''master.sys.sp_detach_db ''''' + rtrim(@save_sqbfile_db) + '_nxt'''', @skipchecks = ''''true''''''" -E -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@save_sqbfile_db) + '_nxt_detach.gsql'
	Print  @cmd
	exec master.sys.xp_cmdshell @cmd

	waitfor delay '00:00:03'


	--  Detach *_nxt database, delete ldf and rename mdf and ldf files
	Select @cmd = 'sqlcmd -S' + @@servername + ' -u -E -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@save_sqbfile_db) + '_nxt_detach.gsql'
	Print  @cmd
	exec master.sys.xp_cmdshell @cmd

	waitfor delay '00:00:03'


	--  Rename the mdf and ndf files and delete the ldf files
	--------------------  Cursor for 15DB  -----------------------
	Select @cmd = 'DECLARE cu15_file Insensitive Cursor For ' + 
	  'SELECT f.fileid, f.groupid, f.name, f.filename
	   From dbaadmin.dbo.' + rtrim(@save_sqbfile_db) + '_nxt_temp_sysfiles  f ' + 
	  'Order By f.fileid For Read Only'
	EXECUTE(@cmd)

	OPEN cu15_file

	WHILE (15=15)
	   Begin
		FETCH Next From cu15_file Into @cu15fileid, @cu15groupid, @cu15name, @cu15filename 
		IF (@@fetch_status < 0)
		   begin
		      CLOSE cu15_file
		      BREAK
		   end
        	
		--  parse and save the file name
		Select @save_file_name = rtrim(@cu15filename)
		Select @charpos = charindex('\', @save_file_name)
		label15a:
		IF @charpos <> 0
		   begin
			Select @save_file_name = substring(@save_file_name, @charpos + 1, 200)
		   end	
		Select @charpos = charindex('\', @save_file_name)
		IF @charpos <> 0
		   begin
			goto label15a
		   end	

		--  parse and save the file path
		Select @save_file_path = ''
		Select @savepos = 1
		label15c:
		Select @charpos = charindex('\', @cu15filename, @savepos)
		IF @charpos <> 0
		   begin
			Select @savepos = @charpos+1
			goto label15c
		   end	

		Select @save_file_path = @save_file_path + substring(@cu15filename, 1, @savepos-2)


		--  Rename the mdf and ndf files
		If @cu15groupid <> 0
		   begin
			Print ''
			Print '-- Rename mdf or ndf file (with nxt sufix).'

			--  Update the file permissions
			Select @cmd = 'XCACLS "' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + '" /G "Administrators":F /Y'
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd, no_output
         
			Select @cmd = 'XCACLS "' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + '" /E /G "NT AUTHORITY\SYSTEM":R /Y'
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd, no_output

			--  Rename the DB file, adding 'nxt' to the extention
			Select @cmd = 'REN ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + ' ' + rtrim(@save_file_name) + 'nxt'
			Print @cmd	
			EXEC master.sys.xp_cmdshell @cmd--, no_output 
		   end
		Else
		   begin
			Print ''
			Print '-- Delete ldf file.'

			--  Delete the ldf files
			Select @cmd = 'Del ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name)
			Print @cmd	
			EXEC master.sys.xp_cmdshell @cmd--, no_output
		   end

	   End  -- loop 15
	   DEALLOCATE cu15_file



	skip_sqb:

	--  Delete this row and check to see if there are more rows to process
	delete from #sqb_TempTable where cmdoutput = @save_sqb_dirdata
	If (select count(*) from #sqb_TempTable) > 0
	   begin
		goto start_sqb
	   end

   end



--  One last check for *_nxt databases
If exists (select 1 from master.sys.databases where name like '%nxt')
   begin
	Delete from #Dbnames
	Insert into #Dbnames select name from master.sys.databases where name like '%nxt'
	Delete from #Dbnames where dbname is null
	--select * from #Dbnames
	
	Start_DBnxt02:
	Select @save_dbname = (select top 1 dbname from #Dbnames order by dbname)
	
	exec dbaadmin.dbo.dbasp_SetStatusForRestore @dbname = @save_dbname, @dropDB = 'y'
   
	Delete from #Dbnames where dbname = @save_dbname
   	If (select count(*) from #Dbnames) > 0
	   begin
		goto Start_DBnxt02
	   end
   end



--  Finalization  -------------------------------------------------------------------
label99:

drop table #nxt_TempTable
drop table #sqb_TempTable
drop table #DirectoryTempTable
drop table #filelist_rg
drop table #Dbnames


If  @error_count > 0
   begin
	raiserror(67016, 16, -1, @miscprint)

	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Base_Backup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Base_Backup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Base_Backup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Base_Backup (@dbname sysname = null
					, @target_path nvarchar(200) = null
					, @backup_filename sysname = null
					, @Post_DropDB char(1) = 'y'
					, @delete_source_backup char(1) = 'n'
					, @source_backup_path nvarchar(200) = null
					, @RG_flag char(1) = 'y'
					, @RG_only_flag char(1) = 'y')


/*********************************************************
 **  Stored Procedure dbasp_Base_Backup                  
 **  Written by Jim Wilson, Getty Images                
 **  November 20, 2002                                      
 **  
 **  This procedure is used to backup a database for the
 **  baseline process.  
 **
 **  This proc accepts several input parms (outlined below):
 **
 **  - @dbname is the name of the database being processed.
 **
 **  - @target_path is the full path (unc) where the backup
 **    file will be created.
 **
 **  - @backup_filename is the name of the backup file that
 **    will be created.
 **
 **  - @Post_DropDB is a flag for dropping the DB once the
 **    backup is completed.
 **
 **  - @delete_source_backup is a flag for deleting the source
 **    production backup file from the local restore folder.
 **
 **  - @source_backup_path is the full path (unc) to the restore
 **    folder where the source production backup file was copied.
 **
 **  - @RG_flag is a flag for RedGate backup processing (y or n).
 **
 **  - @RG_only_flag is a flag for RedGate only backup processing (y or n).
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/20/2002	Jim Wilson		New backup detach and move process 
--	11/25/2002	Jim Wilson		Added code to kill spids 
--	12/02/2002	Jim Wilson		Added waitfor commands after the delete stmtscode to kill spids 
--	03/31/2003	Jim Wilson		Added input parm and code to backup directly to the target path
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	11/26/2003	Jim Wilson		Reset ownership chaining option after reattach.
--	07/22/2005	Jim Wilson		Added insert to the @dbname build table.
--	06/22/2006	Jim Wilson		Updated for SQL 2005.
--	06/22/2006	Jim Wilson		New process to delete source production backup file.
--	06/08/2007	Jim Wilson		Moved delete of old nxt file before rename of new mdf or ldf.
--	07/25/2007	Jim Wilson		Added RedGate processing.
--	07/31/2007	Jim Wilson		Added pre-delete for *.SQB files.
--	10/22/2007	Jim Wilson		Added RedGate-only flag.
--	11/12/2007	Jim Wilson		Added verify for RedGate backup file existence.
--	12/07/2007	Jim Wilson		Fix delete of ldf file after initial detach.
--	01/18/2008	Jim Wilson		Added /mov to robocopy.
--	01/25/2008	Jim Wilson		Added alternate MOVE if source and target are on the same drive.
--	01/28/2008	Jim Wilson		Added 2nd LDF delete just before the attach.
--	01/29/2008	Jim Wilson		Added code for restarting (lots of code for this).
--	02/21/2008	Jim Wilson		Changed single use mode to offline\online.
--	10/01/2008	Jim Wilson		Added /Z /R:3 for robocopy
--	11/03/2008	Jim Wilson		Re-written to remove detach and move processing (renamed as well)
--	08/26/2009	Jim Wilson		Added SQB converter process to make sure all SQB files are 5.4.
--	01/06/2010	Jim Wilson		Re-added the code to delete the source backup file.
--	======================================================================================


/***
Declare 
	 @dbname sysname
	,@target_path nvarchar(200)
	,@backup_filename sysname
	,@Post_DropDB nchar(1)
	,@delete_source_backup nchar(1)
	,@source_backup_path nvarchar(200)
	,@RG_flag nchar(1)
	,@RG_only_flag nchar(1)
	

Select @dbname = 'ArtistListing'
Select @target_path = '\\SQLDEPLOYER02\SQLDEPLOYER02_BASE_CF'
Select @backup_filename = 'ArtistListing_prod'
Select @Post_DropDB = 'y'
Select @delete_source_backup = 'n'
Select @source_backup_path = ''
Select @RG_flag = 'y'
Select @RG_only_flag = 'n'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd			nvarchar(4000)
	,@sqlcmd		nvarchar(4000)
	,@dos_command		nvarchar(4000)
	,@parm01		nvarchar(100)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@hold_sharename	sysname
	,@error_count		int
	,@ldf_count		smallint
	,@charpos		int
	,@savepos		int
	,@save_file_path	nvarchar(260)
	,@save_file_name	nvarchar(260)
	,@fileseed		smallint
	,@skip_detach		char(1)
	,@kill_count		char(1)
	,@iSPID			int
	,@DBID			int
	,@Error			int
	,@vchCommand		nvarchar(255)

DECLARE
	 @cu12fileid		smallint
	,@cu12groupid		smallint
	,@cu12name		nvarchar(128)
	,@cu12filename		nvarchar(260)

DECLARE
	 @cu13fileid		smallint
	,@cu13groupid		smallint
	,@cu13name		nvarchar(128)
	,@cu13filename		nvarchar(260)


DECLARE
	 @cu14fileid		smallint
	,@cu14groupid		smallint
	,@cu14name		nvarchar(128)
	,@cu14filename		nvarchar(260)




----------------  initial values  -------------------
Select @error_count = 0
Select @skip_detach = 'n'


Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Create temp tables
Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

Create table #temp_ldf_fullpath (filename nchar(260))



--  Set redgate flags if redgate in not installed
If not exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
   begin
	Select @RG_flag = 'n'
	Select @RG_only_flag = 'n'
   end

--  Set target path to drive letter path (if it's a local share)
If @target_path like '\\' + @save_servername + '%'
   begin
	Select @hold_sharename = substring(@target_path, len(@save_servername)+4, len(@target_path)-(len(@save_servername)+3))
	If @hold_sharename not like '%\%'
	   begin
		exec dbaadmin.dbo.dbasp_get_share_path @hold_sharename, @target_path output
	   end
   end

--  Verify input parm(s)
if @dbname is null or @target_path is null or @backup_filename is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm(s)' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

If @delete_source_backup = 'y' and @source_backup_path = ''
   begin
	Select @miscprint = 'DBA WARNING: Invalid input parms for @delete_source_backup and @source_backup_path.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END




--  Print Header
Print ''
Print '**************************************************************'
Print 'Start the Baseline Backup process for database ' + rtrim(@dbname)
Print '**************************************************************'
raiserror('', -1,-1) with nowait


--  Verify database
If not exists (select 1 from master.sys.databases where name = @dbname)
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @dbname.  No such database exists.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END
Else If (SELECT DATABASEPROPERTYEX (@dbname,'status')) <> 'ONLINE' 
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @dbname.  Database exists but is not online.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

if (select name from master.sys.sysdatabases where name = @dbname) in ('master', 'model', 'msdb', 'tempdb')
   BEGIN
	Select @miscprint = 'DBA WARNING: This process is not allowed for a system database' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


--  Verify RG flags
if @RG_flag = 'n' and @RG_only_flag = 'y'
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @RG_flag.  Must be ''y'' if input parm @RG_only_flag = ''y''.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


--  create perm temp table in dbaadmin for this DB
select @cmd = 'If (object_id(''dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'') is not null)
   begin
	drop table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles
   end'
exec (@cmd)
Select @cmd = 'Create table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles (
		fileid smallint,
		groupid smallint,
		size int,
		maxsize int,
		growth int,
		status int,
		perf int,
		name nchar(128),
		filename nchar(260))'
exec (@cmd)



--  Inset a row into the @dbname build table
Select @cmd = 'If exists (select 1 from ' + @dbname + '.sys.objects where name = ''build'' and type = ''u'')
   begin
	delete from ' + @dbname + '.dbo.Build where vchName = ''' + @dbname + ''' and vchLabel = ''Baseline Backup'' and dtBuildDate > getdate()-1

	INSERT INTO ' + @dbname + '.dbo.Build (vchName, vchLabel, dtBuildDate, vchNotes) VALUES (''' + @dbname + ''', ''Baseline Backup'', GETDATE(), ''' + @dbname + ' Baseline Backup'')
   end'
Print @cmd
exec (@cmd) 




/****************************************************************
 *                MainLine
 ***************************************************************/


--  Prepare attach and detach commands
Select @cmd = 'Delete from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
exec (@cmd)
Select @cmd = 'Insert into dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  select * from [' + @dbname + '].sys.sysfiles'
exec (@cmd)
--Select @cmd = 'select * from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
--exec (@cmd)



--  Format the detach command
Print ''
Print '**************************************************************'
Print 'Create the detach gsql file for database ' + rtrim(@dbname)
Print '**************************************************************'
raiserror('', -1,-1) with nowait

SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''master.sys.sp_detach_db ''''' + rtrim(@dbname) + ''''', @skipchecks = ''''true''''''" -E -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_detach.gsql'
PRINT  @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd



--  Format the attach command
Print ''
Print '**************************************************************'
Print 'Create the attach gsql file for database ' + rtrim(@dbname)
Print '**************************************************************'
raiserror('', -1,-1) with nowait

SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''CREATE DATABASE [' + rtrim(@dbname) + '] ON''" -E >\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
PRINT  @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd


Select @fileseed = 1
Select @ldf_count = 0

--------------------  Cursor for 12DB  -----------------------
select @cmd = 'DECLARE cu12_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.name, f.filename
   From dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  f ' + 
  'Order By f.fileid For Read Only'

EXECUTE(@cmd)

OPEN cu12_file

WHILE (12=12)
   Begin
	FETCH Next From cu12_file Into @cu12fileid, @cu12groupid, @cu12name, @cu12filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_file
	      BREAK
           end
	

	If @cu12groupid <> 0
	   begin
		If @fileseed = 1
		   begin
			SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''  (FILENAME = ''''' + rtrim(@cu12filename) + ''''')''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
			PRINT @sqlcmd
			EXEC master.sys.xp_cmdshell @sqlcmd

			--  parse and save the file path
			Select @save_file_path = ''
			Select @savepos = 1
			label12a:
			Select @charpos = charindex('\', @cu12filename, @savepos)
			IF @charpos <> 0
			   begin
				Select @savepos = @charpos+1
				goto label12a
			   end	

			Select @save_file_path = @save_file_path + substring(@cu12filename, 1, @savepos-2)
		   end
		Else
		   begin
			SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''  ,(FILENAME = ''''' + rtrim(@cu12filename) + ''''')''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
			PRINT @sqlcmd
			EXEC master.sys.xp_cmdshell @sqlcmd
		   end
	   end
	Else
	   begin
		Select @ldf_count = @ldf_count + 1
	   end

	--  If more than one LDF file was found, skip the detach process
	If @ldf_count > 1
	   begin
		Select @skip_detach = 'y'
		goto skip_detach
	   end

	Select @fileseed = @fileseed + 1


   End  -- loop 12
   DEALLOCATE cu12_file


If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 1 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 1
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY ON, DB_CHAINING ON;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 0 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 0
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY OFF, DB_CHAINING OFF;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 1 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 0
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY OFF, DB_CHAINING ON;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @dbname) = 0 
  and (select is_trustworthy_on from master.sys.databases where name = @dbname) = 1
   begin
	SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print '' FOR ATTACH_REBUILD_LOG WITH TRUSTWORTHY ON, DB_CHAINING OFF;''" -E >>\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
	PRINT @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd
   end



--  Make sure all connections to this database are removed
--  Alter the database to offline mode
Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set OFFLINE with ROLLBACK IMMEDIATE '
print @vchCommand
Exec(@vchCommand)
print ' '

--  Pause for a couple seconds
waitfor delay '00:00:01'

--  Alter the database to online mode
Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set ONLINE with ROLLBACK IMMEDIATE '
print @vchCommand
Exec(@vchCommand)
print ' '

--  Pause for a couple seconds
waitfor delay '00:00:01'

Select @vchCommand = 'ALTER DATABASE [' + rtrim(@dbname) + '] SET MULTI_USER WITH ROLLBACK IMMEDIATE'
Print @vchCommand
exec (@vchCommand)

--  Set the dbid value
Select @DBID = dbid FROM master.sys.sysdatabases where name = @dbname
Select @kill_count = 0

start_kill:
If @kill_count > 5
   begin
	Select @skip_detach = 'y'
	goto skip_detach
   end
	
Select @iSPID = 50
WHILE @iSPID IS NOT NULL
   begin
	Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID and spid > @iSPID
	IF @iSPID IS NOT NULL
	   begin
		Select @vchCommand = 'KILL ' + convert(varchar(12), @iSPID )
		Print @vchCommand
		exec(@vchCommand)
		Select @Error = @@ERROR
		IF @error <> 0 
		   begin
			Select @miscprint = 'Unable to kill spid related to database ' + rtrim(@dbname) + '.  spid = ' + convert(varchar(10),@iSPID) 
			RAISERROR(@miscprint, -1, -1 ) with nowait
			Select @kill_count = @kill_count + 1
			waitfor delay '00:01:00'
			goto start_kill
		   end
	   end
   end


Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID
If @iSPID is not null
   begin
	Select @miscprint = 'Unable to kill spid related to database ' + rtrim(@dbname) + '.  spid = ' + convert(varchar(10),@iSPID) 
	RAISERROR(@miscprint, -1, -1 ) with nowait
	Select @kill_count = @kill_count + 1
	waitfor delay '00:01:00'
	goto start_kill
   end



--  Detach the database
Print ''
Print '**************************************************************'
Print 'Detach the database ' + rtrim(@dbname)
Print '**************************************************************'
RAISERROR('', -1, -1 ) with nowait
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -u -E -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_detach.gsql'
PRINT   @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd




--  Delete the LDF DB file and update file permissions
--------------------  Cursor for 13  -----------------------
select @cmd = 'DECLARE cu13_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.name, f.filename
   From dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  f ' + 
  'Order By f.fileid For Read Only'
EXECUTE(@cmd)

OPEN cu13_file

WHILE (13=13)
   Begin
	FETCH Next From cu13_file Into @cu13fileid, @cu13groupid, @cu13name, @cu13filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu13_file
	      BREAK
           end
	
	--  Update the file permissions
	Print ''
	Print '**************************************************************'
	Print 'Update file permissions for: ' + rtrim(@cu13filename)
	Print '**************************************************************'

	Select @dos_command = 'XCACLS "' + rtrim(@cu13filename) + '" /G "Administrators":F /Y'
	Print @dos_command
	EXEC master.sys.xp_cmdshell @dos_command, no_output
 
	Select @dos_command = 'XCACLS "' + rtrim(@cu13filename) + '" /E /G "NT AUTHORITY\SYSTEM":R /Y'
	Print @dos_command
	EXEC master.sys.xp_cmdshell @dos_command, no_output
	RAISERROR('', -1, -1 ) with nowait


	--  Delete the LDF DB file
	If @cu13groupid = 0
	   begin
		Print ''
		Print '**************************************************************'
		Print 'Delete LDF file: ' + rtrim(@cu13filename)
		Print '**************************************************************'

		Select @save_file_name = rtrim(@cu13filename)
		Select @cmd = 'Del ' + rtrim(@save_file_name)
		Print @cmd		
		EXEC master.sys.xp_cmdshell @cmd--, no_output 
	   end

	RAISERROR('', -1, -1 ) with nowait

   End  -- loop 13
   DEALLOCATE cu13_file




--  Delete ldf DB file that might be at the new location
Select @save_file_name = ''
Select @save_file_name = @save_file_path + '\' + rtrim(@dbname) + '*.ldf'
Select @cmd = 'Del ' + rtrim(@save_file_name)
Print @cmd
RAISERROR('', -1, -1 ) with nowait		
EXEC master.sys.xp_cmdshell @cmd--, no_output 



--  Attach the DB and force create a new LDF file
Print ''
Print '**************************************************************'
Print 'Attach the database creating a new LDF file'
Print '**************************************************************'
RAISERROR('', -1, -1 ) with nowait
SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -u -E -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\' + rtrim(@dbname) + '_attach.gsql'
PRINT @sqlcmd
EXEC master.sys.xp_cmdshell @sqlcmd


Waitfor delay '00:00:02'

If not exists (select 1 from master.sys.databases where name = @dbname)
   BEGIN
	Select @miscprint = 'DBA WARNING: Attach failed for database ' + @dbname + '.  No such database exists.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END
Else If (SELECT DATABASEPROPERTYEX (@dbname,'status')) <> 'ONLINE' 
   BEGIN
	Select @miscprint = 'DBA WARNING: Attach failed for database ' + @dbname + '  Database exists but is not online.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

Print ''
Print '**************************************************************'
Print 'The database ' + rtrim(@dbname) + ' has now been shrunk (ldf recreated)'
Print '**************************************************************'
RAISERROR('', -1, -1 ) with nowait



skip_detach:
--  Shrink the ldf file if the detach process was skipped
If @skip_detach = 'y'
   begin
	exec dbaadmin.dbo.dbasp_ShrinkLDFFiles @DBname = @dbname

	Print ''
	Print '**************************************************************'
	Print 'The database ' + rtrim(@dbname) + ' has now been shrunk via dbasp_ShrinkLDFFiles.'
	Print '**************************************************************'
	RAISERROR('', -1, -1 ) with nowait
   end
	



--  Backup the DB 
Print ''
Print '**************************************************************'
Print 'Starting the BACKUP section'
Print '**************************************************************'
RAISERROR('', -1, -1 ) with nowait

--  Backup the DB
If @RG_only_flag = 'n'
   begin
	--  Delete any old standard backup files
	Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.BAK'
	Select @cmd = 'DEL ' + @parm01
	Print @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec master.sys.xp_cmdshell @cmd

	--  Verify the old backup file does not exist at the target
	Delete from #fileexists
	Insert into #fileexists exec master.sys.xp_fileexist @parm01
	If (select doesexist from #fileexists) = 1
	   begin
		Print 'Error:  The old BAK backup file could not be deleted prior to creation of the new BAK backup. ' + @parm01
		Select @error_count = @error_count + 1
		Goto label99
	   end

	Select @cmd = 'Backup database [' + @DBname + '] to disk = ''' + rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.BAK'' with init'
	Print @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec(@cmd)

	Print ' '
	Print 'The database ' + rtrim(@dbname) + ' has now been backed up (standard type) directly to the target location'
	Print ' '
	RAISERROR('', -1, -1 ) with nowait

   end

If @RG_flag = 'y'
   begin
	--  Delete any old redgate backup files
	Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.SQB'
	Select @cmd = 'DEL ' + @parm01
	Print @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec master.sys.xp_cmdshell @cmd

	--  Verify the old backup file does not exist at the target
	Delete from #fileexists
	Insert into #fileexists exec master.sys.xp_fileexist @parm01
	If (select doesexist from #fileexists) = 1
	   begin
		Print 'Error:  The old SQB backup file could not be deleted prior to creation of the new SQB backup. ' + @parm01
		Select @error_count = @error_count + 1
		Goto label99
	   end

	Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '_temp.SQB'
	Select @cmd = 'DEL ' + @parm01
	Print @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec master.sys.xp_cmdshell @cmd

	--  Verify the old backup temp file does not exist at the target
	Delete from #fileexists
	Insert into #fileexists exec master.sys.xp_fileexist @parm01
	If (select doesexist from #fileexists) = 1
	   begin
		Print 'Error:  The old SQB backup temp file could not be deleted prior to creation of the new SQB backup. ' + @parm01
		Select @error_count = @error_count + 1
		Goto label99
	   end


	--  Backup the DB via RedGate to a temp backup file
	Select @cmd = 'exec master.dbo.sqlbackup ''-SQL "BACKUP DATABASE [' + rtrim(@dbname) + ']' 
			+ ' TO DISK = ''''' + rtrim(@target_path) + '\' + rtrim(@backup_filename) + '_temp.SQB'
			+ ''''' WITH THREADCOUNT = 3, COMPRESSION = 1, MAXTRANSFERSIZE = 1048576, VERIFY"''' 
	Print @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec(@cmd)


	Waitfor delay '00:00:04'


	Select @cmd = 'SQBconverter ' + rtrim(@target_path) + '\' + rtrim(@backup_filename) + '_temp.SQB ' + rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.SQB /sqb'
	Print @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec master.sys.xp_cmdshell @cmd


	Waitfor delay '00:00:04'


	Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '_temp.SQB'
	Select @cmd = 'DEL ' + @parm01
	Print @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec master.sys.xp_cmdshell @cmd

	--  Verify the old backup temp file does not exist at the target
	Delete from #fileexists
	Insert into #fileexists exec master.sys.xp_fileexist @parm01
	If (select doesexist from #fileexists) = 1
	   begin
		Print 'Error:  The old SQB backup temp file could not be deleted after the creation of the 5.4 SQB backup. ' + @parm01
		Select @error_count = @error_count + 1
		Goto label99
	   end
	


	--  Verify the new backup file now exists.
	Select @parm01 = rtrim(@target_path) + '\' + rtrim(@backup_filename) + '.SQB'
	Delete from #fileexists
	Insert into #fileexists exec master.sys.xp_fileexist @parm01
	If (select doesexist from #fileexists) <> 1
	   begin
		Print 'Error:  The new SQB backup file was not created as expected. ' + @parm01
		Select @error_count = @error_count + 1
		Goto label99
	   end

	Print ' '
	Print 'The database ' + rtrim(@dbname) + ' has now been backed up via RedGate to the target location'
	Print ' '
	RAISERROR('', -1, -1 ) with nowait
   end





--  Drop the DB if requested (and make sure the DB files no longer exist)
If @Post_DropDB = 'y'
   begin
	Print ' '
	Print ' '
	Print '-- Section to Drop the Database'

	--  Capture sysfile info for this database
	Print ''
	Print '-- Capture sysfiles info for this database.'

	Select @cmd = 'Delete from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
	--Print  @cmd
	exec  (@cmd)
	Select @cmd = 'Insert into dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  select * from [' + @dbname + '].sys.sysfiles'
	--Print  @cmd
	exec  (@cmd)

	--Select @cmd = 'select * from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
	--Print  @cmd
	--exec  (@cmd)

	RAISERROR('', -1, -1 ) with nowait


	--  Make sure all connections to this database are removed
	--  Alter the database to offline mode
	Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set OFFLINE with ROLLBACK IMMEDIATE '
	print @vchCommand
	Exec(@vchCommand)
	print ' '

	--  Pause for a couple seconds
	waitfor delay '00:00:01'

	--  Alter the database to online mode
	Select @vchCommand = 'alter database [' + rtrim(@dbname) + '] set ONLINE with ROLLBACK IMMEDIATE '
	print @vchCommand
	Exec(@vchCommand)
	print ' '

	--  Pause for a couple seconds
	waitfor delay '00:00:01'

	Select @vchCommand = 'ALTER DATABASE [' + rtrim(@dbname) + '] SET SINGLE_USER WITH ROLLBACK IMMEDIATE'
	Print @vchCommand
	exec (@vchCommand)

	RAISERROR('', -1, -1 ) with nowait


	--  Set the dbid value
	Select @DBID = dbid FROM master.sys.sysdatabases where name = @dbname
	Select @kill_count = 0

	start_kill2:
	If @kill_count > 5
	   begin
		goto skip_kill2
	   end
        	
	Select @iSPID = 50
	WHILE @iSPID IS NOT NULL
	   begin
		Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID and spid > @iSPID
		IF @iSPID IS NOT NULL
		   begin
			Select @vchCommand = 'KILL ' + convert(varchar(12), @iSPID )
			Print @vchCommand
			exec(@vchCommand)
			Select @Error = @@ERROR
			IF @error <> 0 
			   begin
				Select @miscprint = 'Unable to kill spid related to database ' + rtrim(@dbname) + '.  spid = ' + convert(varchar(10),@iSPID) 
				RAISERROR(@miscprint, -1, -1 ) with nowait
				Select @kill_count = @kill_count + 1
				waitfor delay '00:01:00'
				goto start_kill2
			   end
		   end
	   end


	Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID
	If @iSPID is not null
	   begin
		Select @miscprint = 'Unable to kill spid related to database ' + rtrim(@dbname) + '.  spid = ' + convert(varchar(10),@iSPID) 
		RAISERROR(@miscprint, -1, -1 ) with nowait
		Select @kill_count = @kill_count + 1
		waitfor delay '00:01:00'
		goto start_kill2
	   end


	skip_kill2:


	Select @cmd = 'drop database [' + @dbname + ']'
	Print  @cmd
	RAISERROR('', -1, -1 ) with nowait
	Exec(@cmd)

	waitfor delay '00:00:02'


	--  Verify the DB no longer exists
	If exists (select 1 from master.sys.databases where name = @dbname)
	   BEGIN
		Select @miscprint = 'DBA ERROR: Unable to drop database ' + @dbname + '. The Database must be dropped and the process restarted in the next step.' 
		Print  @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   END


	--  Now make sure the DB files were deleted
	--------------------  Cursor for 14DB  -----------------------
	select @cmd = 'DECLARE cu14_file Insensitive Cursor For ' + 
	  'SELECT f.fileid, f.groupid, f.name, f.filename
	   From dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  f ' + 
	  'Order By f.fileid For Read Only'

	EXECUTE(@cmd)

	OPEN cu14_file

	WHILE (14=14)
	   Begin
		FETCH Next From cu14_file Into @cu14fileid, @cu14groupid, @cu14name, @cu14filename 
		IF (@@fetch_status < 0)
		   begin
		      CLOSE cu14_file
		      BREAK
		   end
        	
		Select @cmd = rtrim(@cu14filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @cmd
		If (select doesexist from #fileexists) = 1
		   begin
			Select @cmd = 'Del ' + rtrim(@cmd)
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd--, no_output 
		   end

		waitfor delay '00:00:02'

		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @cmd
		If (select doesexist from #fileexists) = 1
		   begin
			Select @miscprint = 'DBA ERROR: Unable to delete database files for ' + @dbname + ' (file - ' + rtrim(@cu14filename) + ').  The files for this DB must be deleted and the process restarted in the next step.' 
			Print  @miscprint
			Select @error_count = @error_count + 1
			goto label99
		   end

		RAISERROR('', -1, -1 ) with nowait


	   End  -- loop 14
	   DEALLOCATE cu14_file

   end


--  Delete the source production backup file if requested
If @delete_source_backup = 'y' and @source_backup_path <> '' and @source_backup_path is not null
   begin
	Select @cmd = 'Del ' + rtrim(@source_backup_path) + '\' + rtrim(@dbname) + '_db_*.*'
	Print @cmd	
	EXEC master.sys.xp_cmdshell @cmd--, no_output

	Print ' '
	Print 'The source production backup file has been deleted'
	Print ' '
   end



--  Finalization  -------------------------------------------------------------------

label99:

select @cmd = 'If (object_id(''dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'') is not null)
   begin
	drop table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles
   end'
exec (@cmd)


If (object_id('tempdb.dbo.#temp_ldf_fullpath') is not null)
   begin
	drop table #temp_ldf_fullpath
   end
If (object_id('tempdb.dbo.#fileexists') is not null)
   begin
	drop table #fileexists
   end


If @error_count > 0
   begin
	raiserror('DBA Error',16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Base_cleanup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Base_cleanup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Base_cleanup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Base_cleanup

/*********************************************************
 **  Stored Procedure dbasp_Base_cleanup                 
 **  Written by Jim Wilson, Getty Images                
 **  May 13, 2010                                      
 **  
 **  This procedure is used to clear out the local NXT share
 **  in preperation for new baseline files.
 **
 **  This proc accepts no input parms at this time.
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	05/13/2008	Jim Wilson		New process 
--	======================================================================================

/***

--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd			nvarchar(4000)
	,@error_count		int
	,@nxt_path 		nvarchar(255)
	,@charpos		int
	,@parm01		nvarchar(100)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_dbname		sysname
	,@base_date_char	nvarchar(30)
	,@base_local_char	sysname
	,@base_local		datetime
	,@base_date_shift	smallint
	,@message		sysname
	,@message2		sysname

----------------  initial values  -------------------
Select @error_count = 0
Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Create temp tables
create table #Dbnames(dbname sysname null)

create table #DirectoryTempTable(cmdoutput nvarchar(255) null)



--  Verfiy nxt share and get nxt path
Select @parm01 = @save_servername2 + '_nxt'
exec dbo.dbasp_get_share_path @parm01, @nxt_path output

if @nxt_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: NXT share is not properly in place.  Check utility RMTSHARE.EXE and/or Run sproc dbaadmin.dbo.dbasp_create_NXTshare.' 
	Print @miscprint
	raiserror('',-1,-1) with nowait
	Select @error_count = @error_count + 1
	goto label99
   END


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Determine if the is the first run this week since Saturday at 6AM.  If not, go to end.
if exists(select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_base_local')
   begin
	select @base_local_char = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_base_local')
	select @base_local = convert(datetime, @base_local_char)

	--  Check for first run after 6:00AM Saturday (10080 minutes in one week)
	if (select datediff(mi, @base_local, getdate())) < 10080
	   begin
		select @miscprint = '*.NXT and *.SQB files will not be deleted by this process'
		Print @miscprint
		raiserror('',-1,-1) with nowait
		goto label99
	   end
	Else
	   begin
		delete from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_base_local'
	   end
   end


--  Format the date for the previous Saturday at 6:00AM
select @base_date_shift = (select datepart(weekday, getdate()))
select @base_date_char = convert(nvarchar(10), getdate()-@base_date_shift, 120)
select @base_date_char = @base_date_char + ' 06:00:00.000'

select @miscprint = 'Retrieving the Server Name and Share name for the del command'
Print @miscprint
raiserror('',-1,-1) with nowait



--  If there are *_NXT databases, drop them
If exists (select 1 from master.sys.databases where name like '%nxt')
   begin
	Delete from #Dbnames
	Insert into #Dbnames select name from master.sys.databases where name like '%nxt'
	Delete from #Dbnames where dbname is null
	--select * from #Dbnames
	
	Start_DBnxt01:
	Select @save_dbname = (select top 1 dbname from #Dbnames order by dbname)
	
	exec dbaadmin.dbo.dbasp_SetStatusForRestore @dbname = @save_dbname, @dropDB = 'y'
   
	Delete from #Dbnames where dbname = @save_dbname
   	If (select count(*) from #Dbnames) > 0
	   begin
		goto Start_DBnxt01
	   end
   end



--  Delete all files from the local NXT share
select @cmd = 'del \\'+@save_servername+'\'+@save_servername2+'_nxt\*.* /Q '

select @miscprint = 'Deleting all files in the local NXT share using ' + @cmd
Print @miscprint
raiserror('',-1,-1) with nowait

exec master.sys.xp_cmdshell @cmd

select @miscprint = 'Setting the check_base_local row in the table dbaadmin.dbo.Local_ServerEnviro'
Print @miscprint
raiserror('',-1,-1) with nowait



--  Check to make sure the local NXT share is empty
select @cmd = 'dir \\'+@save_servername+'\'+@save_servername2+'_nxt\*.* /b'
delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
Delete from #DirectoryTempTable where cmdoutput is null

If (select count(*) from #DirectoryTempTable) > 0
   begin
   	Print 'Email being sent.'
   	
   	Select @message = 'DBA Base Local Cleanup Error for ' + @save_servername2+ '_nxt'
	Select @message2 = 'Base Local Cleanup Error:  The nxt folder could not be emptied - ' + @save_servername2+ '_nxt'

	EXEC dbaadmin.dbo.dbasp_sendmail 
	@recipients = 'tssqldba@gettyimages.com', 
	@subject = @message,
	@message = @message2

   	Print 'Gmail being sent.'
	EXEC dbaadmin.dbo.dbasp_sendmail 
	--@recipients = @save_more_info,  
	@recipients = 'jwilson.getty@gmail.com', 
	@subject = @message,
	@message = @message2
   end

-- Reset the check base local record for this process
insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('check_base_local', @base_date_char)




--  Finalization  -------------------------------------------------------------------
label99:

drop table #Dbnames
drop table #DirectoryTempTable


If  @error_count > 0
   begin
	raiserror(67016, 16, -1, @miscprint)

	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Base_pullSQB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Base_pullSQB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Base_pullSQB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Base_pullSQB

/*********************************************************
 **  Stored Procedure dbasp_Base_pullSQB                  
 **  Written by Jim Wilson, Getty Images                
 **  March 6, 2004                                      
 **  
 **  This procedure is used to pull baseline SQB backup files
 **  from the central baseline server.
 **
 **  This proc accepts no input parms at this time.
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/06/2008	Jim Wilson		New process 
--	05/12/2008	Jim Wilson		Change central server for stage domain. 
--	07/17/2008	Jim Wilson		Added skip process if Redgate is not installed. 
--	07/23/2008	Jim Wilson		Fixed raise error issue when skipping process. 
--	09/23/2008	Jim Wilson		Added code for stage and production domains. 
--	10/06/2008	Jim Wilson		Fixed rococopy retry parm. 
--	05/13/2009	Jim Wilson		Converted systeminfo references to dbaadmin local tables. 
--	07/20/2009	Jim Wilson		Will now copy BAK files. 
--	10/13/2009	Jim Wilson		Removed the /z parm for robocopy. 
--	04/20/2010	Jim Wilson		Added no_check process for spcific DB's. 
--	05/13/2010	Jim Wilson		Added post file copy check for in-limbo files.
--						Converted for SQL2008 
--	======================================================================================

/***

--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd			nvarchar(4000)
	,@error_count		int
	,@nxt_path 		nvarchar(255)
	,@charpos		int
	,@parm01		nvarchar(100)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_database_id	int
	,@seq_id		int
	,@save_dbname		sysname
	,@save_companionDB_name	sysname
	,@save_RSTRfolder	sysname
	,@save_baseline_srvname	sysname
	,@save_ext		nvarchar(10)
	,@message		sysname
	,@message2		sysname


----------------  initial values  -------------------
Select @error_count = 0
Select @save_servername		= @@servername
Select @save_servername2	= @@servername
Select @save_ext = 'bak'

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Create temp tables
create table #baselocation(
		 dbname sysname null
		,RSRTfolder sysname null 
		,baselineserver sysname null
		)
		
create table #DirectoryTempTable(cmdoutput nvarchar(255) null)




--  Verfiy nxt share and get nxt path
Select @parm01 = @save_servername2 + '_nxt'
exec dbo.dbasp_get_share_path @parm01, @nxt_path output

if @nxt_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: NXT share is not properly in place.  Check utility RMTSHARE.EXE and/or Run sproc dbaadmin.dbo.dbasp_create_NXTshare.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Review the local databases and get a list of restore folders to process
Select @save_database_id = 4

start_dblist:

Select @save_database_id = (Select top 1 database_id from master.sys.databases where database_id > @save_database_id order by database_id)
Select @save_dbname = (Select name from master.sys.databases where database_id = @save_database_id)

If @save_database_id is not null and @save_database_id > 4
   begin
	Select @seq_id = 0

	get_baselocation:

	If exists (select 1 from dbo.no_check where NoCheck_type = 'base_pullbak' and Detail01 = @save_dbname)
	   begin
		Select @miscprint = 'DBA Note: Skipping DB ' + @save_dbname + ' due to dbo.no_check table entry' 
		Print @miscprint
		goto skipdb
	   end

	Select @seq_id = (select top 1 seq_id from dbo.db_ApplCrossRef where seq_id > @seq_id and db_name = @save_dbname order by seq_id)
	If @seq_id is not null and @seq_id > 0
	   begin
		Select @save_companionDB_name = (select companionDB_name from dbo.db_ApplCrossRef where seq_id = @seq_id)
		If @save_companionDB_name is null or @save_companionDB_name = ''
		   begin
			Select @save_RSTRfolder = (select RSTRfolder from dbo.db_ApplCrossRef where seq_id = @seq_id)
			Select @save_baseline_srvname = (select baseline_srvname from dbo.db_ApplCrossRef where seq_id = @seq_id)
		   end
		Else If exists(select 1 from master.sys.databases where name = rtrim(@save_companionDB_name))
		   begin
			Select @save_RSTRfolder = (select RSTRfolder from dbo.db_ApplCrossRef where seq_id = @seq_id)
			Select @save_baseline_srvname = (select baseline_srvname from dbo.db_ApplCrossRef where seq_id = @seq_id)
		   end
		Else
		   begin
			goto get_baselocation
		   end

		If (select top 1 env_detail from dbo.Local_ServerEnviro where env_type = 'domain') in ('production', 'stage')
		   begin
			Select @save_baseline_srvname = (select top 1 env_detail from dbo.Local_ServerEnviro where env_type = 'CentralServer')
		   end

		If @save_dbname is not null and @save_RSTRfolder is not null and @save_baseline_srvname is not null
		   begin
			insert into #baselocation values(@save_dbname, @save_RSTRfolder, @save_baseline_srvname)
		   end

	   end

	skipdb:

	If exists(select 1 from master.sys.databases where database_id > @save_database_id)
	   begin
		goto start_dblist
	   end
   end


--  Robocopy all backup files files from the central baseline server to the NXT share
If (select count(*) from #baselocation) > 0
   begin
	start_copy:

	Select @save_RSTRfolder = (Select top 1 RSRTfolder from #baselocation)
	Select @save_dbname = (Select top 1 dbname from #baselocation where RSRTfolder = @save_RSTRfolder)
	Select @save_baseline_srvname = (select top 1 baselineserver from #baselocation where RSRTfolder = @save_RSTRfolder)
	
	If (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain') = 'STAGE'
	   begin
		Select @save_baseline_srvname = (select env_detail from dbo.Local_ServerEnviro where env_type = 'CentralServer')
	   end


	Print ''
	Print '-- Robocopy ' + @save_dbname + '_prod.' + @save_ext + ' to the local NXT share from the central baseline server.'
	Select @cmd = 'robocopy /R:100 \\' + rtrim(@save_baseline_srvname) + '\' + rtrim(@save_baseline_srvname) + '_BASE_' + rtrim(@save_RSTRfolder) + ' ' + rtrim(@nxt_path) + ' ' + @save_dbname + '_prod.' + @save_ext
	Print @cmd
	raiserror('', -1,-1) with nowait
	EXEC master.sys.xp_cmdshell @cmd 

	delete from #baselocation where RSRTfolder = @save_RSTRfolder and dbname = @save_dbname
	If (select count(*) from #baselocation) > 0
	   begin
		goto start_copy
	   end
   end
   
   
--  Make sure we don't have any files in limbo in the NXT share
select @cmd = 'dir '+@nxt_path+'\*.* /A-D'
delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
Delete from #DirectoryTempTable where cmdoutput is null

If (select count(*) from #DirectoryTempTable where cmdoutput like '%01/01/1980%') > 0
   begin
   	Print 'Email being sent.'
   	
   	Select @message = 'DBA Base Local Filecopy for ' + @save_servername2+ '_nxt'
	Select @message2 = 'Base Local Filecopy Error:  File in limbo (01/01/1980) found in folder - ' + @save_servername2+ '_nxt'

	EXEC dbaadmin.dbo.dbasp_sendmail 
	@recipients = 'tssqldba@gettyimages.com', 
	@subject = @message,
	@message = @message2

   	Print 'Gmail being sent.'
	EXEC dbaadmin.dbo.dbasp_sendmail 
	@recipients = 'jwilson.getty@gmail.com', 
	@subject = @message,
	@message = @message2
   end
	


--  Finalization  -------------------------------------------------------------------
label99:

drop table #baselocation
drop table #DirectoryTempTable





If  @error_count > 0
   begin
	raiserror(67016, 16, -1, @miscprint)

	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Base_RemoteStartLocalProcess
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Base_RemoteStartLocalProcess]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Base_RemoteStartLocalProcess]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Base_RemoteStartLocalProcess (@environment sysname = null, @baseline_server sysname =null)

/*********************************************************
 **  Stored Procedure dbasp_Base_RemoteStartLocalProcess                
 **  Written by Anne Varnes, Getty Images                
 **  June 24, 2008                                      
 **  
 **  This procedure is used to start the 'BASE - Local Process'  
 **  baseline job out on dev, test, load, stage, alpha 
 **  beta, candidate or prodsupport servers depending on priority.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	06/24/2008	Anne Varnes		New process to start the BASE - Local Process
--						job based on priority.
--	08/22/2008	Jim Wilson		New table dba_dbinfo.  No longer user start_priority.
--	10/13/2008	Jim Wilson		Added "baselinefolder <> ''" to insert.
--      11/17/2008      David Spriggs	        Added "baseline_server" parameter to start remote
--                                              Base-LocalProcess jobs in Stage.
--	09/14/2009	Jim Wilson		Added riaserror with nowait so we can see what has been done.
--	10/07/2009	Jim Wilson		Added code for new environments (alpha, beta, etc.).
--	======================================================================================


/***
Declare @environment sysname
Declare @baseline_server sysname

Select @environment = 'stage'
Select @baseline_server = 'sqldeployer04'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@charpos		int
	,@cmd			nvarchar(4000)
	,@error_count		int
	,@save_servername	sysname

DECLARE
	 @cu11base_servername	sysname


----------------  initial values  -------------------
Select @error_count = 0

--  Verify imput parm
if @environment not in ('dev', 'test', 'load', 'stage', 'alpha', 'beta', 'candidate', 'prodsupport')
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameter for @environment' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

if @baseline_server IS NULL
   BEGIN
	SELECT @baseline_server = @@servername
   END

--  Create table variable
declare @servernames table (depl_servername sysname)
						
Select @save_servername = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
   end


/****************************************************************
 *                MainLine
 ***************************************************************/


Insert into @servernames
SELECT distinct i.SQLName
from dbo.DBA_DBInfo AS i
JOIN dbo.db_ApplCrossRef AS d ON i.BaseLineFolder = d.RSTRfolder
where i.ENVname = @environment
and i.baselinefolder <> ''
and i.BaselineServername = @@servername
and d.Baseline_srvname = @baseline_server

--select * from @servernames

print 'Starting baseline server selection'
print ''
raiserror('', -1,-1) with nowait

If (select count(*) from @servernames) > 0
   begin
	Start_Baseline_JobStart_Selection:

	Select @cu11base_servername = (select top 1 depl_servername from @servernames order by depl_servername)
	
	
	--  Start baseline job on remote server
		SELECT @cmd = 'sqlcmd -S' + @cu11base_servername + ' -E -Q"exec msdb.dbo.sp_start_job @job_name = ''BASE - Local Process''"'
		PRINT @cmd
		raiserror('', -1,-1) with nowait 
		EXEC master.sys.xp_cmdshell @cmd



	--  Remove this record from @servernames and go to the next
	Delete from @servernames where depl_servername = @cu11base_servername 
	If (select count(*) from @servernames) > 0
	   begin
		goto Start_Baseline_JobStart_Selection
	   end

   end


--  Finalization  -------------------------------------------------------------------


label99:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Base_ShrinkLDF
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Base_ShrinkLDF]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Base_ShrinkLDF]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE dbo.dbasp_Base_ShrinkLDF (@DBname sysname = null)
 
/*********************************************************
 **  Stored Procedure dbasp_Base_ShrinkLDF                  
 **  Written by Jim Wilson, Getty Images                
 **  March 22, 2010                                      
 **
 **  This proc accepts one optional input parm; DBname.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/22/2010	Jim Wilson		New process
--	======================================================================================


/***
Declare @DBname sysname

Select @DBname = 'wcdswork'
--***/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(255)
	,@cmd				sysname

DECLARE
	 @cu22fileid			smallint
	,@cu22name			nvarchar(128)
	,@cu22filename			nvarchar(260)

----------------  initial values  -------------------


/****************************************************************
 *                MainLine
 ***************************************************************/

If @DBname is null or @DBname = ''
   begin
	Print 'DBA Warning:  DBname must be provided for this process.'
	goto label99
   end


If @DBname not in (select name from master.sys.databases)
   begin
	Print 'DBA Warning:  A valid DBname must be provided for this process.'
	goto label99
   end


If DATABASEPROPERTYEX (@DBname,'status') <> 'ONLINE'
   begin
	Print 'DBA Warning:  The DBname provided is offline.'
	Print ' '
	goto label99
   end

If DATABASEPROPERTY(rtrim(@DBname), 'IsReadOnly') = 1
   begin
	Print 'DBA Warning:  The DBname provided is in read only mode.'
	Print ' '
	goto label99
   end





--  Cursor for the log file names
EXECUTE('DECLARE cu22_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.name, f.filename
   From [' + @DBname + '].sys.sysfiles  f ' + 
  'Where f.groupid = 0
   Order By f.fileid For Read Only')

OPEN cu22_file

WHILE (22=22)
   Begin
	FETCH Next From cu22_file Into @cu22fileid, @cu22name, @cu22filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_file
	      BREAK
           end

	Select @cmd = 'sqlcmd -S' + @@servername + ' -d' + @DBname + ' -Q"DBCC SHRINKFILE ([' + rtrim(@cu22name) + '])" -E'
	Print @cmd

	EXEC master.sys.xp_cmdshell @cmd

	Print ' '


   End  -- loop 22
   DEALLOCATE cu22_file



---------------------------  Finalization  -----------------------
label99:


 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Baseline_SQLjobs_mover
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Baseline_SQLjobs_mover]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Baseline_SQLjobs_mover]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Baseline_SQLjobs_mover ( @source_server sysname = '\\10.240.8.6',
				@source_path nvarchar(500) = 'SQLTrans',
				@target_path nvarchar(500) = null,
				@filename sysname = null,
				@retry_limit smallint = 5,
				@retry_num smallint = 3,
				@wait_num smallint = 30,
				@delete_source char(1) = 'n',
				@pre_delete_target char(1) = 'y',
				@trusted char(1) = 'y')

/*********************************************************
 **  Stored Procedure dbasp_Baseline_SQLjobs_mover                 
 **  Written by Jim Wilson, Getty Images                
 **  March 12, 2010                                      
 **  
 **  This procedure is used for copying Baseline APPL
 **  job script files from one server to another where 
 **  there is no trust relationship.
 **
 **  This proc accepts several input parms:
 **  - @source_server is the \\servername where files are being copied from.
 **  - @source_path is the path (share or folder name) where files are being copied from.
 **  - @target_path is the path where files are being copied to.
 **  - @filesource is the name of the server where the file originated.
 **  - @filename is the name of the script file being copied.
 **  - @retry_limit is the number of retries performed if the file is not available.
 **  - @retry_num is the number of retries performed if the network fails.
 **  - @wait_num is the number of seconds to wait between retries.
 **  - @trusted (y or n) if the server is in a non-trusted domain, this should be 'n'.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/12/2010	Jim Wilson		New process
--	03/15/2010	Jim Wilson		Fixed issue with checking source server for non-trusted.
--	05/20/2010	Jim Wilson		Fixed net use code for non-trusted connections.
--	======================================================================================


/***
Declare @source_server sysname
Declare @source_path nvarchar(500)
Declare @target_path nvarchar(500)
Declare @filename sysname
Declare @retry_limit smallint
Declare @wait_num smallint
Declare @delete_source char(1)
Declare @pre_delete_target char(1)
Declare @trusted char(1)

select @source_server = '\\g1sqla'
select @source_path = 'g1sqla$a_backup'
--select @source_server = '\\ginssqla'
--select @source_path = 'ginssqla$a_backup'
select @target_path = '\\SQLDEPLOYER02\SQLDEPLOYER02_base_gmsa'
Select @filename = 'gmsa_Jobs.sql'
select @retry_limit = 3
Select @wait_num = 30
Select @delete_source = 'n'
Select @pre_delete_target = 'n'
Select @trusted = 'y'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@error_count		int
	,@command 		nvarchar(512)
	,@retry_counter		smallint
	,@source_user 		sysname
	,@source_pw 		sysname
	,@hold_string		sysname
	,@newid 		sysname



----------------  initial values  -------------------
Select @error_count = 0
Select @retry_counter = 0
select @newid = convert(sysname, newid())


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)


--  Check input parms
if @filename is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_Baseline_SQLjobs_mover.  @backupname is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_Baseline_SQLjobs_mover. @target_path is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


--  Set login and password
If @trusted <> 'n' and @source_server in ('\\g1sqla', '\\g1sqlb', '\\seapshlsql0a', '\\seadcpcsqla', '\\seadcaspsqla', '\\seadcshsqla') 
   begin
	Select @source_user = 'PRODUCTION\SQLTransSVCAcct'
	Select @hold_string  = 'pw_' + @source_user
	Select @source_pw  = (select top 1 detail01 from dbo.local_control where subject = @hold_string)
	If @source_pw is null or @source_pw = ''
	   begin
		Select @miscprint = 'DBA ERROR: Password not found for ' + @source_user + '.' 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   end


If @trusted <> 'y'
   begin
	select @command = 'net use'
	exec master.sys.xp_cmdshell @command--, no_output

	--  Connect to the remote server share
	select @command = 'net use ' + @source_server + ' /user:' + @source_user + ' xxxxx'
	print @command
	select @command = 'net use ' + @source_server + ' /user:' + @source_user + ' ' + @source_pw
	--print @command
	exec master.sys.xp_cmdshell @command--, no_output

	If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid)
	   begin
		insert into dbo.local_control values ('net_use', @source_server, @newid, '')
	   end

	select @command = 'net use'
	exec master.sys.xp_cmdshell @command--, no_output
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

Label01:
 

select @command = 'dir ' + @source_server + '\' + @source_path + '\' + @filename + ' /b'
print @command

delete from #DirectoryTempTable
exec master.sys.xp_cmdshell @command
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
delete from #DirectoryTempTable where cmdoutput is null
select * from #DirectoryTempTable


if (select count(*) from #DirectoryTempTable) < 1
   BEGIN
	Select @miscprint = 'DBA WARNING: No matching files found for dbasp_Baseline_SQLjobs_mover at ' + @source_server + '\' + @source_path
	If @retry_counter < @retry_limit
	   begin
		Select @retry_counter = @retry_counter + 1
		--Waitfor delay '00:05:00'
		Print 'Retry ' + convert(varchar(10), @retry_counter)
		goto label01
	   end
	Else
	   begin
		Select @error_count = @error_count + 1
		goto label89
	   end
   END
   


--  Check to see if this file is already at the target.  If not, delete the file at the target.
If @pre_delete_target = 'y'
   begin
	Delete from #DirectoryTempTable
	Select @command = 'DIR ' + @target_path + '\' + @filename + ' /b'
	Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command
	delete from #DirectoryTempTable where cmdoutput is null
	select * from #DirectoryTempTable

	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		select @command = 'if exist ' + @target_path + '\' + @filename + ' del ' + @target_path + '\' + @filename
		Print @command
		exec master.sys.xp_cmdshell @command
	   end
   end


--  Perform the copy process
--  Note:  If the file being copied is already at the target, robocopy will skip it.
--         The reason we do it this way is - if the file is damaged, robocopy will overwrite it.
If @delete_source = 'y'
   begin
	select @command = 'robocopy /Z /W:' + convert(nvarchar(10), @wait_num) + ' /R:' + convert(nvarchar(10), @retry_limit) + ' /MOV ' + @source_server + '\' + @source_path + ' ' + @target_path + ' ' + rtrim(@filename)
   end
Else
   begin
	select @command = 'robocopy /Z /W:' + convert(nvarchar(10), @wait_num) + ' /R:' + convert(nvarchar(10), @retry_limit) + ' ' + @source_server + '\' + @source_path + ' ' + @target_path + ' ' + rtrim(@filename)
   end

Print @command
exec master.sys.xp_cmdshell @command




-------------------   end   --------------------------
label89:


If @trusted <> 'n'
   begin
	--  Disconnect the remote server connection
	If exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid)
	   begin
		delete from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid
	   end

	If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server)
	   begin
		select @command = 'net use /DELETE ' + @source_server
		print @command
		exec master.sys.xp_cmdshell @command--, no_output
	   end
   end

label99:


drop table #DirectoryTempTable



If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_BaselineFile_mover
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_BaselineFile_mover]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_BaselineFile_mover]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_BaselineFile_mover ( @source_path nvarchar(500) = '\\sqldeployer03\sqldeployer03_BASE_'
				,@target_path nvarchar(500) = '\\10.207.130.40\SEAFRESTGSQL_BASE_'
				,@application sysname = null
				,@filename_mask sysname = null
				,@extension sysname = null)

/*********************************************************
 **  Stored Procedure dbasp_BaselineFile_mover                  
 **  Written by Jim Wilson, Getty Images                
 **  August 17, 2004                                      
 **  
 **  This procedure is used for copying baseline files from one server
 **  to another where there is no trust relationship.
 **
 **  This proc accepts four input parms:
 **  - @source_path is the path where files are being copied from.
 **  - @target_path is the path where files are being copied to.
 **  - @application is the name of application folder where the files exist.
 **  - @extension is the file extension to be processed (BAK or *nxt).
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/16/2004	Jim Wilson		New process
--	10/25/2005	Jim Wilson		New account for stage and new parm to skip 
--						creating the target application folder.
--	11/30/2006	Jim Wilson		New share name for baseline files (_BASE_). 
--	01/22/2007	Jim Wilson		Fixed @target_path for (_BASE_) targets. 
--	03/06/2007	Jim Wilson		Moved code for fixing @target_path for (_BASE_) targets. 
--	03/06/2007	Jim Wilson		Updated for sql 2005. 
--	06/22/2007	Jim Wilson		New code for server_db_list file copy. 
--	08/07/2007	Jim Wilson		Fixed 'net use to target' command. 
--	02/12/2008	Jim Wilson		Added 'net use' for source command. 
--	09/16/2008	Jim Wilson		seafresqldba02 to seafresqldba01. 
--	10/24/2008	Jim Wilson		Removed passwords. 
--	11/17/2008	David Spriggs	        Removed passwords from print out. Eliminated 
--                                              net use of "@source_path" as not needed.
--	03/26/2009	Jim Wilson		Check local_control table before deleting net use connection. 
--	08/11/2009	Jim Wilson		Updated IP for seafrestgsql. 
--	11/19/2009	Jim Wilson		New code for specific file transfer. 
--	05/18/2010	Jim Wilson		Changed retry to 30. 
--	======================================================================================


/***
Declare @source_path nvarchar(500)
Declare @target_path nvarchar(500)
Declare @application sysname
Declare @filename_mask sysname
Declare @extension sysname

select @source_path = '\\SQLDEPLOYER01\SQLDEPLOYER01_BASE_'
select @target_path = '\\seafrestgsql\seafrestgsql_BASE_'
select @application = 'DW'
select @filename_mask = 'MercuryDM_prod'
Select @extension = 'sqb'
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@charpos		int
	,@save_servername	sysname
	,@save_servername2	sysname
	,@error_count		int
	,@command 		nvarchar(512)
        ,@command2		nvarchar(512)
	,@source_user		sysname
	,@source_pw		sysname
	,@hold_string		sysname
	,@newid 		sysname
	

----------------  initial values  -------------------
Select @error_count = 0
select @newid = convert(sysname, newid())


Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end



--  Check input parms
if @application is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_BaselineFile_mover.  @application is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @extension is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_BaselineFile_mover.  @extension is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


-- Set target path for '_BASE_' shares
If @target_path like ('%_')
   begin
	Select @target_path = @target_path + @application
   end

If @source_path like ('%_')
   begin
	Select @source_path = @source_path + @application
   end

--  Connect to the remote server share
If @target_path like '%seaexsqlmail%' 
   begin
	Select @source_user = 'PRODUCTION\SQLTransSVCAcct'
   end
Else
   begin
	Select @source_user = 'stage\sqlnxtpusher'
   end


Select @hold_string  = 'pw_' + @source_user
Select @source_pw  = (select top 1 detail01 from dbo.local_control where subject = @hold_string)
If @source_pw is null or @source_pw = ''
   begin
	Select @miscprint = 'DBA ERROR: Password not found for ' + @source_user + '.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end


--  Connect using net use command
select @command = 'net use ' + @target_path + ' /user:' + @source_user + ' ' + @source_pw
select @command2 = 'net use ' + @target_path + ' /user:' + @source_user + ' password_here'
print @command2
exec master.sys.xp_cmdshell @command--, no_output

If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @target_path and Detail02 = @newid)
   begin
	insert into dbo.local_control values ('net_use', @target_path, @newid, '')
   end



/****************************************************************
 *                MainLine
 ***************************************************************/
 
If @application = 'dbaadmin_scriptserverlist'
   begin
    select @command = 'robocopy /Z /R:30 ' + @source_path + ' ' + @target_path + ' ' + @application + '*.' + rtrim(@extension)
    Print @command
    exec master.sys.xp_cmdshell @command
   end
Else If @filename_mask is not null and @filename_mask <> ''
   begin
    select @command = 'robocopy /Z /R:30 ' + @source_path + ' ' + @target_path + ' ' + @filename_mask + '*.' + rtrim(@extension)
    Print @command
    exec master.sys.xp_cmdshell @command
   end
Else
   begin
    select @command = 'robocopy /Z /R:30 ' + @source_path + ' ' + @target_path + ' *.' + rtrim(@extension)
    Print @command
    exec master.sys.xp_cmdshell @command
   end




-------------------------
-- Post copy verification
-------------------------

--  first, check to see how many files should have been copied






--  second, check to make sure all those files are now at the target (match name and date)

--  Last, make sure no matching files at the target have a date of 1/1/1980





-------------------   end   --------------------------

label99:

--  Disconnect the remote server connection
If exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @target_path and Detail02 = @newid)
   begin
	delete from dbo.local_control where subject = 'net_use' and Detail01 = @target_path and Detail02 = @newid
   end

If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @target_path)
   begin
	select @command = 'net use /DELETE ' + @target_path
	print @command
	exec master.sys.xp_cmdshell @command--, no_output
   end





If @error_count > 0
   begin
	raiserror(@miscprint,-1,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_bighammer
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_bighammer]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_bighammer]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[dbasp_bighammer](@filepath sysname)

/*********************************************************
 **  Stored Procedure dbasp_bighammer                 
 **  Written by David Spriggs, Getty Images                
 **  May 13, 2009                                      
 **  
 **  This sproc will remove a handle(or file lock) and 
 **  delete the file
 **
 **  CAUTION: This is a dangerous stored procedure. It can
 **  literally delete database files while SQL Server is running.
 **
 **  Input Parm(s);
 **  @filepath - is the file path of the specific file which is locked
 **		 and is targeted for deletion.
 **  External Application;
 **  Handle    - Sysinternal application installed in \system32
 ***************************************************************/

as

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	05/13/2009	David Spriggs		New process. Introducting TRY\CATCH
--	08/05/2009	David Spriggs		Add functionality to allow for either local
--						or network path.
--	
--	======================================================================================

set nocount on
/***
declare @filepath sysname
set @filepath = '\\seafresqldba01\SEAFRESQLDBA01_dbasql\dba_reports\CentralTableUpdate_SEAFRESQLDBA02.gsql'
--***/

-----------------  declares  ------------------
 declare @pid sysname
 declare @handlefilecmd nvarchar(4000)
 declare @handledelcmd nvarchar(4000)
 declare @delcmd nvarchar(4000)
 declare @varintfilepath sysname
 declare @checkfilename sysname
 declare @hold_filename sysname
 declare @hold_backpath sysname
 declare @hold_sharename sysname
 declare @netpathcheck varchar(50)
 declare @netpathcompare varchar(50)
 declare @netOtherFolderCount int
 declare @hold_otherFolders sysname
 declare @chck bit
 declare @returncode int

/*********************************************************************
 *                Initialization
 ********************************************************************/

 set @varintfilepath = @filepath
 
 --verify if either network path or localpath
 set @netpathcheck = substring(@varintfilepath,0,3)

 --print @netpathcheck
 if(@netpathcheck ='\\')
    begin
	set @hold_filename = right(@varintfilepath,charindex('\',reverse(@varintfilepath))-1)
	set @hold_backpath =  replace(@varintfilepath,'\\','')
	select @hold_sharename = splitvalue from dbaadmin.dbo.dbaudf_split(@hold_backpath,'\') where OccurenceID = 2

	select  @hold_filename = splitvalue 
	from dbaadmin.dbo.dbaudf_split(@hold_backpath,'\') 
	where OccurenceID = (select max(occurenceid) 
		       from dbaadmin.dbo.dbaudf_split(@hold_backpath,'\') )

--	print @hold_filename
--	print @hold_backpath
--	print @hold_sharename

	--check if there are other subfolders

	select  @netOtherFolderCount =count(* )
	from dbaadmin.dbo.dbaudf_split(@hold_backpath,'\') 
	where OccurenceID <> (  select max(occurenceid) 
				from dbaadmin.dbo.dbaudf_split(@hold_backpath,'\') )
	and OccurenceID not in (1,2)

	if (@netOtherFolderCount > 0)
	    begin
    		exec dbaadmin.dbo.dbasp_get_share_path @hold_sharename, @phy_path = @netpathcompare OUTPUT

		set @hold_otherFolders = ''
		select @hold_otherFolders = @hold_otherFolders+'\'+splitvalue
		from dbaadmin.dbo.dbaudf_split(@hold_backpath,'\') 
		where OccurenceID <> (select max(occurenceid) 
				   from dbaadmin.dbo.dbaudf_split(@hold_backpath,'\') )
		and OccurenceID not in (1,2)

		--print @netpathcompare+@hold_otherFolders+'\'+@hold_filename

		set @handlefilecmd = 'handle '+@netpathcompare+@hold_otherFolders+'\'+@hold_filename+' -accepteula'
		set @delcmd = 'del '+ @netpathcompare+@hold_otherFolders+'\'+@hold_filename
		--print @handlefilecmd 
		--print @delcmd 
	    end
	else
	    begin
		exec dbaadmin.dbo.dbasp_get_share_path @hold_sharename, @phy_path = @netpathcompare OUTPUT

		--print @netpathcompare

		set @handlefilecmd = 'handle '+@netpathcompare+'\'+@hold_filename+' -accepteula'
		set @delcmd = 'del '+ @netpathcompare+'\'+@hold_filename

		--print @handlefilecmd 
		--print @delcmd 
	    end
    end
 else
    begin
	 set @handlefilecmd = 'handle '+@varintfilepath+' -accepteula'
	 set @delcmd = 'del '+ @varintfilepath
	 --print @handlefilecmd 
	 --print @delcmd 
    end

 


 create table #handleme(handlecmd nvarchar(4000))

/****************************************************************
 *                MainLine
 ***************************************************************/
begin try
  
      ---Check to see if the file is a SQL Server file. If yes, then exit the procedure
     set @checkfilename= RIGHT(@varintfilepath ,charindex('\',reverse(@varintfilepath ))-1)

     if exists(select 1 from master.sys.master_files where RIGHT(physical_name,charindex('\',reverse(physical_name))-1)= @checkfilename)
	begin
	    set @chck = 1
	end
    else
	begin
	     set @chck = 0
	end

 if @chck = 1
	begin
            print 'DBA WARNING: The file '+@varintfilepath+' is either a database data file or log file and will not be deleted.'
	    goto label99 
	end

    --First determine what process is holding a lock(handle) on the file
   
    insert into #handleme
    exec master.sys.xp_cmdshell @handlefilecmd

    delete from #handleme where handlecmd not like '%pid%'

    delete from #handleme where handlecmd is null


    --Now format the output from column handlecmd for processing and set to @pid
    select
	@pid = replace(substring(handlecmd, patindex('%pid%', handlecmd),len(handlecmd)),':',' ')
    from #handleme

    --create the "Handle command to release the file"
    select
	@handledelcmd =  'handle '+
			  max(CASE OccurenceID WHEN 9 THEN '-c '+splitvalue ELSE '' END)+ '  ' +
		          max(CASE OccurenceID WHEN 3 THEN '-p '+splitvalue ELSE '' END)+ '  -y' 
    from dbaadmin.dbo.dbaudf_split(@pid,' ')

    --        select
    --	*
    --    from dbaadmin.dbo.dbaudf_split(@pid,' ')
    --    where splitvalue not like ''
        
    print 'handlecmd ' + @handledelcmd

    --Execute the "Handle" command and delete the file

    exec master.sys.xp_cmdshell @handledelcmd
    exec master.sys.xp_cmdshell @delcmd
   
    select @returncode = 1

    select @returncode

end try

--If there is an error it is trapped here.

begin catch
    select @returncode = 0 

    drop table #handleme

    select @returncode
end catch

-----------------  Finalizations  ------------------

label99:

drop table #handleme
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_capture_local_serverenviro
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_capture_local_serverenviro]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_capture_local_serverenviro]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_capture_local_serverenviro

/***************************************************************
 **  Stored Procedure dbasp_capture_local_serverenviro                  
 **  Written by Jim Wilson, Getty Images                
 **  January 03, 2003                                      
 **  
 **  This sproc is set up to;
 ** 
 **  Capture local server information such as the servername
 **  and the drive path's for the local shares.  This information
 **  will then be used by the maintenance process. 
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	01/03/2003	Jim Wilson		New process.
--	02/21/2003	Jim Wilson		Modified delete from local_serverinfo table.
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	02/04/2005	Jim Wilson		Added capture for Instance and ShareHeader info.
--	03/29/2005	Jim Wilson		Set central server name.
--	05/20/2005	Jim Wilson		Added SQL Port Info.
--	08/19/2005	Jim Wilson		Modify delete from table Local_ServerEnviro so 
--								that backup_type is maintained.
--	12/13/2005	Jim Wilson		Added row for ENVname info. 
--	02/15/2006	Jim Wilson		Modified for sql2005. 
--	03/13/2006	Jim Wilson		Added code for royaltydatabase service account. 
--	04/04/2006	Jim Wilson		If the domain is not in the listed domains, the
--								server will be it's own central server. 
--	04/07/2006	Jim Wilson		Code for new sproc dbasp_regread.
--	05/03/2006	Jim Wilson		Added clean up for the service account to remove the '@'
--	06/01/2006	Jim Wilson		Added Alpha environment.
--	01/03/2007	Jim Wilson		Changed central server sqldeployer to sqldeployer04.
--	03/23/2007	Jim Wilson		New code for Alliant 'rylwdb' servers.
--	08/28/2007	Jim Wilson		New check for service accounts with @ embedded.
--	11/06/2007	Jim Wilson		Fixed reg read for port num.
--	11/12/2007	Jim Wilson		Changed HKLM to HKEY_LOCAL_MACHINE.
--	11/13/2007	Jim Wilson		Fixed port number section (bad if stmt).
--	12/13/2007	Jim Wilson		Added return(0).
--	04/30/2008	Jim Wilson		Added step to drop job 'Base - Local Process' in production.
--	05/06/2008	Jim Wilson		Code for new svc account in prod (sqladminprod2008).
--	05/22/2008	Jim Wilson		Check for one more reg key for port info.
--	05/06/2008	Jim Wilson		Code for new svc account in stage (sqladminstage2008).
--	08/26/2008	Jim Wilson		New path for port in x64 reg.
--	09/16/2008	Jim Wilson		seafresqldba02 to seafresql01.
--	11/06/2008	Jim Wilson		Code to enable job MON - SQL Performance Reporting in prod.
--	11/25/2008	Jim Wilson		More code for royaltydatabase service account.
--	01/30/2009	David Spriggs		Changed the code to accommodate the new service account naming standard
--	10/07/2009	Jim Wilson		Added code for new environments (alpha, beta, etc.).
--	03/16/2010	Jim Wilson		Changed central server sqldeployer04 to sqldeployer05.
--	======================================================================================

-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@command 		nvarchar(4000)
	,@len			int
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_domain		sysname
	,@save_port		sysname
	,@save_sqlinstance	sysname
	,@save_envname		sysname
	,@save_install_folder	sysname
	,@parm01		varchar(100)
	,@outpath		varchar(255)
	,@charpos		int	
	,@isNMinstance		char(1)
	,@fileexist_path	sysname
	,@error_count		int
	,@in_key		sysname
	,@in_path		sysname
	,@in_value		sysname
	,@result_value		nvarchar(500)


----------------  initial values  -------------------
Select
	 @save_domain 			= ' '
	,@isNMinstance			= 'n'
	,@error_count			= 0

Select @save_sqlinstance = 'mssqlserver'
Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
	Select @isNMinstance = 'y'
   end

--  Create Temp Tables
Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

Create table #loginconfig(name1 sysname null, config_value sysname null)

--  Get the domain name and save it (Note:  We have to strip off the last byte from config_value because it's not printable)
If @isNMinstance = 'n'
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\MSSQLServer'
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end
Else
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\MSSQL$' + @save_sqlinstance
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end


Select @save_domain = @result_value
Select @save_envname = @result_value

Select @charpos = charindex('\', @save_domain)
IF @charpos <> 0
   begin
	Select @save_domain = substring(@save_domain, 1, (CHARINDEX('\', @save_domain)-1))
	Select @save_envname = rtrim(substring(@save_envname, @charpos+1, 100))
	goto get_domain_end
   end


Select @charpos = charindex('@', @save_domain)
IF @charpos <> 0
   begin
	Select @save_domain = substring(@save_domain, @charpos+1, (CHARINDEX('.', @save_domain)-1)-@charpos)
	Select @save_envname = rtrim(substring(@save_envname, 1, @charpos-1))
	goto get_domain_end
   end


Insert into #loginconfig exec master.dbo.xp_loginconfig 'default domain'
Select @save_domain = config_value from #loginconfig
Select @len = len(@save_domain)
Select @save_domain = substring(@save_domain, 1, (@len - 1))

get_domain_end:

--print @save_domain
--print @save_envname


--  Clear out the serverenviro table
delete from dbaadmin.dbo.Local_ServerEnviro
where env_type not like ('check%') 
  and env_type <> 'backup_type'


--  Inset Domain and Servername info
If @save_domain <> ' '
   begin
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('domain', @save_domain)
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('SRVname', @save_servername)
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('Instance', @@servername)
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ShareHeader', @save_servername2)
	If @save_domain = 'amer'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('CentralServer', 'SQLDEPLOYER05')
	   end
	Else If @save_domain = 'stage'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('CentralServer', 'SEAFRESTGSQL')
	   end
	Else If @save_domain = 'staging'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('CentralServer', 'SEAEXSTGDELSQL')
	   end
	Else If @save_domain = 'production'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('CentralServer', 'SEAEXSQLMAIL')
	   end
	Else
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('CentralServer', @@servername)
		Print 'Error:  Unable to determine central server.  Domain name ' + @save_domain + ' not found in list. ' 
		Select @error_count = @error_count + 1
	   end


	--  Reformat the service account name if needed (remove the @getty...)
	Select @charpos = charindex('@', @save_envname)
	IF @charpos <> 0
	   begin
		Select @save_envname = substring(@save_envname, 1, @charpos-1)
	   end

	If @save_envname like '%sqladmin%' and @save_envname like '%test%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'test')
	   end
	Else If @save_envname like '%sqladmin%' and @save_envname like '%dev%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'dev')
	   end
	Else If @save_envname like '%sqladmin%' and @save_envname like '%load%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'load')
	   end
	Else If @save_envname like '%sqladmin%' and @save_envname like '%alpha%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'alpha')
	   end
	Else If @save_envname like '%sqladmin%' and @save_envname like '%beta%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'beta')
	   end
	Else If @save_envname like '%sqladmin%' and @save_envname like '%candidate%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'candidate')
	   end
	Else If @save_envname like '%sqladmin%' and @save_envname like '%prodsupport%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'prodsupport')
	   end
	Else If @save_envname like '%sqladmin%' and @save_envname like '%staging%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'staging')
	   end
	Else If @save_envname like '%stage%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'stage')
	   end
	Else If @save_envname like '%production%'
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'production')
		If @save_domain = 'amer'
		   begin
			update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'SEAFRESQLDBA01' where env_type ='CentralServer'  
		   end
	   end
	Else If @save_envname like '%royalty%' and (@@servername like 'sead%' or @@servername like 'fred%')
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'dev')
	   end
	Else If @save_envname like '%royalty%' and (@@servername like 'seat%' or @@servername like 'fret%')
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'test')
	   end
	Else If @save_envname like '%royalty%' and (@@servername like 'seal%' or @@servername like 'frel%')
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'load')
	   end
	Else If @save_envname like '%royalty%' and (@@servername like 'seas%' or @@servername like 'fres%')
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'stage')
	   end
	Else
	   begin
		insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ENVname', 'production')
		If @save_domain = 'amer'
		   begin
			update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'SEAFRESQLDBA01' where env_type ='CentralServer'  
		   end
	   end

   end
Else
   begin
	Print 'Error:  Domain name not found'
	Select @error_count = @error_count + 1
   end



--  Special code for Alliant "rylwdb" sql servers (01,03,04=test; 02=dev)
If @@servername like '%rylwdb%'
   begin
	update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'test' where env_type = 'ENVname'
	update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'SQLDEPLOYER05' where env_type ='CentralServer'  

	If @@servername like '%rylwdb02'
	   begin
		update dbaadmin.dbo.Local_ServerEnviro set env_detail = 'dev' where env_type = 'ENVname'
	   end
   end


--  Verify standard folders and shares
--  Check to see if the 'backup' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_backup' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername2 + '_backup'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('backup_path', @outpath)
   end
Else
   begin
	Print 'Error:  Backup folder or share not configured properly'
	Select @error_count = @error_count + 1
   end


--  Check to see if the 'builds' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername + '_builds' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername + '_builds'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('builds_path', @outpath)
   end
Else
   begin
	Print 'Error:  Builds folder or share not configured properly'
	Select @error_count = @error_count + 1
   end

--  Check to see if the 'log' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_log' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername2 + '_log'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('log_path', @outpath)
   end
Else
   begin
	Print 'Error:  log folder or share not configured properly'
	Select @error_count = @error_count + 1
   end


--  Check to see if the 'dbasql' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_dbasql' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername2 + '_dbasql'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('dbasql_path', @outpath)
   end
Else
   begin
	Print 'Error:  dbasql folder or share not configured properly'
	Select @error_count = @error_count + 1
   end


--  Check to see if the 'dba_archive' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_dba_archive' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername2 + '_dba_archive'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('dba_archive_path', @outpath)
   end
Else
   begin
	Print 'Error:  dba_archive folder or share not configured properly'
	Select @error_count = @error_count + 1
   end


--  Check to see if the 'dba_mail' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername + '_dba_mail' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername + '_dba_mail'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('dba_mail_path', @outpath)
   end
Else
   begin
	Print 'Error:  dba_mail folder or share not configured properly'
	Select @error_count = @error_count + 1
   end


--  Check to see if the 'mdf' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_mdf' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername2 + '_mdf'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('mdf_path', @outpath)
   end
Else
   begin
	Print 'Error:  mdf folder or share not configured properly'
	Select @error_count = @error_count + 1
   end


--  Check to see if the 'ldf' folder and share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_ldf' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @parm01 = @save_servername2 + '_ldf'
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
	insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('ldf_path', @outpath)
   end
Else
   begin
	Print 'Error:  ldf folder or share not configured properly'
	Select @error_count = @error_count + 1
   end


--  Get Port Info for this instance
select @in_key = 'HKEY_LOCAL_MACHINE'
select @in_path = 'SOFTWARE\Microsoft\MSSQLServer\MSSQLServer\SuperSocketNetLib\Tcp'
select @in_value = 'TcpPort'
exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output

If @result_value is null or @result_value = ''
   begin
	--  Get the instalation directory folder name
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'
	select @in_value = @save_sqlinstance
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output

	select @save_install_folder = @result_value
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\' + @save_install_folder + '\MSSQLServer\SuperSocketNetLib\Tcp\IPall'
	select @in_value = 'TcpPort'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output

	If @result_value is null or @result_value = ''
	   begin
		select @in_key = 'HKEY_LOCAL_MACHINE'
		select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\' + @save_install_folder + '\MSSQLServer\SuperSocketNetLib\Tcp\IPall'
		select @in_value = 'TcpDynamicPorts'
		exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
	   end

	If @result_value is null or @result_value = ''
	   begin
		select @in_key = 'HKEY_LOCAL_MACHINE'
		select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\' + @save_install_folder + '\MSSQLServer\SuperSocketNetLib\Tcp\IPall'
		select @in_value = 'TcpPort'
		exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
	   end
   end


If @@version like '%x64%' and (@result_value is null or @result_value = '')
   begin
	select @save_install_folder = @result_value
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'SOFTWARE\Wow6432Node\Microsoft\Microsoft SQL Server\' + @save_sqlinstance + '\MSSQLServer\SuperSocketNetLib\Tcp'
	select @in_value = 'TcpPort'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end

If @result_value is null or @result_value = ''
   begin
	Select @result_value = 'Error'
   end

Select @save_port = @result_value
--Print @save_port
insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('SQL Port', @save_port)



--  Remove 'Base - Local Process' from production if it exists
If exists (Select * from msdb.dbo.sysjobs where (name = N'BASE - Local Process'))
   and (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'envname') = 'production'
   begin
	EXEC msdb.dbo.sp_delete_job @job_name = N'Base - Local Process'
   end

--  Enable job 'MON - SQL Performance Reporting' in production
If exists (Select * from msdb.dbo.sysjobs where (name = N'MON - SQL Performance Reporting'))
   and (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'envname') = 'production'
   begin
	exec msdb.dbo.sp_update_job @job_name = 'MON - SQL Performance Reporting', @enabled = 1
   end



-------------------------------------------------------------------------------------------------------------
drop table #loginconfig
drop table #fileexists



If @error_count > 0
   begin
	return(1)
   end
Else
   begin
	Print 'Environment information has been loaded and standard folders and shares verified'
	return(0)
   end

 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_capture_UserDB_Access
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_capture_UserDB_Access]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_capture_UserDB_Access]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_capture_UserDB_Access @db_name sysname = null

/***************************************************************
 **  Stored Procedure dbasp_capture_UserDB_Access                  
 **  Written by Jim Wilson, Getty Images                
 **  April 01, 2003                                      
 **  
 **  This sproc is set up to;
 ** 
 **  Capture user database access information.  This information
 **  is used for restore processing to dynamically maintain
 **  database security and access. 
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/01/2003	Jim Wilson		New process.
--	05/15/2007	Jim Wilson		Converted to SQL 2005.
--	01/24/2008	Jim Wilson		Fixed bug with standard logins not being processed.
--	======================================================================================

/*
declare @db_name sysname

select @db_name = 'dbaadmin'
--*/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@error_count			int

DECLARE
	 @cu22Lname			sysname
	,@cu22Uname			sysname
	,@cu22Dflt_DBname		sysname

DECLARE
	 @cu23Rname			sysname

DECLARE
	 @cu33Lname			sysname


----------------  initial values  -------------------
Select @error_count = 0




-- VALIDATE DATABASE NAME:
If not exists(select 1 from master.sys.databases where name = @db_name)
   begin
	Select @miscprint = 'DBA WARNING: Database name not found in master.sys.databases' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
end



-- Capture database access info

--  First, we find out who has access to the DB
--------------------  Cursor for 22DB  -----------------------
EXECUTE('DECLARE cu22_DBAccess Insensitive Cursor For ' + 
  'SELECT l.name, u.name, d.name
   From [' + @db_name + '].sys.sysusers  u, master.sys.syslogins  l, master.sys.databases  d ' + 
  'Where u.hasdbaccess = 1
     and u.uid > 3
     and u.isaliased = 0
     and u.issqlrole = 0
     and u.sid= l.sid
     and l.dbname = d.name
   Order By u.uid For Read Only')


OPEN cu22_DBAccess

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBAccess Into @cu22Lname, @cu22Uname, @cu22Dflt_DBname 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_DBAccess
	      BREAK
           end


	If not exists (select * from dbaadmin.dbo.UserDB_Access_Ctrl 
					where DBname = @db_name 
					and Loginname = @cu22Lname 
					and Username = @cu22Uname
					and DBrole = 'public')
	   begin
		insert into dbaadmin.dbo.UserDB_Access_Ctrl (DBname
							,Loginname
							,Username
							,DBrole
							,DfltDB)
						Values (@db_name
							,@cu22Lname
							,@cu22Uname
							,'public'
							,@cu22Dflt_DBname)
	   end



	--  Now, we find out what roles this user is a member of
	--------------------  Cursor for 22DB  -----------------------
	EXECUTE('DECLARE cu23_DBroles Insensitive Cursor For ' + 
	  'SELECT r.name
	   From [' + @db_name + '].sys.sysusers  u, [' + @db_name + '].sys.sysusers  r, [' + @db_name + '].sys.sysmembers  m ' + 
	  'Where u.name = ''' + @cu22Uname + '''
	     and u.uid = m.memberuid
	     and m.groupuid = r.uid
	   Order By u.uid For Read Only')


	OPEN cu23_DBroles

	WHILE (23=23)
	   Begin
		FETCH Next From cu23_DBroles Into @cu23Rname 
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu23_DBroles
		      BREAK
	           end


		If not exists (select * from dbaadmin.dbo.UserDB_Access_Ctrl 
						where DBname = @db_name 
						and Loginname = @cu22Lname 
						and Username = @cu22Uname
						and DBrole = @cu23Rname)
		   begin
			insert into dbaadmin.dbo.UserDB_Access_Ctrl (DBname
								,Loginname
								,Username
								,DBrole
								,DfltDB)
							Values (@db_name
								,@cu22Lname
								,@cu22Uname
								,@cu23Rname
								,@cu22Dflt_DBname)
	   end


	   End  -- loop 23
	   DEALLOCATE cu23_DBroles


   End  -- loop 22
   DEALLOCATE cu22_DBAccess



--  Audit Process.  If logins have been removed, clean up userdb_access table 

--------------------  Cursor for 33DB  -----------------------
EXECUTE('DECLARE cu33_Audit Insensitive Cursor For ' + 
  'SELECT distinct u.Loginname
   From dbaadmin.dbo.UserDB_Access_Ctrl  u ' + 
  'Where u.DBname = ''' + @db_name + '''
   Order By u.Loginname For Read Only')


OPEN cu33_Audit

WHILE (33=33)
   Begin
	FETCH Next From cu33_Audit Into @cu33Lname 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu33_Audit
	      BREAK
           end


	If not exists (select 1 from master.sys.syslogins where name = @cu33Lname)
	   begin
		delete from dbaadmin.dbo.UserDB_Access_Ctrl where DBname = @db_name and Loginname = @cu33Lname
	   end


   End  -- loop 33
   DEALLOCATE cu33_Audit



--  Finalization  -------------------------------------------------------------------

label99:



If  @error_count > 0
   begin
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_CentralTableUpdates
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_CentralTableUpdates]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_CentralTableUpdates]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_CentralTableUpdates

/**************************************************************
 **  Stored Procedure dbasp_CentralTableUpdates                
 **  Written by Jim Wilson, Getty Images                
 **  August 20, 2008                                      
 **  
 **  This dbasp is set up to process the Self Register files
 **  created by the DBA Nightly Process on all supported SQL servers.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/20/2008	Jim Wilson		New process
--	04/13/2009	Jim Wilson		Modified rename process
--	03/15/2010	Jim Wilson		Insert now specific to dbaadmin
--	======================================================================================



-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd 				nvarchar(4000)
	,@filename_wild			nvarchar(50)
	,@filename_ext			nvarchar(50)
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_filename			sysname
	,@save_alt_filename		sysname
	,@charpos			bigint


----------------  initial values  -------------------
select @filename_ext 	= 'gsql'

Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


create table #DirectoryTempTable (cmdoutput nvarchar(255) null)


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Check for files in the DBA_Register folder for this server
Delete from #DirectoryTempTable
Select @cmd = 'dir \\' + @save_servername + '\' + @save_servername + '_SQL_Register\*.' + @filename_ext + ' /B'
print @cmd
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null or cmdoutput = ''
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%.' + @filename_ext
--select * from #DirectoryTempTable

-- Check to see if there are files to process
If (select count(*) from #DirectoryTempTable) > 0
   begin
	start_files:

	Select @save_filename = (select top 1 cmdoutput from #DirectoryTempTable order by cmdoutput)
	Select @save_filename =  rtrim(@save_filename)

	--  Run this file to load data inot the DBA Info tables
	SELECT 	@cmd = 'sqlcmd -S' + @@servername + ' -ddbaadmin -u -E -i\\' + @save_servername + '\' + @save_servername + '_SQL_Register\' + @save_filename
	PRINT   @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @save_alt_filename = replace(@save_filename, '.'+@filename_ext, '.old')

	--  Rename the file so it wont be processed again
	Select @cmd = 'del "\\' + @save_servername + '\' + @save_servername + '_SQL_Register\' + @save_alt_filename + '"'
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @cmd = 'ren "\\' + @save_servername + '\' + @save_servername + '_SQL_Register\' + @save_filename + '" "' + @save_alt_filename + '"'
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output

	--  Check to see if there are more files to process
	delete from #DirectoryTempTable where cmdoutput like '%' + @save_filename + '%'
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto start_files
	   end

	--  One last check to see if we have new rows to process
	Delete from #DirectoryTempTable
	Select @cmd = 'dir \\' + @save_servername + '\' + @save_servername + '_SQL_Register\*.' + @filename_ext + ' /B'
	print @cmd
	Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
	delete from #DirectoryTempTable where cmdoutput is null or cmdoutput = ''
	delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%.' + @filename_ext
	--select * from #DirectoryTempTable

	-- Check to see if there are files to process
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto start_files
	   end

   end



----------------  End  -------------------

label99:

drop table #DirectoryTempTable






 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_Backups
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_Backups]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_Backups]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Check_Backups (@backup_full_dd_period int = 7
					,@backup_diff_dd_period int = 1
					,@tranlog_hh_period int = 24)
 
/*********************************************************
 **  Stored Procedure dbasp_Check_Backups                  
 **  Written by Jim Wilson, Getty Images                
 **  June 12, 2001                                      
 **
 **  This proc accepts the following input parms (position does matter):
 **  @backup_full_dd_period - Specify the oldest allowed age for the most recent 
 **                      full database backup (in days - 7 day is the default)
 **
 **  @backup_diff_dd_period - Specify the oldest allowed age for the most recent 
 **                      differential backup (in days - 1 day is the default)
 **
 **  @tranlog_hh_period - Specify the oldest allowed age for the most recent
 **                       transaction log backup (in hours - 24 hours is the default)
 **
 **  Note: This process will not check for transaction log 
 **        backups for databases set for 'truncate log on checkpoint'
 **
 **  This procedure checks for current backups for each
 **  database on the server and raises a DBA warning to 
 **  the error log if any are not found within the specified
 **  parameters.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	07/23/2002	Jim Wilson		Added code for bulkcopy flag, and to check for DB copy
--						within one day if trans log is not being backed up.
--	01/23/2003	Jim Wilson		Fixed check for transaction log backup.  Must be type 'L'
--						in msdb..backupset.
--	04/14/2005	Jim Wilson		Added code for bulkcopy flag.  Somehow it was not in there.
--	04/18/2005	Jim Wilson		New code to delete database names from the backup_nocheck
--						table after 30 days.  Converted cursor11 to table variable.
--	12/16/2005	Jim Wilson		Modified error message with 'or differential'.
--	05/30/2006	Jim Wilson		Updated for SQL 2005.
--	03/21/2007	Jim Wilson		Added process to update the backup_nocheck_db table.
--	04/25/2007	Jim Wilson		Added skip process for non-production.
--	05/11/2007	Jim Wilson		New seperate input parms for full and diff's.
--	02/11/2008	Jim Wilson		Skip check for DB's not online.
--	02/13/2008	Jim Wilson		Added second Skip check.
--	01/02/2009	Jim Wilson		Converted to new no_check table.
--	05/01/2009	David Spriggs		Remove check for Database names in DEPL jobs
--						due to new request
--	05/18/2009	Jim Wilson		Added @base_flag.
--	======================================================================================

/**
Declare @backup_full_dd_period int
Declare @backup_diff_dd_period int
Declare @tranlog_hh_period int

Select @backup_full_dd_period = 7
Select @backup_diff_dd_period = 1
Select @tranlog_hh_period = 24
--**/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(255)
	,@hold_backup_start_date	datetime
	,@saveDBName			sysname
	,@charpos			int
	,@charpos2			int
	,@base_flag			char(1)

DECLARE
	 @cu10JobName			sysname

DECLARE
	 @cu11DBName			sysname

----------------  initial values  -------------------

Select
	 @saveDBName	= ' '

--  Create table variable
declare @dbnames table	(name	sysname
			,dbid	smallint
			,status	int
			)

declare @jobnames table	(name	sysname)


/****************************************************************
 *                MainLine
 ***************************************************************/

--------------------  Clean up dbaadmin.dbo.no_check table  -------------------
update dbo.no_check set modDate = getdate() where modDate is null

update dbo.no_check set modDate = getdate() where detail01 in (select name from master.sys.databases)


--  Skip this check for non-production servers
If (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'ENVname') <> 'production'
  and not exists (select md.database_name from msdb.dbo.sysdbmaintplans mp, msdb.dbo.sysdbmaintplan_databases md
		where mp.plan_id = md.plan_id
		  and mp.plan_name = 'Mplan_user_full')
   begin
	goto skip_all
   end
Else If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_maint' and env_detail = 'skip')
   begin
	goto skip_all
   end



--  Check for regular restored DB's and add them to the backup no_check table
Insert into @jobnames (name)
SELECT j.name
From msdb.dbo.sysjobs j with (NOLOCK) 
Where j.name not like ('x%')
  and j.name not like ('%Start Restore%')
  and j.name not like ('%End Restore%')
  and j.name not like ('%Restores Complete%')
  and j.name not like ('%DFNTL Restore%')
  and j.name like ('%restore%')
  and (j.name like ('base%') or j.name like ('rstr%'))

delete from @jobnames where name is null or name = ''
--select * from @jobnames


IF (select count(*) from @jobnames) > 0
   begin
	start_jobnames:

	Set @base_flag = 'n'

	Select @cu10JobName = (select top 1 name from @jobnames)
	
	Select @saveDBName = @cu10JobName

	--  get the DB names for BASE
	IF @saveDBName like ('BASE%') 
	   begin
		Set @base_flag = 'y'

		Select @charpos = charindex('Restore', @saveDBName)

		IF @charpos <> 0
		   begin
			Select @saveDBName = substring(@saveDBName, @charpos+7, 200)
			Select @saveDBName = ltrim(rtrim(@saveDBName))
		   end

	    goto end_jobname_parse
	   end

	
	--  get the DB names in ()
	Select @charpos = charindex('(', @saveDBName)
	IF @charpos <> 0
	   begin
		Select @charpos2 = charindex(')', @saveDBName, @charpos+1)
		IF @charpos2 <> 0
		   begin
			Select @saveDBName = substring(@saveDBName, @charpos+1, (@charpos2-@charpos-1))
		   end
	    goto end_jobname_parse
	   end

	--  get the DB names for Rstr jobs
	IF @saveDBName like ('Rstr%')
	   begin
		Select @charpos = charindex(' ', @saveDBName)
		IF @charpos <> 0
		   begin
			Select @charpos2 = charindex(' ', @saveDBName, @charpos+1)
			IF @charpos2 <> 0
			   begin
				Select @saveDBName = substring(@saveDBName, @charpos+1, (@charpos2-@charpos-1))
			   end
		   end
	    goto end_jobname_parse
	   end


	end_jobname_parse:
	--  Update the no_check table
	If exists (select 1 from dbaadmin.dbo.no_check where detail01 = @saveDBName and NoCheck_type = 'backup')
	   begin
		update dbaadmin.dbo.no_check set modDate = getdate() where detail01 = @saveDBName and NoCheck_type = 'backup'
	   end
	Else
	   begin
		INSERT INTO dbaadmin.dbo.no_check (nocheck_type, detail01, createdate, moddate) VALUES ('backup', @saveDBName, getdate(), getdate())
	   end

	If @base_flag = 'y'
	   begin
		If exists (select 1 from dbaadmin.dbo.no_check where detail01 = @saveDBName and NoCheck_type = 'baseline')
		   begin
			update dbaadmin.dbo.no_check set modDate = getdate() where detail01 = @saveDBName and NoCheck_type = 'baseline'
		   end
		Else
		   begin
			INSERT INTO dbaadmin.dbo.no_check (nocheck_type, detail01, createdate, moddate) VALUES ('baseline', @saveDBName, getdate(), getdate())
		   end
	   end


	--  Remove this record from @jobnames and go to the next
	delete from @jobnames where name = @cu10JobName
	If (select count(*) from @jobnames) > 0
	   begin
		goto start_jobnames
	   end
   end

Delete from dbaadmin.dbo.no_check where nocheck_type = 'backup' and modDate < getdate()-30

Select @saveDBName = ' '


--------------------  Cursor for DB names  -------------------
Insert into @dbnames (name)
SELECT d.name
From master.sys.databases d with (NOLOCK) 
Where d.name not in ('master', 'model', 'msdb', 'tempdb')
  and d.name not in (select detail01 from dbo.no_check where nocheck_type = 'backup')

delete from @dbnames where name is null or name = ''
--select * from @dbnames


If (select count(*) from @dbnames) > 0
   begin
	start_dbnames:

	Select @cu11DBName = (select top 1 name from @dbnames order by name)
	

	If (SELECT DATABASEPROPERTYEX (@cu11DBName,'status')) <> 'ONLINE'
	   begin
		goto label01
	   end
	Else
	--  Check to see if this database was specifically excluded from this check process.
	If exists(select 1 from dbaadmin.dbo.no_check where detail01 = @cu11DBName and nocheck_type = 'backup')
	   begin
		goto label01
	   end
	Else
	--  Check the 'read only' option.  If it's 'on', set the 'done' flag for this database.
	If DATABASEPROPERTY(rtrim(@cu11DBName), 'IsReadOnly') = 1
	   begin
		goto label01
	   end


	--  Get the backup time for the last full database backup
	select @hold_backup_start_date  = (select top 1 backup_start_date from msdb.dbo.backupset 
					    where database_name = @cu11DBName
					    and backup_finish_date is not null
					    and type = 'D'
					    order by backup_start_date desc)


	--  Check to see if the backup start date is null.  If so, this database may have never been backed up.
	--  Raise an error and move on to the next database.
	If @hold_backup_start_date is null
	   begin
		select @miscprint = 'DBA WARNING: No Full Backups exist for Database ''' + @cu11DBName + ''''
		raiserror(@miscprint,-1,-1) with log
		goto label01
	   end


	--  Check to see if the last full backup was within the requested database backup time period.
	--  If not, raise an error and move on to the next database. 
	If @hold_backup_start_date < getdate()-@backup_full_dd_period
	   begin
		select @miscprint = 'DBA WARNING: No Full Backup exists for Database ''' 
							+ @cu11DBName + ''' within the past ' + convert(varchar(5), @backup_full_dd_period) + ' day(s)'
		raiserror(@miscprint,-1,-1) with log
		goto label01
	   end


	-- Check for the 'truncate log on check point' option.  If found, we're done checking this database.
	If databaseproperty(rtrim(@cu11DBName), 'IsTrunclog') = 1
	   begin
		goto label01
	   end

	-- Check for the 'bulk copy' option.  If found, we're done checking this database.
	If databaseproperty(rtrim(@cu11DBName), 'IsBulkCopy') = 1
	   begin
		goto label01
	   end

	--  If the last DB backup time was older than the @backup_diff_dd_period limit, check for differentials
	If @hold_backup_start_date < getdate()-@backup_diff_dd_period
	   begin
		select @hold_backup_start_date  = (select top 1 backup_start_date from msdb.dbo.backupset 
						    where database_name = @cu11DBName
						    and backup_finish_date is not null
						    and type = 'I'
						    order by backup_start_date desc)

		--  Check to see if the last differential was within the requested database backup time period.
		--  If not, raise an error and move on to the next database. 
		If @hold_backup_start_date < getdate()-@backup_full_dd_period
		   begin
			select @miscprint = 'DBA WARNING: No Differential Backup exists for Database ''' 
								+ @cu11DBName + ''' within the past ' + convert(varchar(5), @backup_diff_dd_period) + ' day(s)'
			raiserror(@miscprint,-1,-1) with log
			goto label01
		   end

	   end


	--  At this point we know the DB has a good backup file and is in recovery full mode, so it should have a valid tranlog backup
	select @hold_backup_start_date  = (select top 1 backup_start_date from msdb.dbo.backupset 
					    where database_name = @cu11DBName
					    and backup_finish_date is not null
					    and type = 'L'
					    order by backup_start_date desc)


	--  Check to see if the backup start date is null.  If so, the tranlog may have never been backed up.
	--  Raise an error and move on to the next database.
	If @hold_backup_start_date is null
	   begin
		select @miscprint = 'DBA WARNING: No TranLog Backups exist for Database ''' + @cu11DBName + ''''
		raiserror(@miscprint,-1,-1) with log
		goto label01
	   end


	--  Check to see if the last TranLog backup was within the requested TranLog backup time period.
	--  If not, raise an error and move on to the next database. 
	If @tranlog_hh_period < DATEDIFF(hour, @hold_backup_start_date, getdate())
	   begin
		select @miscprint = 'DBA WARNING: No Current Transaction Log Backup exists for Database ''' + @cu11DBName + ''''
		raiserror(@miscprint,-1,-1) with log
		goto label01
	   end



	label01:



	--  Remove this record from @dbname and go to the next
	delete from @dbnames where name = @cu11DBName
	If (select count(*) from @dbnames) > 0
	   begin
		goto start_dbnames
	   end

   end

---------------------------  Finalization  -----------------------
label99:


skip_all:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_BusWare
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_BusWare]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_BusWare]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_Check_BusWare


/*********************************************************
 **  Stored Procedure dbasp_Check_BusWare                  
 **  Written by Jim Wilson, Getty Images                
 **  March 29, 2005                                      
 **  
 **  This procedure checks for the existance of the BusinessWare
 **  related extended sproc.  If needed, the xp_sproc will be
 **  installed via this process.  Files related to this process will
 **  be on the central server in the builds share under the BusWare folder.
 **
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/29/2002	Jim Wilson		New process
--	01/03/2007	Jim Wilson		Updated for 2_10_2006 version
--	12/18/2007	Jim Wilson		Updated for SQL2005
--	02/11/2008	Jim Wilson		Added skip for DB's that are not online.
--	10/09/2009	Jim Wilson		Removed code for systeminfo.
--	======================================================================================

/***

--***/


DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd				nvarchar(500)
	,@doesexist			int
	,@save_dbname			sysname
	,@save_version			sysname
	,@save_centralserver		sysname
	,@save_bittype			nvarchar(10)
	,@run_process			char(1)
	,@install_path 			sysname
	,@returnvalue			int

----------------  initial values  -------------------
Select @run_process = 'n'


--  Create table variable
declare @tblv_DBname table (dbname sysname)



--  Check to see if this sql instance is on the list for BusWare
If exists (select * from dbo.BusWare_cntl where cmptName = @@servername)
   begin
	Print 'Check BusinessWare Setup Process Starting on server ' + @@servername + ' at ' + convert(varchar(20), getdate(), 121)
	Select @save_version = (select version from dbo.BusWare_cntl where cmptName = @@servername)
   end
Else
   begin
	Print 'This instance of SQL does not need the BusinessWare setup.'
	goto label99
   end


--  Capture the list of related database names for this server
Insert into @tblv_DBname (dbname)
SELECT s.name 
From master.sys.databases  s with (NOLOCK), dbaadmin.dbo.BusWare_cntl  b with (NOLOCK)
Where b.cmptType = 'database'
  and s.name = b.cmptName


--  Get the central server name
Select @save_centralserver = (select env_detail from dbo.Local_ServerEnviro where env_type = 'CentralServer')
--print @save_centralserver


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Check to see if the xp_sprcos already exist
If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_init')
   begin
	Print 'xp_sqljdbc_xa_init not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_start')
   begin
	Print 'xp_sqljdbc_xa_start not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_end')
   begin
	Print 'xp_sqljdbc_xa_end not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_prepare')
   begin
	Print 'xp_sqljdbc_xa_prepare not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_commit')
   begin
	Print 'xp_sqljdbc_xa_commit not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_rollback')
   begin
	Print 'xp_sqljdbc_xa_rollback not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_forget')
   begin
	Print 'xp_sqljdbc_xa_forget not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_recover')
   begin
	Print 'xp_sqljdbc_xa_recover not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_rollback_ex')
   begin
	Print 'xp_sqljdbc_xa_rollback_ex not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_forget_ex')
   begin
	Print 'xp_sqljdbc_xa_forget_ex not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end

If not exists (select * from master.sys.objects where name = 'xp_sqljdbc_xa_prepare_ex')
   begin
	Print 'xp_sqljdbc_xa_prepare_ex not found'
	Select @run_process = 'y'
	goto start_run_xp_process
   end



--  Verfiy the last installed BusWare version matches the expected version 
If @save_version <> (select top 1 vchNotes from dbo.build where vchName = 'BusWare' order by iBuildID desc)
   begin
	Print 'Last version installed does not match expected version'
	Select @run_process = 'y'
	goto start_run_xp_process
   end


--  If all XP related items are in place, move to the user table check section
If @run_process = 'n'
   begin
	Print 'BusinessWare extended stored procedures are in place from a previous install.'
	goto start_run_tbl_process
   end



-----------------------------------------------------------------------------------------------
--  This section will install the sqljdbc_xa.dll and related xp_sprocs
-----------------------------------------------------------------------------------------------
start_run_xp_process:

--  Get the sql install path
--exec master.dbo.sp_MSget_setup_paths @sql_path = @install_path output
exec @returnvalue = master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE',N'Software\Microsoft\MSSQLServer\Setup',N'SQLPath', @install_path output, 'no_output'
--print @install_path

--  Determine if we are running 32 or 64 bit
If (select @@version) like '%X64%'
   begin
	Select @save_bittype = 'x64'
   end  
Else
   begin
	Select @save_bittype = 'x86'
   end  

--  Copy the sqljdbc_xa.dll file to the local BINN folder
Select @cmd = 'xcopy "\\' + rtrim(@save_centralserver) + '\' + rtrim(@save_centralserver) + '_builds\BusWare2005\' + rtrim(@save_version) + '\' + @save_bittype + '\sqljdbc_xa.dll" "' + rtrim(@install_path) + '\BINN"'
Select @cmd = @cmd + ' /Y /R'
Print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 


--  Now run the script to create the xp_sprocs
Select @cmd = 'sqlcmd -S' + @@servername + ' -E -w265 -i\\' + rtrim(@save_centralserver) + '\' + rtrim(@save_centralserver) + '_builds\BusWare2005\' + rtrim(@save_version) + '\instjdbc.sql'
Print @cmd
exec master.sys.xp_cmdshell @cmd--, no_output



--  Update the dbaadmin build table
EXEC dbo.UpdateDBAadminBuild 'BusWare', @save_version, @save_version




-----------------------------------------------------------------------------------------------
--  This section will check to make sure the related user databases have the table RDBMSCommits
-----------------------------------------------------------------------------------------------
start_run_tbl_process:

If (select count(*) from @tblv_DBname) = 0
   begin
	goto label99
   end


Select @save_dbname = (select top 1 dbname from @tblv_DBname)


If (SELECT DATABASEPROPERTYEX (@save_dbname,'status')) <> 'ONLINE'
   begin
	goto skip_table_check
   end


Select @cmd = 'USE ' + quotename(@save_dbname) + ' SELECT @doesexist = OBJECT_ID(''RDBMSCommits'')'
--Print @cmd

EXEC sp_executesql @cmd, N'@doesexist int output', @doesexist output


If @doesexist is null
   begin
	Select @cmd = 'sqlcmd -S' + @@servername + ' -d' + rtrim(@save_dbname) + ' -E -w245 -i\\' + rtrim(@save_centralserver) + '\' + rtrim(@save_centralserver) + '_builds\BusWare2005\' + rtrim(@save_version) + '\RDBMSCommits.sql'
	Print @cmd
	exec master.sys.xp_cmdshell @cmd--, no_output
   end


skip_table_check:


Delete from @tblv_DBname where dbname = @save_dbname

If (select count(*) from @tblv_DBname) > 0
   begin
	goto start_run_tbl_process
   end




--  Finalization  --------------------------------------------------------------------------------------------------
label99:

Print 'Check BusinessWare Setup Process Complete'



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_Contention
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_Contention]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_Contention]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Check_Contention


/*********************************************************
 **  Stored Procedure dbasp_Check_Contention                  
 **  Written by Jim Wilson, Getty Images                
 **  March 22, 2005                                      
 **  
 **  This procedure captures information about DB contentions and blocks.
 **  The information is inserted into a table in the dbaadmin database.
 **
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/24/2005	Jim Wilson		New sproc to replace dbasp_check_blocking
--	09/29/2005	Jim Wilson		Added kpid and waittype capture and removed 
--						thread count.
--	08/22/2006	Jim Wilson		Updated for SQL 2005 
--	09/07/2006	Jim Wilson		Modified waittime to bigint 
--	04/10/2007	Jim Wilson		Added purge after 90 days 
--	04/25/2007	Jim Wilson		Added identity column to temp table 
--	02/11/2008	Jim Wilson		Modified raiserror to -1,-1. 
--	04/09/2008	Jim Wilson		Added top 1 to yet another sub query. 
--	07/24/2008	Jim Wilson		Added top 1 to yet another sub query. 
--	======================================================================================

/***

--***/


DECLARE
	 @miscprint			varchar(8000)
	,@dbcccmd			nvarchar(50)
	,@charpos			int	

DECLARE
	 @hold_lastwaittype		nvarchar(32)
	,@hold_waitresource		nvarchar(256)	

DECLARE
	 @save_spid			smallint
	,@save_kpid			smallint
	,@save_status			nvarchar(30)
	,@save_hostname			sysname
	,@save_program_name		sysname
	,@save_cmd			nvarchar(16)
	,@save_blocked			smallint
	,@save_dbid			smallint
	,@save_loginame			sysname
	,@save_open_tran		smallint
	,@save_waitresource		nvarchar(2000)
	,@save_waittime			bigint
	,@save_victim_MAXwaittime	bigint
	,@save_waittype			binary (2)
	,@save_sql_handle		binary(20)
	,@save_lastwaittype		nvarchar(2000)
	,@save_InputBuffer		nvarchar(255)
	,@BLOCKER_SQL			varchar(8000)
	,@BLOCKED_SQL			varchar(8000)
	,@victim_block_count		int
	,@head_blocker_flag		nchar(1)


----------------  initial values  -------------------

--  Create table variables
declare @probclients table	(probclientsID	int IDENTITY (1, 1) NOT NULL
				,spid 		smallint
				,kpid 		smallint
				,ecid 		smallint
				,context_info	binary(128)
				,blocked 	smallint
				,waittype 	binary(2)
				,waittime	bigint
				,lastwaittype   nvarchar(32)
				,waitresource 	nvarchar(256)
				,dbid 		smallint
				,open_tran	smallint
				,status		nvarchar(30)
				,hostname	nvarchar(128)
				,loginame	nvarchar(128)
				,program_name	nvarchar(128)
				,cmd		nvarchar(16)
				,sql_handle	binary(20)
				,primary key 	(blocked, spid, ecid, probclientsID)
				)


declare @tvar_lastwaittype table(lastwaittype nvarchar(32))

declare @tvar_waitresource table(waitresource nvarchar(256))

insert @probclients 
select spid, kpid, ecid, context_info, blocked, waittype, waittime, lastwaittype, waitresource, dbid, open_tran, status, hostname, loginame, program_name, cmd, sql_handle
from master.sys.sysprocesses (nolock)

Delete from @probclients
where waittype = 0x020B
or (waittype = 0x0000
and spid not in (select blocked from @probclients where blocked <> 0))

--select * from @probclients order by spid



--  Check to see if we have anything to process
If exists (select spid from @probclients where blocked = 0 and spid in (select blocked from @probclients where spid != 0))
   begin
	Print 'Head of Blocking Chain found'
	goto start_blocking_head
   end
Else If exists (select 1 from @probclients where ecid <> 0)
   begin
	If exists (select 1 from @probclients where lastwaittype like ('%CXPACKET%'))
	   begin
		Print 'Some contention found on server ' + @@servername + ' at ' + convert(varchar(20), getdate(), 121)
		delete from @probclients where spid < 21 and blocked = 0 
		goto start_other_contention
	   end
	Else
	   begin
		Print 'No contention found on server ' + @@servername + ' at ' + convert(varchar(20), getdate(), 121)
		goto label99
	   end
   end
Else
   begin
	Print 'No contention found on server ' + @@servername + ' at ' + convert(varchar(20), getdate(), 121)
	goto label99
   end




/****************************************************************
 *                MainLine
 ***************************************************************/

--  Process blockers at the head of the blocking chain  ----------------------------------------------------------------------
start_blocking_head:

Select @save_spid = (select top 1 spid from @probclients where blocked = 0 and spid in (select blocked from @probclients where spid != 0))
Select @save_kpid = (select top 1 kpid from @probclients where spid = @save_spid)

Select @head_blocker_flag = 'y'

Select @victim_block_count =	(select count(*) from @probclients where blocked = @save_spid)

Select @save_victim_MAXwaittime = (select max(waittime) from @probclients where blocked = @save_spid)
Select @save_victim_MAXwaittime = Case 
				when @save_victim_MAXwaittime is null then 0
				else @save_victim_MAXwaittime
			   end

Select @save_waittype = (select MAX(waittype) from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_blocked = 0

Select @save_waittime = (select MAX(waittime) from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_lastwaittype = (select MAX(lastwaittype) from @probclients where spid = @save_spid and kpid = @save_kpid)

If @save_lastwaittype = '' or @save_lastwaittype = ' ' or @save_lastwaittype is null
   begin
	Select @save_lastwaittype = '--blank--'
   end


Select @save_waitresource = (select top 1 waitresource from @probclients where spid = @save_spid and kpid = @save_kpid)

If @save_waitresource = '' or @save_waitresource = ' ' or @save_waitresource is null
   begin
	Select @save_waitresource = '--blank--'
   end


Select @save_dbid = (select top 1 dbid from @probclients where spid = @save_spid and kpid = @save_kpid)


Select @save_open_tran = (select top 1 open_tran from @probclients where spid = @save_spid and kpid = @save_kpid) 


Select @save_status = (select top 1 status from @probclients where spid = @save_spid and kpid = @save_kpid)
If @save_status in ('sleeping', 'background')
   begin
	select @save_status = lower(@save_status)
   end
Else
   begin
	select @save_status = upper(@save_status)
   end



Select @save_hostname = (select top 1 hostname from @probclients where spid = @save_spid and kpid = @save_kpid)
Select @save_hostname = Case 
			   when @save_hostname is null then ' '
			   else @save_hostname
			end


Select @save_loginame = (select top 1 loginame from @probclients where spid = @save_spid and kpid = @save_kpid)


Select @save_program_name = (select top 1 program_name from @probclients where spid = @save_spid and kpid = @save_kpid)


Select @save_cmd = (select top 1 cmd from @probclients where spid = @save_spid and kpid = @save_kpid)


Select @save_sql_handle = (select top 1 sql_handle from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @BLOCKER_SQL = text from ::fn_get_sql(@save_sql_handle)

If @BLOCKER_SQL is null
   begin
    Select @BLOCKER_SQL = ''
   end

--  Insert this information into the check_contention table
INSERT INTO dbaadmin.dbo.check_contention	(Spid
					,HeadBlocker
					,VictimBlockCount
					,VictimMaxWaittime
					,kpid
					,Blocked
					,waittype
					,Waittime
					,Lastwaittype
					,Waitresource
					,Status
					,OpenTran
					,Dbid
					,Hostname
					,Loginame
					,ProgramName
					,Cmd
					,InputBuffer)
			VALUES	(@save_spid
				,@head_blocker_flag
				,@victim_block_count
				,@save_victim_MAXwaittime
				,@save_kpid
				,@save_blocked
				,@save_waittype
				,@save_waittime
				,@save_lastwaittype
				,@save_waitresource
				,@save_status
				,@save_open_tran
				,@save_dbid
				,@save_hostname
				,@save_loginame
				,@save_program_name
				,@save_cmd
				,@BLOCKER_SQL)


--  Raise an error for the head blocker
Select @miscprint = 'DBA WARNING: Block Detected - Culprit is spid ' + convert(varchar(20),@save_spid) + ' for dbid ' + convert(varchar(20), @save_dbid)
raiserror(@miscprint,-1,-1) with log

Delete from @probclients where spid = @save_spid and kpid = @save_kpid

If exists (select spid from @probclients where blocked = 0 and spid in (select blocked from @probclients where spid != 0))
   begin
	goto start_blocking_head
   end


--  If a system spid is not at the head of the blocking chain and is not blocked by another process
--  do not report it
delete from @probclients where spid < 21 and blocked = 0 

--  If no more records to process, end
If (select count(*) from @probclients) = 0
   begin
	goto label99
   end




--  Process other contention  ------------------------------------------------------------------------------------------------------
start_other_contention:

Select @save_spid = (select top 1 spid from @probclients)
Select @save_kpid = (select top 1 kpid from @probclients where spid = @save_spid)

Select @head_blocker_flag = 'n'
Select @victim_block_count = 0
Select @save_victim_MAXwaittime = 0

Select @save_waittype = (select MAX(waittype) from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_blocked = (select MAX(blocked) from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_waittime = (select MAX(waittime) from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_lastwaittype = (select top 1 lastwaittype from @probclients where spid = @save_spid and kpid = @save_kpid)

If @save_lastwaittype = '' or @save_lastwaittype = ' ' or @save_lastwaittype is null
   begin
	Select @save_lastwaittype = '--blank--'
   end


Select @save_waitresource = (select top 1 waitresource from @probclients where spid = @save_spid and kpid = @save_kpid)

If @save_waitresource = '' or @save_waitresource = ' ' or @save_waitresource is null
   begin
	Select @save_waitresource = '--blank--'
   end


Select @save_dbid = (select top 1 dbid from @probclients where spid = @save_spid and kpid = @save_kpid)


Select @save_open_tran = (select top 1 open_tran from @probclients where spid = @save_spid and kpid = @save_kpid) 


Select @save_status = (select top 1 status from @probclients where spid = @save_spid and kpid = @save_kpid)
If @save_status in ('sleeping', 'background')
   begin
	select @save_status = lower(@save_status)
   end
Else
   begin
	select @save_status = upper(@save_status)
   end


Select @save_hostname = (select top 1 hostname from @probclients where spid = @save_spid and kpid = @save_kpid)
Select @save_hostname = Case 
			   when @save_hostname is null then ' '
			   else @save_hostname
			end


Select @save_loginame = (select top 1 loginame from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_program_name = (select top 1 program_name from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_cmd = (select top 1 cmd from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @save_sql_handle = (select top 1 sql_handle from @probclients where spid = @save_spid and kpid = @save_kpid)

Select @BLOCKED_SQL = text from ::fn_get_sql(@save_sql_handle)

If @BLOCKED_SQL is null
   begin
    Select @BLOCKED_SQL = ''
   end


--  Insert this information into the check_contention table
INSERT INTO dbaadmin.dbo.check_contention	(Spid
					,HeadBlocker
					,VictimBlockCount
					,VictimMaxWaittime
					,kpid
					,Blocked
					,waittype
					,Waittime
					,Lastwaittype
					,Waitresource
					,Status
					,OpenTran
					,Dbid
					,Hostname
					,Loginame
					,ProgramName
					,Cmd
					,InputBuffer)
			VALUES	(@save_spid
				,@head_blocker_flag
				,@victim_block_count
				,@save_victim_MAXwaittime
				,@save_kpid
				,@save_blocked
				,@save_waittype
				,@save_waittime
				,@save_lastwaittype
				,@save_waitresource
				,@save_status
				,@save_open_tran
				,@save_dbid
				,@save_hostname
				,@save_loginame
				,@save_program_name
				,@save_cmd
				,@BLOCKED_SQL)


Delete from @probclients where spid = @save_spid

If (select count(*) from @probclients) > 0
   begin
	goto start_other_contention
   end



--  Finalization  --------------------------------------------------------------------------------------------------
label99:

delete from dbo.check_contention where CreateDate < getdate()-90

Print 'Check Contention Process Complete'
Print ''
Print ''




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_DBUsers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_DBUsers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_DBUsers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Check_DBUsers

/*********************************************************
 **  Stored Procedure dbasp_Check_DBUsers                  
 **  Written by Jim Wilson, Getty Images                
 **  February 6, 2001                                      
 **  
 **  This procedure checks for orphaned SQL Users
 **  and raises a DBA warning to the error log if any
 **  are found.  This process also checks for object ownership
 **  issues related to any DB users.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	10/04/2002	Jim Wilson		Fixed main select from sysusers 
--						(added sid is not null)
--	10/11/2002	Jim Wilson		Added check for out-of-sync users 
--	04/14/2003	Jim Wilson		Added check for orphaned permissions and
--						orphaned sysobject owners. 
--	06/27/2003	Jim Wilson		Fix error on sysobject uid output
--	08/02/2004	Jim Wilson		Fix bracket problem on dbname (with dash) in cursor
--	11/01/2004	Jim Wilson		Added check for DBO status (should be 2)
--	11/19/2004	Jim Wilson		Updated dbo check (sid must be in master..sysxlogins)
--	09/26/2005	Jim Wilson		New code to check for suser_sname for orphaned DB owner
--	05/31/2006	Jim Wilson		Updated for SQL 2005.
--	07/23/2007	Jim Wilson		Added check for object ownership problems.
--	05/07/2008	Jim Wilson		Added skip DB if status != online.  
--						Also added drop unused schemas.
--	05/09/2008	Jim Wilson		Added if not read only to unused schema delete code.  
--	07/07/2009	Jim Wilson		Revised code for suser_sname.
--	07/09/2009	Jim Wilson		Added code for no_check table - baseline.
--	08/12/2009	Jim Wilson		Added check for invalid default schema.
--	10/28/2009	Jim Wilson		New code to fix invalid default schema.
--	======================================================================================


DECLARE
	 @miscprint		nvarchar(4000)
	,@count			int
	,@cmd 			nvarchar(500)
	,@vars 			nvarchar(500)
	,@return_var 		int
	,@save_sid		varbinary(85)
	,@query			nvarchar(4000)
	,@save_schema_name	sysname


DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu22Oname		sysname
	,@cu22orph_sid		varbinary(85)
	,@cu23Oname		sysname
	,@cu23orph_sid		varbinary(85)
	,@cu24grantee		smallint
	,@cu26schema_id		smallint
	,@cu27schema_name	sysname
	,@cu28principal_name	sysname
	,@cu31user_name		sysname


--  Create temp tables

create table #orphans(orph_sid varbinary(85), orph_name sysname null)
create table #orphan_perms (orph_grantee smallint)
create table #orphan_obj (orph_schema_id smallint)
create table #orphan_sch (orph_schema_name sysname)
create table #orphan_prn (orph_name sysname null)
Create table #enyc_info (enyc_name sysname)


--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.databases   d ' + 
  'Where d.name not in (''model'', ''tempdb'')
   Order By d.name For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	

    If (DATABASEPROPERTYEX(@cu11DBName, N'Status') != N'ONLINE')
       begin
          goto skip_db 
       end


    If @cu11DBName in (select detail01 from dbo.no_check where nocheck_type = 'baseline')
       begin
          goto skip_db 
       end



    --------------------  Capture and Process Orphan user Info  -------------------
    delete from #orphans
    insert into #orphans 	Execute('select sid, name from [' + @cu11DBName + '].sys.sysusers 
			    where sid not in (select sid from master.sys.syslogins where name is not null and sid is not null) 
			    and name not in (''guest'')
			    and sid is not null
			    and issqlrole = 0
			    ')

    select @count = (select count(*) from #orphans)

    If @count > 0
       begin
	    EXECUTE('DECLARE cu22_orphs Insensitive Cursor For ' + 
	      'SELECT o.orph_name, o.orph_sid
	       From #orphans  o ' + 
	      'For Read Only')

	    OPEN cu22_orphs

	    WHILE (22=22)
	       Begin
		    FETCH Next From cu22_orphs Into @cu22Oname, @cu22orph_sid
		    IF (@@fetch_status < 0)
		       begin
			  CLOSE cu22_orphs
			  BREAK
		       end



		    If exists (Select 1 from master.sys.syslogins where name = @cu22Oname)
		       begin
			    Select @miscprint = 'DBA WARNING: Out-of-Sync SQL USER ''' + @cu22Oname + ''' found in database ''' 
								    + @cu11DBName + ''' on server ' + @@servername 
			    raiserror(@miscprint,-1,-1) with log
		       end
		    Else If suser_sname(@cu22orph_sid) is null
		       begin
			    Select @miscprint = 'DBA WARNING: Orphaned SQL USER ''' + @cu22Oname + ''' found in database ''' 
								    + @cu11DBName + ''' on server ' + @@servername 
			    raiserror(@miscprint,-1,-1) with log
		       end


	       End  -- loop 22
	       DEALLOCATE cu22_orphs
       end



    --------------------  Capture and Process disabled user Info  -------------------
    delete from #orphans
    insert into #orphans 	Execute('select sid, name from [' + @cu11DBName + '].sys.sysusers 
			    where uid > 4 
			    and islogin = 1 
			    and hasdbaccess = 0
			    and issqlrole = 0
			    ')

    delete from #orphans where orph_name like '%$%'
    delete from #orphans where orph_name like '%Clust_FullText%'


    select @count = (select count(*) from #orphans)

    If @count > 0
       begin
	    EXECUTE('DECLARE cu23_orphs Insensitive Cursor For ' + 
	      'SELECT o.orph_name, o.orph_sid
	       From #orphans  o ' + 
	      'For Read Only')

	    OPEN cu23_orphs

	    WHILE (23=23)
	       Begin
		    FETCH Next From cu23_orphs Into @cu23Oname, @cu23orph_sid
		    IF (@@fetch_status < 0)
		       begin
			  CLOSE cu23_orphs
			  BREAK
		       end



			Select @miscprint = 'DBA WARNING: Disabled (hasdbaccess=0) SQL USER ''' + @cu23Oname + ''' found in database ''' 
						    + @cu11DBName + ''' on server ' + @@servername 
			raiserror(@miscprint,-1,-1) with log


	       End  -- loop 23
	       DEALLOCATE cu23_orphs
       end


    --------------------  Capture and Process Orphan Permissions Info  -------------------
    delete from #orphan_perms

    insert into #orphan_perms	Execute('SELECT distinct grantee
  				     From [' + @cu11DBName + '].sys.syspermissions ' + 
				    'Where grantee not in (select uid from [' + @cu11DBName + '].sys.sysusers)
				    ')

    select @count = (select count(*) from #orphan_perms)


    EXECUTE('DECLARE cu24_perms Insensitive Cursor For ' + 
      'SELECT o.orph_grantee
       From #orphan_perms  o ' + 
      'For Read Only')

    OPEN cu24_perms

    WHILE (24=24)
       Begin
	    FETCH Next From cu24_perms Into @cu24grantee 
	    IF (@@fetch_status < 0)
	       begin
		  CLOSE cu24_perms
		  BREAK
	       end



	    Select @miscprint = 'DBA WARNING: Orphaned permissions found in database ''' + @cu11DBName + ''' on server ' 
						    + @@servername + '.  SQL user is UID=' + convert(varchar(10), @cu24grantee) + '.  No such user exists.'   
	    raiserror(@miscprint,-1,-1) with log


       End  -- loop 24
       DEALLOCATE cu24_perms





    --------------------  Capture and Process Orphan Object Schema Info  -------------------
    delete from #orphan_obj

    insert into #orphan_obj		Execute('SELECT distinct schema_id
  				     From [' + @cu11DBName + '].sys.objects ' + 
				    'Where schema_id not in (select schema_id from [' + @cu11DBName + '].sys.schemas)
				    ')

    select @count = (select count(*) from #orphan_obj)


    EXECUTE('DECLARE cu26_obj Insensitive Cursor For ' + 
      'SELECT o.orph_schema_id
       From #orphan_obj  o ' + 
      'For Read Only')

    OPEN cu26_obj

    WHILE (26=26)
       Begin
	    FETCH Next From cu26_obj Into @cu26schema_id 
	    IF (@@fetch_status < 0)
	       begin
		  CLOSE cu26_obj
		  BREAK
	       end



	    Select @miscprint = 'DBA WARNING: Orphaned sys.object schema found in database ''' + @cu11DBName + ''' on server ' 
						    + @@servername + '.  Schema_id=' + convert(varchar(10), @cu26schema_id) + '.  No such schema exists.' 
	    raiserror(@miscprint,-1,-1) with log


       End  -- loop 26
       DEALLOCATE cu26_obj





    --------------------  Remove un-used Schemas  -------------------
    If (DATABASEPROPERTYEX(@cu11DBName, N'Updateability') != N'READ_ONLY')
       begin
	    delete from #orphan_sch
    
	    insert into #orphan_sch		Execute('SELECT distinct name
	  				     From [' + @cu11DBName + '].sys.schemas s ' + 
					    'Where s.schema_id > 4 and s.schema_id < 16380 and not exists (select name from [' + @cu11DBName + '].sys.objects o where o.schema_id = s.schema_id)
					    ')

	    select @count = (select count(*) from #orphan_sch)


	    If @count > 0
	       begin
		drop_schema01:
		Select @save_schema_name = (select top 1 orph_schema_name from #orphan_sch)
		Select @cmd = 'use [' + @cu11DBName + '] DROP SCHEMA [' + @save_schema_name + '];'
		Print @cmd
		Exec (@cmd)
	       end 


	    Delete from #orphan_sch where orph_schema_name = @save_schema_name
	    If (select count(*) from #orphan_sch) > 0
	       begin
		    goto drop_schema01
	       end
       end



    --------------------  Capture and Process Orphan Schema Info  -------------------
    delete from #orphan_sch

    insert into #orphan_sch		Execute('SELECT distinct name
  				     From [' + @cu11DBName + '].sys.schemas ' + 
				    'Where principal_id not in (select principal_id from [' + @cu11DBName + '].sys.database_principals)
				    ')

    select @count = (select count(*) from #orphan_sch)


    EXECUTE('DECLARE cu27_sch Insensitive Cursor For ' + 
      'SELECT o.orph_schema_name
       From #orphan_sch  o ' + 
      'For Read Only')

    OPEN cu27_sch

    WHILE (27=27)
       Begin
	    FETCH Next From cu27_sch Into @cu27schema_name 
	    IF (@@fetch_status < 0)
	       begin
		  CLOSE cu27_sch
		  BREAK
	       end



	    Select @miscprint = 'DBA WARNING: Orphaned schema found in database ''' + @cu11DBName + ''' on server ' 
						    + @@servername + '.  Schema name = ' + @cu27schema_name + '.  The related principal_id does not exist.' 
	    raiserror(@miscprint,-1,-1) with log


       End  -- loop 27
       DEALLOCATE cu27_sch





    --------------------  Capture and Process (fix) Orphan default-Schema Info  -------------------
    delete from #orphan_sch

    insert into #orphan_sch		Execute('SELECT distinct name
  				     From [' + @cu11DBName + '].sys.database_principals ' + 
				    'Where default_schema_name not in (select name from [' + @cu11DBName + '].sys.schemas)
				    ')


    select @count = (select count(*) from #orphan_sch)


    EXECUTE('DECLARE cu31_sch Insensitive Cursor For ' + 
      'SELECT o.orph_schema_name
       From #orphan_sch  o ' + 
      'For Read Only')

    OPEN cu31_sch

    WHILE (31=31)
       Begin
	    FETCH Next From cu31_sch Into @cu31user_name 
	    IF (@@fetch_status < 0)
	       begin
		  CLOSE cu31_sch
		  BREAK
	       end



		select @cmd = 'use [' + @cu11DBName + '] ALTER USER [' + @cu31user_name + '] WITH DEFAULT_SCHEMA=dbo'

		EXEC sp_executesql @cmd


	    Select @miscprint = 'DBA WARNING: DB User with invalid default schema found in database ''' + @cu11DBName + ''' on server ' 
						    + @@servername + '.  User name = ' + @cu31user_name + '.  The default schema does not exist and is being changed to dbo.' 
	    raiserror(@miscprint,-1,-1) with log


       End  -- loop 31
       DEALLOCATE cu31_sch



    --------------------  Capture and Process orphaned Principal Info  -------------------
    delete from #orphan_prn

    insert into #orphan_prn		Execute('SELECT name
  				     From [' + @cu11DBName + '].sys.database_principals ' + 
				    'Where sid not in (select sid from master.sys.syslogins where sid is not null)
				     and sid is not null
				     and type in (''S'', ''U'')
				     and name not in (''dbo'', ''guest'')
				    ')

    select @count = (select count(*) from #orphan_prn)


    EXECUTE('DECLARE cu28_prn Insensitive Cursor For ' + 
      'SELECT o.orph_name
       From #orphan_prn  o ' + 
      'For Read Only')

    OPEN cu28_prn

    WHILE (28=28)
       Begin
	    FETCH Next From cu28_prn Into @cu28principal_name
	    IF (@@fetch_status < 0)
	       begin
		  CLOSE cu28_prn
		  BREAK
	       end


	    If SUSER_SID(@cu28principal_name) is null
	       begin
		    Select @miscprint = 'DBA WARNING: Orphaned principal found in database ''' + @cu11DBName + ''' on server ' 
						    + @@servername + '.  Principal name = ' + @cu28principal_name + '.  The related login does not exist.' 
		    raiserror(@miscprint,-1,-1) with log
	       end


       End  -- loop 28
       DEALLOCATE cu28_prn


    --------------------  Check DBO Status  -------------------

	    --  Check for null sid
	    set @return_var = 0
	    SET @cmd = N'IF exists (SELECT 1 FROM [' + @cu11DBName + '].sys.sysusers WHERE name = ''dbo'' and sid is null) SET @return_var = @return_var + 1'
	    SET @vars = N'@return_var integer OUTPUT'

	    exec sp_executeSQL @cmd, @vars, @return_var OUTPUT

	    If @return_var <> 0
	       begin
		    Select @miscprint = 'DBA WARNING: Invalid Status (null sid) for DBO found in database ''' 
							    + @cu11DBName + ''' on server ' + @@servername + '. ' 
		    raiserror(@miscprint,-1,-1) with log
		    --Print @miscprint
		    goto label91
	       end

	    --  Check for dbo sid that does not exist in master
	    set @return_var = 0
	    SET @cmd = N'IF not exists (SELECT 1 FROM [' + @cu11DBName + '].sys.sysusers u, master.sys.syslogins x ' 
				    + 'WHERE u.name = ''dbo'' and u.sid = x.sid) SET @return_var = @return_var + 1'
	    SET @vars = N'@return_var integer OUTPUT'

	    exec master.sys.sp_executeSQL @cmd, @vars, @return_var OUTPUT

	    --  The database owner is not in master.sys.syslogins.  Now make sure it is a valid NT account.
	    If @return_var <> 0
	       begin
		    
		    If (Select suser_sname(owner_sid) from master.sys.databases where name = @cu11DBName) is null
		       begin
			    Select @miscprint = 'DBA WARNING: Invalid SID for DBO found in database ''' + @cu11DBName + ''' on server ' + @@servername + '. ' 
			    raiserror(@miscprint,-1,-1) with log
			    --Print @miscprint
			    goto label91
		       end
	       end

	    label91:



    --------------------  Check Object Ownership  -------------------


    --  Check encryption related ownership
    Select @query = 'select sk.name 
			    from [' + @cu11DBName + '].sys.database_principals dp 
			    inner join [' + @cu11DBName + '].sys.symmetric_keys sk 
			    on dp.principal_id = sk.principal_id 
			    where dp.name <> ''dbo'''
    --print @query
    Delete from #enyc_info
    Insert into #enyc_info exec (@query)

    If (select count(*) from #enyc_info) > 0
       begin
	    Select @miscprint = 'DBA WARNING: A symmetric_key in database [' + @cu11DBName + '] is not owned by ''dbo''.  Check table sys.symmetric_keys.'
	    raiserror(@miscprint,-1,-1) with log
	 --Print @miscprint
       end


    Select @query = 'select sk.name 
			    from [' + @cu11DBName + '].sys.database_principals dp 
			    inner join [' + @cu11DBName + '].sys.asymmetric_keys sk 
			    on dp.principal_id = sk.principal_id 
			    where dp.name <> ''dbo'''
    --print @query
    Delete from #enyc_info
    Insert into #enyc_info exec (@query)

    If (select count(*) from #enyc_info) > 0
       begin
	    Select @miscprint = 'DBA WARNING: An asymmetric_key in database [' + @cu11DBName + '] is not owned by ''dbo''.  Check table sys.asymmetric_keys.'
	    raiserror(@miscprint,-1,-1) with log
	    --Print @miscprint
       end


    Select @query = 'select sk.name 
			    from [' + @cu11DBName + '].sys.database_principals dp 
			    inner join [' + @cu11DBName + '].sys.certificates sk 
			    on dp.principal_id = sk.principal_id 
			    where dp.name <> ''dbo'''
    --print @query
    Delete from #enyc_info
    Insert into #enyc_info exec (@query)

    If (select count(*) from #enyc_info) > 0
       begin
	    Select @miscprint = 'DBA WARNING: A certificate in database [' + @cu11DBName + '] is not owned by ''dbo''.  Check table sys.certificates.'
	    raiserror(@miscprint,-1,-1) with log
	    --Print @miscprint
       end




    skip_db:


 End  -- loop 11


---------------------------  Finalization  -----------------------
DEALLOCATE cu11_DBNames



drop table #orphans
drop table #orphan_perms
drop table #orphan_obj
drop table #orphan_sch
drop table #orphan_prn
drop table #enyc_info


return (0)



 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_check_defrag
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_check_defrag]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_check_defrag]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_check_defrag (@check_period smallint = 7)

/**************************************************************
 **  Stored Procedure dbasp_check_defrag                  
 **  Written by Jim Wilson, Getty Images                
 **  February 13, 2008                                      
 **  
 **  This dbasp is set up to check local defrag processing.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     				Desc
--	==========	====================	=============================================
--	02/13/2008	Jim Wilson		New process for SQL 2005.
--	10/20/2009	Jim Wilson		Added no_check table lookup
--	03/23/2010	Jim Wilson		Added input parm @check_period.
--	======================================================================================

/***
Declare @check_period smallint

Select @check_period = 7
--***/


-----------------  declares  ------------------
DECLARE 
	 @cmd	 		nvarchar(4000)
	,@alert 		sysname



print convert(nvarchar(20), getdate(), 121)

--  If not production, skip this check
If (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'ENVname') <> 'production'
   begin
	goto label99
   end


--  If no full DB's and no defrag DB's, skip this check
If (select count(*) From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s
		    Where d.plan_id = s.plan_id
		     and s.plan_name like '%user_defrag%') = 0
   and (select count(*) From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s
		    Where d.plan_id = s.plan_id
		     and s.plan_name like '%user_full%') = 0
   begin
	goto label99
   end

--  If the check_maint 'skip' row exists in the Local_ServerEnviro table, skip this check
If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_maint' and env_detail = 'skip')
   begin
	goto label99
   end


--  If the 'maint' row exists in the no_check table, skip this check
If exists (select 1 from dbaadmin.dbo.no_check where NoCheck_type = 'maint' and detail01 = 'skip_check')
   begin
	goto label99
   end



If (select count(*) from dbaadmin.dbo.fragmentation_log) < 1
   begin
	Select @alert = 'No defrag has ever been run on this server (' + @@servername + ')!'
	Print @alert
	RAISERROR (67015, -1, -1, @alert) with log
   end
Else If (select max (frag_recdate) from dbaadmin.dbo.fragmentation_log) < getdate()-@check_period
   begin
	Select @alert = 'No defrag has been run in the last seven days for server (' + @@servername + ')!'
	Print @alert
	RAISERROR (67015, -1, -1, @alert) with log
   end



----------------  End  -------------------

label99:

Print ''
Print 'Defrag Check Complete.'




 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_check_errorlog
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_check_errorlog]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_check_errorlog]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_check_errorlog (@size_limit int = 500000)

/**************************************************************
 **  Stored Procedure dbasp_check_errorlog                  
 **  Written by Jim Wilson, Getty Images                
 **  Based on code from Francis Stanisci                
 **  October 9, 2003                                      
 **  
 **  This dbasp is set up to check the size of the SQL errorlog.
 **  If the errorlog is larger than the specified size limit,
 **  it will be recycled using master..sp_cycle_errorlog.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     				Desc
--	==========	====================	=============================================
--	10/09/2003	Jim Wilson				New process.
--	11/20/2003	Jim Wilson				Fixed substring of the file size number.
--	08/22/2006	Jim Wilson				Updated for SQL 2005.
--	======================================================================================

/***
Declare @size_limit int
Select @size_limit = 500
--***/


-----------------  declares  ------------------
DECLARE 
	 @cmd	 			nvarchar(500)
	,@file_size 		int
	,@max_file_size 	int
	,@charpos			int	
	,@path_log			sysname
	,@save_text			nvarchar(500)


--  Maximum allowed file size set in next statement. Adjust accordingly
If @size_limit is not null
   begin
	SET @max_file_size = @size_limit
   end
Else
   begin
	SET @max_file_size = 500000 --  set to 500kb
   end


--  Create table to hold results from DIR command
CREATE table #dir_results (dir_row varchar(255))


--  Get the path to the SQL log folder (s\b at the same path as the data folder which holds the master mdf)
select @path_log = filename from master.sys.sysfiles where name = 'master'

Select @charpos = charindex('\data\master.mdf', @path_log)
Select @path_log = substring(@path_log, 1, (@charpos - 1))
Select @path_log = @path_log + '\log'

SELECT @cmd = 'DIR "' + @path_log + '\errorlog*" /-c'


--  Execute DIR command
INSERT #dir_results
EXEC ('master.sys.xp_cmdshell ''' + @cmd + '''')

--  EXEC ('master..xp_cmdshell ''' + @install_path + '''')  /* for debugging */

--  select * from #dir_results where dir_row like '% errorlog%' /* for debugging  */


--  Extract file size for active Errorlog
SELECT @save_text = (select * FROM #dir_results WHERE dir_row like '%errorlog')

SELECT @save_text = substring(@save_text, (PATINDEX('% errorlog', @save_text))-15, 15) 

SELECT @file_size = ltrim(rtrim(@save_text))



--  Report file size
PRINT 'ERRORLOG File size is: ' + cast(@file_size as varchar(30))

IF @file_size > @max_file_size
   BEGIN
	PRINT 'This file is too large.  Cycling the SQL Errorlog'
	EXEC master.sys.sp_cycle_errorlog
   END
ELSE
   BEGIN
	PRINT 'This file size is OK'
   END



----------------  End  -------------------

drop table #dir_results




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_JoblogRename
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_JoblogRename]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_JoblogRename]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_Check_JoblogRename (@retention_days smallint = 14)

/*********************************************************
 **  Stored Procedure dbasp_Check_JoblogRename                  
 **  Written by Jim Wilson, Getty Images                
 **  November 11, 2004                                      
 **  
 **  This procedure is used to rename SQL job step logs.
 **  The process will add a date stamp at the end of the 
 **  file name, and will also delete files that are past the 
 **  retention period.
 **
 **  This proc accepts one input parm (outlined below):
 **
 **  - @retention_days is the number of days worth of sql job step
 **    logs that will be retained at any given time.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/11/2004	Jim Wilson		New process 
--	06/01/2006	Jim Wilson		Convert to SQL 2005. 
--	10/13/2008	Jim Wilson		Moved temp table creation to start. 
--	======================================================================================



/***
Declare @retention_days smallint

Select @retention_days = 14
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@charpos			int
	,@startpos			int
	,@dotpos			int
	,@uspos				int
	,@joblog_path 		nvarchar(200)
	,@save_extention	nvarchar(50)
	,@BkUpDateStmp 		char(14)
	,@Hold_hhmmss		nvarchar(8)
	,@save_filedate		sysname
	,@error_count		int

DECLARE
	 @cu11cmdoutput		nvarchar(255)



----------------  initial values  -------------------
Select @error_count = 0

Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


Select @joblog_path = '\\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs'

Set @Hold_hhmmss = convert(nvarchar(8), getdate(), 8)
Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 


--  Create temp tables
create table #fileexists ( 
			 doesexist smallint
			,fileindir smallint
			,direxist smallint
			)

create table #DirectoryTempTable(cmdoutput nvarchar(255) null)



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Verify sql job log path existance
delete from #fileexists
Insert into #fileexists exec master.sys.xp_fileexist @joblog_path

--select * from #fileexists

If not exists (select fileindir from #fileexists where fileindir = 1)
   begin
	Select @miscprint = 'DBA WARNING: dbasp_Check_JoblogRename - SQL Job Log Path does not exist.  Check standard Shares.' 
	print @miscprint
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end



--  Check to see if there are files to process
select @cmd = 'dir ' + @joblog_path + '\*.*'

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput like ('%<DIR>%')
delete from #DirectoryTempTable where cmdoutput is null


--select * from #DirectoryTempTable

If (select count(*) from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%File Not Found%') > 0
   begin
	Select @miscprint = 'DBA WARNING: dbasp_Check_JoblogRename - No files found for the Check SQL Job Log Rename process' 
	print @miscprint
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end


--  Process the sql job log files - rename or delete
EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
  'SELECT p.cmdoutput
   From #DirectoryTempTable   p ' +
  'Order by p.cmdoutput for Read Only')

OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11cmdoutput
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end

	--  Check to see if this is a record we want to process.  If not, get the next record
	If substring(@cu11cmdoutput, 3, 1) <> '/'
	   begin
		goto label50
	   end


	--  Next, remove everything but the file name.
	If substring(@cu11cmdoutput, 39, 1) = ' '
	   begin
		Select @cu11cmdoutput = substring(@cu11cmdoutput, 40, 500)
		Select @cu11cmdoutput = rtrim(@cu11cmdoutput)
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: dbasp_Check_JoblogRename - Unable to process the following.' 
		print @miscprint
		Select @miscprint = @cu11cmdoutput 
		print @miscprint
	   end



	--  Save the extension and get the dot location.
	Select @dotpos = 0
	Select @startpos = 1
	Label52:
	Select @charpos = charindex('.', @cu11cmdoutput, @startpos)
	IF @charpos <> 0
	   begin
		Select @startpos = @charpos + 1
		Select @dotpos = @charpos
		goto label52
	   end

	If @dotpos > 0
	   begin
		Select @save_extention = substring(@cu11cmdoutput, @dotpos+1, 50)
	   end
	Else
	   begin
		Select @save_extention = ''
		Select @dotpos = len(@cu11cmdoutput)
	   end



	--  Find the location of the last underscore.  If there is none, then this file needs to be renamed.
	Select @uspos = 0
	Select @startpos = 1
	Label54:
	Select @charpos = charindex('_', @cu11cmdoutput, @startpos)
	IF @charpos <> 0
	   begin
		Select @startpos = @charpos + 1
		Select @uspos = @charpos
		goto label54
	   end

	If @uspos = 0
	   begin
		Select @cmd = 'REN ' + @joblog_path + '\' + @cu11cmdoutput + ' ' + substring(@cu11cmdoutput, 1, @dotpos-1) + '_' + @BkUpDateStmp + '.' + @save_extention
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output 
		goto label50
	   end


	--  If the difference between the last underscore and the last dot is not 15, then this file needs to be renamed.
	If @dotpos - @uspos <> 15
	   begin
		Select @cmd = 'REN ' + @joblog_path + '\' + @cu11cmdoutput + ' ' + substring(@cu11cmdoutput, 1, @dotpos-1) + '_' + @BkUpDateStmp + '.' + @save_extention
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output 
		goto label50
	   end


	--  At this point, this is probably a file that was previously renamed, but we need to be sure.
	--  If any char between the underscore and the dot is alpha, rename the file.
	If substring(@cu11cmdoutput, @uspos+1, 1) not in ('2') or
	   substring(@cu11cmdoutput, @uspos+2, 1) not in ('0') or
	   substring(@cu11cmdoutput, @uspos+3, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+4, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+5, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+6, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+7, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+8, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+9, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+10, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+11, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+12, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+13, 1) not in ('1','2','3','4','5','6','7','8','9','0') or
	   substring(@cu11cmdoutput, @uspos+14, 1) not in ('1','2','3','4','5','6','7','8','9','0')
	   begin
		Select @cmd = 'REN ' + @joblog_path + '\' + @cu11cmdoutput + ' ' + substring(@cu11cmdoutput, 1, @dotpos-1) + '_' + @BkUpDateStmp + '.' + @save_extention
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output 
		goto label50
	   end


	--  PURGE Processing  ------------------------------------------------------------------------------
	--  If we are at this point, we have a file that was previously renamed.  We need to check retention
	--  for this file to see if it should be deleted.
	Select @save_filedate = substring(@cu11cmdoutput, @uspos+1, @dotpos-@uspos-7)

	If datediff(d, convert(datetime, @save_filedate), getdate()) > @retention_days
	   begin
		Select @cmd = 'DEL ' + @joblog_path + '\' + @cu11cmdoutput
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output 
	   end




	Label50:

 End  -- loop 11
 DEALLOCATE cu11_cursor



--  Finalization  -------------------------------------------------------------------

label99:


drop table #fileexists
drop table #DirectoryTempTable





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_Jobs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_Jobs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_Jobs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Check_Jobs

/***************************************************************
 **  Stored Procedure dbasp_Check_Jobs                  
 **  Written by Jim Wilson, Getty Images                
 **  May 11, 2000                                      
 **  
 **  This dbasp is set up to;
 ** 
 **  Check job status and raise errors to the SQL error log
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	06/12/2003	Jim Wilson		Add filter for jobs already reported via the 
--						periodic check process.
--	04/01/2004	Jim Wilson		Change so we don't report on job 
--						'UTIL - SQL Activity Log Process'. 
--	05/30/2006	Jim Wilson		Updated for SQL 2005. 
--	09/22/2006	Jim Wilson		Check for (and replace) '%' in message parm. 
--	04/18/2008	Jim Wilson		Now look for job steps with status 0 (failed) or 3 (cancelled)
--						This will aviod alerting for retrys. 
--	======================================================================================



-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar(4000)
	,@cursor11_text			nvarchar(1024)
	,@cursor12_text			nvarchar(1024)
	,@saverun_date			int
	,@saverun_time			int
	,@status1 			varchar(10)
	,@status2 			varchar(10)

DECLARE
	 @cu11name			sysname
	,@cu11step_name			sysname
	,@cu11sql_message_id		int
	,@cu11sql_severity		int
	,@cu11message			nvarchar(1024)
	,@cu11run_status		int
	,@cu11run_date			int
	,@cu11run_time			int

DECLARE
	 @cu12Jname			sysname
	,@cu12Sname			sysname
	,@cu12next_run_date		int


/*********************************************************************
 *                Initialization
 ********************************************************************/

--------------------  Set last-run date and time parameters  -------------------
select @saverun_date = (Select max(h.run_date) 
			from msdb.dbo.sysjobhistory  h,  msdb.dbo.sysjobs  j 
			where h.job_id = j.job_id 
			  and j.name = 'UTIL - DBA Check Misc process' 
			  and h.run_status = 1 
			  and h.step_id = 0)

If @saverun_date is not null
   begin
	select @saverun_time = (Select max(h.run_time) from msdb.dbo.sysjobhistory  h,  msdb.dbo.sysjobs  j 
				where h.job_id = j.job_id 
				  and h.run_date = @saverun_date 
				  and j.name = 'UTIL - DBA Check Misc process')
   end
Else
   begin
	select @saverun_date = convert(int,(convert(varchar(20),getdate(), 112)))
	select @saverun_time = 0
   end


/****************************************************************
 *                MainLine
 ***************************************************************/
--------------------  Cursor for Failed Job Steps  -------------------
Select @cursor11_text = 'DECLARE cu11_cursor Insensitive Cursor For ' + 
  'SELECT j.name, h.step_name, h.sql_message_id, h.sql_severity, h.message, h.run_status, h.run_date, h.run_time
   From msdb.dbo.sysjobhistory  h,  msdb.dbo.sysjobs  j ' + 
  'Where h.job_id = j.job_id
     and h.instance_ID not in (select instance_ID from dbaadmin.dbo.FailedJobs) 
     and h.run_status in (0, 3)
     and h.run_date >= ' + convert(varchar(10),@saverun_date) + '
   Order by h.job_id, h.instance_id, h.step_id For Read Only'


EXECUTE (@cursor11_text)

OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11name, @cu11step_name, @cu11sql_message_id, @cu11sql_severity, @cu11message, @cu11run_status, @cu11run_date, @cu11run_time
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end

	If @cu11run_date <> @saverun_date or
	   (@cu11run_date = @saverun_date and @cu11run_time >= @saverun_time)
	   begin
		If rtrim(@cu11name) <> 'UTIL - SQL Activity Log Process'
		   begin
			Select @cu11message = replace(@cu11message, '%', 'pct')
			Select @cu11step_name = replace(@cu11step_name, '%', 'pct')
			Select @miscprint = 'DBA WARNING: Job Step Failed - Job: ''' + @cu11name + ''' Step: ''' + @cu11step_name + ''' Message: ''' + @cu11message + ''' Date: ' + convert(varchar(10),@cu11run_date) + ' Time: ' + convert(varchar(10),@cu11run_time) 
			raiserror(@miscprint,-1,-1) with log
		   end
	   end


 End  -- loop 11

DEALLOCATE cu11_cursor



--------------------  Cursor for Next Run Date check  -------------------

--  Note:  The next run date must be at least 24 hours in the past for that job to be picked
--         up by this process.  That fixes the problem of listing jobs that are currently running.

Select @cursor12_text = 'DECLARE cu12_cursor Insensitive Cursor For ' + 
  'SELECT j.name, s.name, sj.next_run_date
   From msdb.dbo.sysjobs j, msdb.dbo.sysschedules s, msdb.dbo.sysjobschedules sj ' + 
  'Where j.job_id = sj.job_id
	 and sj.schedule_id = s.schedule_id
     and j.enabled = 1
     and s.enabled = 1
     and sj.next_run_date is not null
     and sj.next_run_date <> 0
     and sj.next_run_date < ' + convert(char(8), getdate()-1, 112) + '
   Order by j.name For Read Only'


EXECUTE (@cursor12_text)

OPEN cu12_cursor

WHILE (12=12)
 Begin
	FETCH Next From cu12_cursor Into @cu12Jname, @cu12Sname, @cu12next_run_date
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_cursor
	      BREAK
           end

	-- Check to see if the job is currently idle (not running).  If so, raise an error.
	exec dbaadmin.dbo.dbasp_Check_Jobstate @cu12Jname, @status1 output

	IF @status1 = 'idle'
	   begin
		Select @miscprint = 'DBA WARNING: Next Scheduled Run Date for Job: ''' + @cu12Jname + ''' & Schedule: ''' + @cu12Sname + ''' has past (i.e. ' + convert(char(8), @cu12next_run_date) + ').  Please stop and restart SQL Agent on this server to reset job schedules'
		raiserror(@miscprint,-1,-1) with log
	   end


 End  -- loop 12

DEALLOCATE cu12_cursor

---------------------------  Finalization  -----------------------

return 0

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_Jobstate
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_Jobstate]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_Jobstate]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_Check_Jobstate
   @job_name	sysname		= NULL
  ,@job_status	varchar(10)	OUTPUT

/*********************************************************
 **  Stored Procedure dbasp_Check_Jobstate                  
 **  Written by Jim Wilson, Getty Images                
 **  March 9, 2001                                      
 **  
 **  This dbasp is set up to check the job status of a 
 **  specific job.  The intended use of this proc is to 
 **  check to see if maintenance jobs are running prior to
 **  running a transaction log backup.
 ** 
 **  Syntax to run this proc is:
 **  declare @status varchar(10)
 **  exec dbaadmin..dbasp_Check_Jobstate "job name here...", @status output
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	05/30/2006	Jim Wilson		Updated for SQL 2005.
--	======================================================================================


/**
declare @job_name	sysname
declare @job_status	varchar(10)

select @job_name = 'UTIL - DBA Archive process'
select @job_status = null
--**/


DECLARE
	 @is_sysadmin		INT
	,@retval			INT
	,@job_owner			sysname
	,@job_id			UNIQUEIDENTIFIER
	,@job_status_num	tinyint


-- Initialize and clean-up variables
SELECT @job_name		= LTRIM(RTRIM(@job_name))
SELECT @job_id 			= NULL


-- Check for job name
IF (@job_name = N'') or (@job_name IS null)
   BEGIN
	--Print '-- Failure'
	RETURN(1) -- Failure
   END

EXECUTE @retval = msdb.dbo.sp_verify_job_identifiers '@job_name',
                                                '@job_id',
                                                 @job_name OUTPUT,
                                                 @job_id   OUTPUT
IF (@retval <> 0)
   BEGIN
	--Print '-- Failure'
	RETURN(1) -- Failure
   END


-- Step 1: Create intermediate work tables
CREATE TABLE #xp_results (job_id                UNIQUEIDENTIFIER NOT NULL,
                          last_run_date         INT              NOT NULL,
                          last_run_time         INT              NOT NULL,
                          next_run_date         INT              NOT NULL,
                          next_run_time         INT              NOT NULL,
                          next_run_schedule_id  INT              NOT NULL,
                          requested_to_run      INT              NOT NULL, -- BOOL
                          request_source        INT              NOT NULL,
                          request_source_id     sysname          NULL,
                          running               INT              NOT NULL, -- BOOL
                          current_step          INT              NOT NULL,
                          current_retry_attempt INT              NOT NULL,
                          job_state             INT              NOT NULL)

-- Step 2: Capture job execution information (for local jobs only since that's all SQLServerAgent caches)
SELECT @is_sysadmin = ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0)
SELECT @job_owner = SUSER_SNAME()
  
INSERT INTO #xp_results
   EXECUTE master.sys.xp_sqlagent_enum_jobs @is_sysadmin, @job_owner

select @job_status_num = (select job_state from #xp_results where job_id = @job_id)

DROP TABLE #xp_results

IF @job_status_num = 4
   begin
	select @job_status = 'idle'
   end
ELSE
   begin
	select @job_status = 'active'
   end


RETURN(0)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_Logins
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_Logins]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_Logins]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Check_Logins

/*********************************************************
 **  Stored Procedure dbasp_Check_Logins                  
 **  Written by Jim Wilson, Getty Images                
 **  November 30, 2000                                      
 **  
 **  This procedure checks for orphaned SQL logins
 **  and raises a DBA warning to the error log if any
 **  are found.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	01/07/2005	Jim Wilson		Added wait for delay between raiserror's
--	05/30/2006	Jim Wilson		Updated for SQL 2005.
--	11/29/2006	Jim Wilson		Added check for valid default DB.
--	02/11/2008	Jim Wilson		Added skip for DB's not online.
--	04/30/2008	Jim Wilson		Chg defaul DB to master if current default DB does not exist.
--	10/28/2008	Jim Wilson		Allow for no access to defaul DB if it is master.
--	======================================================================================


DECLARE
	 @miscprint		    nvarchar(4000)
	,@cmd			    nvarchar(500)
	,@save_dbname		    sysname

DECLARE
	 @cu11sid		    varbinary(85)
	,@cu11name		    sysname

DECLARE
	 @cu21sid		    varbinary(85)
	,@cu21Login_name	    sysname
	,@cu21default_database_name sysname


--------------------  Capture Orphan Login Info  -------------------

create table #orphans(orph_sid varbinary(85), orph_name sysname null)

insert into #orphans exec master.sys.sp_validatelogins


--------------------  Define cursor  -------------------

EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
  'SELECT o.orph_sid, o.orph_name
   From #orphans   o ' +
  'For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11sid, @cu11name
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end

	If @cu11name like '%SQLServer2005%'
	   begin
	    goto skip11
	   end

	Select @miscprint = 'DBA WARNING: Orphaned SQL Login found on server ' + @@servername + ' - ''' + @cu11name + '''' 
	raiserror(@miscprint,-1,-1) with log
	Waitfor delay '00:00:02'

    skip11:


 End  -- loop 11

DEALLOCATE cu11_cursor




-- Now check to see if all Logins have access to their default DB

--------------------  Define cursor  -------------------
EXECUTE('DECLARE cu21_cursor Insensitive Cursor For ' +
  'SELECT sp.sid, sp.name, sp.default_database_name
   From master.sys.server_principals  sp ' +
  'Where sp.type <> ''R''
   and sp.name is not null
   For Read Only')


OPEN cu21_cursor

WHILE (21=21)
 Begin
	FETCH Next From cu21_cursor Into @cu21sid, @cu21Login_name, @cu21default_database_name

	IF (@@fetch_status < 0)
           begin
              CLOSE cu21_cursor
	      BREAK
           end


	If @cu21default_database_name <> 'master'
	   begin
		--Print @cu21Login_name
		--select @cu21dbid
		If (SELECT DB_ID(@cu21default_database_name)) is null
		   begin
			Select @cmd = 'ALTER LOGIN ' + @cu21Login_name + ' WITH DEFAULT_DATABASE = master;'
			Print @cmd
			Exec(@cmd)
	
			Select @miscprint = 'DBA WARNING: Default DB changed to MASTER for login ''' + @cu21Login_name + ''' on server ' + @@servername 
			print @miscprint
			--raiserror(@miscprint,-1,-1) with log
			goto skip21
		   end


		If (SELECT DATABASEPROPERTYEX (@cu21default_database_name,'status')) <> 'ONLINE'
		   begin
			goto skip21
		   end


		Select @cmd = 'use ' + quotename( @cu21default_database_name , '[') + ' select dp.principal_id from sys.database_principals  dp, master.sys.server_principals  sp 
											where dp.sid = sp.sid
											and sp.name = ''' + @cu21Login_name + '''' 
		Print @cmd
		Exec(@cmd)

		If @@rowcount = 0 and @cu21default_database_name <> 'master'
		   begin


			Select @miscprint = 'DBA WARNING: Login ''' + @cu21Login_name + ''' does not have access to default DB ''' + @cu21default_database_name + ''' on server ' + @@servername
			--print @miscprint
			raiserror(@miscprint,-1,-1) with log
			Waitfor delay '00:00:02'
		   end

		skip21:
		Print ''
	   end


 End  -- loop 21
DEALLOCATE cu21_cursor


---------------------------  Finalization  -----------------------


if (object_id('tempdb..#orphans') is not null)
            drop table #orphans



return (0)



 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_OpenJob
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_OpenJob]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_OpenJob]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Check_OpenJob (@job_run_hours int = 4)
 
/*********************************************************
 **  Stored Procedure dbasp_Check_OpenJob                  
 **  Written by Jim Wilson, Getty Images                
 **  July 23, 2002                                      
 **  
 **  This dbasp is set up to check for long running jobs. 
 **  The default time period is four hours.  If needed, the default
 **  can be modified by using an input parameter.
 ** 
 **  Example syntax to run this proc is:
 **  exec dbaadmin..dbasp_CheckOpenJob @job_run_hours = 6
 **        
 ***************************************************************/
  as
set nocount on

/**
declare @job_run_hours int

select @job_run_hours = 4
--**/


--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	07/23/2002	Jim Wilson		Check for long running jobs created
--	09/26/2002	Jim Wilson		Shortened long lines to 255
--	06/20/2006	Jim Wilson		Converted to SQL 2005.  Now capture top 1 from sysjobactivity
--						for most recent session_id.
--	04/18/2008	Jim Wilson		Added skip for known long running jobs.
--	07/27/2009	David Spriggs		Added No_check table reference.
--	======================================================================================


DECLARE
	 @miscprint		varchar(500)
	,@is_sysadmin		int
	,@job_owner		sysname
	,@save_job_start	varchar(30)
	,@save_job_date		datetime
	,@run_length		int

DECLARE
	 @cu11job_id			UNIQUEIDENTIFIER
	,@cu11name			sysname
	,@cu11start_execution_date	datetime


-- Step 1: Create intermediate work tables
CREATE TABLE #xp_results (job_id                UNIQUEIDENTIFIER NOT NULL,
                          last_run_date         INT              NOT NULL,
                          last_run_time         INT              NOT NULL,
                          next_run_date         INT              NOT NULL,
                          next_run_time         INT              NOT NULL,
                          next_run_schedule_id  INT              NOT NULL,
                          requested_to_run      INT              NOT NULL, -- BOOL
                          request_source        INT              NOT NULL,
                          request_source_id     sysname          NULL,
                          running               INT              NOT NULL, -- BOOL
                          current_step          INT              NOT NULL,
                          current_retry_attempt INT              NOT NULL,
                          job_state             INT              NOT NULL)

-- Step 2: Capture job execution information (for local jobs only since that's all SQLServerAgent caches)
SELECT @is_sysadmin = ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0)
SELECT @job_owner = SUSER_SNAME()
  
INSERT INTO #xp_results
   EXECUTE master.sys.xp_sqlagent_enum_jobs @is_sysadmin, @job_owner

--  Remove row for jobs that are not running
delete from #xp_results where running <> 1
--select * from #xp_results


--------------------  Cursor for job info  -------------------

EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' + 
  'SELECT x.job_id, j.name
   From #xp_results  x, msdb.dbo.sysjobs  j ' + 
  'Where x.job_id = j.job_id
   Order By j.name For Read Only')

   
OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11job_id, @cu11name
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end
	

	--  Capture the start date for the current execution
	Select @cu11start_execution_date = (select top 1 start_execution_date from msdb.dbo.sysjobactivity
											where job_id = @cu11job_id
											order by session_id desc
										)

	If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type like 'check_job_nocheck%' and env_detail = @cu11name)
	   begin
		goto skip_job
	   end

	If exists (select 1 from dbaadmin.dbo.no_check where NoCheck_type like 'sql_job_nocheck%' and detail01 = @cu11name)
	   begin
		goto skip_job
	   end


	--  Now check to see if this job has run long   
	Select @run_length = datediff (hh, @cu11start_execution_date, getdate())


	If @run_length > @job_run_hours
	   begin
		select @miscprint = 'DBA WARNING: Job ''' + @cu11name + ''' has been running for ' + convert(varchar(10), @run_length) + ' hours.'
		raiserror(@miscprint,-1,-1) with log
		Print @miscprint
	   end 

	skip_job:
	

 End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cu11_cursor

DROP TABLE #xp_results


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_Opentran
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_Opentran]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_Opentran]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_Check_Opentran
/*********************************************************
 **  Stored Procedure dbasp_Check_Opentran                  
 **  Written by Jim Wilson, Getty Images                
 **  December 12, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Check for Open Transactions Older Than 10 Minutes
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson				Revision History added
--	06/10/2002	Jim Wilson				Changed isql to osql
--	06/01/2006	Jim Wilson				Updated for SQL 2005.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar (255)
	,@G_O				nvarchar (2)
	,@OTtimespan		int
	,@OTsavesuid		nvarchar (46)
	,@OTmindate_conv	datetime
	,@OTdatediff		int
	,@dbcccmd			nvarchar (255)
	,@sqlcmd			nvarchar (255)
      
DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu22OTtag			nvarchar (30)
	,@cu22OTvalue		nvarchar (46)


----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @OTtimespan	= 10  --number in minutes
  
    
--------------------  Create Tempdb table  -----------------------
create table ##OpenTran
   (OTtag   varchar(30) not null
   ,OTvalue varchar(46) not null)



/*********************************************************************
 *                Initialization
 ********************************************************************/


--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cursor_11DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.databases   d ' + 
  'Where d.database_id > 0
  Order By d.name For Read Only')

/****************************************************************
 *                MainLine
 ***************************************************************/
----------------------  Open the database cursor  ----------------------

OPEN cursor_11DBNames

WHILE (11=11)
   Begin
	FETCH Next From cursor_11DBNames Into @cu11DBName
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11DBNames
	      BREAK
           end


	--------------------  clear out Temp table  -----------------------
	delete from ##OpenTran

	
	----------------------  Capture data into the temp table  ----------------------

	select @dbcccmd = 'dbcc opentran(''' + @cu11DBName + ''') with tableresults, NO_INFOMSGS'
	select @sqlcmd = 'sqlcmd -S' + @@servername + ' -Q''insert ##OpenTran (OTtag, OTvalue) exec (''' + @dbcccmd + ''')'' -E'

	EXEC master.sys.xp_cmdshell @sqlcmd, no_output

	select * from ##OpenTran


	----------------------  Declare the temp table cursor  ----------------------

	EXECUTE('DECLARE cursor_22OpenTran Insensitive Cursor For ' + 
	  'SELECT t.OTtag, t.OTvalue
	   From ##OpenTran  t ' + 
	  'Order by t.OTtag For Read Only')

	----------------------  Open the temp table cursor  ----------------------

	OPEN cursor_22OpenTran

	WHILE (22=22)
	   Begin
		FETCH next from cursor_22OpenTran into @cu22OTtag, @cu22OTvalue
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cursor_22OpenTran
			      BREAK
	           end

		----------------------  check for open trans and report if any are found  ----------------------

		IF @cu22OTtag = 'OLDACT_SPID'
		   begin
			Select @OTsavesuid = @cu22OTvalue
		   end
		Else
		IF @cu22OTtag = 'OLDACT_STARTTIME'
		   begin
			Select @OTmindate_conv = convert(datetime, @cu22OTvalue, 100)
			Select @OTdatediff = datediff(mi, @OTmindate_conv, getdate())

			If @OTdatediff > @OTtimespan
			   begin
				Select @miscprint = 'DBA WARNING: A transaction has been open for ' + convert(nvarchar(20),@OTdatediff) + ' minutes in database ''' + @cu11DBName + ''' for user SUID = ' + @OTsavesuid 
				raiserror(@miscprint,-1,-1) with log
			   end
		   end


	End  -- loop 22
	Deallocate cursor_22OpenTran



End  -- loop 11
DEALLOCATE cursor_11DBNames

----------------------  End the data capture process  ----------------------

Drop table ##OpenTran


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Check_Periodic
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Check_Periodic]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Check_Periodic]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_Check_Periodic (@check_repl_errors char(1) = 'y'
					,@check_jobstep_errors char(1) = 'y'
					,@Check_maintstep_errors char(1) = 'y'
					,@check_jobname_like sysname = 'APPL'
					)  

/***************************************************************
 **  Stored Procedure dbasp_Check_Periodic                  
 **  Written by Jim Wilson, Getty Images                
 **  February 19, 2002                                      
 **  
 **  This dbasp is set up to;
 ** 
 **  Check for SQL job step failures
 **  Check for replication related errors
 **
 **  When problems are found, specific errors are raised to the 
 **  SQL error log.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     				Desc
--	==========	====================	=============================================
--	02/19/2002	Jim Wilson		New process
--	06/11/2003	Jim Wilson		Modify to check previous 48 hours for job step failures
--	10/17/2003	Jim Wilson		Change conversion for @save_rundate
--	07/26/2003	Jim Wilson		Add check for DBA, BASE and RSTR jobs
--	03/28/2005	Jim Wilson		Major revision.  Now using table variables (mostly)
--						with no cursors.
--	08/22/2006	Jim Wilson		Udated for SQL 2005
--	02/09/2007	Jim Wilson		Added check for DEPL job steps.
--	06/05/2007	Jim Wilson		Added reporting for retying job steps.
--	12/19/2007	Jim Wilson		Added spcl gmail alerting for BASE jobs.
--	12/21/2007	Jim Wilson		Added exceptions to on-call lookup process.
--	02/06/2008	Jim Wilson		Added skip raiserror for retries.
--	02/11/2008	Jim Wilson		Added skip in depl and base section for retries.
--	09/24/2008	Jim Wilson		Remove old status = 2 rows from the check process.
--	09/29/2008	Jim Wilson		Added code for STRT jobs.
--	08/28/2009	Jim Wilson		New code for APPL jobs - dev support emails.
--	09/16/2009	Jim Wilson		Disabled new code for APPL jobs - dev support emails.
--	10/26/2009	Jim Wilson		Increased all message variables to nvarchar(4000).
--	02/01/2010	Jim Wilson		Re-enabled code for APPL jobs - dev support emails.
--	03/19/2010	Jim Wilson		Updated APPL jobs - dev support emails to go to SQLDevAdmin.
--	======================================================================================


/***
Declare @check_repl_errors char(1)
Declare @check_jobstep_errors char(1)
Declare @Check_maintstep_errors char(1)
Declare @check_jobname_like sysname

Select @check_repl_errors = 'y'
Select @check_jobstep_errors = 'y'
Select @Check_maintstep_errors = 'y'
Select @check_jobname_like = 'APPL'
--Select @check_jobname_like = '*all*'
--***/


-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@query				nvarchar(1024)
	,@saverun_date			int
	,@saverun_time			int
	,@holdrun_date			int
	,@holdrun_time			int
	,@message			nvarchar(4000)
	,@message2			nvarchar(4000)
	,@message3			nvarchar(4000)
	,@jobtype			sysname
	,@charpos			int
	,@startpos			int
	,@cnvt_old_runtime 		sysname
	,@old_runtime 			sysname
	,@new_runtime 			sysname
	,@Hold_hhmmss 			varchar(8)
	,@reset_int			int
	,@reset_char			varchar(8)
	,@reset_date			datetime
	,@servername			sysname
	,@db_query1			nvarchar(4000)
	,@db_query2			sysname
	,@pong_count			smallint


DECLARE
	 @save_name			sysname
	,@save_instance_ID		int
	,@save_Job_ID			varchar(50) 
	,@save_step_name		sysname
	,@save_sql_message_id		int
	,@save_sql_severity		int
	,@save_message			nvarchar(4000)
	,@save_run_status		int
	,@save_run_date			int
	,@save_run_time			int
	,@save_msdistributiondbs	sysname
	,@save_rq_stamp			sysname
	,@save_more_info		sysname
	,@save_description		nvarchar(512)
	,@appl_name			sysname
	,@save_env_name			sysname
	,@save_sendmail_recipients	nvarchar(500)

DECLARE
	 @save_time			datetime
	,@save_source_name		sysname
	,@save_error_code		sysname
	,@save_error_text		varchar(4000)


/*********************************************************************
 *                Initialization
 ********************************************************************/
Select @message = ''
Select @message2 = ''
Select @message3 = ''
Select @servername = @@servername


Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @new_runtime = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 


--  Create table variables
declare @jobinfo table	(jobname	sysname
			,instance_ID	int
			,Job_ID		varchar(50) 
			,step_name	sysname
			,step_id	int
			,sql_message_id	int
			,sql_severity	int
			,message	nvarchar(4000)
			,run_status	int
			,run_date	int
			,run_time	int
			,primary key 	(instance_ID)
			)

declare @msdistributiondbs table (DBname sysname)


--  Create temp tables
create table #replerrors (time		datetime
			  ,source_name	sysname
			  ,error_code	sysname
			  ,error_text	varchar(4000)
			  )



--  Set last-run date and time parameters  -------------------

Select @old_runtime = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_periodic_time')

If @old_runtime is null
   begin
	Select @old_runtime = @new_runtime
   end


select @cnvt_old_runtime = substring(@old_runtime, 1,4) + '-' + substring(@old_runtime, 5,2) + '-' + substring(@old_runtime, 7,2) + ' ' + substring(@old_runtime, 9,2) + ':' + substring(@old_runtime, 11,2) + ':' + substring(@old_runtime, 13,2) + '.000'

Select @saverun_date = convert(int,(substring(@old_runtime, 1, 8)))
Select @saverun_time = convert(int,(substring(@old_runtime, 9, 6)))
Select @holdrun_date = @saverun_date
Select @holdrun_time = @saverun_time

--Print convert(varchar(20), @saverun_date)
--Print convert(varchar(20), @saverun_time)
--print @cnvt_old_runtime


--  The following code was put in so that we check for job step failures in the
--  past 48 hours, and compare those against previously reported failures.
Select @reset_char = convert(varchar(8), @saverun_date)

Select @reset_date = convert(datetime, @reset_char)

Select @reset_date = DATEADD(day, -2, @reset_date)

Select @reset_char = convert(varchar(8), @reset_date, 112)

Select @saverun_date = convert(int, @reset_char)

--Print convert(varchar(20), @saverun_date)
--Print convert(varchar(20), @saverun_time)



/****************************************************************
 *  Check for failed job steps
 ***************************************************************/
If @check_jobstep_errors = 'y'
   begin
	--------------------  Cursor for Failed Job Steps  -------------------
	If @check_jobname_like = '*ALL*'
	   begin
		Insert into @jobinfo (jobname, instance_ID, Job_ID, step_name, step_id, sql_message_id, sql_severity, message, run_status, run_date, run_time)
		SELECT j.name, h.instance_ID, convert(varchar(50),h.Job_ID), h.step_name, h.step_id, h.sql_message_id, h.sql_severity, h.message, h.run_status, h.run_date, h.run_time
		From msdb.dbo.sysjobhistory  h with (NOLOCK),  msdb.dbo.sysjobs j with (NOLOCK)
		Where h.job_id = j.job_id
		   and h.instance_ID not in (select instance_ID from dbaadmin.dbo.FailedJobs with (NOLOCK)) 
		   and j.name not like 'MAINT%' and j.name not like 'DBA%' and j.name not like 'STRT%' and j.name not like 'DEPL%' and j.name not like 'BASE%' and j.name not like 'RSTR%' and j.name not like 'UTIL - SQL Activity Log Process%'
		   and h.run_status <> 1
		   and h.step_id <> 0
		   and h.run_date >= convert(varchar(8),@saverun_date)
	   end
	Else
	   begin
		Select @jobtype = @check_jobname_like + '%'

		Insert into @jobinfo (jobname, instance_ID, Job_ID, step_name, step_id, sql_message_id, sql_severity, message, run_status, run_date, run_time)
		SELECT j.name, h.instance_ID, convert(varchar(50),h.Job_ID), h.step_name, h.step_id, h.sql_message_id, h.sql_severity, h.message, h.run_status, h.run_date, h.run_time
		From msdb.dbo.sysjobhistory  h with (NOLOCK),  msdb.dbo.sysjobs  j with (NOLOCK) 
		Where h.job_id = j.job_id
		  and h.instance_ID not in (select instance_ID from dbaadmin.dbo.FailedJobs with (NOLOCK)) 
		  and j.name like @jobtype
		  and h.run_status <> 1
		  and h.step_id <> 0
		  and h.run_date >= convert(varchar(8),@saverun_date)
	   end
   end

delete from @jobinfo where run_status = 2 and (run_date < @holdrun_date or run_time < @holdrun_time)

--select * from @jobinfo
--select * from dbaadmin.dbo.FailedJobs


--  Process the results one record at a time by instance_id
If (select count(*) from @jobinfo) > 0
   begin
	start_jobinfo:
	
	Select @save_instance_ID = (select top 1 instance_ID from @jobinfo)
	Select @save_Job_ID = Job_ID from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_status = run_status from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_date = run_date from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_time = run_time from @jobinfo where instance_ID = @save_instance_ID
	Select @save_name = jobname from @jobinfo where instance_ID = @save_instance_ID
	Select @save_step_name = step_name from @jobinfo where instance_ID = @save_instance_ID
	Select @save_message = message from @jobinfo where instance_ID = @save_instance_ID

	--  Fix single quote problem in @save_name
	Select @startpos = 1
	label01:
	select @charpos = charindex('''', @save_name, @startpos)
	IF @charpos <> 0
	   begin
		select @save_name = stuff(@save_name, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	
	
	select @charpos = charindex('''', @save_name, @startpos)
	IF @charpos <> 0
	   begin
		goto label01
 	   end

	--  Fix single quote problem in @save_step_name
	Select @startpos = 1
	label02:
	select @charpos = charindex('''', @save_step_name, @startpos)
	IF @charpos <> 0
	   begin
		select @save_step_name = stuff(@save_step_name, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @save_step_name, @startpos)
	IF @charpos <> 0
	   begin
		goto label02
 	   end

	--  Fix single quote problem in @save_message
	Select @startpos = 1
	label03:
	select @charpos = charindex('''', @save_message, @startpos)
	IF @charpos <> 0
	   begin
		select @save_message = stuff(@save_message, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @save_message, @startpos)
	IF @charpos <> 0
	   begin
		goto label03
 	   end


	If @save_name not in ('UTIL - SQL Perf Log Process', 'UTIL - DBA Check Contention')
	   begin
		Select @message  = 'Job: ' + @save_name + '  Step: ' + @save_step_name + '  Date/Time: ' + convert(varchar(10),@save_run_date) + ' ' + convert(varchar(10),@save_run_time)
		If @save_run_status = 2
		   begin
			Select @message  = 'Retrying Job Step now.  ' + @message
			Select @message2 = '  Message: ' + @save_message 
			Select @message3 = @message + ' ' + @message2 
			--print @message
			--print @message2
			print @message3

			goto skip_this_job_step
		   end
		Else	
		   begin
			Select @message2 = '  Message: ' + @save_message 
			Select @message3 = @message + ' ' + @message2 
			--print @message
			--print @message2
			--print @message3
		   end


		--  raise error for this job step
		raiserror(67023, -1, -1, @message, @message2)



		--  send email to dev if this job is related to any of our dev supported applications
		If @save_name like 'APPL%' and (select count(*) from master.sys.databases where name = 'DEPLinfo') > 0 
		   begin
			Select @save_description = (select top 1 description from msdb.dbo.sysjobs where job_id = @save_Job_ID)

			Select @appl_name = ''
			start_appl_job_check:
			If exists(select 1 from DEPLinfo.dbo.db_BaseLocation where RSTRfolder > @appl_name)
			   begin
				Select @appl_name = (select top 1 RSTRfolder from DEPLinfo.dbo.db_BaseLocation where RSTRfolder > @appl_name order by RSTRfolder)
				--Print @appl_name

				If @save_description like @appl_name + '%'
				  begin
					Select @save_env_name = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'ENVname')
					Select @save_sendmail_recipients = 'SQLDevAdmin@gettyimages.com; SQLDBAreports@gettyimages.com'


					--Select @save_sendmail_recipients = (select top 1 recipients from deplinfo.dbo.sendmail_dist_list where ProjectID = @appl_name and success_flag = 'n' and env_name = @save_env_name)

					--If @save_sendmail_recipients is null or @save_sendmail_recipients = ''
					--   begin
					--	Select @save_sendmail_recipients = (select top 1 recipients from deplinfo.dbo.sendmail_dist_list where ProjectID = 'other' and success_flag = 'n' and env_name = 'ALL')
					--   end

					--If @save_sendmail_recipients is null or @save_sendmail_recipients = ''
					--   begin
					--	Select @save_sendmail_recipients = 'SQLDBAreports@gettyimages.com'
					--   end
					--Else
					--   begin
					--	Select @save_sendmail_recipients = @save_sendmail_recipients + '; SQLDBAreports@gettyimages.com'
					--   end
					
					Select @message  = 'APPL Job Step Failure - Server: ' + @servername + '  Job: ' + @save_name + '  Step: ' + @save_step_name + '  Date/Time: ' + convert(varchar(10),@save_run_date) + ' ' + convert(varchar(10),@save_run_time)
		
					Select @message2 = 'APPL Job Step Failure - Server: ' + @servername + char(13)+char(10)
					Select @message2 = @message2 + 'Job: ' + @save_name + char(13)+char(10)
					Select @message2 = @message2 + 'Step: ' + @save_step_name + char(13)+char(10)
					Select @message2 = @message2 + 'Date/Time: ' + convert(varchar(10),@save_run_date) + ' ' + convert(varchar(10),@save_run_time) + char(13)+char(10)
					Select @message2 = @message2 + char(13)+char(10)
					Select @message2 = @message2 + @save_message

					--print @message
					--print @message2
	
					--  Email TS SQL DBA with this information
					EXEC dbaadmin.dbo.dbasp_sendmail 
					@recipients = @save_sendmail_recipients,  
					@subject = @message,
					@message = @message2

					goto end_appl_job_check
				   end
					

				If exists(select 1 from DEPLinfo.dbo.db_BaseLocation where RSTRfolder > @appl_name)
				   begin
					goto start_appl_job_check
				   end
			   end

			end_appl_job_check:
		   end




		insert into dbaadmin.dbo.FailedJobs(instance_ID, Job_ID, run_status, run_date) values( @save_instance_ID, @save_Job_ID, @save_run_status, @save_run_date )
		--select * from dbaadmin.dbo.FailedJobs

		insert into dbaadmin.dbo.Periodic_Errors (alert_num, Message_text) values(67023, rtrim(@message3))
		--select * from dbaadmin.dbo.Periodic_Errors order by error_id

		skip_this_job_step:
	   end


	Delete from @jobinfo where instance_ID = @save_instance_ID
	If (select count(*) from @jobinfo) > 0
	   begin
		goto start_jobinfo
	   end

   end




/****************************************************************
 *  Check for failed MAINT job steps
 ***************************************************************/
Select @message  = ' '
Select @message2  = ' '
Select @message3  = ' '
delete from @jobinfo

If @Check_maintstep_errors = 'y'
   begin
	--------------------  Cursor for Failed Job Steps  -------------------
	Insert into @jobinfo (jobname, instance_ID, Job_ID, step_name, step_id, sql_message_id, sql_severity, message, run_status, run_date, run_time)
	SELECT j.name, h.instance_ID, convert(varchar(50),h.Job_ID), h.step_name, h.step_id, h.sql_message_id, h.sql_severity, h.message, h.run_status, h.run_date, h.run_time
	From msdb.dbo.sysjobhistory  h with (NOLOCK),  msdb.dbo.sysjobs j with (NOLOCK)
	Where h.job_id = j.job_id
	   and h.instance_ID not in (select instance_ID from dbaadmin.dbo.FailedJobs with (NOLOCK)) 
	   and (j.name like 'MAINT%' or j.name like 'DBA%' or j.name like 'STRT%' or j.name like 'RSTR%' or j.name like 'UTIL%')
	   and h.run_status <> 1
	   and h.step_id <> 0
	   and h.run_date >= convert(varchar(8),@saverun_date)
   end

delete from @jobinfo where run_status = 2 and (run_date < @holdrun_date or run_time < @holdrun_time)

--select * from @jobinfo
--select * from dbaadmin.dbo.FailedJobs

--  Process the results one record at a time by instance_id
If (select count(*) from @jobinfo) > 0
   begin
	start_maintstep:
	
	Select @save_instance_ID = (select top 1 instance_ID from @jobinfo)
	Select @save_Job_ID = Job_ID from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_status = run_status from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_date = run_date from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_time = run_time from @jobinfo where instance_ID = @save_instance_ID
	Select @save_name = jobname from @jobinfo where instance_ID = @save_instance_ID
	Select @save_step_name = step_name from @jobinfo where instance_ID = @save_instance_ID
	Select @save_message = message from @jobinfo where instance_ID = @save_instance_ID

	--  Fix single quote problem in @save_name
	Select @startpos = 1
	label11:
	select @charpos = charindex('''', @save_name, @startpos)
	IF @charpos <> 0
	   begin
		select @save_name = stuff(@save_name, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	
	
	select @charpos = charindex('''', @save_name, @startpos)
	IF @charpos <> 0
	   begin
		goto label11
 	   end

	--  Fix single quote problem in @save_step_name
	Select @startpos = 1
	label12:
	select @charpos = charindex('''', @save_step_name, @startpos)
	IF @charpos <> 0
	   begin
		select @save_step_name = stuff(@save_step_name, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @save_step_name, @startpos)
	IF @charpos <> 0
	   begin
		goto label12
 	   end

	--  Fix single quote problem in @save_message
	Select @startpos = 1
	label13:
	select @charpos = charindex('''', @save_message, @startpos)
	IF @charpos <> 0
	   begin
		select @save_message = stuff(@save_message, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @save_message, @startpos)
	IF @charpos <> 0
	   begin
		goto label13
 	   end


	If @save_name not in ('UTIL - SQL Perf Log Process', 'UTIL - DBA Check Contention')
	   begin
		Select @message  = 'Job: ' + @save_name + '  Step: ' + @save_step_name + '  Date/Time: ' + convert(varchar(10),@save_run_date) + ' ' + convert(varchar(10),@save_run_time)
		If @save_run_status = 2
		   begin
			Select @message  = 'Retrying Job Step now.  ' + @message
			Select @message2 = '  Message: ' + @save_message 
			Select @message3 = @message + ' ' + @message2 
			--print @message
			--print @message2
			print @message3

			goto skip_maint_job_step
		   end
		Else
		   begin
			Select @message2 = '  Message: ' + @save_message 
			Select @message3 = @message + ' ' + @message2 
			--print @message
			--print @message2
			--print @message3
		   end	


		raiserror(67022, -1, -1, @message, @message2)
		insert into dbaadmin.dbo.FailedJobs(instance_ID, Job_ID, run_status, run_date) values( @save_instance_ID, @save_Job_ID, @save_run_status, @save_run_date )
		--select * from dbaadmin.dbo.FailedJobs

		insert into dbaadmin.dbo.Periodic_Errors (alert_num, Message_text) values(67022, rtrim(@message3))
		--select * from dbaadmin.dbo.Periodic_Errors order by error_id

		skip_maint_job_step:

	   end


	Delete from @jobinfo where instance_ID = @save_instance_ID
	If (select count(*) from @jobinfo) > 0
	   begin
		goto start_maintstep
	   end

   end



/****************************************************************
 *  Check for failed DEPL and BASE job steps
 ***************************************************************/
Select @message  = ' '
Select @message2  = ' '
Select @message3  = ' '
delete from @jobinfo

If exists (select 1 from msdb.dbo.sysjobs where name like 'DEPL%' or name like 'BASE%') 
   begin
	--------------------  Cursor for Failed Job Steps  -------------------
	Insert into @jobinfo (jobname, instance_ID, Job_ID, step_name, step_id, sql_message_id, sql_severity, message, run_status, run_date, run_time)
	SELECT j.name, h.instance_ID, convert(varchar(50),h.Job_ID), h.step_name, h.step_id, h.sql_message_id, h.sql_severity, h.message, h.run_status, h.run_date, h.run_time
	From msdb.dbo.sysjobhistory  h with (NOLOCK),  msdb.dbo.sysjobs j with (NOLOCK)
	Where h.job_id = j.job_id
	   and h.instance_ID not in (select instance_ID from dbaadmin.dbo.FailedJobs with (NOLOCK)) 
	   and (j.name like 'DEPL%' or j.name like 'BASE%')
	   and h.run_status <> 1
	   and h.step_id <> 0
	   and h.run_date >= convert(varchar(8),@saverun_date)
   end

delete from @jobinfo where run_status = 2 and (run_date < @holdrun_date or run_time < @holdrun_time)

--select * from @jobinfo
--select * from dbaadmin.dbo.FailedJobs

--  Process the results one record at a time by instance_id
If (select count(*) from @jobinfo) > 0
   begin
	start_deplstep:
	
	Select @save_instance_ID = (select top 1 instance_ID from @jobinfo)
	Select @save_Job_ID = Job_ID from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_status = run_status from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_date = run_date from @jobinfo where instance_ID = @save_instance_ID
	Select @save_run_time = run_time from @jobinfo where instance_ID = @save_instance_ID
	Select @save_name = jobname from @jobinfo where instance_ID = @save_instance_ID
	Select @save_step_name = step_name from @jobinfo where instance_ID = @save_instance_ID
	Select @save_message = message from @jobinfo where instance_ID = @save_instance_ID

	--  Fix single quote problem in @save_name
	Select @startpos = 1
	label21:
	select @charpos = charindex('''', @save_name, @startpos)
	IF @charpos <> 0
	   begin
		select @save_name = stuff(@save_name, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	
	
	select @charpos = charindex('''', @save_name, @startpos)
	IF @charpos <> 0
	   begin
		goto label21
 	   end

	--  Fix single quote problem in @save_step_name
	Select @startpos = 1
	label22:
	select @charpos = charindex('''', @save_step_name, @startpos)
	IF @charpos <> 0
	   begin
		select @save_step_name = stuff(@save_step_name, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @save_step_name, @startpos)
	IF @charpos <> 0
	   begin
		goto label22
 	   end

	--  Fix single quote problem in @save_message
	Select @startpos = 1
	label23:
	select @charpos = charindex('''', @save_message, @startpos)
	IF @charpos <> 0
	   begin
		select @save_message = stuff(@save_message, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @save_message, @startpos)
	IF @charpos <> 0
	   begin
		goto label23
 	   end


	If @save_run_status = 2
	   begin
		Select @message  = 'DEPL Job Step Failure (Retrying Job Step now) - Server: ' + @servername + '  Job: ' + @save_name + '  Step: ' + @save_step_name + '  Date/Time: ' + convert(varchar(10),@save_run_date) + ' ' + convert(varchar(10),@save_run_time)
		goto skip_base
	   end	
	Else
	   begin
		Select @message  = 'DEPL Job Step Failure - Server: ' + @servername + '  Job: ' + @save_name + '  Step: ' + @save_step_name + '  Date/Time: ' + convert(varchar(10),@save_run_date) + ' ' + convert(varchar(10),@save_run_time)
	   end

	Select @message2 = 'DEPL Job Step Failure - Server: ' + @servername + char(13)+char(10)
	Select @message2 = @message2 + 'Job: ' + @save_name + char(13)+char(10)
	Select @message2 = @message2 + 'Step: ' + @save_step_name + char(13)+char(10)
	Select @message2 = @message2 + 'Date/Time: ' + convert(varchar(10),@save_run_date) + ' ' + convert(varchar(10),@save_run_time) + char(13)+char(10)
	Select @message2 = @message2 + char(13)+char(10)
	Select @message2 = @message2 + @save_message

	--print @message
	--print @message2


	--  Email TS SQL DBA with this information
	EXEC dbaadmin.dbo.dbasp_sendmail 
		--@recipients = 'jim.wilson@gettyimages.com',  
		@recipients = 'tssqldba@gettyimages.com',  
		@subject = @message,
		@message = @message2


	--  special alerting for BASE jobs
	If @save_name like 'BASE%'
	  begin

		--  Ping the on-call DB server to see what SQL DBA is on-call
		Select @save_rq_stamp = convert(sysname, getdate(), 121)
		Select @db_query1 = ''
		Select @db_query1 = @db_query1 + 'If exists(select 1 from eds.dbo.EXCEPTIONS where iGroupID = 63 and iPriority = 1 and convert(nvarchar(8), dtDate, 112) = convert(nvarchar(8), getdate(), 112))'
		Select @db_query1 = @db_query1 + ' begin'
		Select @db_query1 = @db_query1 + ' select top 1 cn.vchContactNumber'
		Select @db_query1 = @db_query1 + ' FROM eds.dbo.EXCEPTIONS e, eds.dbo.CONTACT_NUMBERS cn'
		Select @db_query1 = @db_query1 + ' where e.iContactID = cn.iContactID'
		Select @db_query1 = @db_query1 + ' and cn.iNumberTypeID = 29'
		Select @db_query1 = @db_query1 + ' and e.iGroupID = 63'
		Select @db_query1 = @db_query1 + ' and e.iPriority = 1'
		Select @db_query1 = @db_query1 + ' and convert(nvarchar(8), e.dtDate, 112) = convert(nvarchar(8), getdate(), 112)'
		Select @db_query1 = @db_query1 + ' end'
		Select @db_query1 = @db_query1 + ' Else'
		Select @db_query1 = @db_query1 + ' begin'
		Select @db_query1 = @db_query1 + ' select top 1 cn.vchContactNumber'
		Select @db_query1 = @db_query1 + ' FROM eds.dbo.CONTACT_GROUPS cg, eds.dbo.CONTACTS c, eds.dbo.CONTACT_NUMBERS cn'
		Select @db_query1 = @db_query1 + ' where cg.iContactID = c.iContactID'
		Select @db_query1 = @db_query1 + ' and c.iContactID = cn.iContactID'
		Select @db_query1 = @db_query1 + ' and cg.iGroupID = 63'
		Select @db_query1 = @db_query1 + ' and cn.iNumberTypeID = 29'
		Select @db_query1 = @db_query1 + ' and cg.bOncall = 1'
		Select @db_query1 = @db_query1 + ' end'
		Select @db_query2 = '@query_out sysname OUTPUT'
		select @query = 'exec dbaadmin.dbo.dbasp_pong @rq_servername = ''' + @@servername 
			    + ''', @rq_stamp = ''' + @save_rq_stamp 
			    + ''', @rq_type = ''db_query'', @rq_detail01 = ''' + @db_query1 + ''', @rq_detail02 = ''' + @db_query2 + ''''
		Select @miscprint = 'Requesting sql dba on-call info from server seafresqlboa.'
		Print @miscprint
		Select @cmd = 'sqlcmd -Sseafresqlboa -deds -E -Q"' + @query + '"'
		print @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 

		--  capture pong results
		select @pong_count = 0
		start_pong_result:
		Waitfor delay '00:00:05'
		If exists (select 1 from dbaadmin.dbo.pong_return where pong_stamp = @save_rq_stamp)
		   begin
			Select @save_more_info = (select pong_detail01 from dbaadmin.dbo.pong_return where pong_stamp = @save_rq_stamp)
		   end
		Else If @pong_count < 5
		   begin
			Select @pong_count = @pong_count + 1
			goto start_pong_result
		   end

		If @save_more_info like '%gmail%'
		   begin
			Print 'Gmail being sent.'

			EXEC dbaadmin.dbo.dbasp_sendmail 
			@recipients = @save_more_info,  
			@subject = @message,
			@message = @message2

			If @save_more_info not like 'jwilson%'
			   begin
				EXEC dbaadmin.dbo.dbasp_sendmail 
				@recipients = 'jwilson.getty@gmail.com', 
				@subject = @message,
				@message = @message2
			   end
		   end

	   end



	raiserror(67022, -1, -1, @message, @message2)
	insert into dbaadmin.dbo.FailedJobs(instance_ID, Job_ID, run_status, run_date) values( @save_instance_ID, @save_Job_ID, @save_run_status, @save_run_date )
	--select * from dbaadmin.dbo.FailedJobs

	insert into dbaadmin.dbo.Periodic_Errors (alert_num, Message_text) values(67022, rtrim(@message3))
	--select * from dbaadmin.dbo.Periodic_Errors order by error_id


	skip_base:

	Delete from @jobinfo where instance_ID = @save_instance_ID
	If (select count(*) from @jobinfo) > 0
	   begin
		goto start_deplstep
	   end

   end



/****************************************************************
 *  Check for Replication errors
 ***************************************************************/
If exists (select * from msdb.sys.sysobjects where name = 'msdistributiondbs' and xtype = 'U')
   begin
	Insert into @msdistributiondbs (DBname)
	SELECT name from msdb.dbo.msdistributiondbs

	--select * from @msdistributiondbs


	If (select count(*) from @msdistributiondbs) > 0
	   begin
		start_msdistributiondbs:

		Select @save_msdistributiondbs = (select top 1 DBname from @msdistributiondbs)

		Select @message = ' '
		Select @message2 = ' '
		Select @message3 = ' '

		Select @query = 'Insert into #replerrors (time, source_name, error_code, error_text)
		SELECT e.time, e.source_name, e.error_code, convert(varchar(4000), e.error_text)
		From ' + rtrim(@save_msdistributiondbs) + '.dbo.MSrepl_errors  e ' + 
		  'Where convert(varchar(23), e.time, 121) > ''' +  @cnvt_old_runtime + '''
		     and e.source_name is not null'

		Exec (@query)

		--Select * from #replerrors

		If (select count(*) from #replerrors) > 0
		   begin
			start_replerrors:

			Select @save_time = (select top 1 time from #replerrors)
			Select @message = rtrim(source_name) from #replerrors where time = @save_time
			Select @message2 = rtrim(error_code) from #replerrors where time = @save_time
			Select @message3 = rtrim(left(error_text, 50)) from #replerrors where time = @save_time 


			raiserror(67021, -1, -1, @message, @message2, @message3)

			insert into dbaadmin.dbo.Periodic_Errors (alert_num, Message_text) values(67021, rtrim(@message) + rtrim(@message2) + rtrim(@message3))


			Delete from #replerrors where time = @save_time
			If (select count(*) from #replerrors) > 0
			   begin
				goto start_replerrors
			   end
		   end


		Delete from @msdistributiondbs where DBname = @save_msdistributiondbs
		If (select count(*) from @msdistributiondbs) > 0
		   begin
			goto start_msdistributiondbs
		   end
	   end

   end


---------------------------  Finalization  -----------------------

delete from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_periodic_time'
insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('check_periodic_time', @new_runtime)

Select @reset_date = DATEADD(day, -3, @reset_date)
Select @reset_char = convert(varchar(8), @reset_date, 112)
Select @reset_int = convert(int, rtrim(@reset_char))
delete from dbaadmin.dbo.FailedJobs where run_date < @reset_int

drop table #replerrors






 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_check_session_TempDB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_check_session_TempDB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_check_session_TempDB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE [dbo].[dbasp_check_session_TempDB]

/*********************************************************
 **  Stored Procedure dbasp_check_TempDB                  
 **  Written by David Spriggs, Getty Images                
 **  March 9, 2009                                     
 **  
 **  This dbasp is set up to record in the tempdb_stats_log 
 **  tables TempDB Space utilization metrics by SPID. 
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/09/2009	David Spriggs		New Process
--	
--	======================================================================================

/****************************************************************
 *                Declares
 ***************************************************************/

declare	      @miscprint	nvarchar(255)
	     ,@run_date		datetime

/****************************************************************
 *                Initialization
 ***************************************************************/
set @run_date = getdate()

/****************************************************************
 *                MainLine
 ***************************************************************/

insert into dbo.tempdb_sessionstats_log
select
     @run_date
    , ts.session_id
    , ex.command 
    , ses.host_name
    , SUBSTRING(st.text, (ex.statement_start_offset/2)+1, 
        ((CASE ex.statement_end_offset
	    WHEN -1 THEN DATALENGTH(st.text)
	    ELSE ex.statement_end_offset
          END - ex.statement_start_offset)/2) + 1) AS statement_text
    , sum(ts.user_objects_alloc_page_count)*8 as 'User_Obj_UsedSpace'
    , sum(ts.user_objects_dealloc_page_count)*8 as 'User_Obj_FreeSpace'
    , sum(ts.internal_objects_alloc_page_count)*8 as 'Int_Obj_UsedSpace'
    , sum(ts.internal_objects_dealloc_page_count)*8 as 'Int_Obj_FreeSpace'
from sys.dm_exec_requests as ex
join sys.dm_db_task_space_usage as ts on ex.session_id = ts.session_id 
join sys.dm_exec_sessions as ses on ex.session_id = ses.session_id
outer apply sys.dm_exec_sql_text(ex.sql_handle)as st
group by 
      ts.session_id
    , ex.command 
    , st.text    
    , ex.statement_start_offset
    , ex.statement_end_offset
    , ses.host_name



---------------------------  Finalization for process  -----------------------



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_check_TempDB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_check_TempDB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_check_TempDB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbasp_check_TempDB

/*********************************************************
 **  Stored Procedure dbasp_check_TempDB                  
 **  Written by David Spriggs, Getty Images                
 **  March 9, 2009                                     
 **  
 **  This dbasp is set up to record in the tempdb_stats_log 
 **  and dbo.tempdb_pagestats_log tables TempDB Space utilization metrics. 
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/09/2009	David Spriggs		New Process
--	03/17/2009	David Spriggs		Fixed percentage used calc error.
--	10/22/2009	David Spriggs		Fixed error with summation of max size of TempDB
--						data files
--	======================================================================================

/****************************************************************
 *                Declares
 ***************************************************************/

declare	     @miscprint		nvarchar(255)
	    ,@volume		varchar(10)
	    ,@tempdbPath	varchar(255)
            ,@dirCmd		nvarchar(4000)
	    ,@fixeddrivefreeMB  int
	    ,@volumefreespace	int
	    ,@freespace		int
	    ,@usedspace		int
	    ,@totalspaceusage	int
	    ,@totallogspace	int
	    ,@percentagework	decimal(18,0)
	    ,@checkpercent	decimal(18,2)
            ,@chk_max_size	int
	    ,@max_size		varchar(20)
	    ,@num_files		int
	    ,@isShared		bit
	    ,@isPreAllocated    bit
	    ,@run_date		datetime



/****************************************************************
 *                Initialization
 ***************************************************************/

declare @tempFixedDrives table(drl char(1), mbfree int)

create table #tempfiledir(toutput nvarchar(4000))

set @run_date = getdate()


/****************************************************************
 *                MainLine
 ***************************************************************/
--Update the Space Usage information first
--DBCC UPDATEUSAGE (TempDB) WITH NO_INFOMSGS 

/****************************************************************
		  Gathering File Space information
*****************************************************************/

--Get the TempDB Volume(not needed now but just in case)

select 
    top(1)
    @volume  = substring(physical_name,1,1)
from sys.master_files
where db_name(database_id)='tempdb'
and type_desc = 'rows'


--Get the TempDB Path

select
    top(1)
    @tempdbPath = reverse(substring(reverse(physical_name),charindex('\',reverse(physical_name))+1,LEN(physical_name)))
from sys.master_files
where db_name(database_id)='tempdb'
and type_desc = 'rows'

--Check to see if TempDB is pre-allocated

select
  @chk_max_size = max_size 
from sys.master_files
where db_name(database_id)='tempdb'
and type_desc = 'rows'
group by 
max_size

if @chk_max_size = -1
    begin
	set @max_size = 'unlimited'
	set @isPreAllocated   = 0
    end
else if @chk_max_size = 0
    begin
	set @max_size = 'no growth'
	set @isPreAllocated  = 0
    end 
	
else
    begin
	set  @max_size = (select convert(varchar(20),sum(max_size*8))from sys.master_files where db_name(database_id)='tempdb'and type_desc = 'rows')
	set  @isPreAllocated = 1
    end

--Get number of TempDB data physical data files

select 
    @num_files = COUNT(*)
from sys.master_files
where db_name(database_id)='tempdb'
and type_desc = 'rows'

--Get total file size for log

set @totallogspace = (select (sum(size)*8) from sys.master_files where db_name(database_id)='tempdb' and type_desc = 'log')

--Get Physical Disk Free Space

insert into @tempFixedDrives
exec xp_fixeddrives

set @fixeddrivefreeMB = (select mbfree from @tempFixedDrives where drl = @volume)

--Get internal allocated space usage

select
     @usedspace =((sum (user_object_reserved_page_count)*8) +(sum (internal_object_reserved_page_count)*8) + (sum (version_store_reserved_page_count)*8)+(sum (mixed_extent_page_count)*8))
    ,@freespace = ((sum (unallocated_extent_page_count)*8))
from sys.dm_db_file_space_usage 

set @totalspaceusage = @freespace + @usedspace

--Get percentage used

set @percentagework = (convert(numeric(18,2),@usedspace)/convert(numeric(18,2),@totalspaceusage))*1000

--check and see if is alone or with others

set @dirCmd = 'dir '+@tempdbPath

insert into #tempfiledir
exec xp_cmdshell @dirCmd

delete from #tempfiledir where toutput like '%volume%'
delete from #tempfiledir where toutput like '%directory%'
delete from #tempfiledir where toutput like '%<DIR>%'
delete from #tempfiledir where toutput like '%file%'
delete from #tempfiledir where toutput like '%dir%'
delete from #tempfiledir where toutput is null




--Determine if TempDB is on own disk or on shared disk

if(select count(*) from #tempfiledir where toutput not like '%temp%') = 0
    begin
	set @isShared = 0
    end
else
    begin
	set @isShared = 1
    end

--Load data into table

insert into dbo.tempdb_filestats_log(  
				      rundate 
				    , phys_data_file_size_KB 
				    , phys_log_file_size_KB  
				    , int_alloc_space_used_KB 
				    , int_alloc_space_free_KB 
				    , int_percentage_used
				    , phys_max_size_KB 
				    , phys_num_data_files 
				    , phys_disk_free_space_KB 
				    , phys_tempdb_path 
				    , isShared 
				    , isPreAllocated
				 )
select	
				 @run_date	
				,@totalspaceusage
				,@totallogspace
				,@usedspace 
				,@freespace 
				,@percentagework
				,@max_size
				,@num_files
				,@fixeddrivefreeMB
				,@tempdbPath
				,@isShared
				,@isPreAllocated

/****************************************************************
		  Gathering Data Page information
*****************************************************************/
--declare @run_date datetime
--set @run_date = getdate()

insert into dbo.tempdb_pagestats_log
select
      @run_date
    , f.name
    , u.unallocated_extent_page_count
    , u.version_store_reserved_page_count
    , u.user_object_reserved_page_count
    , u.internal_object_reserved_page_count
    , u.mixed_extent_page_count
from sys.dm_db_file_space_usage as u
join sys.master_files as f on u.database_id = f.database_id and u.file_id = f.file_id

/****************************************************************
		 Space utilization space percentage
*****************************************************************/
--Check to see if the utilization space is over pre-determined percentage
--if yes run dbasp_check_session_TempDB

if (select count(*) from dbo.Local_ServerEnviro where env_type = 'check_tempdb_percent')> 0

    begin
	   select @checkpercent = convert(decimal(18,2),env_detail) from  dbo.Local_ServerEnviro where env_type = 'check_tempdb_percent'
    end

else

    begin
	set @checkpercent = 50.00
    end

if @percentagework > @checkpercent

    begin
	    exec dbaadmin.dbo.dbasp_check_session_TempDB
    end

-------------------------  Finalization for process  -----------------------

drop table #tempfiledir



 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_code_updates
------------------------------------------------------------------------------------------------------- 
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
 
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[dbasp_code_updates]') AND type in (N'P', N'PC'))
Begin
EXEC dbo.sp_executesql @statement = N'


CREATE PROCEDURE dbo.dbasp_code_updates

/**************************************************************
 **  Stored Procedure dbasp_code_updates                  
 **  Written by Jim Wilson, Getty Images                
 **  February 13, 2008                                      
 **  
 **  This dbasp is set up to check for new updates of dbaadmin
 **  and DEPLinfo.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     				Desc
--	==========	====================	=============================================
--	02/13/2008	Jim Wilson		New process for SQL 2005.
--	03/16/2010	Jim Wilson		Added section for dbaperf DB.
--	05/04/2010	Jim Wilson		SQL 2008 starts here.
--	======================================================================================

/***
 
--***/


-----------------  declares  ------------------
DECLARE	 
	 @cmd			nvarchar(4000)
	,@sqlcmd		nvarchar(500)
	,@charpos		int
	,@central_server 	sysname
	,@ENVname	 	sysname
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_filename		sysname
	,@save_cmdoutput	nvarchar(255)

create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex(''\'', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX(''\'', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, ''$'')
   end

Select @central_server = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = ''CentralServer''
Select @ENVname = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = ''ENVname''
--print @central_server
--print @ENVname


--  DBAADMIN Process ---------------------------------------------------------------------------------------------
--  capture dir from central server
delete from #DirectoryTempTable
select @cmd = ''dir /B \\'' + @central_server + ''\'' + @central_server + ''_builds\dbaadmin\'' + @ENVname 
Print @cmd
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where cmdoutput not like ''%dbaadmin_2008_release%''
--select * from #DirectoryTempTable

--  start process
start_process01:
If (select count(*) from #DirectoryTempTable) > 0
   begin
	Select @save_cmdoutput = (select top 1 cmdoutput from #DirectoryTempTable where cmdoutput like ''%dbaadmin_2008_release%'')
	Select @save_filename = @save_cmdoutput

	--  check to see if this file has already been run
	If @save_filename not in (select vchNotes from dbaadmin.dbo.build where vchName = ''dbaadmin'') 
	   begin
		select @sqlcmd = ''sqlcmd -S'' + @@servername + '' -ddbaadmin -i\\'' + @central_server + ''\'' + @central_server + ''_builds\dbaadmin\'' + @ENVname + ''\'' + rtrim(@save_filename) + '' -o\\'' + @save_servername + ''\'' + @save_servername2 + ''_SQLjob_logs\dbaadmin_release.txt -E''
		print @sqlcmd
		exec master.sys.xp_cmdshell @sqlcmd
	   end
   end


Delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
If (select count(*) from #DirectoryTempTable) > 0
   begin
	goto start_process01
   end



--  DBAPERF Process ---------------------------------------------------------------------------------------------
--  capture dir from central server
delete from #DirectoryTempTable
select @cmd = ''dir /B \\'' + @central_server + ''\'' + @central_server + ''_builds\dbaperf\'' + @ENVname 
Print @cmd
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where cmdoutput not like ''%dbaperf_2008_release%''
--select * from #DirectoryTempTable

--  start process
start_process02:
If (select count(*) from #DirectoryTempTable) > 0
   begin
	Select @save_cmdoutput = (select top 1 cmdoutput from #DirectoryTempTable where cmdoutput like ''%dbaperf_2008_release%'')
	Select @save_filename = @save_cmdoutput

	--  check to see if this file has already been run
	If @save_filename not in (select vchNotes from dbaadmin.dbo.build where vchName = ''dbaperf'') 
	   begin
		select @sqlcmd = ''sqlcmd -S'' + @@servername + '' -ddbaperf -i\\'' + @central_server + ''\'' + @central_server + ''_builds\dbaperf\'' + @ENVname + ''\'' + rtrim(@save_filename) + '' -o\\'' + @save_servername + ''\'' + @save_servername2 + ''_SQLjob_logs\dbaperf_release.txt -E''
		print @sqlcmd
		exec master.sys.xp_cmdshell @sqlcmd
	   end
   end


Delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
If (select count(*) from #DirectoryTempTable) > 0
   begin
	goto start_process02
   end





--  DEPLinfo Process ---------------------------------------------------------------------------------------------
If (SELECT DATABASEPROPERTYEX (''DEPLinfo'',''status'')) <> ''ONLINE'' or (SELECT DATABASEPROPERTYEX (''DEPLinfo'',''status'')) is null
   begin
	goto label99
   end

--  capture dir from central server
delete from #DirectoryTempTable
select @cmd = ''dir /B \\'' + @central_server + ''\'' + @central_server + ''_builds\DEPLinfo\''
Print @cmd
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where cmdoutput not like ''%DEPLinfo_2008_2%''
--select * from #DirectoryTempTable

--  start process
start_process03:
If (select count(*) from #DirectoryTempTable) > 0
   begin
	Select @save_cmdoutput = (select top 1 cmdoutput from #DirectoryTempTable where cmdoutput like ''%DEPLinfo_2008_2%'')
	Select @save_filename = @save_cmdoutput

	--  check to see if this file has already been run
	If @save_filename not in (select vchNotes from DEPLinfo.dbo.build where vchName = ''DEPLinfo'') 
	   begin
		select @sqlcmd = ''sqlcmd -S'' + @@servername + '' -dDEPLinfo -i\\'' + @central_server + ''\'' + @central_server + ''_builds\DEPLinfo\'' + rtrim(@save_filename) + '' -o\\'' + @save_servername + ''\'' + @save_servername2 + ''_SQLjob_logs\DEPLinfo_release.txt -E''
		print @sqlcmd
		exec master.sys.xp_cmdshell @sqlcmd
	   end
   end

Delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
If (select count(*) from #DirectoryTempTable) > 0
   begin
	goto start_process03
   end

----------------  End  -------------------

label99:

Print ''''
Print ''Code Update Process Complete.''

drop table #DirectoryTempTable



 
 
'
End
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_CopyArchive_process
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_CopyArchive_process]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_CopyArchive_process]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_CopyArchive_process (@DomainName sysname = 'amer'
						,@SQLenv sysname = 'Production')

/**************************************************************
 **  Stored Procedure dbasp_CopyArchive_process                  
 **  Written by Jim Wilson, Getty Images                
 **  October 22, 2008                                      
 **  
 **  This dbasp is set up to gather files from the dbasql
 **  and dba_archive folders for all supported SQL servers.
 **  The files and folders are placed in the Central_Archive 
 **  share on each central server.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/22/2008	Jim Wilson		New process.
--	======================================================================================

/***
Declare @DomainName sysname
Declare @SQLenv sysname

Select @DomainName = 'AMER'
Select @SQLenv = 'Production'
--***/

-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd	 		nvarchar(4000)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@charpos		int
	,@save_dba_ServerName	sysname
	,@save_dba_SQLName	sysname
	,@hold_dba_SQLName	sysname
	,@fileexist_path	nvarchar(255)


----------------  initial values  -------------------
Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Create table variable
declare @servernames table (dba_servername sysname
			    ,dba_sqlname sysname)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

						


/****************************************************************
 *                MainLine
 ***************************************************************/
Print  ' '
Select @miscprint = 'Start:  Copy Archive to central server process.'
Print  @miscprint

If @SQLenv like '%prod%'
   begin
	Insert into @servernames
	SELECT distinct ServerName, SQLName
	from dbo.DBA_Serverinfo
	where DomainName = @DomainName
	and SQLenv = 'Production'
	and active = 'y'
   end
Else
   begin
	Insert into @servernames
	SELECT distinct ServerName, SQLName
	from dbo.DBA_Serverinfo
	where DomainName = @DomainName
	and SQLenv <> 'Production'
	and active = 'y'
   end


--select * from @servernames order by dba_servername

If (select count(*) from @servernames) > 0
   begin
	start01:

	Select @save_dba_ServerName = (select top 1 dba_servername from @servernames order by dba_servername)
	Select @save_dba_SQLName = (select top 1 dba_sqlname from @servernames where dba_servername = @save_dba_ServerName)
	Select @hold_dba_SQLName = @save_dba_SQLName

	Select @charpos = charindex('\', @save_dba_SQLName)
	IF @charpos <> 0
	   begin
		Select @save_dba_SQLName = stuff(@save_dba_SQLName, @charpos, 1, '$')
	   end

	--  Make sure we have a local folder for this sql instance
	--  If not, create one.  If so, remove it and create a new one.
	Delete from #fileexists
	Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername + '_Central_Archive\' + @save_dba_SQLName
	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) <> 1
	   begin
		Select @cmd = 'mkdir "' + @fileexist_path + '"'
		Print 'Creating central archivec folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 

		Select @cmd = 'mkdir "' + @fileexist_path + '\dbasql"'
		Print 'Creating central archivec folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 

		Select @cmd = 'mkdir "' + @fileexist_path + '\dba_archive"'
		Print 'Creating central archivec folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 
	   end
	Else
	   begin
		Select @cmd = 'rmdir "' + @fileexist_path + '" /S /Q'
		Print 'Remove central archivec folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 

		Select @cmd = 'mkdir "' + @fileexist_path + '"'
		Print 'Creating central archivec folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 

		Select @cmd = 'mkdir "' + @fileexist_path + '\dbasql"'
		Print 'Creating central archivec folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 

		Select @cmd = 'mkdir "' + @fileexist_path + '\dba_archive"'
		Print 'Creating central archivec folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 
	   end


	--  Copy the dbasql files from the target server.
	select @cmd = 'robocopy /Z /R:3 /E \\' + @save_dba_ServerName + '\' + @save_dba_SQLName + '_dbasql ' + @fileexist_path + '\dbasql *.*'
	Print @cmd
	exec master.sys.xp_cmdshell @cmd


	--  Copy the dba_archive files from the target server.
	select @cmd = 'robocopy /Z /R:3 /E \\' + @save_dba_ServerName + '\' + @save_dba_SQLName + '_dba_archive ' + @fileexist_path + '\dba_archive *.*'
	Print @cmd
	exec master.sys.xp_cmdshell @cmd


	delete from @servernames where dba_servername = @save_dba_ServerName and dba_sqlname = @hold_dba_SQLName
	If (select count(*) from @servernames) > 0
	   begin
		goto start01
	   end

   end




----------------  End  -------------------
label99:

drop table #fileexists

Print  ' '
Select @miscprint = 'End:  Copy Archive to central server process.'
Print  @miscprint




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_create_NXTshare
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_create_NXTshare]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_create_NXTshare]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_create_NXTshare (@nxt_path nvarchar(200) = NULL)

/**************************************************************
 **  Stored Procedure dbasp_create_NXTshare                  
 **  Written by Jim Wilson, Getty Images                
 **  October 10, 2005                                      
 **  
 **  This dbasp is set up to create the NXT share, which is used
 **  as part of the SQL deployment process.  The NXT share will
 **  allow for local storage of the *.mdfnxt files.
 **
 **  NOTE:  This share should not be configured on Production Servers!
 **
 **  To execute this sproc, the path to the desired location for 
 **  the NXT folder may be provided as input.  If the path is not
 **  specified, the NXT folder will be created at the root directory
 **  on the drive that holds the backup share.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/10/2005	Jim Wilson		New process.
--	07/26/2007	Jim Wilson		Added check for production environment.
--	07/26/2007	Jim Wilson		Updated for SQL2005.
--	======================================================================================

/***
Declare @nxt_path nvarchar(200)

--Select @nxt_path = 'e:\'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@command 			nvarchar(4000)
	,@dos_command			nvarchar(1500)
	,@charpos			int	
	,@result			int
	,@save_nxtfoldername		sysname
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_sqlinstance		sysname
	,@save_envname			sysname
	,@fileexist_path		sysname
	,@phy_path			sysname
	,@path_nxt			sysname
	,@isNMinstance			char(1)
	,@in_key			sysname
	,@in_path			sysname
	,@in_value			sysname
	,@result_value			nvarchar(500)


----------------  initial values  -------------------

Select @save_servername = @@servername
Select @save_servername2 = @@servername
Select @save_nxtfoldername = 'nxt'
Select @isNMinstance = 'n'


Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
	Select @isNMinstance = 'y'

	Select @save_nxtfoldername = @save_nxtfoldername + '$' + @save_sqlinstance
   end


Create table #ShareTempTable(path nvarchar(500) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)



--  Make sure the user has admin privileges
IF (not is_srvrolemember(N'sysadmin') = 1)
   begin
	Select @miscprint = 'ERROR: Current user does not have sufficient privileges to run this process.' 
	Print  @miscprint
	Select @miscprint = '       Must have local admin privileges on the server.' 
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Nothing was done.' 
	Print  @miscprint
	goto label99
   end


--  Do not run this in production
If @isNMinstance = 'n'
   begin
	select @in_key = 'HKLM'
	select @in_path = 'System\CurrentControlSet\Services\MSSQLServer'
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end
Else
   begin
	select @in_key = 'HKLM'
	select @in_path = 'System\CurrentControlSet\Services\MSSQL$' + @save_sqlinstance
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end

Select @save_envname = @result_value

If @save_envname like '%production%'
   begin
	Select @miscprint = 'DBA ERROR: This process (create NXT share) is not designed to run in a production environment.' 
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Nothing was done.' 
	Print  @miscprint
	goto label99
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Check input parm and if the @nxt_path input parm is null, try to fill it in using the path to the backup share.
If @nxt_path is null
   begin
	Delete from #ShareTempTable
	Select @command = 'RMTSHARE \\' + @save_servername + '\' + @save_servername2 + '_backup'
	Insert into #ShareTempTable exec master.sys.xp_cmdshell @command

	Select @phy_path = substring(path,charindex('h',path)+1,len(path)-charindex('h',path))
	from #ShareTempTable
	where path like 'path%'

	If @phy_path is not null
	   begin
		select @phy_path = ltrim(rtrim(@phy_path))
		Select @nxt_path = substring(@phy_path, 1, charindex(':',@phy_path)+1)
	   end
   end


--  If the @nxt_path is still null, error out.  If not, verify the path exists.
If @nxt_path is null
   begin
	Select @miscprint = 'ERROR: A path for the NXT folder could not be found.' 
	Print  @miscprint
	Select @miscprint = '       Please provide full path to the intended location of the NXT folder via the input parm ''@nxt_path''.' 
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Nothing was done.' 
	Print  @miscprint
	goto label99
   end
Else
   begin
	Delete from #fileexists

	If right(@nxt_path, 1) = '\'
	   begin
		Select @fileexist_path = @nxt_path
	   end
	Else
	   begin
		Select @fileexist_path = @nxt_path + '\'
	   end

	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) = 0
	   begin
		Select @miscprint = 'ERROR: Path provided could not be found.' 
		Print  @miscprint
		Select @miscprint = '       Please verify the intended location of the NXT folder.' 
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'Nothing was done.' 
		Print  @miscprint
		goto label99
	   end
	Else
	   begin
		Select @path_nxt = @fileexist_path
	   end
   end



--  Check to see if the 'nxt' folder exists
Delete from #fileexists
Select @fileexist_path = @path_nxt + @save_nxtfoldername
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) <> 1
   begin
	Select @dos_command = 'mkdir "' + @path_nxt + @save_nxtfoldername + '"'
	Print 'Creating ''' + @save_nxtfoldername + ''' folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

Print ' '
Print 'The ' + @save_nxtfoldername + ' folder is in place.'
Print ' '


--  Check to see if the NXT share has already been set up
Delete from #ShareTempTable
Select @command = 'RMTSHARE \\' + @save_servername
Insert into #ShareTempTable exec master.sys.xp_cmdshell @command
delete from #ShareTempTable where path is null
--select * from #ShareTempTable

If exists(select 1 from #ShareTempTable where path like '%' + @save_servername2 + '_nxt%')
   begin
	--  If the nxt share is found, delete it (we will recreate it)
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_nxt /DELETE'
	Print 'Deleting the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	
	Print ' '
	Print 'Existing NXT share has been deleted'
	Print ' '
   end

Select @path_nxt = '"' + @path_nxt + @save_nxtfoldername + '"'

Print ' '
Print ' '

--  Create the share, and share security, for NXT
Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_nxt =' + @path_nxt + ' /unlimited'
Print 'Creating the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_nxt /grant administrators:f'
Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_nxt /Remove everyone'
Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

Select @dos_command = 'XCACLS ' + @path_nxt + ' /G administrators:F /Y'
Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

Print ' '



----------------  End  -------------------

label99:


drop table #ShareTempTable
drop table #fileexists



Print ' '
Print 'Processing for dbasp_create_NXTshare - complete!'
Print ' '






 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_dba_setpolicygrants
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_dba_setpolicygrants]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_dba_setpolicygrants]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_dba_setpolicygrants


/*********************************************************
 **  Stored Procedure dbasp_dba_setpolicygrants                 
 **  Written by Jim Wilson, Getty Images                
 **  November 13, 2008                                      
 **  
 **  This procedure sets user_rights for specific policies
 **  within Windows.  The normal SQL install will do this, but
 **  this sproc will grant those rights to a domain group, which
 **  will make it easier to change service accounts at some regular
 **  interval.
 **
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/13/2008	Jim Wilson		New process
--	11/22/2008	Jim Wilson		Removed loop on ##temp table
--	======================================================================================

/***

--***/


DECLARE
	 @miscprint				nvarchar(4000)
	,@cmd					nvarchar(500)
	,@charpos				int
	,@save_servername			sysname
	,@isNMinstance				char(1)
	,@save_svcaccount			sysname
	,@save_domain				sysname
	,@save_sqlinstance			sysname
	,@save_groupSID				nvarchar(500)
	,@save_infvalue				nvarchar(4000)
	,@SeTcbPrivilege_flag			char(1)
	,@SeChangeNotifyPrivilege_flag		char(1)
	,@SeLockMemoryPrivilege_flag		char(1)
	,@SeBatchLogonRight_flag		char(1)
	,@SeServiceLogonRight_flag		char(1)
	,@SeAssignPrimaryTokenPrivilege_flag	char(1)
	,@updated_flag				char(1)

----------------  initial values  -------------------
Select @SeTcbPrivilege_flag = 'n'
Select @SeChangeNotifyPrivilege_flag = 'n'
Select @SeLockMemoryPrivilege_flag = 'n'
Select @SeBatchLogonRight_flag = 'n'
Select @SeServiceLogonRight_flag = 'n'
Select @SeAssignPrimaryTokenPrivilege_flag = 'n'
Select @updated_flag = 'n'

--  Create temp tables
declare @tblv_DBname table (dbname sysname)
create table #DirectoryTempTable(cmdoutput nvarchar(255) null)
create table ##INF (INFValue nvarchar (4000) null)
create table ##INFout (INFValue nvarchar (4000) null)


--  Get server name info
Select @save_domain = ''
Select @save_servername = @@servername
Select @isNMinstance = 'n'

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
	Select @isNMinstance = 'y'
   end

--  Get domain name info
Select @cmd = 'whoami'

insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd--, no_output 
delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable

If (select count(*) from #DirectoryTempTable) > 0
   begin
	Select @save_svcaccount = (select top 1 cmdoutput from #DirectoryTempTable)
   end

Select @charpos = charindex('\', @save_svcaccount)
IF @charpos <> 0
   begin
	Select @save_domain = substring(@save_svcaccount, 1, (CHARINDEX('\', @save_svcaccount)-1))
   end





/****************************************************************
 *                MainLine
 ***************************************************************/

-- Step 1: Verfiy the local *.sdb file is in place (move it to c:\)
Select @cmd = 'dir %windir%\security\Database\secedit.sdb'
Delete from #DirectoryTempTable
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
Delete from #DirectoryTempTable where cmdoutput not like '%secedit.sdb%'
Delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable
If (select count(*) from #DirectoryTempTable) = 0
   begin
	Select @miscprint = 'DBA ERROR: Local secedit.sdb file not found.'
	Print @miscprint
	Select @miscprint = 'DBA ERROR: Unable to complete User_Rights Policy Updates for server ' + @@servername
	Print @miscprint
	goto label99
   end

Print 'Copy *.sdb file to c:\'
Select @cmd = 'xcopy "%windir%\security\Database\secedit.sdb" "c:\"'
Select @cmd = @cmd + ' /Y /R'
Print @cmd
Print ''
EXEC master.sys.xp_cmdshell @cmd--, no_output 




-- Step 2: Create new *.INF template file using secedit /export
Select @cmd = 'secedit /export /cfg c:\dba_user_rights_now.INF /areas user_rights'
Print @cmd
Print ''
EXEC master.sys.xp_cmdshell @cmd--, no_output 




-- Step 3: Get the SID that matches the SQL service account domain group
Select @cmd = 'whoami /groups'
Print @cmd
Print ''

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd--, no_output 
delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable

If exists (select 1 from #DirectoryTempTable where cmdoutput like 'AMER\SG-AMER-SeaSQLProdsvc%' or cmdoutput like 'STAGE\SeaSQLStageSvc%' or cmdoutput like 'PRODUCTION\SeaSQLProdsvc%')
   begin
	Select @save_groupSID = (select top 1 cmdoutput from #DirectoryTempTable where cmdoutput like 'AMER\SG-AMER-SeaSQLProdsvc%' or cmdoutput like 'STAGE\SeaSQLStageSvc%' or cmdoutput like 'PRODUCTION\SeaSQLProdsvc%')

	Select @charpos = charindex('Group', @save_groupSID)
	IF @charpos <> 0
	   begin
		Select @save_groupSID = substring(@save_groupSID, @charpos+5, 200)
		Select @save_groupSID = ltrim(@save_groupSID)
	   end
	Else
	   begin
		Select @miscprint = 'DBA ERROR: Group SID not found for AMER\SG-AMER-SeaSQLProdsvc.'
		Print @miscprint
		Select @miscprint = 'DBA ERROR: Unable to complete User_Rights Policy Updates for server ' + @@servername
		Print @miscprint
		goto label99
	   end


	Select @charpos = charindex(' ', @save_groupSID)
	IF @charpos <> 0
	   begin
		Select @save_groupSID = substring(@save_groupSID, 1, @charpos-1)
	   end

	Select @save_groupSID = rtrim(@save_groupSID)

   end

Print 'SQL service domain group SID is ' + @save_groupSID
Print ''



-- Step 4: Read in the *.INF file created in Step 2, and create a modified version using the SID from Step 3.
Select @cmd = 'bcp ##INF in "c:\dba_user_rights_now.INF" -S' + @@servername + ' -m 0 -w -b 1000 -T' 
Print @cmd
Print ''

delete from ##INF
insert into ##INF exec master.sys.xp_cmdshell @cmd--, no_output 
delete from ##INF where INFValue is null
--select * from ##INF

If not exists (select 1 from ##INF where INFvalue like '%Privilege Rights%')
   begin
	Select @miscprint = 'DBA ERROR: The created *.INF file for this process is invalid.'
	Print @miscprint
	Select @miscprint = 'DBA ERROR: Unable to complete User_Rights Policy Updates for server ' + @@servername
	Print @miscprint
	goto label99
   end


--  Check for policies
Select @save_infvalue = (select top 1 INFvalue from ##INF where INFvalue like '%SeTcbPrivilege%')
If @save_infvalue like 'SeTcbPrivilege%'
   begin
	Select @SeTcbPrivilege_flag = 'y'
	If @save_infvalue not like '%' + @save_groupSID + '%'
	   begin
		Select @updated_flag = 'y'
		Select @save_infvalue = rtrim(@save_infvalue) + ',*' + @save_groupSID
		Insert into ##INFout values(@save_infvalue)
		--Print @save_infvalue
	   end
   end 

Select @save_infvalue = (select top 1 INFvalue from ##INF where INFvalue like '%SeChangeNotifyPrivilege%')
If @save_infvalue like 'SeChangeNotifyPrivilege%'
   begin
	Select @SeChangeNotifyPrivilege_flag = 'y'
	If @save_infvalue not like '%' + @save_groupSID + '%'
	   begin
		Select @updated_flag = 'y'
		Select @save_infvalue = rtrim(@save_infvalue) + ',*' + @save_groupSID
		Insert into ##INFout values(@save_infvalue)
		--Print @save_infvalue
	   end
   end 

Select @save_infvalue = (select top 1 INFvalue from ##INF where INFvalue like '%SeLockMemoryPrivilege%')
If @save_infvalue like 'SeLockMemoryPrivilege%'
   begin
	Select @SeLockMemoryPrivilege_flag = 'y'
	If @save_infvalue not like '%' + @save_groupSID + '%'
	   begin
		Select @updated_flag = 'y'
		Select @save_infvalue = rtrim(@save_infvalue) + ',*' + @save_groupSID
		Insert into ##INFout values(@save_infvalue)
		--Print @save_infvalue
	   end
   end 

Select @save_infvalue = (select top 1 INFvalue from ##INF where INFvalue like '%SeBatchLogonRight%')
If @save_infvalue like 'SeBatchLogonRight%'
   begin
	Select @SeBatchLogonRight_flag = 'y'
	If @save_infvalue not like '%' + @save_groupSID + '%'
	   begin
		Select @updated_flag = 'y'
		Select @save_infvalue = rtrim(@save_infvalue) + ',*' + @save_groupSID
		Insert into ##INFout values(@save_infvalue)
		--Print @save_infvalue
	   end
   end 

Select @save_infvalue = (select top 1 INFvalue from ##INF where INFvalue like '%SeServiceLogonRight%')
If @save_infvalue like 'SeServiceLogonRight%'
   begin
	Select @SeServiceLogonRight_flag = 'y'
	If @save_infvalue not like '%' + @save_groupSID + '%'
	   begin
		Select @updated_flag = 'y'
		Select @save_infvalue = rtrim(@save_infvalue) + ',*' + @save_groupSID
		Insert into ##INFout values(@save_infvalue)
		--Print @save_infvalue
	   end
   end 

Select @save_infvalue = (select top 1 INFvalue from ##INF where INFvalue like '%SeAssignPrimaryTokenPrivilege%')
If @save_infvalue like 'SeAssignPrimaryTokenPrivilege%'
   begin
	Select @SeAssignPrimaryTokenPrivilege_flag = 'y'
	If @save_infvalue not like '%' + @save_groupSID + '%'
	   begin
		Select @updated_flag = 'y'
		Select @save_infvalue = rtrim(@save_infvalue) + ',*' + @save_groupSID
		Insert into ##INFout values(@save_infvalue)
		--Print @save_infvalue
	   end
   end 


end_inf:



--  Now check to see if specific policies were not in the INF file at all.
If @SeTcbPrivilege_flag = 'n'
   begin
	Select @updated_flag = 'y'
	Select @save_infvalue = 'SeTcbPrivilege = *' + @save_groupSID
	Insert into ##INFout values(@save_infvalue)
   end

If @SeChangeNotifyPrivilege_flag = 'n'
   begin
	Select @updated_flag = 'y'
	Select @save_infvalue = 'SeChangeNotifyPrivilege = *' + @save_groupSID
	Insert into ##INFout values(@save_infvalue)
   end

If @SeLockMemoryPrivilege_flag = 'n'
   begin
	Select @updated_flag = 'y'
	Select @save_infvalue = 'SeLockMemoryPrivilege = *' + @save_groupSID
	Insert into ##INFout values(@save_infvalue)
   end

If @SeBatchLogonRight_flag = 'n'
   begin
	Select @updated_flag = 'y'
	Select @save_infvalue = 'SeBatchLogonRight = *' + @save_groupSID
	Insert into ##INFout values(@save_infvalue)
   end

If @SeServiceLogonRight_flag = 'n'
   begin
	Select @updated_flag = 'y'
	Select @save_infvalue = 'SeServiceLogonRight = *' + @save_groupSID
	Insert into ##INFout values(@save_infvalue)
   end

If @SeAssignPrimaryTokenPrivilege_flag = 'n'
   begin
	Select @updated_flag = 'y'
	Select @save_infvalue = 'SeAssignPrimaryTokenPrivilege = *' + @save_groupSID
	Insert into ##INFout values(@save_infvalue)
   end


--Select * from ##INFout
Select @cmd = 'bcp ##INFout out "c:\dba_user_rights_new.INF" -S' + @@servername + ' -w -T' 
Print @cmd
Print ''
exec master.sys.xp_cmdshell @cmd--, no_output 

-- Verfiy output file exists
Select @cmd = 'dir c:\dba_user_rights_new.INF'
Delete from #DirectoryTempTable
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd--, no_output 
Delete from #DirectoryTempTable where cmdoutput not like '%dba_user_rights_new.INF%'
Delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable
If (select count(*) from #DirectoryTempTable) = 0
   begin
	Select @miscprint = 'DBA ERROR: New c:\dba_user_rights_new.INF file was not created properly.'
	Print @miscprint
	Select @miscprint = 'DBA ERROR: Unable to complete User_Rights Policy Updates for server ' + @@servername
	Print @miscprint
	goto label99
   end


-- Step 5: Update the user_rights policy permissions using secedit /configure and the *.INF file created in Step 4.
If @updated_flag = 'y'
   begin
	Print ''
	Print 'Start secedit /configure process'

	Select @cmd = 'secedit /configure /db c:\secedit.sdb /cfg c:\dba_user_rights_new.INF /overwrite /areas user_rights /quiet'
	Print @cmd
	Print ''
	EXEC master.sys.xp_cmdshell @cmd--, no_output 
   end
Else
   begin
	Print 'No policy user_rights updates needed.'
	Print ''
   end
 

--  Finalization  --------------------------------------------------------------------------------------------------
label99:

drop table #DirectoryTempTable
drop table ##INF
drop table ##INFout





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_dba_sqlsetup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_dba_sqlsetup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_dba_sqlsetup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[dbasp_dba_sqlsetup] (@backup_path varchar(200) = NULL
					,@mdf_path varchar(200) = NULL
					,@ldf_path varchar(200) = NULL)

/**************************************************************
 **  Stored Procedure dbasp_dba_sqlsetup                  
 **  Written by Jim Wilson, Getty Images                
 **  September 6, 2002                                      
 **  
 **  This dbasp is set up to help in the standard SQL setup
 **  process, which includes standard folders and shares.
 **
 **  To execute this sproc, the full path to the backup folder
 **  must be provided as input, unless shares to the dbasql and
 **  dba_archive folders had previously been created.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/06/2002	Jim Wilson		New SQL setup process.
--	10/22/2002	Jim Wilson		Added SQLjob_logs and deployment_logs folders.
--	11/06/2002	Jim Wilson		Added mdf and ldf shares.
--	02/11/2003	Jim Wilson		Moved location of SQLjob_logs folder and added share.
--	04/17/2003	Jim Wilson		Changes for new instance share names.
--	06/09/2003	Jim Wilson		Added permissionsfor AMER domain users.
--	10/17/2003	Jim Wilson		Added double quotes around all paths.
--	03/01/2004	Jim Wilson		Added local read and write groups.
--	07/13/2004	Jim Wilson		Check for error 1788 when adding local read and write groups.
--	08/27/2004	Jim Wilson		Add bracket in cursor cu11 for dbname.
--	09/29/2004	Jim Wilson		Fix order of folder creation.
--	01/07/2005	Jim Wilson		Added double quotes for mkdir statements.
--	12/29/2005	Jim Wilson		exec dbasp_FixJobOutput at end to fix current jobs.
--	02/14/2006	Jim Wilson		Converted for sql2005.
--	05/04/2007	Jim Wilson		Fixed spelling for 'local'.
--	07/26/2007	Jim Wilson		exec dbasp_create_NXTshare to create NXT share.
--	12/28/2007	Jim Wilson		Added cluster processing. NXT is now done within this sproc also.
--	03/04/2008	Jim Wilson		Added default setting for @isNMinstance.
--	04/30/2008	Jim Wilson		Set dbaadmin and systeminfo owner and recovery option.
--	05/06/2008	Jim Wilson		New code for production group seasqlprodsvc.
--	05/12/2008	Jim Wilson		New code for sqladminprod2008 svc accounts.
--	05/27/2008	Jim Wilson		Added more new code for stage group seasqlstagesvc.
--	06/09/2008	Jim Wilson		Added XCACLS permissions to cluster shares.
--	01/09/2009	Jim Wilson		Changed cluster share perms from "domain admins" to "NOC".
--	02/06/2009	Jim Wilson		Fixed bug for Disk s: in clusters.
--	06/09/2009	Jim Wilson		Added code for dba_UpdateFiles folder.
--	06/18/2009	Jim Wilson		Added code for filescan folder.
--	05/21/2010	Jim Wilson		Removed systeminfo references.
--	======================================================================================

/***
Declare @backup_path varchar(200)
Declare @mdf_path varchar(200)
Declare @ldf_path varchar(200)
Select @backup_path = 'g:\Backup'
--Select @mdf_path = 'e:\mssql$a\data'
--Select @ldf_path = 'e:\mssql$a\data'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@command 			nvarchar(4000)
	,@dos_command			varchar(500)
	,@result			int
	,@len				int
	,@save_DBname			sysname
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_sqlinstance		sysname
	,@save_domain			sysname
	,@save_envname			sysname
	,@charpos			int	
	,@save_charpos			int
	,@save_drive_letter_part	char(2)
	,@save_data2			nvarchar(4000)
	,@save_disk_resname		sysname
	,@save_group_resname		sysname
	,@save_network_resname		sysname
	,@fileexist_path		sysname
	,@path_log			sysname
	,@path_dbasql			sysname
	,@path_dba_archive		sysname
	,@path_dba_reports		sysname
	,@path_dba_UpdateFiles		sysname
	,@path_filescan			sysname
	,@path_dba_mail			sysname
	,@path_builds			sysname
	,@path_datamigration		sysname
	,@path_backup			sysname
	,@path_mdf			sysname
	,@path_ldf			sysname
	,@path_SQLjob_logs		sysname
	,@path_nxt			sysname
	,@newpath_mdf			sysname
	,@newpath_ldf			sysname
	,@found_dbasql_fol		char(1)
	,@found_dba_archive_fol		char(1)
	,@found_dba_reports_fol		char(1)
	,@found_dba_UpdateFiles_fol	char(1)
	,@found_filescan_fol		char(1)
	,@found_dba_mail_fol		char(1)
	,@found_builds_fol		char(1)
	,@found_datamigration_fol	char(1)
	,@found_SQLjob_logs_fol		char(1)
	,@found_deployment_logs_fol	char(1)
	,@found_backup_fol		char(1)
	,@found_nxt_fol			char(1)
	,@found_dbasql_shr		char(1)
	,@found_dba_archive_shr		char(1)
	,@found_dba_mail_shr		char(1)
	,@found_builds_shr		char(1)
	,@found_backup_shr		char(1)
	,@found_log_shr			char(1)
	,@found_mdf_shr			char(1)
	,@found_ldf_shr			char(1)
	,@found_SQLjob_logs_shr		char(1)
	,@found_nxt_shr			char(1)
	,@save_iscluster		char(1)
	,@isNMinstance			char(1)
	,@error_count			int
	,@in_key			sysname
	,@in_path			sysname
	,@in_value			sysname
	,@result_value			nvarchar(500)

DECLARE
	 @cu11filename			sysname

DECLARE
	 @cu12path			nvarchar(500)


----------------  initial values  -------------------
Select 	
	 @found_dbasql_fol		= 'n'
	,@found_dba_archive_fol		= 'n'
	,@found_dba_reports_fol		= 'n'
	,@found_dba_UpdateFiles_fol	= 'n'
	,@found_filescan_fol		= 'n'
	,@found_dba_mail_fol		= 'n'
	,@found_builds_fol		= 'n'
	,@found_datamigration_fol	= 'n'
	,@found_SQLjob_logs_fol		= 'n'
	,@found_deployment_logs_fol	= 'n'
	,@found_backup_fol		= 'n'
	,@found_nxt_fol			= 'n'
	,@found_dbasql_shr		= 'n'
	,@found_dba_archive_shr		= 'n'
	,@found_dba_mail_shr		= 'n'
	,@found_builds_shr		= 'n'
	,@found_backup_shr		= 'n'
	,@found_log_shr			= 'n'
	,@found_mdf_shr			= 'n'
	,@found_ldf_shr			= 'n'
	,@found_SQLjob_logs_shr		= 'n'
	,@found_nxt_shr			= 'n'
	,@newpath_mdf 			= ''
	,@newpath_ldf 			= ''


-- Set variables ---------------------------------------------------------------------------
Select @save_sqlinstance = 'mssqlserver'
Select @save_servername = @@servername
Select @save_servername2 = @@servername
Select @isNMinstance = 'n'


Create table #ShareTempTable(path nvarchar(500) null)

Create table #loginconfig(name1 sysname null, config_value sysname null)

Create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

Create table #cluster_info1 (data1 nvarchar(4000))
Create table #cluster_info2 (data2 nvarchar(4000))

declare @filenames table (fname		sysname)


Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
	Select @isNMinstance = 'y'
   end


--  Make sure the user has admin privileges
IF (not is_srvrolemember(N'sysadmin') = 1)
   begin
	Select @miscprint = 'ERROR: Current user does not have sufficient privileges to run this process.' 
	Print  @miscprint
	Select @miscprint = '       Must have local admin privileges on the server.' 
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Nothing was done.' 
	Print  @miscprint
	goto label99
   end


--  Get the domain name and save it (Note:  We have to strip off the last byte from config_value because it's not printable)
If @isNMinstance = 'n'
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\MSSQLServer'
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end
Else
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\MSSQL$' + @save_sqlinstance
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end


Select @save_domain = @result_value
Select @save_envname = @result_value

print @save_domain
print @save_envname

Select @charpos = charindex('\', @save_domain)
IF @charpos <> 0
   begin
	Select @save_domain = substring(@save_domain, 1, (CHARINDEX('\', @save_domain)-1))
	Select @save_envname = rtrim(substring(@save_envname, @charpos+1, 100))
	goto get_domain_end
   end


Select @charpos = charindex('@', @save_domain)
IF @charpos <> 0
   begin
	Select @save_domain = substring(@save_domain, @charpos+1, (CHARINDEX('.', @save_domain)-1)-@charpos)
	Select @save_envname = rtrim(substring(@save_envname, 1, @charpos-1))
	goto get_domain_end
   end


Insert into #loginconfig exec master.dbo.xp_loginconfig 'default domain'
Select @save_domain = config_value from #loginconfig

get_domain_end:


--  Reformat the service account name if needed (remove the @getty...)
Select @charpos = charindex('@', @save_envname)
IF @charpos <> 0
   begin
	Select @save_envname = substring(@save_envname, 1, @charpos-1)
   end


--  Capture Cluster (y/n)
If (SERVERPROPERTY('IsClustered')) = 0
   begin
	Select @save_iscluster = 'n'
   end
Else
   begin
	Select @save_iscluster = 'y'
	Select @command = 'cluster . res /prop'
	--Print @command
	Insert into #cluster_info1 exec master.sys.xp_cmdshell @command
	delete from #cluster_info1 where data1 is null
	delete from #cluster_info1 where rtrim(data1) = ''
--Select * from #cluster_info1

	Select @command = 'cluster . res /status'
	--Print @command
	Insert into #cluster_info2 exec master.sys.xp_cmdshell @command
	delete from #cluster_info2 where data2 is null
	delete from #cluster_info2 where rtrim(data2) = ''
	delete from #cluster_info2 where rtrim(data2) like '%Listing status%'
--Select * from #cluster_info2
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Check input parm and if the @backup_path input parm is null, try to fill it in.
If @backup_path is null
   begin
	Delete from #ShareTempTable
	Select @command = 'RMTSHARE \\' + @save_servername
	Insert into #ShareTempTable exec master.sys.xp_cmdshell @command
	delete from #ShareTempTable where path is null
	delete from #ShareTempTable where path not like '%dba%'
	--select * from #ShareTempTable

	If (select count(*) from #ShareTempTable) > 0
	   begin
		start_cu12:
		Select @cu12path = (select Top 1 path from #ShareTempTable order by path)

		Select @charpos = charindex('dbasql', @cu12path)
		IF @charpos <> 0
		   begin
			Select @charpos = charindex('\backup\', @cu12path)
			IF @charpos <> 0
			   begin
				Select @save_charpos = @charpos
				Select @charpos = charindex(':\', @cu12path)
				Select @backup_path = substring(@cu12path, @charpos-1, (@save_charpos - @charpos+8))
				goto end_cu12
			   end
		   end

		Select @charpos = charindex('dba_archive', @cu12path)
		IF @charpos <> 0
		   begin
			Select @charpos = charindex('\backup\', @cu12path)
			IF @charpos <> 0
			   begin
				Select @save_charpos = @charpos
				Select @charpos = charindex(':\', @cu12path)
				Select @backup_path = substring(@cu12path, @charpos-1, (@save_charpos - @charpos+8))
				goto end_cu12
			   end
		   end

		Delete from #ShareTempTable where path = @cu12path
		If (select count(*) from #ShareTempTable) > 0
		   begin
			goto start_cu12
		   end

	   end

	end_cu12:

   end


--  If the @backup_path is still null, error out.  If not, verify the folder exists and set variables
If @backup_path is null
   begin
	Select @miscprint = 'ERROR: Backup path could not be found.' 
	Print  @miscprint
	Select @miscprint = '       Please provide full path to the backup folder via the input parm ''@backup_path''.' 
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Nothing was done.' 
	Print  @miscprint
	goto label99
   end
Else
   begin
	Delete from #fileexists
	Select @fileexist_path = @backup_path + '\'
	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) = 0
	   begin
		Select @miscprint = 'ERROR: Backup path provided could not be found.' 
		Print  @miscprint
		Select @miscprint = '       Make sure the folder has been created and please provide' 
		Print  @miscprint
		Select @miscprint = '       full path to the backup folder via the input parm ''@backup_path''.' 
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'Nothing was done.' 
		Print  @miscprint
		goto label99
	   end
	Else
	   begin
		Select @found_backup_fol = 'y'
		Select @path_dba_archive = @backup_path + '\dba_archive'
		Select @path_dbasql = @backup_path + '\dbasql'
		Select @path_dba_reports = @backup_path + '\dbasql\dba_reports'
		Select @path_dba_UpdateFiles = @backup_path + '\dbasql\dba_UpdateFiles'
		Select @path_filescan = @backup_path + '\dbasql\filescan'
		Select @path_backup = @backup_path
		Select @path_dba_mail = substring(@backup_path, 1, 1) + ':\dba_mail'
		Select @path_builds = substring(@backup_path, 1, 1) + ':\builds' 
		Select @path_datamigration = @path_builds + '\DataMigration' 
	   end
   end


--  Get the path to the SQL log folder (s\b at the same level as the data folder which holds the master mdf)
select @path_log = filename from master.sys.sysfiles where name = 'master'

Select @charpos = charindex('\data\master.mdf', @path_log)
Select @path_log = substring(@path_log, 1, (@charpos - 1))
Select @path_log = @path_log + '\log'
Select @path_SQLjob_logs = @path_log + '\SQLjob_logs'


--  Check to see if the 'log' folder exists.  If not, error out
Delete from #fileexists
Select @fileexist_path = @path_log + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 0
   begin
	Select @miscprint = 'ERROR: Path to the ''log'' folder could not be found.  ' + @path_log 
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Nothing was done.' 
	Print  @miscprint
	goto label99
   end




--  Get the paths for the mdf and ldf files
If @mdf_path is null or @ldf_path is null
   begin
	Select @save_DBname = (select top 1 name 
			from master.sys.sysdatabases 
			where name not in ('master', 'model', 'msdb', 'tempdb'))


	If @save_DBname is null or @save_DBname = ''
	   begin
		Select @miscprint = 'ERROR: Path to the ''mdf'' or ''ldf'' folders could not be found.' 
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'Nothing was done.  Please specifiy the mdf and ldf paths as input parms.' 
		Print  @miscprint
		goto label99
	   end

	Select @command = 'SELECT filename From [' + @save_DBname + '].sys.sysfiles '

	insert into @filenames (fname) exec (@command)

	delete from @filenames where fname is null or fname = ''
	--select * from @filenames


	If (select count(*) from @filenames) > 0
	   begin
		start_filenames:

		Select @cu11filename = (select top 1 fname from @filenames)


		--  Format the path for the mdf files
		Select @charpos = charindex('.mdf', @cu11filename)

		If @charpos > 0
		   begin
			Select @path_mdf = @cu11filename
			Select @charpos = charindex('\', @path_mdf)

			If @charpos > 0
			   begin
				label01:
				Select @charpos = charindex('\', @path_mdf)
				Select @newpath_mdf = @newpath_mdf + substring(@path_mdf, 1, (@charpos))
				Select @path_mdf = substring(@path_mdf, (@charpos+ 1), 200)
	
				Select @charpos = charindex('\', @path_mdf)
				If @charpos > 0
				   begin
					goto label01
				   end

				Select @len = len(@newpath_mdf)
				Select @newpath_mdf = substring(@newpath_mdf, 1, (@len - 1))
			   end
			Select @mdf_path = @newpath_mdf
		   end


		--  Format the path for the ldf files
		Select @charpos = charindex('.ldf', @cu11filename)

		If @charpos > 0
		   begin
			Select @path_ldf = @cu11filename
			Select @charpos = charindex('\', @path_ldf)

			If @charpos > 0
			   begin
				label02:
				Select @charpos = charindex('\', @path_ldf)
				Select @newpath_ldf = @newpath_ldf + substring(@path_ldf, 1, (@charpos))
				Select @path_ldf = substring(@path_ldf, (@charpos+ 1), 200)
	
				Select @charpos = charindex('\', @path_ldf)
				If @charpos > 0
				   begin
					goto label02
				   end

				Select @len = len(@newpath_ldf)
				Select @newpath_ldf = substring(@newpath_ldf, 1, (@len - 1))
			   end
			Select @ldf_path = @newpath_ldf
		   end

		--  check for more rows to process
		Delete from @filenames where fname = @cu11filename
		If (select count(*) from @filenames) > 0
		   begin
			goto start_filenames
		   end

	   end

   end


If @mdf_path is null or @ldf_path is null or
   @mdf_path = '' or @ldf_path = ''
   begin
	Select @miscprint = 'ERROR: MDF or LDF paths could not be found.' 
	Print  @miscprint
	Select @miscprint = '       Please provide full paths to both the MDF files and the LDF files via the input parms ''@mdf_path'' and ''@ldf_path''.' 
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Nothing was done.' 
	Print  @miscprint
	goto label99
   end
Else
   begin
	Select @path_mdf = @mdf_path
	Select @path_ldf = @ldf_path
   end



--  Set the NXT path
Select @path_nxt = substring(@path_mdf, 1, 1) + ':\nxt'
If @isNMinstance = 'y'
   begin
	Select @path_nxt = @path_nxt + '$' + @save_sqlinstance
   end 
 



--  Check to see if the 'dba_archive' folder exists
Delete from #fileexists
Select @fileexist_path = @path_dba_archive + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_dba_archive_fol = 'y'
   end

--  Check to see if the 'dbasql' folder exists
Delete from #fileexists
Select @fileexist_path = @path_dbasql + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_dbasql_fol = 'y'
   end

--  Check to see if the 'dba_reports' folder exists
Delete from #fileexists
Select @fileexist_path = @path_dba_reports + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_dba_reports_fol = 'y'
   end

--  Check to see if the 'dba_UpdateFiles' folder exists
Delete from #fileexists
Select @fileexist_path = @path_dba_UpdateFiles + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_dba_UpdateFiles_fol = 'y'
   end

--  Check to see if the 'filescan' folder exists
Delete from #fileexists
Select @fileexist_path = @path_filescan + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_filescan_fol = 'y'
   end

--  Check to see if the 'dba_mail' folder exists
Delete from #fileexists
Select @fileexist_path = @path_dba_mail + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_dba_mail_fol = 'y'
   end

--  Check to see if the 'builds' folder exists
Delete from #fileexists
Select @fileexist_path = @path_builds + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_builds_fol = 'y'
   end

--  Check to see if the 'DataMigration' folder exists
Delete from #fileexists
Select @fileexist_path = @path_datamigration + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_datamigration_fol = 'y'
   end

--  Check to see if the 'deployment_logs' folder exists
Delete from #fileexists
Select @fileexist_path = @path_builds + '\deployment_logs' + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_deployment_logs_fol = 'y'
   end

--  Check to see if the 'SQLjob_logs' folder exists
Delete from #fileexists
Select @fileexist_path = @path_SQLjob_logs + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_SQLjob_logs_fol = 'y'
   end

--  Check to see if the 'nxt' folder exists
Delete from #fileexists
Select @fileexist_path = @path_nxt + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) = 1
   begin
	Select @found_nxt_fol = 'y'
   end



--  Create the folders as needed
If @found_dba_archive_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_dba_archive + '"'
	Print 'Creating dba_archive folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_dbasql_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_dbasql + '"'
	Print 'Creating dbasql folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_dba_reports_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_dba_reports + '"'
	Print 'Creating dba_reports folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_dba_UpdateFiles_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_dba_UpdateFiles + '"'
	Print 'Creating dba_UpdateFiles folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_filescan_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_filescan + '"'
	Print 'Creating filescan folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

	Select @dos_command = 'mkdir "' + @path_filescan + '\filescan_result"'
	Print 'Creating filescan folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

	Select @dos_command = 'mkdir "' + @path_filescan + '\filescan_temp"'
	Print 'Creating filescan folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output
   end

If @found_dba_mail_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_dba_mail + '"'
	Print 'Creating dba_mail folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_builds_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_builds + '"'
	Print 'Creating builds folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_datamigration_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_datamigration + '"'
	Print 'Creating DataMigration folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_deployment_logs_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_builds + '\deployment_logs' + '"'
	Print 'Creating deployment_logs folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @found_SQLjob_logs_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_log + '\SQLjob_logs' + '"'
	Print 'Creating SQLjob_logs folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end

If @save_envname not like '%prod%' and @found_nxt_fol = 'n'
   begin
	Select @dos_command = 'mkdir "' + @path_nxt + '"'
	Print 'Creating nxt folder using command '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
   end


Print ' '
Print 'Standard folders are in place'
Print ' '



Select @path_dba_archive = '"' + @path_dba_archive + '"'
Select @path_dbasql = '"' + @path_dbasql + '"'
Select @path_dba_reports = '"' + @path_dba_reports + '"'
Select @path_dba_UpdateFiles = '"' + @path_dba_UpdateFiles + '"'
Select @path_filescan = '"' + @path_filescan + '"'
Select @path_datamigration = '"' + @path_datamigration + '"' 
Select @path_backup = '"' + @path_backup + '"'
Select @path_dba_mail = '"' + @path_dba_mail + '"'
Select @path_builds = '"' + @path_builds + '"' 
Select @path_SQLjob_logs = '"' + @path_SQLjob_logs + '"'
Select @path_log = '"' + @path_log + '"'
Select @path_mdf = '"' + @path_mdf + '"'
Select @path_ldf = '"' + @path_ldf + '"'
Select @path_nxt = '"' + @path_nxt + '"' 

If @save_iscluster = 'n'
   begin
	--  Check to see if standard shares have already been set up
	Delete from #ShareTempTable
	Select @command = 'RMTSHARE \\' + @save_servername
	Insert into #ShareTempTable exec master.sys.xp_cmdshell @command
	delete from #ShareTempTable where path is null or path = ''

	If exists (select 1 from #ShareTempTable where path like '%_dba_archive')
	   begin
		Select @found_dba_archive_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_dbasql')
	   begin
		Select @found_dbasql_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_dba_mail')
	   begin
		Select @found_dba_mail_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_builds')
	   begin
		Select @found_builds_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_backup')
	   begin
		Select @found_backup_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_log')
	   begin
		Select @found_log_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_mdf')
	   begin
		Select @found_mdf_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_ldf')
	   begin
		Select @found_ldf_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_SQLjob_logs')
	   begin
		Select @found_SQLjob_logs_shr = 'y'
	   end
	If exists (select 1 from #ShareTempTable where path like '%_nxt')
	   begin
		Select @found_nxt_shr = 'y'
	   end


	--  If any standard shares are found, delete them (we will recreate them)
	If @found_dba_archive_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dba_archive /DELETE'
		Print 'Deleting the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_dbasql_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dbasql /DELETE'
		Print 'Deleting the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_dba_mail_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_dba_mail /DELETE'
		Print 'Deleting the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_builds_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_builds /DELETE'
		Print 'Deleting the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_backup_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_backup /DELETE'
		Print 'Deleting the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_log_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_log /DELETING'
		Print 'Deleting the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_mdf_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_mdf /DELETING'
		Print 'Deleting the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_ldf_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_ldf /DELETING'
		Print 'Deleting the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_SQLjob_logs_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs /DELETING'
		Print 'Deleting the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_nxt_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_nxt /DELETE'
		Print 'Deleting the ' + @save_servername + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	Print ' '
	Print 'Existing Standard shares have been deleted'
	Print ' '



	--  Check to see if the standard Local Groups have been created
	Delete from #ShareTempTable
	Select @command = 'net localgroup "' + @save_servername2 + '_SQL_Local_Read"'
	Insert into #ShareTempTable exec master.sys.xp_cmdshell @command
	If exists (select * from #ShareTempTable where path like '%cannot be found%' or path like '%does not exist%' or path like '%System error 1788%')
	   begin
		Select @dos_command = 'net localgroup "' + @save_servername2 + '_SQL_Local_Read" /add /COMMENT:"SQL Local Read group"'
		Print 'Creating the ' + @save_servername2 + '_SQL_Local_Read local group using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end

	Delete from #ShareTempTable
	Select @command = 'net localgroup "' + @save_servername2 + '_SQL_Local_Write"'
	Insert into #ShareTempTable exec master..xp_cmdshell @command
	If exists (select * from #ShareTempTable where path like '%cannot be found%' or path like '%does not exist%' or path like '%System error 1788%')
	   begin
		Select @dos_command = 'net localgroup "' + @save_servername2 + '_SQL_Local_Write" /add /COMMENT:"SQL Local Write group"'
		Print 'Creating the ' + @save_servername2 + '_SQL_Local_Write local group using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end

	Print ' '
	Print ' '



	--  Create the shares, and share security, for dba_archive
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dba_archive =' + @path_dba_archive + ' /unlimited'
	Print 'Creating the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dba_archive /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dba_archive /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '


	--  Create the shares, and share security, for dbasql
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dbasql =' + @path_dbasql + ' /unlimited'
	Print 'Creating the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dbasql /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dbasql /grant "' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read":r'
	Print 'Assign READ ONLY Permissions: ' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dbasql /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_dbasql + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read":R /Y'
	Print 'Assign READ ONLY NTFS Permissions: ' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '


	--  Create the shares, and share security, for dba_mail
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_dba_mail =' + @path_dba_mail + ' /unlimited'
	Print 'Creating the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_dba_mail /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_dba_mail /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_dba_mail share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_dba_mail share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '


	--  Create the shares, and share security, for builds
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_builds =' + @path_builds + ' /unlimited'
	Print 'Creating the ' + @save_servername + '_builds share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_builds /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername + '_builds share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_builds /grant "' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read":r'
	Print 'Assign READ ONLY Permissions: ' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read to the ' + @save_servername + '_builds share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_builds /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername + '_builds share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_builds + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername + '_builds share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_builds share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read":R /Y'
	Print 'Assign READ ONLY NTFS Permissions: ' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read to the ' + @save_servername + '_builds share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '


	--  Create the shares, and share security, for backup
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_backup =' + @path_backup + ' /unlimited'
	Print 'Creating the ' + @save_servername2 + '_backup share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_backup /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_backup /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_backup share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_backup + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '


	--  Create the shares, and share security, for log
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_log =' + @path_log + ' /unlimited'
	Print 'Creating the ' + @save_servername2 + '_log share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_log /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_log share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_log /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_log share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_log + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_log share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_log + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_log share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '


	--  Create the shares, and share security, for mdf
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_mdf =' + @path_mdf + ' /unlimited'
	Print 'Creating the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_mdf /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_mdf /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_mdf + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '



	--  Create the shares, and share security, for ldf
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_ldf =' + @path_ldf + ' /unlimited'
	Print 'Creating the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_ldf /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_ldf /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_ldf + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Print ' '



	--  Create the shares, and share security, for SQLjob_logs
	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs =' + @path_SQLjob_logs + ' /unlimited'
	Print 'Creating the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs /grant administrators:f'
	Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs /grant "' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read":r'
	Print 'Assign READ ONLY Permissions: ' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs /Remove everyone'
	Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /G administrators:F /Y'
	Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G system:R /Y'
	Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read":R /Y'
	Print 'Assign READ ONLY NTFS Permissions: ' + @save_servername + '\' + @save_servername2 + '_SQL_Local_Read to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	--  Create the shares, and share security, for nxt
	If @save_envname not like '%prod%'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_nxt =' + @path_nxt + ' /unlimited'
		Print 'Creating the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_nxt /grant administrators:f'
		Print 'Assign FULL Permissions, Local administrators to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername2 + '_nxt /Remove everyone'
		Print 'Remove Share permissions for ''Everyone'' from the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /G administrators:F /Y'
		Print 'Assign FULL NTFS Permissions, Local administrators to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G system:R /Y'
		Print 'Assign READ ONLY NTFS Permissions: Local System to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end

	Print ' '


	Print ' '
	Print ' '
	Print 'Standard shares, including folder and NTFS security, are in place'
	Print ' '
   end
Else
   begin
	--  Check to see if standard shares have already been set up
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername2 + '_dba_archive%')
	   begin
		Select @found_dba_archive_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername2 + '_dbasql%')
	   begin
		Select @found_dbasql_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername + '_dba_mail%')
	   begin
		Select @found_dba_mail_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername + '_builds%')
	   begin
		Select @found_builds_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername2 + '_backup%')
	   begin
		Select @found_backup_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername2 + '_log%')
	   begin
		Select @found_log_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername2 + '_mdf%')
	   begin
		Select @found_mdf_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '' + @save_servername2 + '_ldf%')
	   begin
		Select @found_ldf_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername2 + '_SQLjob_logs%')
	   begin
		Select @found_SQLjob_logs_shr = 'y'
	   end
	If exists (select 1 from #cluster_info2 where data2 like '%' + @save_servername2 + '_nxt%')
	   begin
		Select @found_nxt_shr = 'y'
	   end


	--  If any standard shares are found, delete them (we will recreate them)
	If @found_dba_archive_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_dba_archive /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_dba_archive offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_dba_archive /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_dba_archive using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_dbasql_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_dbasql /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_dbasql offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_dbasql /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_dbasql using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_dba_mail_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername + '_dba_mail /off'
		Print 'Take the File Share Resource ' + @save_servername + '_dba_mail offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername + '_dba_mail /delete'
		Print 'Deleting the File Share Resource ' + @save_servername + '_dba_mail using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_builds_shr = 'y'
	   begin
		Select @dos_command = 'rmtshare \\' + @save_servername + '\' + @save_servername + '_builds /DELETE'
		Print 'Deleting the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
		Select @dos_command = 'cluster . res ' + @save_servername + '_builds /off'
		Print 'Take the File Share Resource ' + @save_servername + '_builds offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername + '_builds /delete'
		Print 'Deleting the File Share Resource ' + @save_servername + '_builds using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_backup_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_backup /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_backup offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_backup /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_backup using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_log_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_log /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_log offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_log /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_log using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_mdf_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_mdf /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_mdf offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_mdf /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_mdf using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_ldf_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_ldf /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_ldf offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_ldf /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_ldf using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_SQLjob_logs_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_SQLjob_logs /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_SQLjob_logs offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_SQLjob_logs /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_SQLjob_logs using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end


	If @found_nxt_shr = 'y'
	   begin
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_nxt /off'
		Print 'Take the File Share Resource ' + @save_servername2 + '_nxt offline using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Select @dos_command = 'cluster . res ' + @save_servername2 + '_nxt /delete'
		Print 'Deleting the File Share Resource ' + @save_servername2 + '_nxt using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
		Print ' '
	   end



	Print ' '
	Print 'Existing Standard shares have been deleted'
	Print ' '


	--  Local groups are not allowed for use in cluster share permissions so none will be created


	--  Create the shares, and share security, for dba_archive
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_dba_archive, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_dba_archive.'
		goto skip_clust_dba_archive
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_dba_archive.'
		goto skip_clust_dba_archive
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv Path=' + @path_dba_archive
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv ShareName=' + @save_servername2 + '_dba_archive'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_dba_archive + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_dba_archive share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dba_archive" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_dba_archive:




	--  Create the shares, and share security, for dbasql
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_dbasql, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_dbasql.'
		goto skip_clust_dbasql
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_dbasql.'
		goto skip_clust_dbasql
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv Path=' + @path_dbasql
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv ShareName=' + @save_servername2 + '_dbasql'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	 begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_dbasql + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_dbasql share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_dbasql" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_dbasql:





	--  Create the shares, and share security, for dba_mail
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_dba_mail, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername + '_dba_mail.'
		goto skip_clust_dba_mail
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername + '_dba_mail.'
		goto skip_clust_dba_mail
	   end

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv Path=' + @path_dba_mail
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv ShareName=' + @save_servername + '_dba_mail'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_dba_mail + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername + '_dba_mail share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_dba_mail" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_dba_mail:




	--  Create the shares, and share security, for builds
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_builds, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername + '_builds.'
		goto skip_clust_builds
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername + '_builds.'
		goto skip_clust_builds
	   end

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv Path=' + @path_builds
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv ShareName=' + @save_servername + '_builds'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_builds + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername + '_builds share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername + '_builds" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_builds:




	--  Create the shares, and share security, for backup
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_backup, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('  ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_backup.'
		goto skip_clust_backup
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_backup.'
		goto skip_clust_backup
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv Path=' + @path_backup
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv ShareName=' + @save_servername2 + '_backup'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SQLTransSVCAcct",grant,r:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SQLTransSVCAcct":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLTransSVCAcct" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output   
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_backup + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_backup share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_backup" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_backup:




	--  Create the shares, and share security, for log
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_log, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_log.'
		goto skip_clust_log
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_log.'
		goto skip_clust_log
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv Path=' + @path_log
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv ShareName=' + @save_servername2 + '_log'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_log + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_log share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_log" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_log:




	--  Create the shares, and share security, for mdf
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_mdf, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_mdf.'
		goto skip_clust_mdf
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_mdf.'
		goto skip_clust_mdf
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv Path=' + @path_mdf
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv ShareName=' + @save_servername2 + '_mdf'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_mdf + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_mdf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_mdf" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_mdf:




	--  Create the shares, and share security, for ldf
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_ldf, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_ldf.'
		goto skip_clust_ldf
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_ldf.'
		goto skip_clust_ldf
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv Path=' + @path_ldf
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv ShareName=' + @save_servername2 + '_ldf'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output   
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_ldf + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_ldf share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_ldf" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_ldf:




	--  Create the shares, and share security, for SQLjob_logs
	--  Get selected cluster info (disk)
	Select @save_drive_letter_part = substring(@path_SQLjob_logs, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_SQLjob_logs.'
		goto skip_clust_SQLjob_logs
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_SQLjob_logs.'
		goto skip_clust_SQLjob_logs
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv Path=' + @path_SQLjob_logs
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv ShareName=' + @save_servername2 + '_SQLjob_logs'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output   
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_SQLjob_logs + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_SQLjob_logs share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_SQLjob_logs" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_SQLjob_logs:




	--  Create the shares, and share security, for nxt
	--  Get selected cluster info (disk)

	If @save_envname like '%prod%'
	   begin
		goto skip_clust_nxt
	   end

	Select @save_drive_letter_part = substring(@path_nxt, 2,2)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%' + @save_drive_letter_part + '%')

	Select @save_disk_resname = @save_data2
	Select @charpos = charindex('   ', @save_data2)
	If @charpos > 0
	   begin
		Select @save_disk_resname = left(@save_data2, @charpos-1)
		Select @save_group_resname = substring(@save_data2, @charpos, 200)
		Select @save_group_resname = ltrim(@save_group_resname)
		Select @charpos = charindex('   ', @save_group_resname)
		If @charpos > 0
		   begin
			Select @save_group_resname = left(@save_group_resname, @charpos-1)
		   end
	   end
	Else
	   begin
		Print 'Unable to find the cluster resource for the disk ' + @save_drive_letter_part + '\.  Skipping create share process for ' + @save_servername2 + '_nxt.'
		goto skip_clust_nxt
	   end

	--  Get selected cluster info (network)
	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like '%network%' and data2 like '%' + @save_group_resname + ' %')

	Select @save_network_resname = @save_data2
	Select @charpos = charindex(@save_group_resname + ' ', @save_network_resname)
	If @charpos > 0
	   begin
		Select @save_network_resname = left(@save_network_resname, @charpos-1)
		Select @save_network_resname = rtrim(@save_network_resname)
	   end
	Else
	   begin
		Print 'Unable to find the cluster network resource for the group ' + @save_group_resname + '.  Skipping create share process for ' + @save_servername2 + '_nxt.'
		goto skip_clust_nxt
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /Create /Group:"' + @save_group_resname + '" /Type:"File Share"'
	Print 'Create the File Share Resource in the cluster group [' + @save_group_resname + '] using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv Path=' + @path_nxt
	Print 'Set the File Share Path using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv ShareName=' + @save_servername2 + '_nxt'
	Print 'Set the File Share ShareName using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv Remark="DBA File Share"'
	Print 'Set the File Share Remark using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /prop Description="DBA Clustered Share"'
	Print 'Set the File Share Description using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 


	If @save_domain = 'Production'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SeaSQLProdsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SQLDBA",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\SeaSQLProdsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdsvc" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\SQLDBA":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQLDBA" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else If @save_domain = 'stage'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SeaSQLSTAGEsvc",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SQL Stage Admins",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SQLnxtPusher",grant,c:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\SeaSQLSTAGEsvc":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLSTAGEsvc" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\SQL Stage Admins":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SQL Stage Admins" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output   
	   end
	Else If @save_envname like '%prod%'
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end
	Else
	   begin
		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"NOC",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SeaSQLProdFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=' + @save_domain + '\"SeaSQLTestFull",grant,f:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /priv security=everyone,revoke:security'
		Print 'Set the File Share permissions using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\NOC":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\NOC" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\SeaSQLProdFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLProdFull" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  

		Select @dos_command = 'XCACLS ' + @path_nxt + ' /E /G "' + @save_domain + '\SeaSQLTestFull":F /Y'
		Print 'Assign FULL NTFS Permissions: "' + @save_domain + '\SeaSQLTestFull" to the ' + @save_servername2 + '_nxt share using command: '+ @dos_command
		EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output  
	   end

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /AddDep:"' + @save_disk_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /AddDep:"' + @save_network_resname + '"'
	Print 'Set the File Share dependency using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	Select @dos_command = 'cluster . res "' + @save_servername2 + '_nxt" /On'
	Print 'Set the File Share OnLine using command: '+ @dos_command
	EXEC @Result = master.sys.xp_cmdshell @dos_command, no_output 

	skip_clust_nxt:

   end



--  Fix existing job output paths
exec dbaadmin.dbo.dbasp_FixJobOutput



--  Fix owner and options for dbaadmin 
ALTER AUTHORIZATION ON DATABASE::dbaadmin TO sa;

ALTER DATABASE [dbaadmin] SET RECOVERY SIMPLE WITH NO_WAIT






----------------  End  -------------------

label99:


drop table #ShareTempTable
drop table #loginconfig
drop table #DirectoryTempTable
drop table #fileexists
drop table #cluster_info1
drop table #cluster_info2


Print ' '
Print 'Processing for dbasp_dba_sqlsetup - complete'
Print ' '

 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_dbamail_cleanup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_dbamail_cleanup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_dbamail_cleanup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_dbamail_cleanup (@purge_days smallint = 14
					   ,@save_SQLEnv sysname = '')

/**************************************************************
 **  Stored Procedure dbasp_dbamail_cleanup                  
 **  Written by Jim Wilson, Getty Images                
 **  August 23, 2002                                      
 **  
 **  This dbasp is set up to cleanup the dba_mail folders.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/23/2002	Jim Wilson		New SQLMail cleanup process.
--	12/27/2002	Jim Wilson		Now using the UTIL_servers table.
--	06/09/2006	Jim Wilson		Updated for SQL 2005.
--	08/27/2008	Jim Wilson		Now using the dba_serverinfo table.
--	======================================================================================

/***
Declare @purge_days smallint
declare @save_SQLEnv sysname

Select @purge_days = 14
Select @save_SQLEnv = 'production'
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@command 		nvarchar(4000)
	,@retcode		int
	,@charpos		int
	,@save_filedate_char	char(10)
	,@save_filedate		datetime
	,@save_filename		sysname
	,@save_mailshare	varchar(200)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_domain		sysname
	
DECLARE
	 @cu11SQLservername	sysname

DECLARE
	 @cu12cmdoutput		nvarchar(255)



----------------  initial values  -------------------

create table #DirectoryTempTable(cmdoutput nvarchar(255) null)
create table #Smail_Info(ParmText nvarchar(4000) null)

Select @save_servername = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Cursor for SQL Servers to check
EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
  'SELECT p.SQLName
   From dbaadmin.dbo.DBA_ServerInfo  p ' +
  'Where p.active = ''y''
     and p.SQLmail = ''y'' 
     and p.DomainName = ''' + @save_domain + '''
     and p.SQLEnv like ''%' + @save_SQLEnv + '%''
   Order by p.SQLName for Read Only')

OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11SQLservername
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end

	Select @charpos = charindex('\', @cu11SQLservername)
	IF @charpos <> 0
	   begin
		Select @cu11SQLservername = rtrim(substring(@cu11SQLservername, 1, (CHARINDEX('\', @cu11SQLservername)-1)))
	   end

	Select @save_mailshare = '\\'+ @cu11SQLservername + '\' + @cu11SQLservername + '_dba_mail'
print @save_mailshare
raiserror ('', -1, -1) with nowait


	--  Check for files in the dba_mail folder for this server
	Delete from #DirectoryTempTable
	Select @command = 'dir ' + @save_mailshare + '\*.*'
	Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @command



	--  cursor for the dba_mail 'dir' results
	EXECUTE('DECLARE cu12_cursor Insensitive Cursor For ' +
	  'SELECT p.cmdoutput
	   From #DirectoryTempTable   p ' +
	  'Order by p.cmdoutput for Read Only')
	
	OPEN cu12_cursor
	
	WHILE (12=12)
	 Begin
		FETCH Next From cu12_cursor Into @cu12cmdoutput
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu12_cursor
		      BREAK
	           end


		--  Check for file dates and names
		If substring(@cu12cmdoutput, 3, 1) = '/' and substring(@cu12cmdoutput, 6, 1) = '/' and substring(@cu12cmdoutput, 25, 5) <> '<DIR>'
		   begin
			Select @save_filedate_char = substring(@cu12cmdoutput, 1, 10)
			Select @save_filedate = convert(datetime, @save_filedate_char)

			--  Check to see if file is older than the purge date parm
			If datediff(day, @save_filedate, getdate()) > @purge_days
			   begin
				Select @save_filename = ltrim(rtrim(substring(@cu12cmdoutput, 40, 200)))

				Select @command = 'del "' + @save_mailshare + '\' + @save_filename + '"'
				Print @command
				EXEC @retcode = master.sys.xp_cmdshell @command, no_output

				IF @@error <> 0 or @retcode <> 0
				   begin
					Select @miscprint = 'DBA WARNING: DBA mail cleanup process failed for file ' +  @save_mailshare + '\' + @save_filename
					raiserror(@miscprint,-1,-1) with log
				   end
			   end
		   end


	 End  -- loop 12
	DEALLOCATE cu12_cursor


 End  -- loop 11
DEALLOCATE cu11_cursor

----------------  End  -------------------


drop table #DirectoryTempTable

drop table #Smail_Info




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_dbamail_process
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_dbamail_process]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_dbamail_process]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_dbamail_process (@server_name sysname = null
					   ,@save_SQLEnv sysname = '')

/**************************************************************
 **  Stored Procedure dbasp_dbamail_process                  
 **  Written by Jim Wilson, Getty Images                
 **  March 10, 2002                                      
 **  
 **  This dbasp is set up to process sql mail requests using
 **  the DBAmail process in SQL 2005.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/10/2004	Jim Wilson		New SQLMail process w/o Exchange.
--	03/29/2004	Jim Wilson		Added 5 second wait between emails.
--	04/07/2004	Jim Wilson		New server in staging.
--	01/05/2005	Jim Wilson		Added support for sqldeployer and seafresqldba01.
--	03/04/2005	Jim Wilson		Added carriage return char(10) to end of each message line.
--	11/16/2005	Jim Wilson		New code to handle additional features (priority, from, from_name, etc.)
--	11/28/2005	Jim Wilson		Removed cursors.  Added check of file attachment using
--						dbaadmin.dbo.dbaudf_CheckFileStatus.
--	05/04/2006	Jim Wilson		Converted for SQL 2005.
--	08/11/2006	Jim Wilson		Added code to update @type parm.
--	11/21/2006	Jim Wilson		Added code to fix orphan single quotes in the message.
--	04/17/2007	Jim Wilson		Added truncate on messages over len=3200.
--	04/19/2007	Jim Wilson		New code for very long attachment strings
--	05/04/2007	Jim Wilson		Added print of servername for error diag
--	02/04/2008	Jim Wilson		Added input parm for servername
--	02/05/2008	Jim Wilson		Removed xp_getfiledetails and replaced with xp_cmdshell DIR.
--	07/30/2008	Jim Wilson		Added print of file name and path for error diag
--	08/27/2008	Jim Wilson		New table dba_serverinfo.
--	09/19/2008	Jim Wilson		Addd dynamic profile creation for @FROM values.
--	09/24/2008	Jim Wilson		Addded retry on rename.
--	10/22/2008	Jim Wilson		Addded @subject to output for error diag.
--	11/10/2008	Jim Wilson		New check to ignore mutiple rows for most parms.
--	04/10/2009	Jim Wilson		Added /B to DIR.
--	04/13/2009	Jim Wilson		Modified file rename process.
--	03/12/2010	Jim Wilson		New code for active = 'm'.
--	======================================================================================


/*
declare @server_name sysname
declare @save_SQLEnv sysname

select @server_name = 'sqldeployer02'
select @save_SQLEnv = ''
--*/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd 				nvarchar(4000)
	,@filename_wild			nvarchar(100)
	,@startpos			int
	,@charpos			bigint
	,@charpos2			bigint
	,@start_charpos			bigint
	,@length			int
	,@EOLWinNT 			nvarchar(2)
	,@message_flag			char(1)
	,@attach_continue		char(1)
	,@attach_fail_flag		char(1)
	,@last_char_test		char(1)
	,@retcode			int
	,@retry 			smallint
	,@parm_recipients		nvarchar(500)
	,@parm_copy_recipients 		nvarchar(500)
	,@parm_blind_copy_recipients	nvarchar(500)
	,@parm_attach			nvarchar(4000)
	,@parm_subject			nvarchar(255)
	,@parm_message			nvarchar(max)
	,@parm_priority			nvarchar(10)
	,@parm_type			nvarchar(100)
	,@save_cmdoutput2		nvarchar(255)
	,@save_parm_attach		nvarchar(4000)
	,@save_parm_attach_result	nvarchar(4000)
	,@save_parm_attach_single	nvarchar(4000)
	,@save_parm_attach_len		int
	,@save_mailshare		nvarchar(200)
	,@save_profile_name		sysname
	,@save_date			nvarchar(20)
	,@save_file_currdate		nchar(20)
	,@save_file_currtime		nchar(20)
	,@save_fileYYYY			nchar(4)
	,@save_fileMM			nchar(2)
	,@save_fileDD			nchar(2)
	,@save_fileHH			nchar(2)
	,@save_fileMN			nchar(2)
	,@save_fileSS			nchar(2)
	,@save_fileAMPM			nchar(2)
	,@hold_SQLservername		sysname
	,@hold_cmdoutput		nvarchar(255)
	,@hold_ParmText			nvarchar(max)
	,@check_single_quote		char(1)
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_domain			sysname
	,@save_alt_filename		sysname
	,@extention			nvarchar(10)

DECLARE
	 @from_flag			char(1)
	,@save_mailserver		sysname
	,@parm_from			sysname
	,@parm_from_name		sysname
	,@parm_replyto			sysname


DECLARE
	 @cu11SQLservername		sysname

DECLARE
	 @cu12cmdoutput			nvarchar(255)

DECLARE
	 @cu13ParmText			nvarchar(max)
	,@cu13PT_row			int


----------------  initial values  -------------------
select @filename_wild 	= '%.sml'
Select @extention 	= 'sml'
Select @EOLWinNT        = char(13)+char(10)
Select @message_flag	= 'n'
select @attach_continue = 'n'
Select @save_mailserver = 'mail.gettyimages.com'

Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')

If @@servername in ('seafrestgsql')
   begin
	Select @save_profile_name = 'sqladminstage'
   end
Else
   begin
	Select @save_profile_name = 'sqladminproduction'
   end


create table #DirectoryTempTable (cmdoutput nvarchar(255) null)

create table #DirectoryTempTable2 (cmdoutput nvarchar(255) null)

create table #Smail_Info_bulk(ParmText nvarchar(max) null)

create table #Smail_Info(
			 ParmText nvarchar(max) null
			,pt_row [int] IDENTITY (1, 1) NOT NULL
			)

create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint
		)


--  Create table variable
declare @servers table	(SQLservername sysname null)



/****************************************************************
 *                MainLine
 ***************************************************************/
If @server_name is null
   begin
	Insert into @servers (SQLservername)
	SELECT p.SQLname
	From dbaadmin.dbo.DBA_Serverinfo  p with (NOLOCK)
	Where p.active in ('y', 'm')
	  and p.SQLmail = 'y'
          and p.DomainName = @save_domain
	  and p.SQLEnv like '%' + @save_SQLEnv + '%'

   end
Else
   begin
	Insert into @servers (SQLservername) values (@server_name)
   end

delete from @servers where SQLservername is null or SQLservername = ''
--select * from @servers


-- Check to see if there are servers to process
If (select count(*) from @servers) > 0
   begin
	start_servers:

	Select @cu11SQLservername = (select top 1 SQLservername from @servers order by SQLservername)
	Select @hold_SQLservername =  @cu11SQLservername
Print @cu11SQLservername


	Select @charpos = charindex('\', @cu11SQLservername)
	IF @charpos <> 0
	   begin
		Select @cu11SQLservername = rtrim(substring(@cu11SQLservername, 1, (CHARINDEX('\', @cu11SQLservername)-1)))
	   end

	Select @save_mailshare = '\\'+ @cu11SQLservername + '\' + @cu11SQLservername + '_dba_mail'

	--  Check for files in the dba_mail folder for this server
	Delete from #DirectoryTempTable
	Select @cmd = 'dir ' + @save_mailshare + '\*.' + @extention + ' /B'
	Print @cmd
	Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
	delete from #DirectoryTempTable where cmdoutput is null or cmdoutput = ''
	--select * from #DirectoryTempTable
	delete from #DirectoryTempTable where cmdoutput like '%File Not Found%'
	delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
select * from #DirectoryTempTable


	--  If a sql mail request file was found, process the request
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		start_cmdoutput:

		Select @cu12cmdoutput = (select top 1 cmdoutput from #DirectoryTempTable)


		select @hold_cmdoutput = @cu12cmdoutput
		select @cu12cmdoutput = ltrim(rtrim(@cu12cmdoutput))

		--  Capture the sql mail parameters for this request
		Delete from #Smail_Info_bulk
		Select @cmd = 'bulk insert #Smail_Info_bulk from  ''' + @save_mailshare + '\' + @cu12cmdoutput + ''''
		--Print @cmd
		exec master.sys.sp_executesql @cmd
		delete from #Smail_Info_bulk where ParmText = char(9)
		--select * from #Smail_Info_bulk

		Delete from #Smail_Info
		Insert into #Smail_Info select ParmText from #Smail_Info_bulk
		--select * from #Smail_Info

		--  Process the sql mail request
		If (select count(*) from #Smail_Info) > 0
		   begin
			--  Reset parameters
			Select @parm_from = ''    
			Select @parm_from_name = ''
			Select @parm_replyto = ''
			Select @parm_recipients = ' '
			Select @parm_attach = ' ' 
			Select @parm_subject = ' ' 
			Select @parm_message = ' '
			Select @parm_copy_recipients = ' '
			Select @parm_blind_copy_recipients = ' '
			Select @parm_priority = 'NORMAL'
			Select @parm_type = 'text'
			Select @from_flag = 'n'

			If @@servername in ('seafrestgsql')
			   begin
				Select @save_profile_name = 'sqladminstage'
			   end
			Else
			   begin
				Select @save_profile_name = 'sqladminproduction'
			   end


			start_smail:

			Select @cu13PT_row = (select top 1 pt_row from #Smail_Info order by pt_row)
			Select @cu13ParmText = (select ParmText from #Smail_Info where pt_row = @cu13PT_row)

			Select @hold_ParmText = @cu13ParmText

			--  Here we check the parameters in the sql mail request file
			If @cu13ParmText is null
			   begin
				select @cu13ParmText = ' '
			   end


			select @charpos = charindex('@FROM ', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_from = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_from = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				If @parm_from like '%@%'
				   begin
					Select @from_flag = 'y'
				   end
				goto label01
			   end

			select @charpos = charindex('@FROM_NAME', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_from_name = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_from_name = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end

			select @charpos = charindex('@replyto', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_replyto = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_replyto = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end


			select @charpos = charindex('@recipients', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end

			select @charpos = charindex('@TO ', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end

			select @charpos = charindex('@subject', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_subject = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_subject = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end

			select @charpos = charindex('@copy_recipients', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end

			select @charpos = charindex('@CC ', @cu13ParmText)
			If @charpos > 0
			   begin

				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end

			select @charpos = charindex('@blind_copy_recipients', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_blind_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_blind_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				goto label01
			   end

			select @charpos = charindex('@BCC ', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				If @charpos2 > @charpos
				   begin
					select @parm_blind_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				   end
				Else
				   begin
					select @parm_blind_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, len(@cu13ParmText)-@charpos)))
				   end

				select @parm_blind_copy_recipients = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				goto label01
			   end

			select @charpos = charindex('@priority', @cu13ParmText)
			If @charpos > 0
			   begin
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				select @parm_priority = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				goto label01
			   end

			select @charpos = charindex('@type', @cu13ParmText)
			If @charpos > 0
			   begin
				Select @cu13ParmText = REPLACE(@cu13ParmText, 'text/plain', 'text')
				select @charpos = charindex('''', @cu13ParmText)
				select @charpos2 = charindex('''', @cu13ParmText, @charpos+1)
				select @parm_type = ltrim(rtrim(substring(@cu13ParmText, @charpos+1, (@charpos2-@charpos)-1)))
				goto label01
			   end


			select @charpos = charindex('@attachments', @cu13ParmText)
			If @charpos > 0
			   begin
				Select @parm_attach = ltrim(rtrim(substring(@cu13ParmText, @charpos+16, len(@cu13ParmText))))

				select @last_char_test = substring(rtrim(@parm_attach), len(@parm_attach), 1)
				If @last_char_test = char(39)
				   begin
					select @parm_attach = substring(rtrim(@parm_attach), 1, len(@parm_attach)-1)
					select @parm_attach = rtrim(@parm_attach)
				   end
				Else
				   begin
					select @parm_attach = substring(rtrim(@parm_attach), 1, len(@parm_attach))
					select @parm_attach = rtrim(@parm_attach)

					select @attach_continue = 'y'
				   end

				goto label01
			   end


			If @attach_continue = 'y'
			   begin
				select @last_char_test = substring(rtrim(@cu13ParmText), len(@cu13ParmText), 1)
				If @last_char_test = char(39)
				   begin
					select @parm_attach = @parm_attach + substring(rtrim(@cu13ParmText), 1, len(@cu13ParmText)-1)
					select @attach_continue = 'n'
				   end
				Else
				   begin
					select @parm_attach = @parm_attach + substring(rtrim(@cu13ParmText), 1, len(@cu13ParmText))
				   end

				goto label01
			   end



			select @charpos = charindex('@message', @cu13ParmText)
			If @charpos > 0
			   begin
				select @message_flag	= 'y'
				select @charpos = charindex('@message = ''', @cu13ParmText)
				select @parm_message = substring(@cu13ParmText, @charpos+12, (len(@cu13ParmText)-@charpos+12))
				select @parm_message = rtrim(@parm_message)
				select @length = len(@parm_message)
				select @last_char_test = substring(rtrim(@parm_message), @length, 1)
				If @last_char_test = char(39)
				   begin
					select @parm_message = substring(rtrim(@parm_message), 1, @length-1)
					select @message_flag	= 'n'
				   end

				--  Check for orphaned single quotes and fix any that are found
				Select @start_charpos = 1
				dbl_check_single_quote01:
				select @charpos = charindex('''', @parm_message, @start_charpos)
				If @charpos > 0
				   begin
					select @check_single_quote = substring(@parm_message, @charpos+1, 1)
					If @check_single_quote <> char(39)
					   begin
						Select @parm_message = stuff(@parm_message, @charpos, 1, '''''')
					   end
					Select @start_charpos = @charpos+2
					goto dbl_check_single_quote01
				   end

				goto label01
			   end


			If @message_flag = 'y'
			   begin
				select @parm_message = @parm_message + @EOLWinNT
				select @length = len(rtrim(@cu13ParmText))
				select @last_char_test = substring(rtrim(@cu13ParmText), @length, 1)

				If @last_char_test = char(39)
				   begin
					select @cu13ParmText = substring(rtrim(@cu13ParmText), 1, @length-1)
					select @message_flag	= 'n'
				   end

				--  Check for orphaned single quotes and fix any that are found
				Select @start_charpos = 1
				dbl_check_single_quote02:
				select @charpos = charindex('''', @cu13ParmText, @start_charpos)
				If @charpos > 0
				   begin
					select @check_single_quote = substring(@cu13ParmText, @charpos+1, 1)
					If @check_single_quote <> char(39)
					   begin
						Select @cu13ParmText = stuff(@cu13ParmText, @charpos, 1, '''''')
					   end

					Select @start_charpos = @charpos+2
					goto dbl_check_single_quote02
				   end

				--  Add this line to the message
				select @parm_message = @parm_message + rtrim(@cu13ParmText)
			   end


			Label01:


		--  Remove this record from #Smail_Info and go to the next
		delete from #Smail_Info where pt_row = @cu13PT_row
		If (select count(*) from #Smail_Info) > 0
		   begin
			goto start_smail
		   end

	   end


		--  Now we verify the attachment if one was specified
		IF @parm_attach <> ' '
		   begin
			Select @attach_fail_flag = 'n'
			Select @save_parm_attach_result = ''
			Select @save_parm_attach = ltrim(@parm_attach)
			Select @save_parm_attach_len = len(@parm_attach)
			Select @startpos = 1
			label06:
				Select @charpos = charindex(';', @save_parm_attach, @startpos)
				IF @charpos <> 0
				   begin
					Select @save_parm_attach_single = substring(@save_parm_attach, @startpos, @charpos-@startpos)
					
					Delete from #fileexists
					Insert into #fileexists exec master.sys.xp_fileexist @save_parm_attach_single
	
					If exists (select 1 from #fileexists where doesexist <> 1)
					   begin
						Select @miscprint = 'DBA WARNING: xp_sendmail attachment does not exist. ' +  @parm_attach
						Select @parm_message = @parm_message + '


NOTE: Attachment Error for file ' + @save_parm_attach_single
						goto next_attach_multi
					   end



					--  Check to see if the file is ready to be attached
					If dbaadmin.dbo.dbaudf_CheckFileStatus (@save_parm_attach_single) <> 0
					   begin
						--  The file is not ready to be attached.  If the file is less than 5 minutes old, skip this request for now.
						Select @attach_fail_flag = 'y'

						Delete from #DirectoryTempTable2
						Select @cmd = 'dir /4 ' + @save_parm_attach_single
						Print @cmd
						Insert into #DirectoryTempTable2 exec master.sys.xp_cmdshell @cmd
						delete from #DirectoryTempTable2 where cmdoutput is null or cmdoutput = ''
						delete from #DirectoryTempTable2 where cmdoutput like ' Volume%'
						delete from #DirectoryTempTable2 where cmdoutput like ' Directory%'
						delete from #DirectoryTempTable2 where cmdoutput like '% bytes %'
						delete from #DirectoryTempTable2 where cmdoutput like '%File(s)%'
						--select * from #DirectoryTempTable2

						If (select count(*) from #DirectoryTempTable2) = 1
						   begin
							Select @save_cmdoutput2 = (select top 1 cmdoutput from #DirectoryTempTable2)
							select @save_fileYYYY = substring(@save_cmdoutput2, 7, 4)
							select @save_fileMM = substring(@save_cmdoutput2, 1, 2)
							select @save_fileDD = substring(@save_cmdoutput2, 4, 2)

							Select @save_fileHH = substring(@save_cmdoutput2, 13, 2)
							Select @save_fileMN = substring(@save_cmdoutput2, 16, 2)
							Select @save_fileSS = '00'
							Select @save_fileAMPM = substring(@save_cmdoutput2, 19, 2)

							If @save_fileAMPM = 'PM'
							   begin
								Select @save_fileHH = convert(nchar(2), (convert(smallint,@save_fileHH) + 12))
							   end

							select @save_date = @save_fileYYYY + '-' + @save_fileMM + '-' + @save_fileDD + ' ' + @save_fileHH + ':' + @save_fileMN + ':' + @save_fileSS

							If (select datediff(mi, convert(datetime, @save_date), getdate())) < 6
							   begin
								-- skip this email request for now
								goto get_next_request
							   end
						   end
					   end


					--  Attach the file and go onto the next one
					Select @save_parm_attach_result = @save_parm_attach_result + @save_parm_attach_single + ';'

					next_attach_multi:
					Select @startpos = @charpos + 1
					goto label06
				   end	
				Else
				   begin
					Select @save_parm_attach_single = substring(@save_parm_attach, @startpos, @save_parm_attach_len - @startpos + 1)
					
					Delete from #fileexists
					Insert into #fileexists exec master.sys.xp_fileexist @save_parm_attach_single
	
					If exists (select 1 from #fileexists where doesexist <> 1)
					   begin
						Select @miscprint = 'DBA WARNING: xp_sendmail attachment does not exist. ' +  @parm_attach
						Select @parm_message = @parm_message + '


NOTE: Attachment Error for file ' + @save_parm_attach_single
						Select @save_parm_attach_len = len(@save_parm_attach_result)
						If @save_parm_attach_len > 0 
						   begin
							Select @save_parm_attach_result = substring(@save_parm_attach_result, 1, @save_parm_attach_len - 1)
						   end
						Else
						 begin
							Select @save_parm_attach_result = ' '
						   end
					   end
					Else
					   begin
						--  Check to see if the file is ready to be attached
						If dbaadmin.dbo.dbaudf_CheckFileStatus (@save_parm_attach_single) <> 0
						   begin
							--  The file is not ready to be attached.  If the file is less than 5 minutes old, skip this request for now.
							Select @attach_fail_flag = 'y'


							Delete from #DirectoryTempTable2
							Select @cmd = 'dir /4 ' + @save_parm_attach_single
							Print @cmd
							Insert into #DirectoryTempTable2 exec master.sys.xp_cmdshell @cmd
							delete from #DirectoryTempTable2 where cmdoutput is null or cmdoutput = ''
							delete from #DirectoryTempTable2 where cmdoutput like ' Volume%'
							delete from #DirectoryTempTable2 where cmdoutput like ' Directory%'
							delete from #DirectoryTempTable2 where cmdoutput like '% bytes %'
							delete from #DirectoryTempTable2 where cmdoutput like '%File(s)%'
							--select * from #DirectoryTempTable2

							If (select count(*) from #DirectoryTempTable2) = 1
							   begin
								Select @save_cmdoutput2 = (select top 1 cmdoutput from #DirectoryTempTable2)
								select @save_fileYYYY = substring(@save_cmdoutput2, 7, 4)
								select @save_fileMM = substring(@save_cmdoutput2, 1, 2)
								select @save_fileDD = substring(@save_cmdoutput2, 4, 2)
	
								Select @save_fileHH = substring(@save_cmdoutput2, 13, 2)
								Select @save_fileMN = substring(@save_cmdoutput2, 16, 2)
								Select @save_fileSS = '00'
								Select @save_fileAMPM = substring(@save_cmdoutput2, 19, 2)

								If @save_fileAMPM = 'PM'
								   begin
									Select @save_fileHH = convert(nchar(2), (convert(smallint,@save_fileHH) + 12))
								   end

								select @save_date = @save_fileYYYY + '-' + @save_fileMM + '-' + @save_fileDD + ' ' + @save_fileHH + ':' + @save_fileMN + ':' + @save_fileSS

								If (select datediff(mi, convert(datetime, @save_date), getdate())) < 6
								   begin
									-- skip this email request for now
									goto get_next_request
								   end
							   end
						   end

						Select @save_parm_attach_result = @save_parm_attach_result + @save_parm_attach_single
					   end
				   end	

 
			Select @parm_attach = @save_parm_attach_result

			--  If there was an attachment that was not ready to be attached, and the request is no longer being skipped...
			If @attach_fail_flag = 'y'
			   begin
				Select @miscprint = 'DBA WARNING: xp_sendmail attachment failed. ' +  @parm_attach
				Select @parm_message = @parm_message + '


NOTE: Attachment Error' 
				Select @parm_attach = ' '
			   end



		   end


		--  Verfiy we have a recipient and a subject for this email
		IF @parm_recipients = ' '
		   begin
			Select @miscprint = 'DBA WARNING: SQL Mail parameter file does not include recipients. ' +  @cu12cmdoutput
			raiserror(@miscprint,-1,-1) with log
			goto label89
		   end

		IF @parm_subject = ' '
		   begin
			Select @miscprint = 'DBA WARNING: SQL Mail parameter file does not include subject. ' +  @cu12cmdoutput
			raiserror(@miscprint,-1,-1) with log
			goto label89
		   end



		--  Truncate message if it's over len=3200
		If (select len(@parm_message)) > 3200
		   begin
			Select @parm_message = left(@parm_message, 3200) + '... (Message has been truncated due to length)...' + @EOLWinNT
		   end

		--  Truncate message depedning on lenght of attachments
		If (select len(@parm_message)) + (select len(@parm_attach)) > 3500
		   begin
			Select @parm_message = left(@parm_message, 3500-len(@parm_attach)) + '... (Message has been truncated due to length)...' + @EOLWinNT
		   end

		--  If @FROM was used, update the @save_profile_name value
		If @from_flag = 'y'
		   begin
			--  Check @parm_from_name value
			If  @parm_from_name = ''
			   begin
				select @parm_from_name = @parm_from
			   end

			If @parm_from_name like '%@%'
			   begin
				select @charpos = charindex('@', @parm_from_name)
				If @charpos > 0
				   begin
					Select @parm_from_name = left(@parm_from_name, @charpos-1)
				   end
			   end
    
			--  Make sure we have a profile set up for this @parm_from_name value
			if not exists (select 1 from msdb.dbo.sysmail_profile where name = @parm_from_name)
			   begin

				EXECUTE msdb.dbo.sysmail_add_profile_sp
					@profile_name = @parm_from_name,
					@description = @parm_from_name
                		
				EXECUTE msdb.dbo.sysmail_add_account_sp
					@account_name = @parm_from_name,
					@description = @parm_from_name,
					@email_address = @parm_from,
					@display_name = @parm_from_name,
					@replyto_address = @parm_replyto,
					@mailserver_name = @save_mailserver

				EXECUTE msdb.dbo.sysmail_add_profileaccount_sp
					@profile_name = @parm_from_name,
					@account_name = @parm_from_name,
					@sequence_number =1 ;

				EXECUTE msdb.dbo.sysmail_add_principalprofile_sp
					@profile_name = @parm_from_name,
					@principal_id = 0,
					@is_default = 'false'
			   end

			Select @save_profile_name = @parm_from_name

		   end


		--  Format  and exectute the sp_send_dbmail command
		Select @cmd = 'msdb.dbo.sp_send_dbmail @profile_name = ''' + @save_profile_name 
						+ ''', @recipients = ''' + @parm_recipients 
						+ ''', @subject = ''' + @parm_subject 
						+ ''', @body = ''' + @parm_message
						+ ''', @importance = ''' + @parm_priority
						+ ''', @body_format = ''' + @parm_type 
						+ ''''

		If @parm_copy_recipients <> ' '
		   begin
			Select @cmd = @cmd + ', @copy_recipients = ''' + @parm_copy_recipients + ''''
		   end

		If @parm_blind_copy_recipients <> ' '
		   begin
			Select @cmd = @cmd + ', @blind_copy_recipients = ''' + @parm_blind_copy_recipients + ''''
		   end

		If @parm_attach <> ' '
		   begin
			If charindex(';', @parm_attach) > 0
			   begin
				Select @cmd = @cmd + ', @file_attachments = ''' + @parm_attach + ''''
			   end
			Else
			   begin
				Select @cmd = @cmd + ', @file_attachments = ''' + @parm_attach + ''''
			   end
		   end


		Print @save_mailshare + '\' + @cu12cmdoutput
		--print @cmd
		raiserror('', -1,-1) with nowait
		EXEC @retcode = master.sys.sp_executesql @cmd

		Waitfor delay '00:00:02'


label89:


		IF @@error <> 0 or @retcode <> 0
		   begin
			Select @save_alt_filename = replace(@cu12cmdoutput, '.'+@extention, '.err')
			Select @cmd = 'ren "' + @save_mailshare + '\' + @cu12cmdoutput + '" "' + @save_alt_filename + '"'
			select @retry = 0

			rename_error:

			print @cmd
			raiserror('', -1,-1) with nowait
			EXEC @retcode = master.sys.xp_cmdshell @cmd, no_output

			IF @@error <> 0 or @retcode <> 0
			   begin
				select @retry = @retry  + 1
				If @retry < 5
				   begin
					Waitfor delay '00:00:10'
					goto rename_error
				   end
			   end
				

			Select @miscprint = 'DBA WARNING: msdb.dbo.sp_send_dbmail process failed for file ' +  @save_mailshare + '\' + @cu12cmdoutput
			Print 'Mail ERROR for server\file: ' + @save_mailshare + '\' + @cu12cmdoutput + '  ' + convert(nvarchar(30), getdate(), 121)
			Print 'Subject: ' + @parm_subject

			raiserror(@miscprint,-1,-1) with log
		   end
		Else
		   begin
			Print 'Mail sent for server\file: ' + @save_mailshare + '\' + @cu12cmdoutput + '  ' + convert(nvarchar(30), getdate(), 121)
			Print 'Subject: ' + @parm_subject
			Select @save_alt_filename = replace(@cu12cmdoutput, '.'+@extention, '.old')
			Select @cmd = 'ren "' + @save_mailshare + '\' + @cu12cmdoutput + '" "' + @save_alt_filename + '"'
			select @retry = 0

			rename_sml2:

			print @cmd
			raiserror('', -1,-1) with nowait
			EXEC @retcode = master.sys.xp_cmdshell @cmd, no_output

			IF @@error <> 0 or @retcode <> 0
			   begin
				select @retry = @retry  + 1
				If @retry < 5
				   begin
					Waitfor delay '00:00:10'
					goto rename_sml2
				   end
			   end
		   end


		--  Remove special Profile
		If @from_flag = 'y'
		   begin
			EXECUTE msdb.dbo.sysmail_delete_profile_sp @profile_name = @parm_from_name

			EXECUTE msdb.dbo.sysmail_delete_account_sp @account_name = @parm_from_name
		   end




		get_next_request:


		--  Remove this record from #DirectoryTempTable and go to the next
		delete from #DirectoryTempTable where cmdoutput = @hold_cmdoutput
		If (select count(*) from #DirectoryTempTable) > 0
		   begin
			goto start_cmdoutput
		   end

	   end


	--  Remove this record from @servers and go to the next
	delete from @servers where SQLservername = @hold_SQLservername
	If (select count(*) from @servers) > 0
	   begin
		goto start_servers
	   end

   end

----------------  End  -------------------
label99:

drop table #DirectoryTempTable

drop table #DirectoryTempTable2

drop table #Smail_Info_bulk

drop table #Smail_Info

drop table #fileexists




 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DBAperfLog
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DBAperfLog]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DBAperfLog]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_DBAperfLog

/*********************************************************
 **  Stored Procedure dbasp_DBAperfLog                  
 **  Written by Jim Wilson, Getty Images                
 **  December 08, 2005                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/08/2005	Jim Wilson		New process to replave the Activity Log Process.
--	08/22/2006	Jim Wilson		Updated for SQL 2005.
--	05/11/2007	Jim Wilson		Changed memstatcount values to bugint.
--	04/21/2008	Jim Wilson		Changed all numeric(12,2) to (16,2).
--	09/25/2008	Jim Wilson		Commented out @@cpu_busy warning.
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@spidcount			int
	,@cpu_busy			bigint
	,@connections			int
	,@total_read			int
	,@total_write			int
	,@TransPerSec			numeric(16,2)
	,@LockWaitSec			numeric(16,2)
	,@LatchWaitSec			numeric(16,2)
	,@BatchReqSec			numeric(16,2)
	,@ComplSec			numeric(16,2)
	,@ReComplSec			numeric(16,2)
	,@mem_BuffDist_Stolen		bigint
	,@mem_BuffDist_Free		bigint
	,@mem_BuffCount_Hashed		bigint
	,@mem_BuffCount_IntResv		bigint
	,@mem_BuffCount_ExtResv		bigint
	,@mem_QMemObj_AvalBuffs		bigint
	,@secpertick			dec(15,10)	/* seconds per tick */
	,@a 				int
	,@b 				int
	,@query 			nvarchar(500)

Declare 
	 @cpu_busy_new			int
	,@connections_new		int
	,@total_read_new		int
	,@total_write_new		int
	,@TransPerSec_new		numeric(16,2)
	,@LockWaitSec_new		numeric(16,2)
	,@BuffCacheHitRatio_new		float
	,@LatchWaitSec_new		numeric(16,2)
	,@BatchReqSec_new		numeric(16,2)
	,@ComplSec_new			numeric(16,2)
	,@ReComplSec_new		numeric(16,2)


--  Create temp table
CREATE TABLE #memstatus (memstatkey int identity
			,memstatname sysname
			,memstatcount bigint)


/*
**  If we're in a transaction, disallow this since it might make recovery
**  impossible.
*/
set implicit_transactions off
if @@trancount > 0
	begin
		raiserror(15002,-1,-1,'dbasp_DBAperfLog')
		return (1)
	end

/*
**  Set @secpertick.  This is just used to make the numbers easier to handle
**  and avoid overflow.
*/
select @secpertick = convert(dec(15,10), @@timeticks / 1000000.0)

/*
**  Get current monitor values.
*/
select
	@rundate = getdate(),
	@cpu_busy = @@cpu_busy,
	@connections = @@connections,
	@total_read = @@total_read,
	@total_write = @@total_write

select @spidcount = (select count(spid) from master.sys.sysprocesses WHERE SPID NOT IN (1,2,3,4))
	
--  capture Database Transactions per second
Select @TransPerSec = (select cast(cntr_value as numeric(16,2))
				from master.sys.sysperfinfo
				where counter_name= 'Transactions/sec'
				and instance_name = '_Total'
				)


--  capture Database Lock Waits per second
Select @LockWaitSec = (select cast(cntr_value as numeric(16,2))
				from master.sys.sysperfinfo
				where counter_name= 'Lock Waits/sec'
				and instance_name = '_Total'
				)


--  capture Latch Waits per second
Select @LatchWaitSec = (select cast(cntr_value as numeric(16,2))
				from master.sys.sysperfinfo
				where counter_name= 'Latch Waits/sec'
				)


--  capture General Batch Requests per second
Select @BatchReqSec = (select cast(cntr_value as numeric(16,2))
				from master.sys.sysperfinfo
				where counter_name= 'Batch Requests/sec'
				)


--  capture General Compiles per second
Select @ComplSec = (select cast(cntr_value as numeric(16,2))
				from master.sys.sysperfinfo
				where counter_name= 'SQL Compilations/sec'
				)


--  capture General Re-Compiles per second
Select @ReComplSec = (select cast(cntr_value as numeric(16,2))
				from master.sys.sysperfinfo
				where counter_name= 'SQL Re-Compilations/sec'
				)


/*
**  Check to see if DBAperf_current has ever been updated. 
**  If not, update the DBAperf_current table.
*/

--  insert into the DBAperf_current table
if exists (select 1 from dbo.DBAperf_current) 
   begin
	--  Capture Memory Info
	Select @query = 'use master DBCC memorystatus'
	--print @query
		
	INSERT INTO #memstatus (memstatname, memstatcount) exec (@query)

	Select @mem_BuffDist_Stolen = (select top 1 memstatcount from #memstatus where memstatname = 'Stolen' order by memstatkey)
	
	Select @mem_BuffDist_Free = (select top 1 memstatcount from #memstatus where memstatname = 'Free' order by memstatkey)

	Select @mem_BuffCount_Hashed = (select top 1 memstatcount from #memstatus where memstatname = 'Hashed' order by memstatkey)

	Select @mem_BuffCount_IntResv = (select top 1 memstatcount from #memstatus where memstatname = 'Stolen Potential' order by memstatkey)

	Select @mem_BuffCount_ExtResv = (select top 1 memstatcount from #memstatus where memstatname = 'External Reservation' order by memstatkey)

	Select @mem_QMemObj_AvalBuffs = (select top 1 memstatcount from #memstatus where memstatname = 'Available (Buffers)' order by memstatkey)


	-- Calculate new values for the DBAperf_log table.
	select @connections_new = @connections - (select connections from dbaadmin.dbo.DBAperf_current)
	select @total_read_new = @total_read - (select total_read from dbaadmin.dbo.DBAperf_current)
	select @total_write_new = @total_write - (select total_write from dbaadmin.dbo.DBAperf_current)
	select @cpu_busy_new = @cpu_busy - (select cpu_busy from dbaadmin.dbo.DBAperf_current)
	select @cpu_busy_new = convert(int, (convert(dec(15,0), @cpu_busy_new) * @secpertick))

	--  If the @cpu_busy_new = 0, raise a DBA Warning.
	--if @cpu_busy_new = 0 
	--   begin
	--	raiserror('DBA WARNING: @@CPU_BUSY has not changed.  Server may need a reboot.',-1,-1)
	--   end


	--  capture Buffer Cache Hit Ratio
	select @a = (SELECT cntr_value FROM master.sys.sysperfinfo where counter_name = 'Buffer cache hit ratio base')
	If @a = 0
	   begin
		Select @a = 1
	   end

	select @b = (SELECT cntr_value FROM master.sys.sysperfinfo where counter_name = 'Buffer cache hit ratio')
	If @b = 0
	   begin
		Select @b = 1
	   end

	Select @BuffCacheHitRatio_new = (SELECT CONVERT(FLOAT, @b) / @a)


	--  Calculate the difference for the remaining values
	Select @TransPerSec_new = @TransPerSec - (select TransPerSec from dbaadmin.dbo.DBAperf_current)

	Select @LockWaitSec_new = @LockWaitSec - (select LockWaitSec from dbaadmin.dbo.DBAperf_current)

	Select @LatchWaitSec_new = @LatchWaitSec - (select LatchWaitSec from dbaadmin.dbo.DBAperf_current)

	Select @BatchReqSec_new = @BatchReqSec - (select BatchReqSec from dbaadmin.dbo.DBAperf_current)

	Select @ComplSec_new = @ComplSec - (select ComplSec from dbaadmin.dbo.DBAperf_current)

	Select @ReComplSec_new = @ReComplSec - (select ReComplSec from dbaadmin.dbo.DBAperf_current)



	/*
	**  Now insert a new record into the DBAperf_log table
	**  and update the DBAperf_log table.
	*/
	Insert Into dbaadmin.dbo.DBAperf_log (
			 rundate
			,spidcount
			,connections
			,cpu_busy
			,total_read
			,total_write
			,TransPerSec
			,LockWaitSec
			,BuffCacheHitRatio
			,LatchWaitSec
			,BatchReqSec
			,ComplSec
			,ReComplSec
			,mem_BuffDist_Stolen
			,mem_BuffDist_Free
			,mem_BuffCount_Hashed
			,mem_BuffCount_IntResv
			,mem_BuffCount_ExtResv
			,mem_QMemObj_AvalBuffs
			)
		Values (@rundate
			,@spidcount
			,@connections_new
			,@cpu_busy_new
			,@total_read_new
			,@total_write_new
			,@TransPerSec_new
			,@LockWaitSec_new
			,@BuffCacheHitRatio_new
			,@LatchWaitSec_new
			,@BatchReqSec_new
			,@ComplSec_new
			,@ReComplSec_new
			,@mem_BuffDist_Stolen
			,@mem_BuffDist_Free
			,@mem_BuffCount_Hashed
			,@mem_BuffCount_IntResv
			,@mem_BuffCount_ExtResv
			,@mem_QMemObj_AvalBuffs	
			)


	--  Update the record in the 'current' table
	update dbaadmin.dbo.DBAperf_current
	   set
		 rundate = @rundate
		,connections = @connections
		,cpu_busy = @cpu_busy
		,total_read = @total_read
		,total_write = @total_write
		,TransPerSec = @TransPerSec
		,LockWaitSec = @LockWaitSec
		,LatchWaitSec = @LatchWaitSec
		,BatchReqSec = @BatchReqSec
		,ComplSec = @ComplSec
		,ReComplSec = @ReComplSec

   end
Else
   begin
	Insert Into dbaadmin.dbo.DBAperf_current (
			 rundate
			,connections
			,cpu_busy
			,total_read
			,total_write
			,TransPerSec
			,LockWaitSec
			,LatchWaitSec
			,BatchReqSec
			,ComplSec
			,ReComplSec
			)
		Values (@rundate
			,@connections
			,@cpu_busy
			,@total_read
			,@total_write
			,@TransPerSec
			,@LockWaitSec
			,@LatchWaitSec
			,@BatchReqSec
			,@ComplSec
			,@ReComplSec
			)
   end


-----------------  Finalizations  ------------------

drop table #memstatus


return (0) -- dbasp_DBAperfLog


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DBCCscripting
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DBCCscripting]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DBCCscripting]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_DBCCscripting (@DBname sysname = null,
				@PlanName sysname = null,
				@Process_mode sysname = null,
				@ARITHABORT_ON char(1) = 'n',
				@QUOTED_ID_ON char(1) = 'n')
 
/***************************************************************
 **  Stored Procedure dbasp_DBCCscripting                  
 **  Written by Jim Wilson, Getty Images                
 **  August 03, 2004                                      
 **
 **  This procedure is used for various 
 **  DBCC processing.
 **
 **  This proc accepts five input parms: 
 **
 **  Either @dbname or @planname is required.
 **
 **  - @dbname is the name of the database to be processed.
 **    use 'ALL_USER_DBs' to process all user databases
 **    use 'ALL_SYS_DBs' to process all system databases
 **    use 'ALL_DBs' to process all databases
 **
 **  - @planname is the maintenance plan that is used to determine
 **    which database to process.
 **
 **  - @Process_mode must be 'weekly' or 'daily'. (Required)
 **
 **  - @ARITHABORT_ON is an optional parm to have this attribute set
 **    to on prior to running the DBCC command.
 **
 **  - @QUOTED_ID_ON is an optional parm to have this attribute set
 **    to on prior to running the DBCC command.
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/04/2004	Jim Wilson		New DBCC process 
--	08/11/2004	Jim Wilson		Minor fix to maintenance plan processing 
--	02/16/2006	Jim Wilson		Modified for sql 2005 
--	04/15/2010	Jim Wilson		Change daily to checkalloc and checkcatalog only.
--						Added with physical_only to weekly checkdb. 
--	======================================================================================

/***
Declare @DBname sysname
Declare @PlanName sysname
Declare @Process_mode sysname
Declare @ARITHABORT_ON char(1)
Declare @QUOTED_ID_ON char(1)


--Select @DBname = 'dbaadmin'
--Select @DBname = 'ALL_USER_DBs'
--Select @DBname = 'ALL_SYS_DBs'
--Select @DBname = 'ALL_DBs'
Select @PlanName = 'Mplan_user_all'
Select @Process_mode = 'daily'
--Select @Process_mode = 'weekly'
--Select @ARITHABORT_ON = 'y'
--Select @QUOTED_ID_ON = 'y'
--***/

DECLARE
	 @miscprint		varchar(500)  
	,@cmd			varchar(500)
	,@date 			char(14)
	,@Month  		varchar(4)
	,@Day  			varchar(4)
	,@year 			varchar(4)
	,@Hold_hhmmss		varchar(8)
	,@outpath 		varchar(255)
	,@error_count		int
	,@parm01		varchar(100)
	,@save_DBname		sysname
	,@save_backupname	sysname
	,@save_servername	sysname
	,@save_servername2	sysname
	,@cursor_text		varchar(500)
	,@charpos		int
	,@plan_flag		char(1)
	,@oneDB_flag		char(1)
	,@userDB_flag		char(1)
	,@sysDB_flag		char(1)
	,@allDB_flag		char(1)

DECLARE
	 @cu10DBName		sysname

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint
	,@cu11DBStatus		int

DECLARE
	 @cu12DBName		sysname
	,@cu12DBId		smallint
	,@cu12DBStatus		int

DECLARE
	 @cu13DBName		sysname
	,@cu13DBId		smallint
	,@cu13DBStatus		int


----------------  initial values  -------------------
Select @error_count = 0
Select @save_DBname = ''
Select @plan_flag = 'n'
Select @oneDB_flag = 'n'
Select @userDB_flag = 'n'
Select @sysDB_flag = 'n'
Select @allDB_flag = 'n'

Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @date = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

declare @DBnames table	(name		sysname)


----------------------  Main header  ----------------------
Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'DBCC Processing for Standard Maintenance'  
Print  @miscprint
Select @miscprint = 'Script Created For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '


--  Check input parameters and determine backup process
If @Process_mode not in ('weekly', 'daily')
   begin
	Print '-- DBA Warning:  Invalid input parameter for @Process_mode.'
	Select @error_count = @error_count + 1
	Goto label99
   end


If @PlanName is not null and @PlanName <> ''
   begin
	If not exists (select * from msdb.dbo.sysdbmaintplans Where plan_name = @PlanName)
	   begin
		Print '-- DBA WARNING: Invaild parameter passed to dbasp_DBCCscripting - @PlanName parm is invalid'
		Select @error_count = @error_count + 1
		Goto label99
	   end
	Else
	   begin
		If exists (select *  
			From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s 
			Where d.plan_id = s.plan_id
			and s.plan_name = @PlanName
			and d.database_name = 'All User Databases')
		   begin
			Print '-- Process mode is for all User DBs using Maintenance plan [' + @PlanName + ']'
			Select @userDB_flag = 'y'
			goto label05
		   end

		If exists (select *  
			From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s 
			Where d.plan_id = s.plan_id
			and s.plan_name = @PlanName
			and d.database_name = 'All System Databases')
		   begin
			Print '-- Process mode is for all System DBs using Maintenance plan [' + @PlanName + ']'
			Select @sysDB_flag = 'y'
			goto label05
		   end

		Print '-- Process mode is from Maintenance plan [' + @PlanName + ']'
		Select @plan_flag = 'y'
		goto label05
	   end
   end


If @DBname is not null
   begin
	If @DBname = 'ALL_USER_DBs' 
	   begin
		Print '-- Process mode is for all User DBs.'
		Select @userDB_flag = 'y'
		goto label05
	   end
	Else If @DBname = 'ALL_SYS_DBs' 
	   begin
		Print '-- Process mode is for all System DBs.'
		Select @sysDB_flag = 'y'
		goto label05
	   end
	Else If @DBname = 'ALL_DBs' 
	   begin
		Print '-- Process mode is for all DBs.'
		Select @allDB_flag = 'y'
		goto label05
	   end
	Else 
	   begin
		If not exists(select 1 from master.sys.sysdatabases where name = @DBname)
		   begin
			Print '-- DBA Warning:  Invalid input parameter.  Database ' + @DBname + ' does not exist on this server.'
			Select @error_count = @error_count + 1
			Goto label99
		   end
		Else
		   begin
			Print '-- Process mode is for a single DB - ' + @DBname
			Select @oneDB_flag = 'y'
			goto label05
		   end
	   end
   end


If @DBname is null and @PlanName is null
   begin
	Print '-- DBA Warning:  Invalid input parameter.  @DBname or @PlanName must be specified'
	Select @error_count = @error_count + 1
	Goto label99
   end


--  DBCC process has been determined at this point
label05:



Print ' '
Select @miscprint = 'Set nocount on'
Print  @miscprint
Select @miscprint = 'go'
Print  @miscprint
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/
--  Maintenance plan used for DB list
If @plan_flag = 'y'
   begin

	Select @cmd = 'SELECT d.database_name
	   From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s ' + 
	  'Where d.plan_id = s.plan_id
	     and s.plan_name = ''' + @PlanName + ''''

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''

	If @Process_mode = 'weekly'
	   begin
		delete from @DBnames where name in (select detail01 from dbo.no_check where nocheck_type = 'DBCC_weekly')
	   end
	Else If @Process_mode = 'daily'
	   begin
		delete from @DBnames where name in (select detail01 from dbo.no_check where nocheck_type = 'DBCC_daily')
	   end

	--select * from @DBnames


	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames:

		Select @cu10DBName = (select top 1 name from @DBnames order by name)


		If @save_DBname <> @cu10DBName
		   begin
			Print ' '
			Select @miscprint = 'Use ' + @cu10DBName 
			Print @miscprint
			Print 'go'
			Print ' '

			Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + @cu10DBName + ']'''
			Print @miscprint
			Print 'Select getdate()'
			Print 'go'
			Print ' '

			Select @save_DBname = @cu10DBName
		   end

		Print  ' '
		Select @miscprint = '-- DBCC PROCESS for database [' + (rtrim(@cu10DBName)) + ']'
		Print  @miscprint
		Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + rtrim(@cu10DBName) + ']'''
		Print @miscprint
		Print 'Select getdate()'

		If @Process_mode = 'weekly'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			Select @cmd = 'DBCC CHECKDB (''' + rtrim(@cu10DBName) + ''') with physical_only'
			Print @cmd
			Print  'go'
			Print  ' '
		   end
		Else If @Process_mode = 'daily'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			Select @cmd = 'DBCC CHECKALLOC (''' + rtrim(@cu10DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
			
			Select @cmd = 'DBCC CHECKCATALOG (''' + rtrim(@cu10DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
		   end


		--  check for more rows to process
		Delete from @DBnames where name = @cu10DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames
		   end

	   end

   end
--  Process a single DB
Else If @oneDB_flag = 'y'
   begin

	If @save_DBname <> @DBname
	   begin
		Print ' '
		Select @miscprint = 'Use ' + @DBname 
		Print @miscprint
		Print 'go'
		Print ' '

		Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + @DBname + ']'''
		Print @miscprint
		Print 'Select getdate()'
		Print 'go'
		Print ' '

		Select @save_DBname = @DBname
	   end

	Print  ' '
	Select @miscprint = '-- DBCC PROCESS for database [' + (rtrim(@DBname)) + ']'
	Print  @miscprint
	Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + rtrim(@DBname) + ']'''
	Print @miscprint
	Print 'Select getdate()'

	If @Process_mode = 'weekly'
	   begin
		If @ARITHABORT_ON = 'y'
		   begin
			Select @cmd = 'SET ARITHABORT ON'
			Print @cmd
		   end
		If @QUOTED_ID_ON = 'y'
		   begin
			Select @cmd = 'SET QUOTED_IDENTIFIER ON'
			Print @cmd
		   end
		Select @cmd = 'DBCC CHECKDB (''' + rtrim(@DBname) + ''') with physical_only'
		Print @cmd
		Print  'go'
		Print  ' '
	   end
	Else If @Process_mode = 'daily'
	   begin
		If @ARITHABORT_ON = 'y'
		   begin
			Select @cmd = 'SET ARITHABORT ON'
			Print @cmd
		   end
		If @QUOTED_ID_ON = 'y'
		   begin
			Select @cmd = 'SET QUOTED_IDENTIFIER ON'
			Print @cmd
		   end
		   		
		Select @cmd = 'DBCC CHECKALLOC (''' + rtrim(@DBname) + ''')'
		Print @cmd
		Print  'go'
		Print  ' '
			
		Select @cmd = 'DBCC CHECKCATALOG (''' + rtrim(@DBname) + ''')'
		Print @cmd
		Print  'go'
		Print  ' '

	   end

   end
--  Process all user DBs
Else If @userDB_flag = 'y'
   begin

	Select @cmd = 'SELECT d.name
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''

	If @Process_mode = 'weekly'
	   begin
		delete from @DBnames where name in (select detail01 from dbo.no_check where nocheck_type = 'DBCC_weekly')
	   end
	Else If @Process_mode = 'daily'
	   begin
		delete from @DBnames where name in (select detail01 from dbo.no_check where nocheck_type = 'DBCC_daily')
	   end

	--select * from @DBnames


	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames11:

		Select @cu11DBName = (select top 1 name from @DBnames order by name)


		If @save_DBname <> @cu11DBName
		   begin
			Print ' '
			Select @miscprint = 'Use ' + @cu11DBName 
			Print @miscprint
			Print 'go'
			Print ' '

			Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + @cu11DBName + ']'''
			Print @miscprint
			Print 'Select getdate()'
			Print 'go'
			Print ' '

			Select @save_DBname = @cu11DBName
		   end

		Print  ' '
		Select @miscprint = '-- DBCC PROCESS for database [' + (rtrim(@cu11DBName)) + ']'
		Print  @miscprint
		Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + rtrim(@cu11DBName) + ']'''
		Print @miscprint
		Print 'Select getdate()'

		If @Process_mode = 'weekly'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			Select @cmd = 'DBCC CHECKDB (''' + rtrim(@cu11DBName) + ''') with physical_only'
			Print @cmd
			Print  'go'
			Print  ' '
		   end
		Else If @Process_mode = 'daily'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			
			Select @cmd = 'DBCC CHECKALLOC (''' + rtrim(@cu11DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
        			
			Select @cmd = 'DBCC CHECKCATALOG (''' + rtrim(@cu11DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
		   end


		--  check for more rows to process
		Delete from @DBnames where name = @cu11DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames11
		   end

	   end

   end
--  Process all system DBs
Else If @sysDB_flag = 'y'
   begin

	Select @cmd = 'SELECT d.name
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name in (''master'', ''model'', ''msdb'')'

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''
	--select * from @DBnames

	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames12:

		Select @cu12DBName = (select top 1 name from @DBnames order by name)


		If @save_DBname <> @cu12DBName
		   begin
			Print ' '
			Select @miscprint = 'Use ' + @cu12DBName 
			Print @miscprint
			Print 'go'
			Print ' '

			Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + @cu12DBName + ']'''
			Print @miscprint
			Print 'Select getdate()'
			Print 'go'
			Print ' '

			Select @save_DBname = @cu12DBName
		   end

		Print  ' '
		Select @miscprint = '-- DBCC PROCESS for database [' + (rtrim(@cu12DBName)) + ']'
		Print  @miscprint
		Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + rtrim(@cu12DBName) + ']'''
		Print @miscprint
		Print 'Select getdate()'

		If @Process_mode = 'weekly'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			Select @cmd = 'DBCC CHECKDB (''' + rtrim(@cu12DBName) + ''') with physical_only'
			Print @cmd
			Print  'go'
			Print  ' '
		   end
		Else If @Process_mode = 'daily'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			
			Select @cmd = 'DBCC CHECKALLOC (''' + rtrim(@cu12DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
        			
			Select @cmd = 'DBCC CHECKCATALOG (''' + rtrim(@cu12DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
		   end


		--  check for more rows to process
		Delete from @DBnames where name = @cu12DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames12
		   end

	   end

   end
--  Process all DBs
Else If @allDB_flag = 'y'
   begin

	Select @cmd = 'SELECT d.name
	   From master.sys.sysdatabases   d ' + 
	  'Where d.name not in (''tempdb'')'

	delete from @DBnames

	insert into @DBnames (name) exec (@cmd)

	delete from @DBnames where name is null or name = ''

	If @Process_mode = 'weekly'
	   begin
		delete from @DBnames where name in (select detail01 from dbo.no_check where nocheck_type = 'DBCC_weekly')
	   end
	Else If @Process_mode = 'daily'
	   begin
		delete from @DBnames where name in (select detail01 from dbo.no_check where nocheck_type = 'DBCC_daily')
	   end

	--select * from @DBnames

	If (select count(*) from @DBnames) > 0
	   begin
		start_dbnames13:

		Select @cu13DBName = (select top 1 name from @DBnames order by name)

		If @save_DBname <> @cu13DBName
		   begin
			Print ' '
			Select @miscprint = 'Use ' + @cu13DBName 
			Print @miscprint
			Print 'go'
			Print ' '

			Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + @cu13DBName + ']'''
			Print @miscprint
			Print 'Select getdate()'
			Print 'go'
			Print ' '

			Select @save_DBname = @cu13DBName
		   end

		Print  ' '
		Select @miscprint = '-- DBCC PROCESS for database [' + (rtrim(@cu13DBName)) + ']'
		Print  @miscprint
		Select @miscprint = 'Print ''Start ' + @Process_mode + ' DBCC processing for database [' + rtrim(@cu13DBName) + ']'''
		Print @miscprint
		Print 'Select getdate()'

		If @Process_mode = 'weekly'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			Select @cmd = 'DBCC CHECKDB (''' + rtrim(@cu13DBName) + ''') with physical_only'
			Print @cmd
			Print  'go'
			Print  ' '
		   end
		Else If @Process_mode = 'daily'
		   begin
			If @ARITHABORT_ON = 'y'
			   begin
				Select @cmd = 'SET ARITHABORT ON'
				Print @cmd
			   end
			If @QUOTED_ID_ON = 'y'
			   begin
				Select @cmd = 'SET QUOTED_IDENTIFIER ON'
				Print @cmd
			   end
			   			
			Select @cmd = 'DBCC CHECKALLOC (''' + rtrim(@cu13DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
        			
			Select @cmd = 'DBCC CHECKCATALOG (''' + rtrim(@cu13DBName) + ''')'
			Print @cmd
			Print  'go'
			Print  ' '
		   end

		--  check for more rows to process
		Delete from @DBnames where name = @cu13DBName
		If (select count(*) from @DBnames) > 0
		   begin
			goto start_dbnames13
		   end

	   end

   end	


	
Label99:



If @error_count > 0
   begin
	return(1)
   end


 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_depl_NXTcheck
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_depl_NXTcheck]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_depl_NXTcheck]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_depl_NXTcheck    (@dbname sysname = null)

/*********************************************************
 **  Stored Procedure dbasp_depl_NXTcheck                  
 **  Written by Jim Wilson, Getty Images                
 **  February 12, 2007                                      
 **  
 **  This procedure is used to check for local NXT files 
 **  that are used as part of the DEPL DB restore process.
 **
 **  MDFnxt and NDFnxt files are used as part of the 
 **  file attach process in SQL deployments.  These files
 **  are created on the local servers using backup files 
 **  that were created as part of the weekly baseline process.
 **
 **  This process checks for DEPL restore jobs.  Then it checks
 **  for related NXT files in the NXT share.  The 'Base - Local Process' 
 **  job is started if there is available disk space but no
 **  no NXT files.
 **
 **  If @dbname is specified, the process will check for NXT files
 **  related to that DB only.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	02/12/2007	Jim Wilson		New process 
--	03/23/2007	Jim Wilson		Fix code for single dbname request
--	04/10/2007	Jim Wilson		Updated for SQL 2005
--	04/30/2008	Jim Wilson		Changes to support new local nxt creation process.
--	05/08/2008	Jim Wilson		Several updates.  Will now alert for NXT's in the mdf share.
--						Check for nxt and mdf share on the same drive.
--						Skip entire process for production.
--	05/12/2008	Jim Wilson		Fix start job syntax error.
--	09/17/2008	Jim Wilson		Added skip for DBnames in ase_Skip_sqb2nxt table.
--	======================================================================================


/***
Declare @dbname sysname

--Select @dbname = 'dbaadmin'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint			varchar(4000)
	,@outmessage			varchar(4000)
	,@outsubject			varchar(500)
	,@charpos			int
	,@charpos2			int
	,@cmd				varchar(4000)
	,@local_nxt_path		varchar(500)
	,@local_mdf_path		varchar(500)
	,@local_nxt_share		varchar(500)
	,@local_mdf_share		varchar(500)
	,@nxt_path			sysname
	,@mdf_path			sysname
	,@save_path			varchar(500)
	,@error_count			int
	,@save_servername		sysname
	,@save_servername2		sysname
	,@sv_filesize			nvarchar(255)
	,@sv_freespace			nvarchar(255)
	,@sv_cmdout			nvarchar(255)
	,@sv_filedate			nvarchar(10)
	,@save_dbname			sysname
	,@save_depljobname		sysname
	,@save_jname			sysname
	,@hold_full_jname		sysname
	,@save_mdfnxt_name		sysname
	,@save_mdf_name			sysname
	,@start_job			char(1)
	,@nxt_flag			char(1)
	,@status1 			varchar(10)
	,@save_sqb_name			sysname


DECLARE
	 @cu11filename			sysname


----------------  initial values  -------------------
Select @error_count = 0
Select @start_job = 'n'
Select @nxt_flag = 'y'
Select @outmessage = ''
Select @outsubject = 'DBA NXT Warning for SQL instance ' + @@servername

--  Create table variable
declare @dbnames table (dbname sysname)

Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

create table #DirTmpTbl(cmdout nvarchar(255) null)
create table #DirTmpTbl2(cmdout nvarchar(255) null)
create table #DirTmpTbl3(cmdout nvarchar(255) null)

create table #fileexists (doesexist smallint,
			fileindir smallint,
			direxist smallint)



--  Skip this process for production
If (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'ENVname') = 'production'
   begin
	goto label99
   end


--  Process input parm.  Insert DB names into the table variable
if @dbname is null and (select count(*) from msdb.dbo.sysjobs where name like 'depl%' and name like '% - Restore %') > 0
   begin
	Select @hold_full_jname = ''
	start_jname_parse:
	select @save_jname = (select top 1 name from msdb.dbo.sysjobs 
				where name like 'depl%' 
				and name like '% - Restore %' 
				and name > @hold_full_jname)
	--print @save_jname 
	select @hold_full_jname = @save_jname

	If @save_jname is not null
	   begin
		select @charpos = charindex('- Restore', @save_jname)
		IF @charpos <> 0
		   begin
			select @save_jname = substring(@save_jname, @charpos + 10, 100)
			Insert into @dbnames values(@save_jname)
			--Print @save_jname
		   end	
		goto start_jname_parse
	   end
   end
Else if @dbname is not null
   begin
	Insert into @dbnames values(@dbname)
   end


If (select count(*) from @dbnames) = 0
   begin
	Select @miscprint = 'No DEPL Restore jobs configured on this SQL instance'
	Print @miscprint
	goto label99
   end 


--  Make sure the Base - Local Process job exists
if not exists (select 1 from msdb.dbo.sysjobs where name = 'BASE - Local Process')
   begin
	Select @miscprint = 'DBA Error:  The SQL job ''Base - Local Process'' does not exists on this SQL instance. ' + @@servername
	Print @miscprint
	raiserror(@miscprint,16,-1) with log
	goto label99
   end


--  Set and verify MDF share
Select @local_mdf_path = '\\' + @save_servername + '\' + @save_servername2 + '_mdf'
delete from #fileexists
Insert into #fileexists exec master.sys.xp_fileexist @local_mdf_path
--select * from #fileexists
If (select top 1 direxist from #fileexists) = 0
   begin
	Select @miscprint = 'DBA Error:  No MDF share configured for this SQL instance. ' + @@servername
	Print @miscprint
	raiserror(@miscprint,16,-1) with log
	goto label99
   end


--  Set and verify NXT share
Select @local_nxt_path = '\\' + @save_servername + '\' + @save_servername2 + '_nxt'
delete from #fileexists
Insert into #fileexists exec master.sys.xp_fileexist @local_nxt_path
--select * from #fileexists
If (select top 1 direxist from #fileexists) = 0
   begin
	Select @miscprint = 'DBA Warning:  No NXT share configured for this SQL instance. ' + @@servername
	Print @miscprint
	raiserror(@miscprint,16,-1) with log
	Select @nxt_flag = 'n'
   end
Else
   begin
	--  Make sure the mdf and nxt shares are on the same physical drive
	Select @local_mdf_share = @save_servername2 + '_mdf'
	Select @local_nxt_share = @save_servername2 + '_nxt'
	exec dbaadmin.dbo.dbasp_get_share_path @local_mdf_share, @mdf_path output
	exec dbaadmin.dbo.dbasp_get_share_path @local_nxt_share, @nxt_path output

	If @mdf_path is not null 
	    and @nxt_path is not null
	    and left(@mdf_path, 3) <> left(@nxt_path, 3)
	   begin
		Select @miscprint = 'DBA Warning:  MDF and NXT shares are not on the same physical drive for this SQL instance. ' + @@servername
		Print @miscprint
		raiserror(@miscprint,16,-1) with log
	   end
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

--  First, check the MDF share for NXT files.  There should be none.  NXT files should only live in the NXT share.
--  Get info from the mdf share
Select @cmd = 'DIR ' + rtrim(@local_mdf_path) + '\*.*nxt /-c'
--print @cmd
delete from #DirTmpTbl
Insert into #DirTmpTbl exec master.sys.xp_cmdshell @cmd
delete from #DirTmpTbl where cmdout like '%network path was not found%' or cmdout is null
delete from #DirTmpTbl where cmdout like '%volume %' or cmdout is null
delete from #DirTmpTbl where cmdout like '%Directory %' or cmdout is null
--select * from #DirTmpTbl

If not exists (select 1 from #DirTmpTbl where cmdout like '%File Not Found%')
   begin
	select * from #DirTmpTbl
	Select @miscprint = 'DBA Warning:  NXT files exist in the local MDF share for this SQL instance (' + @@servername + ').  They should be deleted).'
	Print @miscprint
	raiserror(@miscprint,16,-1) with log
   end


--  Next, check the MDF share for SQB files.  There should be none.  SQB files should only live in the NXT share.
--  Get info from the mdf share
Select @cmd = 'DIR ' + rtrim(@local_mdf_path) + '\*.sqb /-c'
--print @cmd
delete from #DirTmpTbl
Insert into #DirTmpTbl exec master.sys.xp_cmdshell @cmd
delete from #DirTmpTbl where cmdout like '%network path was not found%' or cmdout is null
delete from #DirTmpTbl where cmdout like '%volume %' or cmdout is null
delete from #DirTmpTbl where cmdout like '%Directory %' or cmdout is null
--select * from #DirTmpTbl

If not exists (select 1 from #DirTmpTbl where cmdout like '%File Not Found%')
   begin
	select * from #DirTmpTbl
	Select @miscprint = 'DBA Warning:  SQB files exist in the local MDF share for this SQL instance (' + @@servername + ').  They should be deleted).'
	Print @miscprint
	raiserror(@miscprint,16,-1) with log
   end



--  Get the first DB name to check
Start_dbnames:
Select @save_dbname = (select top 1 dbname from @dbnames)
--print @save_dbname

If exists (select SQBname from dbo.Base_Skip_sqb2nxt where SQBname = @save_dbname + '_prod.SQB')
   begin 
	Print 'Skip the dbname: ' + @save_dbname 
	goto end_dbnames
   end



--  Get info from the nxt share
If @nxt_flag = 'y'
   begin
	Select @cmd = 'DIR ' + rtrim(@local_nxt_path) + '\*.* /-c'
	--print @cmd
	delete from #DirTmpTbl2
	Insert into #DirTmpTbl2 exec master.sys.xp_cmdshell @cmd
	delete from #DirTmpTbl2 where cmdout like '%network path was not found%' or cmdout is null
	--select * from #DirTmpTbl2
   end



--  Get the mdf and ndf files names related to this DB

--------------------  Cursor for sysfiles -----------------------
EXECUTE('DECLARE cursor_11files Insensitive Cursor For ' + 
  'SELECT a.filename
   From ' + @save_dbname + '.sys.sysfiles a ' + 
  'Where a.groupid > 0
   For Read Only')


OPEN cursor_11files

WHILE (11=11)
   Begin
	FETCH Next From cursor_11files Into @cu11filename
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11files
	      BREAK
           end

	--  Check to see if all components of the file attach process exist
	Select @save_mdfnxt_name = rtrim(@cu11filename)
	label10a:	
	select @charpos = charindex('\', @save_mdfnxt_name)
	IF @charpos <> 0
	   begin
		select @save_mdfnxt_name = substring(@save_mdfnxt_name, @charpos + 1, 100)
	   end	
	
	select @charpos = charindex('\', @save_mdfnxt_name)
	IF @charpos <> 0
	   begin
		goto label10a
	   end

	Select @save_mdf_name = rtrim(@save_mdfnxt_name)
	Select @save_mdfnxt_name = rtrim(@save_mdfnxt_name) + 'nxt'
	Select @save_sqb_name = rtrim(@save_dbname) + '_prod.sqb'
	--Print rtrim(@save_mdfnxt_name)


	--  Check to see if we have an old nxt file or sqb file in the nxt share.  Delete it if too old.
	If exists (select 1 from #DirTmpTbl2 where cmdout like '%' + @save_mdfnxt_name + '%')
	   and @nxt_flag = 'y'
	   begin
		select @sv_cmdout = (select top 1 cmdout from #DirTmpTbl2 where cmdout like '%' + @save_mdfnxt_name + '%')
		select @sv_filedate = rtrim(substring(@sv_cmdout, 1, 10))
		If datediff(d, convert(datetime, @sv_filedate), getdate()) > 8
		   begin
			select @cmd = 'del ' + rtrim(@local_nxt_path) + '\' + rtrim(@save_mdfnxt_name)
			Print @cmd
			exec master.sys.xp_cmdshell @cmd

			delete from #DirTmpTbl2 where cmdout like '%' + @save_mdfnxt_name + '%'

			Select @miscprint = 'DBA Warning: Old NXT file deleted from the NXT share on server ' + @@servername + '.  File: ' + @save_mdfnxt_name + '  Date: ' + @sv_filedate
			Print @miscprint
		   end
	   end

	If exists (select 1 from #DirTmpTbl2 where cmdout like '%' + @save_sqb_name + '%')
	   and @nxt_flag = 'y'
	   begin
		select @sv_cmdout = (select top 1 cmdout from #DirTmpTbl2 where cmdout like '%' + @save_sqb_name + '%')
		select @sv_filedate = rtrim(substring(@sv_cmdout, 1, 10))
		If datediff(d, convert(datetime, @sv_filedate), getdate()) > 8
		   begin
			select @cmd = 'del ' + rtrim(@local_nxt_path) + '\' + rtrim(@save_sqb_name)
			Print @cmd
			exec master.sys.xp_cmdshell @cmd

			delete from #DirTmpTbl2 where cmdout like '%' + @save_sqb_name + '%'

			Select @miscprint = 'DBA Warning: Old SQB file deleted from the NXT share on server ' + @@servername + '.  File: ' + @save_sqb_name + '  Date: ' + @sv_filedate
			Print @miscprint
		   end
	   end

	--  Now check to see if we have an NXT file in the NXT share.
	If not exists (select 1 from #DirTmpTbl2 where cmdout like '%' + @save_mdfnxt_name + '%')
	   and @nxt_flag = 'y'
	   begin
		--  The nxt file was not found.  Now check to see if there is room for the file
		--  Get the size of the current DB file
		Select @cmd = 'DIR ' + rtrim(@cu11filename) + ' /-c'
		--print @cmd
		delete from #DirTmpTbl3
		Insert into #DirTmpTbl3 exec master.sys.xp_cmdshell @cmd
		delete from #DirTmpTbl3 where cmdout like '%network path was not found%' or cmdout is null
		delete from #DirTmpTbl3 where cmdout not like '%' + @save_mdf_name + '%'
		--select * from #DirTmpTbl3
		select @sv_cmdout = (select top 1 cmdout from #DirTmpTbl3)
		select @sv_filesize = ltrim(substring(@sv_cmdout, 22, 17))


		--  get the amount of free space available for this share
		select @sv_freespace = (select top 1 cmdout from #DirTmpTbl2 where cmdout like '%bytes free%')
		Select @charpos = charindex('Dir(s)', @sv_freespace)
		Select @charpos2 = charindex('bytes free', @sv_freespace)
		select @sv_freespace = ltrim(substring(@sv_freespace, @charpos+6, (@charpos2-@charpos)-7))

		If convert(bigint, rtrim(@sv_filesize)) < convert(bigint, rtrim(@sv_freespace))
		   begin
			Select @miscprint = 'DBA Warning: NXT file missing from the NXT share on server ' + @@servername + '.  File: ' + @save_mdfnxt_name
			Print @miscprint
			Select @outmessage = @outmessage + @miscprint 
			Select @outmessage = @outmessage + char(13)+char(10) + char(13)+char(10)
			Select @start_job = 'y'
		   end
		Else
		   begin
			Select @miscprint = 'DBA Message: NXT file missing due to disk space in the NXT share on server ' + @@servername + '.  File: ' + @save_mdfnxt_name
			Print @miscprint
		   end

	   end

	end_11:

   End  -- loop 11
Deallocate cursor_11files


end_dbnames:

Delete from @dbnames where dbname = @save_dbname
If (select count(*) from @dbnames) > 0
   begin
	goto Start_dbnames
   end




--  check @start_job.  If all DEPL jobs are idle, start the 'BASE - Local Process' job
If @start_job = 'y'
   begin
	Select @save_depljobname = ''
	start_jobstate:
	Select @save_depljobname = (select top 1 name from msdb.dbo.sysjobs where name like 'depl%' and name > @save_depljobname)
	If @save_depljobname is not null
	   begin
		exec dbaadmin.dbo.dbasp_Check_Jobstate @save_depljobname, @status1 output

		IF @status1 <> 'idle'
		   begin
			Select @start_job = 'n'
			goto start_job_end
		   end
	   end

	If exists (select 1 from msdb.dbo.sysjobs where name like 'depl%' and name > @save_depljobname)
	   begin
		goto start_jobstate
	   end

	--  If the Base - Local Process job is not running, start it now
	exec dbaadmin.dbo.dbasp_Check_Jobstate 'BASE - Local Process', @status1 output

	IF @status1 = 'idle'
	   begin
		exec msdb.dbo.sp_start_job @job_name = 'BASE - Local Process'
		Select @miscprint = 'Note: Started SQL job ''BASE - Local Process'' on SQL instance ' + @@servername
		Print @miscprint
		Select @outmessage = @outmessage + @miscprint 
		Select @outmessage = @outmessage + char(13)+char(10) + char(13)+char(10)
	   end
   end


start_job_end:


If @outmessage <> ''
   begin
	--  Email TS SQL DBA with this information
	EXEC dbaadmin.dbo.dbasp_sendmail 
		--@recipients = 'jim.wilson@gettyimages.com',  
		@recipients = 'tssqldba@gettyimages.com',  
		@subject = @outsubject,
		@message = @outmessage
   end



--  Finalization  -------------------------------------------------------------------


label99:

drop table #DirTmpTbl
drop table #DirTmpTbl2
drop table #DirTmpTbl3
drop table #fileexists


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_depl_NXTcreatelocal
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_depl_NXTcreatelocal]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_depl_NXTcreatelocal]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_depl_NXTcreatelocal

/*********************************************************
 **  Stored Procedure dbasp_depl_NXTcreatelocal                  
 **  Written by Jim Wilson, Getty Images                
 **  August 02, 2007                                      
 **  
 **  This procedure is used to create local NXT files using 
 **  baseline *.SQB RedGate backup files.
 **
 **  MDFnxt and NDFnxt files are used as part of the 
 **  file attach process in SQL deployments.  These files
 **  also exist on the central baseline SQL server.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/02/2007	Jim Wilson		New process for 2005 
--	======================================================================================


/***

--***/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@query				nvarchar(4000)
	,@restore_cmd			nvarchar(4000)
	,@detach_cmd			nvarchar(4000)
	,@charpos			int
	,@charpos2			int
	,@savepos			int
	,@cmd				nvarchar(4000)
	,@error_count			int
	,@parm01			nvarchar(100)
	,@outpath 			nvarchar(255)
	,@save_NXTpath 			nvarchar(255)
	,@save_MDFpath 			nvarchar(255)
	,@save_file_path		nvarchar(255)
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_SQBfilename		sysname
	,@save_DBname			sysname
	,@savePhysicalNamePart		nvarchar(260)
	,@savefilepath			nvarchar(260)
	,@save_file_name		sysname
	,@sv_filesize			nvarchar(255)
	,@sv_freespace			nvarchar(255)


DECLARE
	 @cu15fileid			smallint
	,@cu15groupid			smallint
	,@cu15name			nvarchar(128)
	,@cu15filename			nvarchar(260)

DECLARE
	 @cu21LogicalName		nvarchar(128)
	,@cu21PhysicalName		nvarchar(260)
	,@cu21Type			char(1)
	,@cu21FileGroupName		nvarchar(128)


----------------  initial values  -------------------
Select @error_count = 0

Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Create temp tables
create table #DirTmpTbl(cmdout nvarchar(255) null)
create table #DirTmpTbl2(cmdout nvarchar(255) null)

create table #filelist_rg(LogicalName nvarchar(128) null, 
						PhysicalName nvarchar(260) null, 
						Type char(1), 
						FileGroupName nvarchar(128) null, 
						Size numeric(20,0), 
						MaxSize numeric(20,0),
						FileId bigint,
						CreateLSN numeric(25,0),
						DropLSN numeric(25,0),
						UniqueId uniqueidentifier,
						ReadOnlyLSN numeric(25,0),
						ReadWriteLSN numeric(25,0),
						BackupSizeInBytes bigint,
						SourceBlockSize int,
						FileGroupId int,
						LogGroupGUID sysname null,
						DifferentialBaseLSN numeric(25,0),
						DifferentialBaseGUID uniqueidentifier,
						IsReadOnly bit,
						IsPresent bit
						)

Create table #temp_sysfiles (
		fileid smallint,
		groupid smallint,
		size int,
		maxsize int,
		growth int,
		status int,
		perf int,
		name nchar(128),
		filename nchar(260))




--  Get the path to the nxt file share
Select @parm01 = @save_servername2 + '_nxt'
exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
If @outpath is null
   begin
	Select @miscprint = 'DBA WARNING: Unable to find the NXT file share for ' + @@servername + '.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end
Else
   begin
	Select @save_NXTpath = rtrim(@outpath)
	Print 'NXT share path is ' + @save_NXTpath + ' for server ' + @@servername
   end


--  Make sure the mdf share and the nxt share don't point to the same folder
Select @parm01 = @save_servername2 + '_mdf'
exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output
If @outpath is null
   begin
	Select @miscprint = 'DBA WARNING: Unable to find the MDF file share for ' + @@servername + '.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end
Else
   begin
	Select @save_MDFpath = rtrim(@outpath)
	Print 'MDF share path is ' + @save_MDFpath + ' for server ' + @@servername
   end

If @save_NXTpath = @save_MDFpath
   begin
	Select @miscprint = 'DBA WARNING: MDF share and NXT share point to the same folder for server ' + @@servername + '.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end


--  Verify RedGate is installed
If not exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
   begin
	Select @miscprint = 'DBA WARNING: RedGate is not installed on server ' + @@servername + '.  This NXT local create process requires RedGate.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end


--  Get a list of SQB files in the nxt share
delete from #DirTmpTbl
Select @cmd = 'DIR ' + rtrim(@save_NXTpath) + '\*.SQB /b'
Insert into #DirTmpTbl exec master.sys.xp_cmdshell @cmd

delete from #DirTmpTbl where cmdout is null
--Select * from #DirTmpTbl

--  If no rows to process, quit
If (select count(*) from #DirTmpTbl) = 0
   begin
	Select @miscprint = 'DBA WARNING: No local *.SQB file to process for the NXT create local process on server ' + @@servername + '.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Start processing the *.SQB files
start_sqb:
Select @save_SQBfilename = (Select top 1 cmdout from #DirTmpTbl)

Select @charpos = charindex('_prod.sqb', @save_SQBfilename)
IF @charpos <> 0
   begin
	select @save_DBname = left(@save_SQBfilename, @charpos-1)
   end	


--  Get the header info from the SQB file
delete from #filelist_rg

Select @query = 'Exec master.dbo.sqlbackup ''-SQL "RESTORE FILELISTONLY FROM DISK = ''''' + rtrim(@save_NXTpath) + '\' + rtrim(@save_SQBfilename) + '''''"'''
insert into #filelist_rg exec (@query)
--select * from #filelist_rg
If (select count(*) from #filelist_rg) = 0
   begin
	Select @miscprint = 'DBA WARNING: Unable to process RedGate filelistonly for file ' + @save_NXTpath + '\' + @save_SQBfilename 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end

Select @sv_filesize = (select convert(nvarchar(255), sum(size)) from #filelist_rg)


--  drop the "nxt" db if it exists
If exists(select 1 from master.sys.databases where name = @save_DBname + 'NXT')
   begin
	Select @query = 'alter database [' + @save_DBname + 'NXT] set SINGLE_USER with ROLLBACK IMMEDIATE '
	print @query
	Exec(@query)

	waitfor delay '00:00:01'

	Select @query = 'alter database [' + @save_DBname + 'NXT] set OFFLINE with ROLLBACK IMMEDIATE '
	print @query
	Exec(@query)

	waitfor delay '00:00:01'

	Select @query = 'alter database [' + @save_DBname + 'NXT] set ONLINE with ROLLBACK IMMEDIATE '
	print @query
	Exec(@query)

	select @query = 'drop database ' + @save_DBname + 'NXT'
	print @query
	Exec(@query)
   end



--  Create the restore script and delete any related DB files still in the nxt share
select @restore_cmd = '-SQL "RESTORE DATABASE [' + @save_DBname + 'NXT]'
select @restore_cmd = @restore_cmd + ' FROM DISK = ''' + @save_NXTpath + '\' + @save_SQBfilename + ''''
select @restore_cmd = @restore_cmd + ' WITH RECOVERY'


EXECUTE('DECLARE cu21_cursor Insensitive Cursor For ' +
  'SELECT f.LogicalName, f.PhysicalName, f.Type, f.FileGroupName
   From #filelist_rg   f ' +
  'for Read Only')

OPEN cu21_cursor
	
WHILE (21=21)
 Begin
	FETCH Next From cu21_cursor Into @cu21LogicalName, @cu21PhysicalName, @cu21Type, @cu21FileGroupName
	IF (@@fetch_status < 0)
           begin
              CLOSE cu21_cursor
	      BREAK
           end

	select @savePhysicalNamePart = @cu21PhysicalName
	label02:
		select @charpos = charindex('\', @savePhysicalNamePart)
		IF @charpos <> 0
		   begin
  		    select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
		   end	
	
		select @charpos = charindex('\', @savePhysicalNamePart)
		IF @charpos <> 0
		   begin
		    goto label02
 		   end

	Select @savefilepath = @save_NXTpath + '\' + @savePhysicalNamePart

	select @restore_cmd = @restore_cmd + ' ,MOVE ''' + rtrim(@cu21LogicalName) + ''' to ''' + rtrim(@savefilepath) + ''''

	--  Delete this file from the NXT share (just in case there is a file there by the same name)
	Select @cmd = 'Del ' + rtrim(@savefilepath)
	Print @cmd	
	EXEC master.sys.xp_cmdshell @cmd--, no_output

	Select @cmd = 'Del ' + rtrim(@savefilepath) + 'nxt'
	Print @cmd	
	EXEC master.sys.xp_cmdshell @cmd--, no_output


End  -- loop 21
DEALLOCATE cu21_cursor


select @restore_cmd = @restore_cmd + ' ,REPLACE"'



--  Check to make sure we have space for the new nxt
Select @cmd = 'DIR ' + rtrim(@save_NXTpath) + '\*.* /-c'
delete from #DirTmpTbl2
Insert into #DirTmpTbl2 exec master.sys.xp_cmdshell @cmd

select @sv_freespace = (select top 1 cmdout from #DirTmpTbl2 where cmdout like '%bytes free%')
Select @charpos = charindex('Dir(s)', @sv_freespace)
Select @charpos2 = charindex('bytes free', @sv_freespace)
select @sv_freespace = ltrim(substring(@sv_freespace, @charpos+6, (@charpos2-@charpos)-7))

If convert(bigint, rtrim(@sv_filesize)) > convert(bigint, rtrim(@sv_freespace))
   begin
	Select @miscprint = 'DBA NOTE: Unable to create local NXT file for ' + @save_SQBfilename + ' due to space issues' 
	Print @miscprint
	goto next_sqb
   end



--  Restore the nxt db
Print @restore_cmd
Exec master.dbo.sqlbackup @restore_cmd



--  verify the nxt restore
If not exists(select 1 from master.sys.databases where name = @save_DBname + 'NXT')
   begin
	Select @miscprint = 'DBA WARNING: RedGate restore for DB ' + @save_DBname + 'NXT failed.' 
	Print @miscprint
	goto next_sqb
   end


--  clean the nxt db
Select @query = 'Use master ALTER AUTHORIZATION ON DATABASE::' + @save_DBname + 'NXT TO sa;'
print @query
Exec(@query)

Select @query = 'ALTER DATABASE [' + @save_DBname + 'NXT] SET RECOVERY SIMPLE WITH ROLLBACK IMMEDIATE'
Print @query
Exec(@query)



--  Capture the file info for this NXT db
Delete from #temp_sysfiles
Select @query = 'select * from [' + @save_DBname + 'NXT].sys.sysfiles'
Insert into #temp_sysfiles exec (@query)
select * from #temp_sysfiles



--  detach the nxt db
Select @detach_cmd = 'master.sys.sp_detach_db ''' + rtrim(@save_DBname) + 'NXT'', @skipchecks = ''true'''
Print @detach_cmd
Exec(@detach_cmd)



--  rename nxt db mdf and ndf files
EXECUTE('DECLARE cu15_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.name, f.filename
   From #temp_sysfiles  f ' + 
  'Order By f.fileid For Read Only')

OPEN cu15_file

WHILE (15=15)
   Begin
	FETCH Next From cu15_file Into @cu15fileid, @cu15groupid, @cu15name, @cu15filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu15_file
	      BREAK
           end

	If @cu15groupid = 0
	   begin
		Select @cmd = 'Del ' + rtrim(@cu15filename)
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output
	   end
	Else
	   begin
		--  parse and save the file name
		Select @save_file_name = rtrim(@cu15filename)
		Select @charpos = charindex('\', @save_file_name)
		label15a:
		IF @charpos <> 0
		   begin
			Select @save_file_name = substring(@save_file_name, @charpos + 1, 200)
		   end	
		Select @charpos = charindex('\', @save_file_name)
		IF @charpos <> 0
		   begin
			goto label15a
		   end	

		--  parse and save the file path
		Select @save_file_path = ''
		Select @savepos = 1
		label15c:
		Select @charpos = charindex('\', @cu15filename, @savepos)
		IF @charpos <> 0
		   begin
			Select @savepos = @charpos+1
			goto label15c
		   end	

		Select @save_file_path = @save_file_path + substring(@cu15filename, 1, @savepos-2)

		--  Rename the DB file, adding 'nxt' to the extention
		Select @cmd = 'REN ' + rtrim(@save_file_path) + '\' + rtrim(@save_file_name) + ' ' + rtrim(@save_file_name) + 'nxt'
		Print @cmd	
		EXEC master.sys.xp_cmdshell @cmd--, no_output 
	   end

   End  -- loop 15
   DEALLOCATE cu15_file




--  Check for more SQB files to process
next_sqb:
delete from #DirTmpTbl where cmdout = @save_SQBfilename

If (select count(*) from #DirTmpTbl) > 0
   begin
	goto start_sqb
   end



--  Finalization  -------------------------------------------------------------------

label99:

drop table #DirTmpTbl
drop table #DirTmpTbl2
drop table #filelist_rg
drop table #temp_sysfiles


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_depl_NXTdelete
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_depl_NXTdelete]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_depl_NXTdelete]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_depl_NXTdelete @environment sysname = null

/*********************************************************
 **  Stored Procedure dbasp_depl_NXTdelete                  
 **  Written by Jim Wilson, Getty Images                
 **  April 01, 2005                                      
 **  
 **  This procedure is used to delete mdfnxt files prior to
 **  pushing deployment baseline files out to servers in 
 **  the dev, test, load and stage environments.
 **
 **  MDFnxt and NDFnxt files are used as part of the 
 **  file attach process in SQL deployments.  These files
 **  exist on a central SQL server and are pushed to the 
 **  target servers as part of the weekly baseline process.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/01/2005	Jim Wilson		New process 
--	07/20/2005	Jim Wilson		Delete MDFNXT files from active and non-active 
--						sql servers.
--	10/12/2005	Jim Wilson		Delete *NXT files from the new NXT shares 
--	05/14/2007	Jim Wilson		Added delete for NXT files on the central server. 
--	05/14/2007	Jim Wilson		Updated for SQL 2005. 
--	06/19/2007	Jim Wilson		New columns in depl_server_db_list 
--	06/22/2007	Jim Wilson		New select for temp table insert 
--	08/06/2007	Jim Wilson		Added delete for SQB files 
--	02/11/2008	Jim Wilson		Added unlocker processing for locked files. 
--	02/25/2008	Jim Wilson		Fixed lines that were commented out in error. 
--	08/22/2008	Jim Wilson		New table dba_dbinfo. 
--	08/31/2009	Jim Wilson		Changed Unlocker to Big Hammer and added kill code. 
--	10/07/2009	Jim Wilson		Added code for new environments (alpha, beta, etc.). 
--	======================================================================================


/***
Declare @environment sysname 

--Select @environment = 'dev'
Select @environment = 'central'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@charpos			int
	,@exists 			bit
	,@cmd				nvarchar(4000)
	,@error_count			int
	,@retry_nxt			smallint
	,@retry_sqb			smallint
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_trgt_servername		sysname
	,@save_trgt_servername2		sysname
	,@save_filename			nvarchar(255)
	,@check_path			nvarchar(500)
	,@parm01			nvarchar(500)
	,@drive_path			nvarchar(500)
	,@hammer_path			nvarchar(500)
	,@kCMD				sysname
	,@proc				sysname
	,@cmd1				nvarchar(4000)
	,@cmd2				nvarchar(4000)


DECLARE
	 @cu11depl_servername		sysname

DECLARE
	 @cu22depl_restore_folder	sysname

----------------  initial values  -------------------
Select @error_count = 0


--  Create table variable
declare @tvar_server_list table(detail01 sysname)

create table #DirectoryTempTable(cmdoutput nvarchar(255) null)

create table #tkill(cmd nvarchar(4000))



--  Verify imput parm
if @environment not in ('dev', 'test', 'load', 'stage', 'alpha', 'beta', 'candidate', 'prodsupport', 'central')
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameter for @environment' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END


Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

if @environment = 'central'
   BEGIN
	goto skip_servername
   END

--  Start process for non-central servers
Insert @tvar_server_list SELECT distinct(SQLname)
				From dbaadmin.dbo.DBA_DBInfo 
				Where ENVname = @environment
				  and BaselineServername = @@servername
				  and BaselineFolder <> 'na'
				  and BaselineFolder <> ''


If (select count(*) from @tvar_server_list) > 0
   begin
	start_servername:
	Select @cu11depl_servername = (select top 1 detail01 from @tvar_server_list)


	Select @save_trgt_servername = @cu11depl_servername
	Select @save_trgt_servername2 = @cu11depl_servername

	Select @charpos = charindex('\', @cu11depl_servername)
	IF @charpos <> 0
	   begin
		Select @save_trgt_servername = substring(@cu11depl_servername, 1, (CHARINDEX('\', @cu11depl_servername)-1))
		Select @save_trgt_servername2 = stuff(@cu11depl_servername, @charpos, 1, '$')
	   end


	--  Format and execute the robocopy command to delete the 'nxt' file from the mdf share
	SELECT @cmd = 'DEL \\' + rtrim(@save_trgt_servername) + '\' + rtrim(@save_trgt_servername2) + '_mdf\*.*nxt /Q'
	PRINT @cmd
	EXEC master.sys.xp_cmdshell @cmd
	

	--  Format and execute the robocopy command to delete the 'nxt' file  from the nxt share
	SELECT @cmd = 'DEL \\' + rtrim(@save_trgt_servername) + '\' + rtrim(@save_trgt_servername2) + '_nxt\*.*nxt /Q'
	PRINT @cmd
	EXEC master.sys.xp_cmdshell @cmd

	--  Format and execute the robocopy command to delete the 'sqb' file  from the nxt share
	SELECT @cmd = 'DEL \\' + rtrim(@save_trgt_servername) + '\' + rtrim(@save_trgt_servername2) + '_nxt\*.sqb /Q'
	PRINT @cmd
	EXEC master.sys.xp_cmdshell @cmd


	--  Check to see if there are more records to process
	Delete from @tvar_server_list where detail01 = @cu11depl_servername
	If (select count(*) from @tvar_server_list) > 0
	   begin
		goto start_servername
	   end


   end

skip_servername:




--  Start process for the local central server

if @environment <> 'central'
   BEGIN
	goto skip_central
   END


Delete from @tvar_server_list
Insert @tvar_server_list select distinct (BaselineFolder) 
				from dbaadmin.dbo.DBA_DBInfo
				where BaselineServername = @@servername
				  and BaselineFolder <> 'na'
				  and BaselineFolder <> ''


If (select count(*) from @tvar_server_list) > 0
   begin
	start_central:

	Select @cu22depl_restore_folder = (select top 1 detail01 from @tvar_server_list)

	Select @retry_sqb = 0
	retry_sqb:

	--  Format and execute the robocopy command to delete the 'sqb' file from the BASE share
	SELECT @cmd = 'DEL \\' + @@servername + '\' + @@servername + '_BASE_' + rtrim(@cu22depl_restore_folder) + '\*.sqb /Q'
	PRINT @cmd
	Exec master.sys.xp_cmdshell @cmd

	--  Check to make sure files were deleted
	Select @cmd = 'DIR \\' + @@servername + '\' + @@servername + '_BASE_' + rtrim(@cu22depl_restore_folder) + '\*.sqb'
	print @cmd
	delete from #DirectoryTempTable
	insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
	delete from #DirectoryTempTable where cmdoutput is null
	delete from #DirectoryTempTable where cmdoutput not like '%.sqb%'
	--select * from #DirectoryTempTable

	--  If all sqb files were not deleted, use the big hammer
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		--  First, make sure the bpbkar32.exe is not running (tape backup process)
		set @proc = 'bpbkar32.exe'

		Print 'Note:  SQB file delete failed.  Killng processes that hold these files'
		Print ''

		set @cmd1 = 'tasklist /fo list /fi "Imagename eq ' + @proc + '"'
		print @cmd1
		Delete from #tkill
		insert into #tkill exec master.sys.xp_cmdshell @cmd1
		delete from #tkill where cmd is null
		--select * from #tkill

		if(select count(*) from #tkill )> 0
		   begin	
			set @cmd2 = 'taskkill /im ' + @proc
			exec master.sys.xp_cmdshell @cmd2
		   end


		--  Set drive letter path
		Select @parm01 = @@servername + '_BASE_' + rtrim(@cu22depl_restore_folder)
		Print @parm01
		exec dbaadmin.dbo.dbasp_get_share_path @parm01, @drive_path output

		Select @save_filename = (select top 1 cmdoutput from #DirectoryTempTable)
		Select @save_filename = rtrim(substring(@save_filename, 40,200))

		Select @hammer_path = @drive_path + '\' + @save_filename
		Print 'Note:  Using BigHammer on file: ' + @hammer_path
		exec dbo.dbasp_bighammer @filepath = @hammer_path
		
		If @retry_sqb < 3
		   begin
			Select @retry_sqb = @retry_sqb + 1
			goto retry_sqb
		   end
		Else
		   begin
			Select @miscprint = 'DBA Baseline error: File delete error encountered for: ' + @drive_path + '\' + @save_filename
			Print @miscprint 
			RAISERROR( @miscprint, 16, -1 )
		   end
	    end


	--  Check to see if there are more records to process
	Delete from @tvar_server_list where detail01 = @cu22depl_restore_folder
	If (select count(*) from @tvar_server_list) > 0
	   begin
		goto start_central
	   end

   end

skip_central:


--  Finalization  -------------------------------------------------------------------


label99:

drop table #DirectoryTempTable
drop table #tkill





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_depl_ScriptServerList
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_depl_ScriptServerList]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_depl_ScriptServerList]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE dbo.dbasp_depl_ScriptServerList (@forServermask sysname = null)

 
/***************************************************************
 **  Stored Procedure dbasp_depl_ScriptServerList                  
 **  Written by Jim Wilson, Getty Images                
 **  October 13, 2005                                      
 **
 **  This procedure creates a file that is used to populate the 
 **  dba_dbinfo table.  This table is maintained on the DBA
 **  central server and is used by the deployment baseline servers.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	10/13/2005	Jim Wilson		New process
--	01/10/2005	Jim Wilson		Convert active to nvarchar(10)
--	05/15/2006	Jim Wilson		Updated for SQL 2005
--	06/04/2007	Jim Wilson		Added ENVnum column.
--	06/20/2005	Jim Wilson		New columns in depl_server_db_list
--	06/21/2005	Jim Wilson		New output for insert and update. Remove delete from output.
--	02/13/2008	Jim Wilson		Added delete to start of output script.
--	08/22/2008	Jim Wilson		New table dba_dbinfo.
--	10/09/2009	Jim Wilson		Added code for DB DEPLinfo.
--	03/12/2010	Jim Wilson		New code for active = 'm'.
--	======================================================================================

/***
Declare @forServermask sysname

--Select @forServermask = 'sqldeployer03'
--***/

Declare	 
	 @miscprint			nvarchar(4000)
	,@save_servername		sysname

DECLARE
	 @cu11Parent_name		sysname
	,@cu11App_name			sysname
	,@cu11SQLname			sysname
	,@cu11ENVname			sysname
	,@cu11ENVnum			sysname
	,@cu11BaselineFolder		sysname
	,@cu11DBname			sysname
	,@cu11Active			nvarchar(10)
	,@cu11push_to_nxt		nchar(1)
	,@cu11BaselineServerName	sysname
	,@cu11moddate   		datetime

----------------  initial values  -------------------

If @forServermask is not null and @forServermask <> ''
   begin
    Select @save_servername = @forServermask
    Select @forServermask = @forServermask + '%'
   end
Else
   begin
    Select @save_servername = @@servername
   end


--  Create table variable
declare @servernames table (SQLName sysname
			    ,DBName sysname
			    ,ENVname sysname
			    ,ENVnum sysname
			    ,BaselineFolder sysname
			    ,BaselineServername sysname
			)


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Script DATA for Table ''DBA_DBinfo'' Process'  
Print  @miscprint
Select @miscprint = 'Created From Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint

If @forServermask is not null and @forServermask <> ''
   begin
	Select @miscprint = 'Created For Server: ' + @save_servername
	Print  @miscprint
   end

Print  '************************************************************************/'
Print  ' '
Select @miscprint = 'Use dbaadmin' 
Print @miscprint
Print 'go'
Print ' '


--  Capture data from the DBA_DBinfo table
If @forServermask is null or @forServermask = ''
   begin
    insert @servernames select d.SQLName, d.DBName, d.ENVname, d.ENVnum, d.BaselineFolder, d.BaselineServername 
			From dbo.DBA_DBinfo d, DBA_Serverinfo s
			where s.SQLname = d.SQLname
			  and d.DBName not in ('dbaadmin', 'DEPLinfo', 'systeminfo')
			  and s.active in ('y', 'm')
			  and d.BaselineServername is not null
			  and d.BaselineServername <> ''
   end
Else
   begin
    insert @servernames select d.SQLName, d.DBName, d.ENVname, d.ENVnum, d.BaselineFolder, d.BaselineServername 
			From dbo.DBA_DBinfo d, DBA_Serverinfo s
			where s.SQLname = d.SQLname
			  and d.DBName not in ('dbaadmin', 'DEPLinfo', 'systeminfo')
			  and s.active in ('y', 'm')
			  and d.BaselineServername like @forServermask
   end


--select * from @servernames

If (select count(*) from @servernames) > 0
   begin
	start_output:

	Select @cu11SQLName = (select top 1 SQLName from @servernames order by SQLName)
	Select @cu11BaselineFolder = (select top 1 BaselineFolder from @servernames where SQLName = @cu11SQLname)
	Select @cu11DBname = (select top 1 DBname from @servernames where SQLName = @cu11SQLname and BaselineFolder = @cu11BaselineFolder)
	Select @cu11ENVname = (select ENVname from @servernames where SQLName = @cu11SQLname and BaselineFolder = @cu11BaselineFolder and DBname = @cu11DBname)
	Select @cu11ENVnum = (select ENVnum from @servernames where SQLName = @cu11SQLname and BaselineFolder = @cu11BaselineFolder and DBname = @cu11DBname)
	Select @cu11BaselineServerName = (select BaselineServerName from @servernames where SQLName = @cu11SQLname and BaselineFolder = @cu11BaselineFolder and DBname = @cu11DBname)
    
	Select @miscprint = 'If not exists (select 1 from dbo.DBA_DBinfo where SQLName = ''' + @cu11SQLname + ''' and DBname = ''' + @cu11DBname + ''')' + char(13)+char(10)
	Select @miscprint = @miscprint + '   begin' + char(13)+char(10)
	Select @miscprint = @miscprint + '      Insert into dbo.DBA_DBinfo (SQLName, DBName, ENVname, ENVnum, BaselineFolder, BaselineServername)' + char(13)+char(10)
	Select @miscprint = @miscprint + '      values (''' + @cu11SQLName + ''',' + char(13)+char(10)
	Select @miscprint = @miscprint + '              ''' + @cu11DBname + ''',' + char(13)+char(10) 
	Select @miscprint = @miscprint + '              ''' + @cu11ENVname + ''',' + char(13)+char(10)
	Select @miscprint = @miscprint + '              ''' + @cu11ENVnum + ''',' + char(13)+char(10) 
	Select @miscprint = @miscprint + '              ''' + @cu11BaselineFolder + ''',' + char(13)+char(10) 
	Select @miscprint = @miscprint + '              ''' + @cu11BaselineServerName + ''')' + char(13)+char(10)
	Select @miscprint = @miscprint + '   end' + char(13)+char(10)

	Print @miscprint
	Print 'go'
	Print ' '


	--  Remove this record from @servernames and go to the next
	delete from @servernames where SQLname = @cu11SQLname and BaselineFolder = @cu11BaselineFolder and DBname = @cu11DBname
	If (select count(*) from @servernames) > 0
	   begin
		goto start_output
	   end
   end


-----------------------------------------------------------------------------------------------------------------
--  Finalization  -----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------

label99:

Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Script DATA for Table ''DBA_DBinfo'' Process Complete'  
Print  @miscprint
Print  '************************************************************************/'



 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_Blocks
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_Blocks]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_Blocks]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_Blocks

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_Blocks                  
 **  Written by Jim Wilson, Getty Images                
 **  April 09, 2007                                      
 **  
 **  This dbasp is set up to capture blocking information
 **  for problem analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/09/2007	Jim Wilson		New process.
--	11/19/2008	Jim Wilson		Added Tran Lock processing and lookup for DBname
--						and object names.
--	07/09/2009	Jim Wilson		Added convert for bigint to nvarchar at blockingChain output.
--	07/13/2009	Jim Wilson		waiting_user_id can now be null.
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @query 			nvarchar(max)
	,@miscprint			nvarchar(4000)
	,@save_database_id		nvarchar(20)
	,@save_object_id		nvarchar(20)
	,@save_ObjectName		sysname
	,@save_ObjectType		nvarchar(10)
	,@save_session_id 		smallint
	,@save_head_wait_resource	nvarchar(512)

Declare 
	 @cmd	 			nvarchar(4000)
	,@charpos			int
	,@save_rundate			datetime
	,@save_DBname			sysname
	,@save_resourceType		sysname
	,@save_blockedObject		bigint
	,@save_blockedObject_id		int
	,@save_blocked_ObjectName	sysname



/*********************************************************************
 *                Initialization
 ********************************************************************/
Select @save_rundate = getdate()

--  Create temp tables

create table #blocks (head_wait_resource 		nvarchar (512) NULL
			,session_id 			smallint NULL
			,request_id 			smallint NULL
			,blocking_session_id 		int NULL
			,program_name 			nvarchar (128) NULL
			,tree_level 			int NULL
			,QueryText			nvarchar (max) NULL
			,sql_handle			nvarchar (max) NULL
			,plan_handle			nvarchar (max) NULL
			,statement_start_offset		int NULL
			,statement_end_offset		int NULL
			,session_or_request_status	nvarchar (60) NULL
			,wait_type			nvarchar (60) NULL
			,wait_time			int NULL
			,wait_resource			nvarchar (512) NULL
			,transaction_id			bigint NULL
			,transaction_isolation_level	smallint NULL
			,open_transaction_count		int NULL
			,seconds_active_idle		bigint NULL
			,transaction_name		nvarchar (64) NULL
			,transaction_begin_time		datetime NULL
			,transaction_type		int NULL
			,transaction_state		int NULL
			,dtc_state			int NULL
			,dtc_isolation_level		int NULL
			,enlist_count			int NULL
			,is_user_transaction		bit NULL
			,is_local			bit NULL
			,is_enlisted			bit NULL
			,is_bound			bit NULL
			)

create table #blockingChain(resourceType 	nvarchar(60)
			,databaseName 		sysname
			,blockedObject 		bigint
			,waiting_request_mode 	nvarchar(60)
			,waiting_user_id 	sysname null
			,waiting_session_id 	int
			,blockingUserId 	sysname
			,blocking_session_id 	int
			,blockerText 		text
			,waitingText 		text
			,sessionPlan 		XML
			)



--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
   begin
    raiserror(15002,-1,-1,'dbasp_DMVcapture_Blocks')
    goto label99
   end


--  Make sure the Blocks table exists
if not exists(select * from sys.objects where name = 'DMV_Blocks' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_Blocks failed.  Table dbo.DMV_Blocks does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end

if not exists(select * from sys.objects where name = 'DMV_Tran_Locks' and type = 'U')
begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_Blocks failed.  Table dbo.DMV_Tran_Locks does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end

	


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Catpture Blocks info
select @query = 'with blocking_hierarchy (head_wait_resource, session_id, blocking_session_id, tree_level, request_id, transaction_id, 
	status, sql_handle, plan_handle, statement_start_offset, statement_end_offset, wait_type, wait_time, wait_resource, 
	program_name, seconds_active_idle, open_transaction_count, transaction_isolation_level) 
as 
(
	select 
		(select min(wait_resource) from sys.dm_exec_requests where blocking_session_id = s.session_id) as head_wait_resource, 
		s.session_id, 
		convert(smallint, NULL), 
		convert(int, 0), 
		r.request_id, 
		coalesce(r.transaction_id, st.transaction_id), 
		isnull(r.status, ''idle''), 
		r.sql_handle, 
		r.plan_handle, 
		r.statement_start_offset, 
		r.statement_end_offset, 
		r.wait_type, 
		r.wait_time, 
		r.wait_resource, 
		s.program_name,
		case when r.request_id is null then datediff(ss, s.last_request_end_time, getdate()) else datediff(ss, r.start_time, getdate()) end,
		convert(int, p.open_tran),
		coalesce(r.transaction_isolation_level, s.transaction_isolation_level)
	from sys.dm_exec_sessions s
		join sys.sysprocesses p on s.session_id = p.spid
		left join sys.dm_exec_requests r on s.session_id = r.session_id
		left join sys.dm_tran_session_transactions st on s.session_id = st.session_id
	where s.session_id in (select blocking_session_id from sys.dm_exec_requests) 
		and isnull(r.blocking_session_id, 0) = 0

	union all

	select b.head_wait_resource, 
		r.session_id, 
		r.blocking_session_id, 
		tree_level + 1, 
		r.request_id, 
		r.transaction_id, 
		r.status, 
		r.sql_handle, 
		r.plan_handle, 
		r.statement_start_offset, 
		r.statement_end_offset, 
		r.wait_type, 
		r.wait_time, 
		r.wait_resource, 
		NULL,
		NULL,
		r.open_transaction_count,
		r.transaction_isolation_level
	from sys.dm_exec_requests r
		join blocking_hierarchy b on r.blocking_session_id = b.session_id
)
select  b.head_wait_resource,
	b.session_id, 
	b.request_id, 
	b.blocking_session_id, 
	b.program_name, 
	b.tree_level, 
	case when LEN(qt.query_text) < 2048 then qt.query_text else LEFT(qt.query_text, 2048) + N''...'' end as query_text,
	master.dbo.fn_varbintohexstr(b.sql_handle) as sql_handle, 
	master.dbo.fn_varbintohexstr(b.plan_handle) as plan_handle, 
	b.statement_start_offset, 
	b.statement_end_offset, 
	b.status as session_or_request_status, 
	b.wait_type, 
	b.wait_time, 
	b.wait_resource, 
	b.transaction_id, 
	b.transaction_isolation_level,
	b.open_transaction_count,
	b.seconds_active_idle,
	t.name as transaction_name, 
	t.transaction_begin_time, 
	t.transaction_type, 
	t.transaction_state, 
	t.dtc_state, 
	t.dtc_isolation_level,
	st.enlist_count, 
	st.is_user_transaction, 
	st.is_local, 
	st.is_enlisted, 
	st.is_bound
from blocking_hierarchy b
	left join sys.dm_tran_session_transactions st on st.transaction_id = b.transaction_id and st.session_id = b.session_id
	left join sys.dm_tran_active_transactions t on t.transaction_id = b.transaction_id
	outer apply msdb.dbo.fn_QueryTextFromHandle(b.sql_handle, b.statement_start_offset, b.statement_end_offset) as qt'

insert into #blocks (head_wait_resource
			,session_id
			,request_id
			,blocking_session_id
			,program_name
			,tree_level
			,QueryText
			,sql_handle
			,plan_handle
			,statement_start_offset
			,statement_end_offset
			,session_or_request_status
			,wait_type
			,wait_time
			,wait_resource
			,transaction_id
			,transaction_isolation_level
			,open_transaction_count
			,seconds_active_idle
			,transaction_name
			,transaction_begin_time
			,transaction_type
			,transaction_state
			,dtc_state
			,dtc_isolation_level
			,enlist_count
			,is_user_transaction
			,is_local
			,is_enlisted
			,is_bound)
exec (@query)

Delete from #blocks where session_id is null or head_wait_resource is null
If (select count(*) from #blocks) > 0
   begin
	Print ''
	Print '#blocks rows'
	select convert(nvarchar(30), head_wait_resource) as head_wait_resource, session_id, request_id, convert(nvarchar(30), QueryText) as QueryText from #blocks
	Print ''
   end


--  Capture Tran Locks info
insert #blockingChain
select t1.resource_type
    ,db_name(t1.resource_database_id) as database_name
    ,t1.resource_associated_entity_id as blocked_object
    ,t1.request_mode as waiting_request_mode
    ,t5.login_name as waiting_user_id
    ,t1.request_session_id  as waiting_session_id 
    ,t4.login_name as blockingUserId
    ,t2.blocking_session_id  
    ,blockerText.Text
    ,waitingText.Text
    ,sessionPlan.query_plan
from
sys.dm_tran_locks as t1 
inner join sys.dm_os_waiting_tasks as t2 on 
      t1.lock_owner_address = t2.resource_address 
inner join sys.dm_exec_requests t31 on
      t1.request_session_id = t31.session_id
inner join sys.dm_exec_connections t41 on
      t2.blocking_session_id = t41.session_id
inner join sys.dm_exec_sessions t4 on
      t2.blocking_session_id = t4.session_id
left join sys.dm_exec_sessions t5 on
      t1.request_session_id = t5.session_id
cross apply sys.dm_exec_sql_text(t31.sql_handle) as waitingText
cross apply sys.dm_exec_sql_text(t41.Most_recent_sql_handle) as blockerText
CROSS APPLY sys.dm_exec_query_plan(t31.plan_handle) sessionPlan
where t2.wait_Duration_MS > 3000

Delete from #blockingChain where databaseName is null or resourceType is null or blockedObject is null
If (select count(*) from #blockingChain) > 0
   begin
	Print ''
	Print '#blockingChain rows'
	select convert(nvarchar(30), resourceType) as resourceType, convert(nvarchar(30), databaseName) as databaseName, convert(nvarchar(20), blockedObject) as blockedObject from #blockingChain
	Print 'End of BlockingChain rows.'
	Print ''
   end


----------------------------------------------------------------------------------------------------------
--  Process Blocks info
----------------------------------------------------------------------------------------------------------
If (select count(*) from #blocks) > 0
   begin
	start01:
	Select @save_session_id = (select top 1 session_id from #blocks order by session_id)
	Select @save_head_wait_resource = (select top 1 head_wait_resource from #blocks where session_id = @save_session_id order by head_wait_resource)
	Set @save_DBname = null
	Set @save_ObjectName = null
	Set @save_ObjectType = null

	If @save_head_wait_resource like 'OBJECT:%'
	   begin
		Select @save_database_id = substring(@save_head_wait_resource, 8, 20)
		Select @save_database_id = ltrim(@save_database_id) 

		Select @charpos = charindex(':', @save_database_id)
		IF @charpos <> 0
		   begin
			Select @save_object_id = substring(@save_database_id, @charpos+1, 20) 
			Select @save_object_id = ltrim(@save_object_id) 
			Select @save_database_id = substring(@save_database_id, 1, @charpos-1)
		   end

		Select @charpos = charindex(':', @save_object_id)
		IF @charpos <> 0
		   begin
			Select @save_object_id = substring(@save_object_id, 1, @charpos-1) 
		   end

		Select @save_database_id = rtrim(ltrim(@save_database_id))
		Select @save_DBname = (select name from master.sys.databases where database_id = @save_database_id)

		If @save_object_id is not null
		   begin
			Select @cmd = 'use [' + @save_DBname + '] select @save_ObjectName = name from sys.objects where object_id = ' + @save_object_id
			EXEC sp_executesql @cmd, N'@save_ObjectName sysname output', @save_ObjectName output

			Select @cmd = 'use [' + @save_DBname + '] select @save_ObjectType = type from sys.objects where object_id = ' + @save_object_id
			EXEC sp_executesql @cmd, N'@save_ObjectType nvarchar(10) output', @save_ObjectType output
		   end
	   end
	Else If @save_head_wait_resource like 'KEY:%'
	   begin
		Select @save_database_id = substring(@save_head_wait_resource, 5, 20)
		Select @save_database_id = ltrim(@save_database_id) 

		Select @charpos = charindex(':', @save_database_id)
		IF @charpos <> 0
		   begin
			Select @save_database_id = substring(@save_database_id, 1, @charpos-1)
		   end

		Select @save_database_id = rtrim(ltrim(@save_database_id))
		Select @save_DBname = (select name from master.sys.databases where database_id = @save_database_id)
	   end
	Else If @save_head_wait_resource like 'PAGE:%'
	   begin
		Select @save_database_id = substring(@save_head_wait_resource, 6, 20)
		Select @save_database_id = ltrim(@save_database_id) 

		Select @charpos = charindex(':', @save_database_id)
		IF @charpos <> 0
		   begin
			Select @save_database_id = substring(@save_database_id, 1, @charpos-1)
		   end

		Select @save_database_id = rtrim(ltrim(@save_database_id))
		Select @save_DBname = (select name from master.sys.databases where database_id = @save_database_id)
	   end
	Else If @save_head_wait_resource like 'DATABASE:%'
	   begin
		Select @save_database_id = substring(@save_head_wait_resource, 10, 20)

		Select @save_database_id = rtrim(ltrim(@save_database_id)) 
		Select @save_DBname = (select name from master.sys.databases where database_id = @save_database_id)
	   end



	Insert into dbo.DMV_Blocks (rundate, head_wait_resource, database_name, object_name, object_type, session_id) 
	    values (@save_rundate, @save_head_wait_resource, @save_DBname, @save_ObjectName, @save_ObjectType, @save_session_id)

	Update d set d.request_id = b.request_id 
		,d.blocking_session_id = b.blocking_session_id
		,d.program_name = b.program_name
		,d.tree_level = b.tree_level
		,d.QueryText = b.QueryText
		,d.sql_handle = b.sql_handle
		,d.plan_handle = b.plan_handle
		,d.statement_start_offset = b.statement_start_offset
		,d.statement_end_offset = b.statement_end_offset
		,d.session_or_request_status = b.session_or_request_status
		,d.wait_type = b.wait_type
		,d.wait_time = b.wait_time
		,d.wait_resource = b.wait_resource
		,d.transaction_id = b.transaction_id
		,d.transaction_isolation_level = b.transaction_isolation_level
		,d.open_transaction_count = b.open_transaction_count
		,d.seconds_active_idle = b.seconds_active_idle
		,d.transaction_name = b.transaction_name
		,d.transaction_begin_time = b.transaction_begin_time
		,d.transaction_type = b.transaction_type
		,d.transaction_state = b.transaction_state
		,d.dtc_state = b.dtc_state
		,d.dtc_isolation_level = b.dtc_isolation_level
		,d.enlist_count = b.enlist_count
		,d.is_user_transaction = b.is_user_transaction
		,d.is_local = b.is_local
		,d.is_enlisted = b.is_enlisted
		,d.is_bound = b.is_bound
		from dbo.DMV_Blocks d, #blocks b
		where d.rundate = @save_rundate
		  and d.session_id = b.session_id
		  and d.session_id = @save_session_id
		  and d.head_wait_resource = b.head_wait_resource
		  and d.head_wait_resource = @save_head_wait_resource


	--  check for more rows to process
	Delete from #blocks where head_wait_resource = @save_head_wait_resource and session_id = @save_session_id
	If (select count(*) from #blocks) > 0
	   begin
		goto start01
	   end
   end



----------------------------------------------------------------------------------------------------------
--  Process Tran Locks info
----------------------------------------------------------------------------------------------------------
If (select count(*) from #blockingChain) > 0
   begin
	start02:
	Select @save_DBname = (select top 1 databaseName from #blockingChain order by databaseName)
	Select @save_resourceType = (select top 1 resourceType from #blockingChain where databaseName = @save_DBname order by resourceType)
	Select @save_blockedObject = (select top 1 blockedObject from #blockingChain where databaseName = @save_DBname and resourceType = @save_resourceType order by resourceType)
	Select @save_blockedObject_id = null
	Select @save_blocked_ObjectName = null

	--  Get the blockedObjectId info
	Select @cmd = 'use [' + @save_DBname + '] select @save_blockedObject_id = object_id from sys.partitions where partition_id = ' + convert(nvarchar(30), @save_blockedObject)
	EXEC sp_executesql @cmd, N'@save_blockedObject_id int output', @save_blockedObject_id output

	If @save_blockedObject_id is not null
	   begin
		Select @cmd = 'use [' + @save_DBname + '] select @save_blocked_ObjectName = name from sys.objects where object_id = ' + convert(nvarchar(30), @save_blockedObject_id)
		EXEC sp_executesql @cmd, N'@save_blocked_ObjectName sysname output', @save_blocked_ObjectName output
	   end
	Else
	   begin
		Select @save_blockedObject_id = @save_blockedObject
		Select @cmd = 'use [' + @save_DBname + '] select @save_blocked_ObjectName = name from sys.objects where object_id = ' + convert(nvarchar(30), @save_blockedObject_id)
		EXEC sp_executesql @cmd, N'@save_blocked_ObjectName sysname output', @save_blocked_ObjectName output
	   end


	Insert into dbo.DMV_Tran_Locks (rundate, dbname, resource_type, blocked_object, blocked_ObjectId, blocked_ObjectName) 
	    values (@save_rundate, @save_DBname, @save_resourceType, @save_blockedObject, @save_blockedObject_id, @save_blocked_ObjectName)

	Update tl set tl.waiting_request_mode = b.waiting_request_mode
		,tl.waiting_user_id = b.waiting_user_id
		,tl.waiting_session_id = b.waiting_session_id
		,tl.waiting_Text = b.waitingText
		,tl.blocking_user_id = b.blockingUserId
		,tl.blocking_session_id = b.blocking_session_id
		,tl.blocking_Text = b.blockerText
		,tl.sessionPlan = b.sessionPlan
		from dbo.DMV_Tran_Locks tl, #blockingChain b
		where tl.rundate = @save_rundate
		  and tl.dbname = b.databaseName
		  and tl.dbname = @save_DBname
		  and tl.resource_type = b.resourceType
		  and tl.resource_type = @save_resourceType
		  and tl.blocked_object = b.blockedObject
		  and tl.blocked_object = @save_blockedObject


	--  check for more rows to process
	Delete from #blockingChain where databaseName = @save_DBname and resourceType = @save_resourceType and blockedObject = @save_blockedObject
	If (select count(*) from #blockingChain) > 0
	   begin
		goto start02
	   end
   end


--  Purge old rows (90 days)
delete from dbo.DMV_Blocks where rundate < getdate()-90
delete from dbo.DMV_Tran_Locks where rundate < getdate()-90

-----------------  Finalizations  ------------------

label99:

drop table #blocks
drop table #blockingChain




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_fileio
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_fileio]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_fileio]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_fileio

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_fileio                  
 **  Written by Jim Wilson, Getty Images                
 **  March 30, 2007                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/30/2007	Jim Wilson		New process.
--	04/02/2007	Jim Wilson		Ignore rows with zero values.
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@query 			nvarchar(2000)

Declare 
	 @save_database_id		smallint
	,@save_file_id			smallint
	,@save_io_stall_read_ms		bigint
	,@save_num_of_reads		bigint
	,@save_io_stall_write_ms	bigint
	,@save_num_of_writes		bigint
	,@old_io_stall_read_ms		bigint
	,@old_num_of_reads		bigint
	,@old_io_stall_write_ms		bigint
	,@old_num_of_writes		bigint
	,@new_io_stall_read_ms		bigint
	,@new_num_of_reads		bigint
	,@new_io_stall_write_ms		bigint
	,@new_num_of_writes		bigint
	,@new_io_stalls_ms		bigint
	,@new_total_io			bigint
	,@new_avg_read_stall_ms		numeric(10,1)
	,@new_avg_write_stall_ms	numeric(10,1)
	,@new_avg_io_stall_ms		numeric(10,1)


/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  Create temp table
CREATE TABLE #filestats (database_id smallint
			,file_id smallint
			,io_stall_read_ms bigint
			,num_of_reads bigint
			,io_stall_write_ms bigint
			,num_of_writes bigint)


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
	begin
		raiserror(15002,-1,-1,'dbasp_DMVcapture_fileio')
		goto label99
	end

	

/****************************************************************
 *                MainLine
 ***************************************************************/


Select @query = 'select database_id
    ,file_id
    ,io_stall_read_ms 
    ,num_of_reads
    ,io_stall_write_ms
    ,num_of_writes
from master.sys.dm_io_virtual_file_stats(null,null)'

INSERT INTO #filestats exec (@query)
--select * from #filestats

Delete from #filestats where io_stall_read_ms = 0
			and num_of_reads = 0
			and io_stall_write_ms = 0
			and num_of_writes = 0
--select * from #filestats

-- Loop through the filestats rows
If (select count(*) from #filestats) > 0
   begin
    start_01:

    --  Get the top row from the current stats
    Select @save_database_id = (select top 1 database_id from #filestats order by database_id)
    Select @save_file_id = (select top 1 file_id from #filestats where database_id = @save_database_id order by file_id)
    Select @save_io_stall_read_ms = (select top 1 io_stall_read_ms from #filestats where database_id = @save_database_id and file_id = @save_file_id)
    Select @save_num_of_reads = (select top 1 num_of_reads from #filestats where database_id = @save_database_id and file_id = @save_file_id)
    Select @save_io_stall_write_ms = (select top 1 io_stall_write_ms from #filestats where database_id = @save_database_id and file_id = @save_file_id)
    Select @save_num_of_writes = (select top 1 num_of_writes from #filestats where database_id = @save_database_id and file_id = @save_file_id)


    --  Get the matching info from the last run
    If exists (select 1 from DMV_IOfile_current where database_id = @save_database_id and file_id = @save_file_id)
       begin
	Select @old_io_stall_read_ms = (select top 1 io_stall_read_ms from dbo.DMV_IOfile_current where database_id = @save_database_id and file_id = @save_file_id)
        Select @old_num_of_reads = (select top 1 num_of_reads from dbo.DMV_IOfile_current where database_id = @save_database_id and file_id = @save_file_id)
	Select @old_io_stall_write_ms = (select top 1 io_stall_write_ms from dbo.DMV_IOfile_current where database_id = @save_database_id and file_id = @save_file_id)
	Select @old_num_of_writes = (select top 1 num_of_writes from dbo.DMV_IOfile_current where database_id = @save_database_id and file_id = @save_file_id)

	--  format the data for the insert
	Select @new_io_stall_read_ms = Case when @save_io_stall_read_ms > @old_io_stall_read_ms 
					then @save_io_stall_read_ms - @old_io_stall_read_ms
					else 0
					end

	Select @new_num_of_reads = Case when @save_num_of_reads > @old_num_of_reads 
					then @save_num_of_reads - @old_num_of_reads
					else 0
					end

	Select @new_io_stall_write_ms = Case when @save_io_stall_write_ms > @old_io_stall_write_ms 
					then @save_io_stall_write_ms - @old_io_stall_write_ms
					else 0
					end

	Select @new_num_of_writes = Case when @save_num_of_writes > @old_num_of_writes 
					then @save_num_of_writes - @old_num_of_writes
					else 0
					end

	Select @new_io_stalls_ms = @new_io_stall_read_ms + @new_io_stall_write_ms
	Select @new_total_io = @new_num_of_reads + @new_num_of_writes

	Select @new_avg_read_stall_ms = cast(@new_io_stall_read_ms/(1.0+@new_num_of_reads) as numeric(10,1)) 
	Select @new_avg_write_stall_ms = cast(@new_io_stall_write_ms/(1.0+@new_num_of_writes) as numeric(10,1)) 
	Select @new_avg_io_stall_ms = cast(@new_io_stalls_ms/(1.0+@new_total_io) as numeric(10,1)) 


	Insert into dbo.DMV_IOfile_log values(@rundate
					    ,@save_database_id
					    ,@save_file_id
					    ,@new_io_stall_read_ms
					    ,@new_num_of_reads
					    ,@new_avg_read_stall_ms
					    ,@new_io_stall_write_ms
					    ,@new_num_of_writes
					    ,@new_avg_write_stall_ms
					    ,@new_io_stalls_ms
					    ,@new_total_io
					    ,@new_avg_io_stall_ms)			    


	UPDATE dbo.DMV_IOfile_current set rundate = @rundate
					,io_stall_read_ms = @save_io_stall_read_ms
					,num_of_reads = @save_num_of_reads
					,io_stall_write_ms = @save_io_stall_write_ms
					,num_of_writes = @save_num_of_writes
				    where database_id = @save_database_id and file_id = @save_file_id
       end
    Else
       begin
	INSERT INTO dbo.DMV_IOfile_current values (@rundate, @save_database_id, @save_file_id, @save_io_stall_read_ms, @save_num_of_reads, @save_io_stall_write_ms, @save_num_of_writes)
       end


    --  Check to see if there are more rows to process
    Delete from #filestats where database_id = @save_database_id and file_id = @save_file_id
    If (select count(*) from #filestats) > 0
       begin
        goto start_01
       end


   end


delete from dbo.DMV_IOfile_current where rundate <> @rundate

delete from dbo.DMV_IOfile_log where rundate < getdate()-90


-----------------  Finalizations  ------------------

label99:

drop table #filestats




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_Indexusage
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_Indexusage]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_Indexusage]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_Indexusage

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_Indexusage                 
 **  Written by Jim Wilson, Getty Images                
 **  November 17, 2008                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/17/2008	Jim Wilson		New process.
--	11/21/2008	Jim Wilson		Added object type and changed to hourly capture.
--	======================================================================================

-----------------  declares  ------------------
Declare 
	 @rundate			datetime
	,@query 			nvarchar(max)
	,@miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@save_dbname			sysname
	,@save_objectname		sysname
	,@save_objecttype		char(2)
	,@save_indexname		sysname
	,@save_last_rundate		datetime
	,@save_intrvl_time_S		bigint
	,@change_flag			char(1)

Declare 
	 @save_database_id		smallint
	,@save_object_id		int
	,@save_index_id			int
	,@save_user_seeks		bigint
	,@save_user_scans		bigint
	,@save_user_lookups		bigint
	,@save_user_updates		bigint
	,@save_last_user_seek		datetime
	,@save_last_user_scan		datetime
	,@save_last_user_lookup		datetime
	,@save_last_user_update		datetime
	,@save_system_seeks		bigint
	,@save_system_scans		bigint
	,@save_system_lookups		bigint
	,@save_system_updates		bigint
	,@save_last_system_seek		datetime
	,@save_last_system_scan		datetime
	,@save_last_system_lookup	datetime
	,@save_last_system_update	datetime
	,@old_user_seeks		bigint
	,@old_user_scans		bigint
	,@old_user_lookups		bigint
	,@old_user_updates		bigint
	,@old_system_seeks		bigint
	,@old_system_scans		bigint
	,@old_system_lookups		bigint
	,@old_system_updates		bigint
	,@diff_user_seeks		bigint
	,@diff_user_scans		bigint
	,@diff_user_lookups		bigint
	,@diff_user_updates		bigint
	,@diff_system_seeks		bigint
	,@diff_system_scans		bigint
	,@diff_system_lookups		bigint
	,@diff_system_updates		bigint


/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  Create temp table
CREATE TABLE #indexwork01 (database_id smallint
		, object_id int
		, index_id int
		, user_seeks bigint
		, user_scans bigint
		, user_lookups bigint
		, user_updates bigint
		, last_user_seek datetime null
		, last_user_scan datetime null
		, last_user_lookup datetime null
		, last_user_update datetime null
		, system_seeks bigint
		, system_scans bigint
		, system_lookups bigint
		, system_updates bigint
		, last_system_seek datetime null
		, last_system_scan datetime null
		, last_system_lookup datetime null
		, last_system_update datetime null
		) 

CREATE UNIQUE CLUSTERED INDEX IX_1 on #indexwork01 (database_id, object_id, index_id)


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
   begin
    raiserror(15002,-1,-1,'dbasp_DMVcapture_Indexusage')
    goto label99
   end


--  Make sure the current and log tables exist
if not exists(select * from sys.objects where name = 'DMV_Indexusage_current' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: DMVcapture_Indexusage failed.  Table dbo.DMV_Indexusage_current does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_Indexusage_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: DMVcapture_Indexusage failed.  Table dbo.DMV_Indexusage_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end


--  Check to see if this data has been captured this hour
If exists (select 1 from dbo.DMV_Indexusage_log where convert(char(13), rundate, 120) = convert(char(13), getdate(), 120))
   begin
	goto label99
   end
Else
   begin
	Print 'Start capture for dbo.DMV_Indexusage_log'
	Print ''
   end



--  Set the interval time in seconds (from the last execution)
Select @save_last_rundate = (select max(rundate) from dbo.DMV_Indexusage_current)
Select @save_intrvl_time_S = DATEDIFF(S, @save_last_rundate, @rundate)
If @save_intrvl_time_S is null
   begin
	Select @save_intrvl_time_S = 0
   end

/****************************************************************
 *                MainLine
 ***************************************************************/

--  Get all the query info related to database objects
Select @query = 'select database_id
	    , object_id
	    , index_id
	    , user_seeks
	    , user_scans
	    , user_lookups
	    , user_updates
	    , last_user_seek
	    , last_user_scan
	    , last_user_lookup
	    , last_user_update
	    , system_seeks
	    , system_scans
	    , system_lookups
	    , system_updates
	    , last_system_seek
	    , last_system_scan
	    , last_system_lookup
	    , last_system_update
FROM  sys.dm_db_index_usage_stats
where database_id > 4
  and object_id > 99
and DATABASEPROPERTYEX (db_name(database_id),''status'') = ''ONLINE'''


INSERT INTO #indexwork01 exec (@query)
--select * from #indexwork01 order by database_id, object_id, index_id
--select count(*) from #indexwork01

delete i 
from #indexwork01 i, dbo.DMV_Indexusage_current d
where i.database_id = d.database_id
  and i.object_id = d.object_id
  and i.index_id = d.index_id
  and i.user_seeks = d.user_seeks
  and i.user_scans = d.user_scans
  and i.user_lookups = d.user_lookups
  and i.user_updates = d.user_updates
  and i.system_seeks = d.system_seeks
  and i.system_scans = d.system_scans
  and i.system_lookups = d.system_lookups
  and i.system_updates = d.system_updates


Print ''
Print 'Index Usage Capture'
select count(*) as rows_to_process from #indexwork01
Print ''


If (select count(*) from #indexwork01) > 0
   begin
	start_01:

	Select @change_flag = 'n'

	--  Get the top row from the query stats
	Select @save_database_id = (select top 1 database_id from #indexwork01 order by database_id)
	Select @save_object_id = (select top 1 object_id from #indexwork01 where database_id = @save_database_id order by object_id)
	Select @save_index_id = (select top 1 index_id from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id order by index_id)

	Select @save_user_seeks = (select user_seeks from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @save_user_scans = (select user_scans from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @save_user_lookups = (select user_lookups from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @save_user_updates = (select user_updates from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @save_system_seeks = (select system_seeks from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @save_system_scans = (select system_scans from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @save_system_lookups = (select system_lookups from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @save_system_updates = (select system_updates from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)

	Select @old_user_seeks = (select user_seeks from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_user_scans = (select user_scans from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_user_lookups = (select user_lookups from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_user_updates = (select user_updates from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_system_seeks = (select system_seeks from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_system_scans = (select system_scans from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_system_lookups = (select system_lookups from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_system_updates = (select system_updates from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)


	--  Get the matching info from the last run
	If exists (select 1 from dbo.DMV_Indexusage_current 
			where database_id = @save_database_id 
			and object_id = @save_object_id 
			and index_id = @save_index_id)
	   begin
		--  See if any of the values have changed
		If @save_user_seeks > @old_user_seeks 
		 or @save_user_scans > @old_user_scans 
		 or @save_user_lookups > @old_user_lookups
		 or @save_user_updates > @old_user_updates
		 or @save_system_seeks > @old_system_seeks
		 or @save_system_scans > @old_system_scans
		 or @save_system_lookups > @old_system_lookups
		 or @save_system_updates > @old_system_updates
		   begin
			Select @change_flag = 'y'

			Select @diff_user_seeks = 0
			Select @diff_user_scans = 0
			Select @diff_user_lookups = 0
			Select @diff_user_updates = 0
			Select @diff_system_seeks = 0
			Select @diff_system_scans = 0
			Select @diff_system_lookups = 0
			Select @diff_system_updates = 0

			If @save_user_seeks > @old_user_seeks
			   begin
				Select @diff_user_seeks = @save_user_seeks - @old_user_seeks
			   end

			If @save_user_scans > @old_user_scans
			   begin
				Select @diff_user_scans = @save_user_scans - @old_user_scans
			   end

			If @save_user_lookups > @old_user_lookups
			   begin
				Select @diff_user_lookups = @save_user_lookups - @old_user_lookups
			   end

			If @save_user_updates > @old_user_updates
			   begin
				Select @diff_user_updates = @save_user_updates - @old_user_updates
			   end

			If @save_system_seeks > @old_system_seeks
			   begin
				Select @diff_system_seeks = @save_system_seeks - @old_system_seeks
			   end

			If @save_system_scans > @old_system_scans
			   begin
				Select @diff_system_scans = @save_system_scans - @old_system_scans
			   end

			If @save_system_lookups > @old_system_lookups
			   begin
				Select @diff_system_lookups = @save_system_lookups - @old_system_lookups
			   end

			If @save_system_updates > @old_system_updates
			   begin
				Select @diff_system_updates = @save_system_updates - @old_system_updates
			   end
		   end
	   end
	Else If @save_user_seeks > 0 
		or @save_user_scans > 0 
		or @save_user_lookups > 0 
		or @save_user_updates > 0 
		or @save_system_seeks > 0 
		or @save_system_scans > 0
		or @save_system_lookups > 0
		or @save_system_updates > 0
	   begin
		Select @change_flag = 'y'
		Select @diff_user_seeks = @save_user_seeks
		Select @diff_user_scans = @save_user_scans
		Select @diff_user_lookups = @save_user_lookups
		Select @diff_user_updates = @save_user_updates
		Select @diff_system_seeks = @save_system_seeks
		Select @diff_system_scans = @save_system_scans
		Select @diff_system_lookups = @save_system_lookups
		Select @diff_system_updates = @save_system_updates
	   end



	If @change_flag = 'y'
	   begin
		Select @save_dbname = (select name from master.sys.databases where database_id = @save_database_id)

		Select @cmd = 'use [' + @save_dbname + '] select @save_objectname = name from sys.objects where object_id = ' + convert(nvarchar(30), @save_object_id)
		EXEC sp_executesql @cmd, N'@save_objectname sysname output', @save_objectname output

		Select @cmd = 'use [' + @save_dbname + '] select @save_objecttype = type from sys.objects where object_id = ' + convert(nvarchar(30), @save_object_id)
		EXEC sp_executesql @cmd, N'@save_objecttype char(2) output', @save_objecttype output

		Select @cmd = 'use [' + @save_dbname + '] select @save_indexname = name from sys.indexes where object_id = ' + convert(nvarchar(30), @save_object_id) + ' and index_id = ' + convert(nvarchar(30), @save_index_id)
		EXEC sp_executesql @cmd, N'@save_indexname sysname output', @save_indexname output

		If @save_indexname is null
		   begin
			Select @cmd = 'use [' + @save_dbname + '] select @save_indexname = type_desc from sys.indexes where object_id = ' + convert(nvarchar(30), @save_object_id) + ' and index_id = ' + convert(nvarchar(30), @save_index_id)
			EXEC sp_executesql @cmd, N'@save_indexname sysname output', @save_indexname output
		   end

		Select @save_last_user_seek = (select last_user_seek from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		Select @save_last_user_scan = (select last_user_scan from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		Select @save_last_user_lookup = (select last_user_lookup from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		Select @save_last_user_update = (select last_user_update from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		Select @save_last_system_seek = (select last_system_seek from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		Select @save_last_system_scan = (select last_system_scan from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		Select @save_last_system_lookup = (select last_system_lookup from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		Select @save_last_system_update = (select last_system_update from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)


		--  Update or insert row in the current table
		If exists (select 1 from dbo.DMV_Indexusage_current where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
		   begin
			Update dbo.DMV_Indexusage_current set rundate = @rundate
						,user_seeks = @save_user_seeks
						,user_scans = @save_user_scans
						,user_lookups = @save_user_lookups
						,user_updates = @save_user_updates
						,system_seeks = @save_system_seeks
						,system_scans = @save_system_scans
						,system_lookups = @save_system_lookups
						,system_updates = @save_system_updates
			where database_id = @save_database_id
			  and object_id= @save_object_id
			  and index_id = @save_index_id
		   end
		Else
		   begin
			INSERT INTO dbo.DMV_Indexusage_current
				Values(@rundate
					,@save_database_id
					,@save_object_id
					,@save_index_id
					,@save_user_seeks
					,@save_user_scans
					,@save_user_lookups
					,@save_user_updates
					,@save_system_seeks
					,@save_system_scans
					,@save_system_lookups
					,@save_system_updates
					)
		   end


		--  insert row into the log table
		INSERT INTO dbo.DMV_Indexusage_log
			Values(@rundate
				,@save_intrvl_time_S
				,@save_dbname
				,@save_objectname
				,@save_objecttype
				,@save_indexname
				,@diff_user_seeks
				,@diff_user_scans
				,@diff_user_lookups
				,@diff_user_updates
				,@save_last_user_seek
				,@save_last_user_scan
				,@save_last_user_lookup
				,@save_last_user_update
				,@diff_system_seeks
				,@diff_system_scans
				,@diff_system_lookups
				,@diff_system_updates
				,@save_last_system_seek
				,@save_last_system_scan
				,@save_last_system_lookup
				,@save_last_system_update
				)
	   end


	--  Delete this row from the temp table and check for more rows to process
	Delete from #indexwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id

	If (select count(*) from #indexwork01) > 0
	   begin
		goto start_01
	   end

   end


--  Remove rows from the current table that no longer exist
delete from dbo.DMV_Indexusage_current where rundate < getdate()-90

--  Purge old rows (90 days)
delete from dbo.DMV_Indexusage_log where rundate < getdate()-90

-----------------  Finalizations  ------------------

label99:


drop table #indexwork01





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_IOwaitstats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_IOwaitstats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_IOwaitstats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_IOwaitstats

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_IOwaitstats                  
 **  Written by Jim Wilson, Getty Images                
 **  April 09, 2007                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/09/2007	Jim Wilson		New process.
--	12/30/2008	Jim Wilson		Loop the data insert process just for ONLINE DB's
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@IOwaits 			nvarchar(max)
	,@miscprint			nvarchar(4000)
	,@save_last_rundate		datetime
	,@save_intrvl_time_S		bigint

Declare 
	 @save_database_id		    smallint
	,@hold_database_id		    smallint
	,@save_object_id		    int
	,@save_index_id			    int
	,@save_page_io_latch_wait_count	    bigint
	,@save_page_io_latch_wait_in_ms	    bigint
	,@save_range_scan_count		    bigint
	,@save_singleton_lookup_count	    bigint
	,@old_page_io_latch_wait_count	    bigint
	,@old_page_io_latch_wait_in_ms	    bigint
	,@old_range_scan_count		    bigint
	,@old_singleton_lookup_count	    bigint
	,@new_page_io_latch_wait_count	    bigint
	,@new_page_io_latch_wait_in_ms	    bigint
	,@new_range_scan_count		    bigint
	,@new_singleton_lookup_count	    bigint


/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  Create temp table

CREATE TABLE #IOwaitwork01 (database_id smallint
			    ,object_id int
			    ,index_id int
			    ,page_io_latch_wait_count bigint
			    ,page_io_latch_wait_in_ms bigint
			    ,range_scan_count bigint
			    ,singleton_lookup_count bigint) 


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
   begin
    raiserror(15002,-1,-1,'dbasp_DMVcapture_IOwaitStats')
    goto label99
   end


--  Make sure the current and log tables exist
if not exists(select * from sys.objects where name = 'DMV_IOwaitStats_current' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_IOwaitStats failed.  Table dbo.DMV_IOwaitStats_current does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_IOwaitStats_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_IOwaitStats failed.  Table dbo.DMV_IOwaitStats_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end


--  Check to see if this data has been captured this hour
If exists (select 1 from dbo.DMV_IOwaitStats_log where convert(char(13), rundate, 120) = convert(char(13), getdate(), 120))
   begin
	goto label99
   end
Else
   begin
	Print 'Start capture for dbo.dbasp_DMVcapture_IOwaitStats'
   end


--  Set the interval time in seconds (from the last execution)
Select @save_last_rundate = (select max(rundate) from dbo.DMV_IOwaitStats_current)
Select @save_intrvl_time_S = DATEDIFF(S, @save_last_rundate, @rundate)



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Loop the inserts for all 'ONLINE' databases
delete from #IOwaitwork01
select @hold_database_id = 0

start_insert01:

select @hold_database_id = (select top 1 database_id from master.sys.databases where state = 0 and database_id > @hold_database_id order by database_id)

--  Get all the IOwait info related to database objects
Select @IOwaits = 'select 
      database_id,
      object_id,
      index_id,
      sum(page_io_latch_wait_count),
      sum(page_io_latch_wait_in_ms),
      sum(range_scan_count),
      sum(singleton_lookup_count)
      from master.sys.dm_db_index_operational_stats(' + convert(nvarchar(10), @hold_database_id) + ', NULL, NULL, NULL)
      where page_io_latch_wait_count > 0
      group by database_id, object_id, index_id'

INSERT INTO #IOwaitwork01 exec (@IOwaits)
--select * from #IOwaitwork01

If exists (select 1 from master.sys.databases where state = 0 and database_id > @hold_database_id)
   begin
	goto start_insert01
   end

--select * from #IOwaitwork01


-- Loop through the IOwaitwork01 rows
If (select count(*) from #IOwaitwork01) > 0
   begin
    start_01:

    --  Get the top row from IOwaitwork01
    Select @save_database_id = (select top 1 database_id from #IOwaitwork01 order by database_id)
    Select @save_object_id = (select top 1 object_id from #IOwaitwork01 where database_id = @save_database_id)
    Select @save_index_id = (select top 1 index_id from #IOwaitwork01 where database_id = @save_database_id and object_id = @save_object_id)
    Select @save_page_io_latch_wait_count = (select page_io_latch_wait_count from #IOwaitwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
    Select @save_page_io_latch_wait_in_ms = (select page_io_latch_wait_in_ms from #IOwaitwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
    Select @save_range_scan_count = (select range_scan_count from #IOwaitwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
    Select @save_singleton_lookup_count = (select singleton_lookup_count from #IOwaitwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
    

    --  Get the matching info from the last run
    If exists (select 1 from dbo.DMV_IOwaitStats_current 
			where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
       begin
	Select @old_page_io_latch_wait_count = (select page_io_latch_wait_count from dbo.DMV_IOwaitStats_current 
								    where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_page_io_latch_wait_in_ms = (select page_io_latch_wait_in_ms from dbo.DMV_IOwaitStats_current 
								    where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_range_scan_count = (select range_scan_count from dbo.DMV_IOwaitStats_current 
								    where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)
	Select @old_singleton_lookup_count = (select singleton_lookup_count from dbo.DMV_IOwaitStats_current 
								    where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id)



	--  Calculate the delta change for this row
	Select @new_page_io_latch_wait_count = Case when @save_page_io_latch_wait_count > @old_page_io_latch_wait_count 
					then @save_page_io_latch_wait_count - @old_page_io_latch_wait_count
					else 0
					end

	Select @new_page_io_latch_wait_in_ms = Case when @save_page_io_latch_wait_in_ms > @old_page_io_latch_wait_in_ms
					then @save_page_io_latch_wait_in_ms - @old_page_io_latch_wait_in_ms
					else 0
					end

	Select @new_range_scan_count = Case when @save_range_scan_count > @old_range_scan_count 
					then @save_range_scan_count - @old_range_scan_count
					else 0
					end

	Select @new_singleton_lookup_count = Case when @save_singleton_lookup_count > @old_singleton_lookup_count 
					then @save_singleton_lookup_count - @old_singleton_lookup_count
					else 0
					end



	--  Save this rows' info 
	If @new_page_io_latch_wait_count > 0
	   begin
	    Insert into dbo.DMV_IOwaitStats_log values(@rundate
					    ,@save_intrvl_time_S
					    ,@save_database_id
					    ,@save_object_id
					    ,@save_index_id
					    ,@new_page_io_latch_wait_count
					    ,@new_page_io_latch_wait_in_ms
					    ,@new_range_scan_count
					    ,@new_singleton_lookup_count)
	   end


	--  Update this row in the "current" table
	UPDATE dbo.DMV_IOwaitStats_current set rundate = @rundate
					    ,page_io_latch_wait_count = @new_page_io_latch_wait_count
					    ,page_io_latch_wait_in_ms = @new_page_io_latch_wait_in_ms
					    ,range_scan_count = @new_range_scan_count
					    ,singleton_lookup_count = @new_singleton_lookup_count
					where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id
       end
    Else
       begin
	INSERT INTO dbo.DMV_IOwaitStats_current values (@rundate
						    ,@save_database_id
						    ,@save_object_id
						    ,@save_index_id
						    ,@new_page_io_latch_wait_count
						    ,@new_page_io_latch_wait_in_ms
						    ,@new_range_scan_count
						    ,@new_singleton_lookup_count)

	Insert into dbo.DMV_IOwaitStats_log values(@rundate
					    ,@save_intrvl_time_S
					    ,@save_database_id
					    ,@save_object_id
					    ,@save_index_id
					    ,@save_page_io_latch_wait_count
					    ,@save_page_io_latch_wait_in_ms
					    ,@save_range_scan_count
					    ,@save_singleton_lookup_count)

       end



    --  Check to see if there are more rows to process
    Delete from #IOwaitwork01 where database_id = @save_database_id and object_id = @save_object_id and index_id = @save_index_id

    If (select count(*) from #IOwaitwork01) > 0
       begin
        goto start_01
       end

   end



--  Remove row from the current table that no longer exist
delete from dbo.DMV_IOwaitStats_current where rundate <> @rundate

--  Purge old rows (90 days)
delete from dbo.DMV_IOwaitStats_log where rundate < getdate()-90

-----------------  Finalizations  ------------------

label99:


drop table #IOwaitwork01



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_memorystats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_memorystats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_memorystats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_memorystats

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_memorystats                  
 **  Written by Jim Wilson, Getty Images                
 **  April 05, 2007                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis.
 **
 **  Note:  This process is set up to capture data hourly
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	04/05/2007	Jim Wilson		New process.
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@miscprint			nvarchar(4000)


/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
	begin
		raiserror(15002,-1,-1,'dbasp_DMVcapture_memorystats')
		goto label99
	end


--  Make sure the log tables exist
if not exists(select * from sys.objects where name = 'DMV_Memory_Objects_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_memorystats failed.  Table dbo.DMV_Memory_Objects_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_Memory_Clerks_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_memorystats failed.  Table dbo.DMV_Memory_Clerks_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end


--  Check to see if this data has been captured this hour
If exists (select 1 from dbo.DMV_Memory_Clerks_log where convert(char(13), rundate, 120) = convert(char(13), getdate(), 120))
   begin
	goto label99
   end
Else
   begin
	Print 'Start capture for dbo.dbasp_DMVcapture_memorystats'
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

Insert into dbo.DMV_Memory_Clerks_log 
	    select @rundate
		,type
		,sum(multi_pages_kb + virtual_memory_committed_kb + shared_memory_committed_kb)
		,sum(multi_pages_kb + virtual_memory_committed_kb + shared_memory_committed_kb + awe_allocated_kb)
		,sum(single_pages_kb)
		,sum(multi_pages_kb)
		,sum(awe_allocated_kb)
		from sys.dm_os_memory_clerks
		group by type


Insert into dbo.DMV_Memory_Objects_log 
	    select @rundate
		,type
		,sum(pages_allocated_count)
		from sys.dm_os_memory_objects
		group by type




--  Delete row older than 90 days
delete from dbo.DMV_Memory_Clerks_log where rundate < getdate()-90
delete from dbo.DMV_Memory_Objects_log where rundate < getdate()-90

-----------------  Finalizations  ------------------


label99:



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_optinfo
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_optinfo]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_optinfo]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_optinfo

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_optinfo                  
 **  Written by Jim Wilson, Getty Images                
 **  March 30, 2007                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	03/30/2007	Jim Wilson		New process.
--	04/02/2007	Jim Wilson		Ignore zero values and capture only once a day.
--	04/04/2007	Jim Wilson		Added check for current and log tables.
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@query 			nvarchar(2000)
	,@miscprint			nvarchar(4000)

Declare 
	 @save_counter			nvarchar(500)
	,@save_occurrence		bigint
	,@save_value			float
	,@old_occurrence		bigint
	,@new_occurrence		bigint


/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
	begin
		raiserror(15002,-1,-1,'dbasp_DMVcapture_optinfo')
		goto label99
	end


--  Make sure the current and log tables exist
if not exists(select * from sys.objects where name = 'DMV_QueryOpt_current' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_optinfo failed.  Table dbo.DMV_QueryOpt_current does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_QueryOpt_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_optinfo failed.  Table dbo.DMV_QueryOpt_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end


--  Check to see if this data has been captured today
If exists (select 1 from dbo.DMV_QueryOpt_log where convert(char(8), rundate, 112) = convert(char(8), getdate(), 112))
   begin
	goto label99
   end
Else
   begin
	Print 'Start capture for master.sys.dm_exec_query_optimizer_info'
   end


--  Create temp table
CREATE TABLE #optstats (counter nvarchar(500)
			,occurrence bigint
			,value float)


/****************************************************************
 *                MainLine
 ***************************************************************/


Select @query = 'select * from master.sys.dm_exec_query_optimizer_info'

INSERT INTO #optstats exec (@query)
--select * from #optstats

delete from #optstats where occurrence = 0
--select * from #optstats


-- Loop through the filestats rows
If (select count(*) from #optstats) > 0
   begin
    start_01:

    --  Get the top row from the current stats
    Select @save_counter = (select top 1 counter from #optstats)
    Select @save_occurrence = (select occurrence from #optstats where counter = @save_counter)
    Select @save_value = (select value from #optstats where counter = @save_counter)


    --  Get the matching info from the last run
    If exists (select 1 from dbo.DMV_QueryOpt_current where counter = @save_counter)
       begin
        Select @old_occurrence = (select occurrence from dbo.DMV_QueryOpt_current where counter = @save_counter)
	--  format the data for the insert
	Select @new_occurrence = Case when @save_occurrence > @old_occurrence 
					then @save_occurrence - @old_occurrence
					else 0
					end


	Insert into dbo.DMV_QueryOpt_log values(@rundate
					    ,@save_counter
					    ,@new_occurrence
					    ,@save_value)			    


	UPDATE dbo.DMV_QueryOpt_current set rundate = @rundate
					,occurrence = @save_occurrence
				    where counter = @save_counter
       end
    Else
       begin
	INSERT INTO dbo.DMV_QueryOpt_current values (@rundate, @save_counter, @save_occurrence)
       end


    --  Check to see if there are more rows to process
    Delete from #optstats where counter = @save_counter
    If (select count(*) from #optstats) > 0
       begin
        goto start_01
       end

   end


delete from dbo.DMV_QueryOpt_current where rundate <> @rundate

delete from dbo.DMV_QueryOpt_log where rundate < getdate()-90

-----------------  Finalizations  ------------------

drop table #optstats

label99:



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_querystats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_querystats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_querystats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_querystats

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_querystats                  
 **  Written by Jim Wilson, Getty Images                
 **  April 03, 2007                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/03/2007	Jim Wilson		New process.
--	04/09/2007	Jim Wilson		Added Daily process (captures once each day).
--	04/18/2007	Jim Wilson		Query text for objects (sprocs) will be the object name.
--	05/25/2007	Jim Wilson		Changed select for dynamic sql to only pick up recent activity.
--	11/20/2008	Jim Wilson		New indexes for temp tables.
--	05/26/2008	Jim Wilson		Added last_execution_time to the where cluase for 
--						the "objectID" related inserts to the temp table.
--	07/17/2009	Jim Wilson		Code for new table DMV_always_track_these_objects. 
--	11/20/2009	Jim Wilson		Removed code for new table DMV_always_track_these_objects. 
--						Added identity columns to temp tables to speed processing.
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@query 			nvarchar(max)
	,@miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@save_dbname			sysname
	,@save_schemaname		sysname
	,@save_schema_id		int
	,@save_objectname		sysname
	,@save_last_rundate		datetime
	,@save_intrvl_time_S		bigint
	,@save_last_daily_rundate	datetime
	,@save_intrvl_daily_time_S	bigint

Declare 
	 @save_dbid			smallint
	,@save_objectid			int
	,@save_qw01_id			int
	,@save_qw02_id			int
	,@save_sql_handle		varbinary(64)
	,@save_plan_handle		varbinary(64)
	,@save_plan_generation_num	bigint
	,@save_statement_start_offset	bigint
	,@save_total_worker_time	bigint
	,@save_total_elapsed_time	bigint
	,@save_total_physical_reads	bigint
	,@save_total_logical_reads	bigint
	,@save_total_logical_writes	bigint
	,@save_execution_count		bigint
	,@save_querytext		nvarchar(max)
	,@save_last_execution_time	datetime
	,@old_qs_id			int
	,@old_total_worker_time		bigint
	,@old_total_elapsed_time	bigint
	,@old_total_physical_reads	bigint
	,@old_total_logical_reads	bigint
	,@old_total_logical_writes	bigint
	,@old_execution_count		bigint
	,@new_total_worker_time		bigint
	,@new_total_elapsed_time	bigint
	,@new_total_physical_reads	bigint
	,@new_total_logical_reads	bigint
	,@new_total_logical_writes	bigint
	,@new_execution_count		bigint


/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  Create temp table

CREATE TABLE #querywork01 (qw01_id int IDENTITY(1,1)
			,last_execution_time datetime
			,sql_handle varbinary(64)
			,plan_handle varbinary(64)
			,plan_generation_num bigint
			,statement_start_offset int
			,total_worker_time bigint
			,total_elapsed_time bigint
			,total_physical_reads bigint
			,total_logical_reads bigint
			,total_logical_writes bigint
			,execution_count bigint
			,dbid smallint null
			,objectid int null
			,querytext  nvarchar(max) null
			) 

CREATE CLUSTERED INDEX IX_01 on #querywork01 (dbid, objectid, qw01_id, sql_handle, plan_handle, plan_generation_num, statement_start_offset)


CREATE TABLE #querywork02 (qw02_id int IDENTITY(1,1)
			,rundate datetime
			,intrvl_time_S bigint
			,dbid smallint
			,objectid int
			,total_worker_time bigint
			,total_elapsed_time bigint
			,total_physical_reads bigint
			,total_logical_reads bigint
			,total_logical_writes bigint
			,execution_count bigint
			,querytext  nvarchar(max) null
			,saveflag char(1)
			) 

CREATE CLUSTERED INDEX IX_02 on #querywork02 (dbid, objectid, qw02_id)


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
   begin
    raiserror(15002,-1,-1,'dbasp_DMVcapture_querystats')
    goto label99
   end


--  Make sure the current and log tables exist
if not exists(select * from sys.objects where name = 'DMV_QueryStats_current' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_querystats failed.  Table dbo.DMV_QueryStats_current does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_QueryStats_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_querystats failed.  Table dbo.DMV_QueryStats_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end


if not exists(select * from sys.objects where name = 'DMV_QueryDaily_current' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_querystats failed.  Table dbo.DMV_QueryDaily_current does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_QueryDaily_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_querystats failed.  Table dbo.DMV_QueryDaily_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end


--  Set the interval time in seconds (from the last execution)
Select @save_last_rundate = (select max(rundate) from dbo.DMV_QueryStats_current)
Select @save_intrvl_time_S = DATEDIFF(S, @save_last_rundate, @rundate)

If @save_last_rundate is null
   begin
	Select @save_last_rundate = getdate()
	Select @save_intrvl_time_S = 1
   end
	


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Get all the query info related to database objects
Select @query = 'SELECT qs.last_execution_time
    ,qs.sql_handle
    ,qs.plan_handle 
    ,qs.plan_generation_num
    ,qs.statement_start_offset
    ,qs.total_worker_time
    ,qs.total_elapsed_time
    ,qs.total_physical_reads
    ,qs.total_logical_reads
    ,qs.total_logical_writes
    ,qs.execution_count
    ,st.dbid 
    ,st.objectid 
    ,null
FROM sys.dm_exec_query_stats AS qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
where st.objectid is not null
and qs.last_execution_time >= ''' + convert(nvarchar(30), @save_last_rundate) + ''''


INSERT INTO #querywork01 exec (@query)
--select * from #querywork01

Delete from #querywork01 where total_worker_time = 0
			and total_elapsed_time = 0
			and total_physical_reads = 0
			and total_logical_reads = 0
			and total_logical_writes = 0
--select * from #querywork01


--  Reset the rundate for rows not exectued since the last delta
UPDATE c set c.rundate = @rundate
	from dbo.DMV_QueryStats_current c, sys.dm_exec_query_stats AS qs
	CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
		where st.objectid is not null
		and c.sql_handle = qs.sql_handle
		and c.plan_handle = qs.plan_handle
		and c.plan_generation_num = qs.plan_generation_num
		and c.statement_start_offset = qs.statement_start_offset
		and c.dbid = st.dbid
		and c.objectid = st.objectid
		and qs.last_execution_time < @save_last_rundate



-- Loop through the querywork01 rows
If (select count(*) from #querywork01) > 0
   begin
    start_01:

    --  Get the top row from the query stats
    Select @save_dbid = (select top 1 dbid from #querywork01 order by dbid)
    Select @save_qw01_id = (select top 1 qw01_id from #querywork01 where dbid = @save_dbid order by qw01_id)
    Select @save_objectid = (select top 1 objectid from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_sql_handle = (select top 1 sql_handle from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_plan_handle = (select top 1 plan_handle from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_plan_generation_num = (select top 1 plan_generation_num from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_statement_start_offset = (select top 1 statement_start_offset from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_last_execution_time = (select top 1 last_execution_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_worker_time = (select total_worker_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_elapsed_time = (select total_elapsed_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_physical_reads = (select total_physical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_reads = (select total_logical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_writes = (select total_logical_writes from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_execution_count = (select execution_count from #querywork01 where qw01_id = @save_qw01_id)

    Select @save_dbname = (select name from master.sys.databases where database_id = @save_dbid)
    Select @cmd = 'use [' + @save_dbname + '] select @save_schema_id = schema_id from sys.objects where object_id = ' + convert(nvarchar(30), @save_objectid)
    EXEC sp_executesql @cmd, N'@save_schema_id int output', @save_schema_id output

    Select @cmd = 'use [' + @save_dbname + '] select @save_schemaname = name from sys.schemas where schema_id = ' + convert(nvarchar(30), @save_schema_id)
    EXEC sp_executesql @cmd, N'@save_schemaname sysname output', @save_schemaname output

    Select @cmd = 'use [' + @save_dbname + '] select @save_objectname = name from sys.objects where object_id = ' + convert(nvarchar(30), @save_objectid)
    EXEC sp_executesql @cmd, N'@save_objectname sysname output', @save_objectname output

    Select @save_querytext = @save_dbname + '.' + @save_schemaname + '.' + @save_objectname


    --  Get the matching info from the last run
    If exists (select 1 from dbo.DMV_QueryStats_current 
			where dbid = @save_dbid 
			and objectid = @save_objectid 
			and sql_handle = @save_sql_handle 
			and plan_handle = @save_plan_handle 
			and plan_generation_num = @save_plan_generation_num 
			and statement_start_offset = @save_statement_start_offset)
       begin
	Select @old_qs_id = (select top 1 qs_id from dbo.DMV_QueryStats_current 
						    where dbid = @save_dbid 
						    and objectid = @save_objectid 
						    and sql_handle = @save_sql_handle 
						    and plan_handle = @save_plan_handle 
						    and plan_generation_num = @save_plan_generation_num 
						    and statement_start_offset = @save_statement_start_offset)

	Select @old_total_worker_time = (select total_worker_time from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_elapsed_time = (select total_elapsed_time from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_physical_reads = (select total_physical_reads from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_logical_reads = (select total_logical_reads from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_logical_writes = (select total_logical_writes from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_execution_count = (select execution_count from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)


	--  Calculate the delta change for this row
	Select @new_total_worker_time = Case when @save_total_worker_time > @old_total_worker_time 
					then @save_total_worker_time - @old_total_worker_time
					else 0
					end

	Select @new_total_elapsed_time = Case when @save_total_elapsed_time > @old_total_elapsed_time
					then @save_total_elapsed_time - @old_total_elapsed_time
					else 0
					end

	Select @new_total_physical_reads = Case when @save_total_physical_reads > @old_total_physical_reads 
					then @save_total_physical_reads - @old_total_physical_reads
					else 0
					end

	Select @new_total_logical_reads = Case when @save_total_logical_reads > @old_total_logical_reads 
					then @save_total_logical_reads - @old_total_logical_reads
					else 0
					end

	Select @new_total_logical_writes = Case when @save_total_logical_writes > @old_total_logical_writes 
					then @save_total_logical_writes - @old_total_logical_writes
					else 0
					end

	Select @new_execution_count = Case when @save_execution_count > @old_execution_count 
					then @save_execution_count - @old_execution_count
					else 0
					end



	--  Save this rows' info in the work02 table (by dbid and objectid)
	If exists (select 1 from #querywork02 where dbid = @save_dbid 
					    and objectid = @save_objectid)
	   begin
	    Update #querywork02 set total_worker_time = total_worker_time + @new_total_worker_time
				    ,total_elapsed_time = total_elapsed_time + @new_total_elapsed_time
				    ,total_physical_reads = total_physical_reads + @new_total_physical_reads
				    ,total_logical_reads = total_logical_reads + @new_total_logical_reads
				    ,total_logical_writes = total_logical_writes + @new_total_logical_writes
				    ,execution_count = execution_count + @new_execution_count
				where dbid = @save_dbid
				and objectid = @save_objectid
	   end
        Else
	   begin
	    Insert into #querywork02 values(@rundate
					    ,@save_intrvl_time_S
					    ,@save_dbid
					    ,@save_objectid
					    ,@new_total_worker_time
					    ,@new_total_elapsed_time
					    ,@new_total_physical_reads
					    ,@new_total_logical_reads
			    		    ,@new_total_logical_writes
					    ,@new_execution_count
					    ,@save_querytext
					    ,'n')
	   end


	--  Update this row in the "current" table
	UPDATE dbo.DMV_QueryStats_current set rundate = @rundate
					    ,total_worker_time = @save_total_worker_time
					    ,total_elapsed_time = @save_total_elapsed_time
					    ,total_physical_reads = @save_total_physical_reads
					    ,total_logical_reads = @save_total_logical_reads
					    ,total_logical_writes = @save_total_logical_writes
					    ,execution_count = @save_execution_count
					where sql_handle = @save_sql_handle
					and plan_handle = @save_plan_handle
					and plan_generation_num = @save_plan_generation_num
					and statement_start_offset = @save_statement_start_offset
					and dbid = @save_dbid
					and objectid = @save_objectid
       end
    Else
       begin
	INSERT INTO dbo.DMV_QueryStats_current values (@rundate
						    ,@save_sql_handle
						    ,@save_plan_handle
						    ,@save_plan_generation_num
						    ,@save_statement_start_offset
						    ,@save_total_worker_time
						    ,@save_total_elapsed_time
						    ,@save_total_physical_reads
						    ,@save_total_logical_reads
						    ,@save_total_logical_writes
						    ,@save_execution_count
						    ,@save_dbid
						    ,@save_objectid)
       end


    skip01:


    --  Check to see if there are more rows to process
    Delete from #querywork01 where qw01_id = @save_qw01_id

    If (select count(*) from #querywork01) > 0
       begin
        goto start_01
       end

   end


--  Mark the rows we want to save from #querywork02
If (select max(total_worker_time) from #querywork02) > 0
   begin
	Update #querywork02 set saveflag = 'y' 
	where total_worker_time in (select top 10 total_worker_time 
					from #querywork02 
					where total_worker_time > 0
					order by total_worker_time desc)
	and saveflag <> 'y'
   end

If (select max(total_elapsed_time) from #querywork02) > 0
   begin
	Update #querywork02 set saveflag = 'y' 
	where total_elapsed_time in (select top 10 total_elapsed_time 
					from #querywork02
					where total_elapsed_time > 0 
					order by total_elapsed_time desc)
	and saveflag <> 'y'
   end

/*
If (select max(total_physical_reads) from #querywork02) > 0
   begin
	Update #querywork02 set saveflag = 'y' 
	where total_physical_reads in (select top 10 total_physical_reads 
					from #querywork02
					where total_physical_reads > 0 
					order by total_physical_reads desc)
	and saveflag <> 'y'
   end

If (select max(total_logical_reads) from #querywork02) > 0
   begin
	Update #querywork02 set saveflag = 'y' 
	where total_logical_reads in (select top 10 total_logical_reads 
					from #querywork02 
					where total_logical_reads > 0
					order by total_logical_reads desc)
	and saveflag <> 'y'
   end

If (select max(total_logical_writes) from #querywork02) > 0
   begin
	Update #querywork02 set saveflag = 'y' 
	where total_logical_writes in (select top 10 total_logical_writes 
					from #querywork02 
					where total_logical_writes > 0
					order by total_logical_writes desc)
	and saveflag <> 'y'
   end
*/

If (select max(execution_count) from #querywork02) > 0
   begin
	Update #querywork02 set saveflag = 'y' 
	where execution_count in (select top 10 execution_count 
					from #querywork02 
					where execution_count > 0
					order by execution_count desc)
	and saveflag <> 'y'
   end

delete from #querywork02 where saveflag = 'n'


-- Insert the saved rows into the log table
If (select count(*) from #querywork02) > 0
  begin
    Select @query = 'Select rundate
			    ,intrvl_time_S
			    ,dbid
			    ,objectid
			    ,total_worker_time
			    ,(total_worker_time/execution_count)/1000.00
			    ,total_elapsed_time
			    ,(total_elapsed_time/execution_count)/1000.00
			    ,total_physical_reads
			    ,total_logical_reads
			    ,(total_logical_reads/execution_count)
			    ,total_logical_writes
			    ,(total_logical_writes/execution_count)
			    ,execution_count
			    ,QueryText
			from #querywork02
			where execution_count <> 0'

    Insert into dbo.DMV_QueryStats_log exec (@query)

   end




----------------------------------------------------
--  Now, process information related to dynamic SQL
----------------------------------------------------

delete from #querywork01
delete from #querywork02

Select @query = 'SELECT qs.last_execution_time
    ,qs.sql_handle
    ,qs.plan_handle 
    ,qs.plan_generation_num
    ,qs.statement_start_offset
    ,qs.total_worker_time
    ,qs.total_elapsed_time
    ,qs.total_physical_reads
    ,qs.total_logical_reads
    ,qs.total_logical_writes
    ,qs.execution_count
    ,st.dbid 
    ,st.objectid 
    ,st.text
FROM sys.dm_exec_query_stats AS qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
where st.objectid is null
  and qs.last_execution_time > ''' + convert(varchar(30), @save_last_rundate, 121) + ''''


INSERT INTO #querywork01 exec (@query)
--select * from #querywork01


Delete from #querywork01 where total_worker_time = 0
			and total_elapsed_time = 0
			and total_physical_reads = 0
			and total_logical_reads = 0
			and total_logical_writes = 0

Delete from #querywork01 where total_elapsed_time < 5000
--select * from #querywork01


-- Loop through the querywork01 rows
If (select count(*) from #querywork01) > 0
   begin
    start_02:
    --  Get the top row from the query stats

    Select @save_sql_handle = (select top 1 sql_handle from #querywork01 order by sql_handle)
    Select @save_qw01_id = (select top 1 qw01_id from #querywork01 where sql_handle = @save_sql_handle order by qw01_id)
    Select @save_plan_handle = (select top 1 plan_handle from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_plan_generation_num = (select top 1 plan_generation_num from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_statement_start_offset = (select top 1 statement_start_offset from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_worker_time = (select total_worker_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_elapsed_time = (select total_elapsed_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_physical_reads = (select total_physical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_reads = (select total_logical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_writes = (select total_logical_writes from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_execution_count = (select execution_count from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_querytext = (select querytext from #querywork01 where qw01_id = @save_qw01_id)

    --  Get the matching info from the last run
    If exists (select 1 from dbo.DMV_QueryStats_current 
			where sql_handle = @save_sql_handle 
			and plan_handle = @save_plan_handle 
			and plan_generation_num = @save_plan_generation_num 
			and statement_start_offset = @save_statement_start_offset)
       begin
	Select @old_qs_id = (select top 1 qs_id from dbo.DMV_QueryStats_current 
						    where sql_handle = @save_sql_handle 
						    and plan_handle = @save_plan_handle 
						    and plan_generation_num = @save_plan_generation_num 
						    and statement_start_offset = @save_statement_start_offset)

	Select @old_total_worker_time = (select total_worker_time from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_elapsed_time = (select total_elapsed_time from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_physical_reads = (select total_physical_reads from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_logical_reads = (select total_logical_reads from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_total_logical_writes = (select total_logical_writes from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)
	Select @old_execution_count = (select execution_count from dbo.DMV_QueryStats_current where qs_id = @old_qs_id)


	--  Calculate the delta change for this row
	Select @new_total_worker_time = Case when @save_total_worker_time > @old_total_worker_time 
					then @save_total_worker_time - @old_total_worker_time
					else 0
					end

	Select @new_total_elapsed_time = Case when @save_total_elapsed_time > @old_total_elapsed_time
					then @save_total_elapsed_time - @old_total_elapsed_time
					else 0
					end

	Select @new_total_physical_reads = Case when @save_total_physical_reads > @old_total_physical_reads 
					then @save_total_physical_reads - @old_total_physical_reads
					else 0
					end

	Select @new_total_logical_reads = Case when @save_total_logical_reads > @old_total_logical_reads 
					then @save_total_logical_reads - @old_total_logical_reads
					else 0
					end

	Select @new_total_logical_writes = Case when @save_total_logical_writes > @old_total_logical_writes 
					then @save_total_logical_writes - @old_total_logical_writes
					else 0
					end

	Select @new_execution_count = Case when @save_execution_count > @old_execution_count 
					then @save_execution_count - @old_execution_count
					else 0
					end



	--  Save this rows' info in the work02 table (by querytext)
	If exists (select 1 from #querywork02 where querytext = @save_querytext)
	   begin
	    Update #querywork02 set total_worker_time = total_worker_time + @new_total_worker_time
				    ,total_elapsed_time = total_elapsed_time + @new_total_elapsed_time
				    ,total_physical_reads = total_physical_reads + @new_total_physical_reads
				    ,total_logical_reads = total_logical_reads + @new_total_logical_reads
				    ,total_logical_writes = total_logical_writes + @new_total_logical_writes
				    ,execution_count = execution_count + @new_execution_count
				where querytext = @save_querytext
	   end
        Else
	   begin
	    Insert into #querywork02 values(@rundate
					    ,@save_intrvl_time_S
					    ,null
					    ,null
					    ,@new_total_worker_time
					    ,@new_total_elapsed_time
					    ,@new_total_physical_reads
					    ,@new_total_logical_reads
			    		    ,@new_total_logical_writes
					    ,@new_execution_count
					    ,@save_querytext
					    ,'n')
	   end


	--  Update this row in the "current" table
	UPDATE dbo.DMV_QueryStats_current set rundate = @rundate
					    ,total_worker_time = @save_total_worker_time
					    ,total_elapsed_time = @save_total_elapsed_time
					    ,total_physical_reads = @save_total_physical_reads
					    ,total_logical_reads = @save_total_logical_reads
					    ,total_logical_writes = @save_total_logical_writes
					    ,execution_count = @save_execution_count
					where sql_handle = @save_sql_handle
					and plan_handle = @save_plan_handle
					and plan_generation_num = @save_plan_generation_num
					and statement_start_offset = @save_statement_start_offset
       end
    Else
       begin
	INSERT INTO dbo.DMV_QueryStats_current values (@rundate
						    ,@save_sql_handle
						    ,@save_plan_handle
						    ,@save_plan_generation_num
						    ,@save_statement_start_offset
						    ,@save_total_worker_time
						    ,@save_total_elapsed_time
						    ,@save_total_physical_reads
						    ,@save_total_logical_reads
						    ,@save_total_logical_writes
						    ,@save_execution_count
						    ,null
						    ,null)
       end


    skip02:

    --  Check to see if there are more rows to process
    Delete from #querywork01 where qw01_id = @save_qw01_id

    If (select count(*) from #querywork01) > 0
       begin
        goto start_02
       end

   end


--  Mark the rows we want to save from #querywork02
delete from #querywork02 where execution_count = 0
delete from #querywork02 where total_worker_time < 5000

If (select max(total_worker_time) from #querywork02) > 0
   begin
    Update #querywork02 set saveflag = 'y' where total_worker_time in (select top 5 total_worker_time 
									from #querywork02 
									where total_worker_time > 0
									order by total_worker_time desc)
   end

If (select max(total_elapsed_time) from #querywork02) > 0
   begin
    Update #querywork02 set saveflag = 'y' where total_elapsed_time in (select top 5 total_elapsed_time 
									from #querywork02
									where total_elapsed_time > 0 
									order by total_elapsed_time desc)
   end


delete from #querywork02 where saveflag = 'n'


-- Insert the saved rows into the log table
If (select count(*) from #querywork02) > 0
  begin
    Select @query = 'Select rundate
			    ,intrvl_time_S
			    ,dbid
			    ,objectid
			    ,total_worker_time
			    ,(total_worker_time/execution_count)/1000.00
			    ,total_elapsed_time
			    ,(total_elapsed_time/execution_count)/1000.00
			    ,total_physical_reads
			    ,total_logical_reads
			    ,(total_logical_reads/execution_count)
			    ,total_logical_writes
			    ,(total_logical_writes/execution_count)
			    ,execution_count
			    ,QueryText
			from #querywork02
			where execution_count <> 0'

    Insert into dbo.DMV_QueryStats_log exec (@query)

   end




----------------------------------------------------------------------------
--  Now, Capture full daily query stats if it hasn't already been done today
----------------------------------------------------------------------------
start_daily:

If exists (select 1 from dbo.DMV_QueryDaily_current where convert(char(8), rundate, 112) = convert(char(8), getdate(), 112))
   begin
	goto end_daily
   end
Else
   begin
    Print 'Start capture for dbo.DMV_QueryDaily_log'
    Select @save_last_daily_rundate = (select max(rundate) from dbo.DMV_QueryDaily_current)
    Select @save_intrvl_daily_time_S = DATEDIFF(S, @save_last_daily_rundate, @rundate)
   end

delete from #querywork01
delete from #querywork02


--  Get all the querys info related to database objects
Select @query = 'SELECT last_execution_time
    ,sql_handle
    ,plan_handle 
    ,plan_generation_num
    ,statement_start_offset
    ,total_worker_time
    ,total_elapsed_time
    ,total_physical_reads
    ,total_logical_reads
    ,total_logical_writes
    ,execution_count
    ,dbid 
    ,objectid 
    ,text
FROM sys.dm_exec_query_stats AS qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
where objectid is not null
and dbid <> 32767'

INSERT INTO #querywork01 exec (@query)
--select * from #querywork01


Delete from #querywork01 where total_worker_time = 0
			and total_elapsed_time = 0
			and total_physical_reads = 0
			and total_logical_reads = 0
			and total_logical_writes = 0
--select * from #querywork01


-- Loop through the querywork01 rows
If (select count(*) from #querywork01) > 0
   begin
    start_03:

    --  Get the top row from the query stats

    Select @save_dbid = (select top 1 dbid from #querywork01 order by dbid)
    Select @save_qw01_id = (select top 1 qw01_id from #querywork01 where dbid = @save_dbid order by qw01_id)
    Select @save_objectid = (select top 1 objectid from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_sql_handle = (select top 1 sql_handle from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_plan_handle = (select top 1 plan_handle from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_plan_generation_num = (select top 1 plan_generation_num from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_statement_start_offset = (select top 1 statement_start_offset from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_last_execution_time = (select top 1 last_execution_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_worker_time = (select total_worker_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_elapsed_time = (select total_elapsed_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_physical_reads = (select total_physical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_reads = (select total_logical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_writes = (select total_logical_writes from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_execution_count = (select execution_count from #querywork01 where qw01_id = @save_qw01_id)

    Select @save_dbname = (select name from master.sys.databases where database_id = @save_dbid)
    Select @cmd = 'use [' + @save_dbname + '] select @save_schema_id = schema_id from sys.objects where object_id = ' + convert(nvarchar(30), @save_objectid)
    EXEC sp_executesql @cmd, N'@save_schema_id int output', @save_schema_id output

    Select @cmd = 'use [' + @save_dbname + '] select @save_schemaname = name from sys.schemas where schema_id = ' + convert(nvarchar(30), @save_schema_id)
    EXEC sp_executesql @cmd, N'@save_schemaname sysname output', @save_schemaname output

    Select @cmd = 'use [' + @save_dbname + '] select @save_objectname = name from sys.objects where object_id = ' + convert(nvarchar(30), @save_objectid)
    EXEC sp_executesql @cmd, N'@save_objectname sysname output', @save_objectname output

    Select @save_querytext = @save_dbname + '.' + @save_schemaname + '.' + @save_objectname


    --  Get the matching info from the last run
    If exists (select 1 from dbo.DMV_QueryDaily_current 
			where dbid = @save_dbid 
			and objectid = @save_objectid 
			and sql_handle = @save_sql_handle 
			and plan_handle = @save_plan_handle 
			and plan_generation_num = @save_plan_generation_num 
			and statement_start_offset = @save_statement_start_offset)
       begin
	Select @old_qs_id = (select top 1 qs_id from dbo.DMV_QueryStats_current 
							where dbid = @save_dbid 
							and objectid = @save_objectid 
							and sql_handle = @save_sql_handle 
							and plan_handle = @save_plan_handle 
							and plan_generation_num = @save_plan_generation_num 
							and statement_start_offset = @save_statement_start_offset)

	Select @old_total_worker_time = (select total_worker_time from dbo.DMV_QueryDaily_current where qs_id = @old_qs_id)
	Select @old_total_elapsed_time = (select total_elapsed_time from dbo.DMV_QueryDaily_current where qs_id = @old_qs_id)
	Select @old_total_physical_reads = (select total_physical_reads from dbo.DMV_QueryDaily_current where qs_id = @old_qs_id)
	Select @old_total_logical_reads = (select total_logical_reads from dbo.DMV_QueryDaily_current where qs_id = @old_qs_id)
	Select @old_total_logical_writes = (select total_logical_writes from dbo.DMV_QueryDaily_current where qs_id = @old_qs_id)
	Select @old_execution_count = (select execution_count from dbo.DMV_QueryDaily_current where qs_id = @old_qs_id)


	--  Calculate the delta change for this row
	Select @new_total_worker_time = Case when @save_total_worker_time > @old_total_worker_time 
					then @save_total_worker_time - @old_total_worker_time
					else 0
					end

	Select @new_total_elapsed_time = Case when @save_total_elapsed_time > @old_total_elapsed_time
					then @save_total_elapsed_time - @old_total_elapsed_time
					else 0
					end

	Select @new_total_physical_reads = Case when @save_total_physical_reads > @old_total_physical_reads 
					then @save_total_physical_reads - @old_total_physical_reads
					else 0
					end

	Select @new_total_logical_reads = Case when @save_total_logical_reads > @old_total_logical_reads 
					then @save_total_logical_reads - @old_total_logical_reads
					else 0
					end

	Select @new_total_logical_writes = Case when @save_total_logical_writes > @old_total_logical_writes 
					then @save_total_logical_writes - @old_total_logical_writes
					else 0
					end

	Select @new_execution_count = Case when @save_execution_count > @old_execution_count 
					then @save_execution_count - @old_execution_count
					else 0
					end



	--  Save this rows' info in the work02 table (by dbid and objectid)
	If exists (select 1 from #querywork02 where dbid = @save_dbid 
					    and objectid = @save_objectid)
	   begin
	    Update #querywork02 set total_worker_time = total_worker_time + @new_total_worker_time
				    ,total_elapsed_time = total_elapsed_time + @new_total_elapsed_time
				    ,total_physical_reads = total_physical_reads + @new_total_physical_reads
				    ,total_logical_reads = total_logical_reads + @new_total_logical_reads
				    ,total_logical_writes = total_logical_writes + @new_total_logical_writes
				    ,execution_count = execution_count + @new_execution_count
				where dbid = @save_dbid
				and objectid = @save_objectid
	   end
        Else
	   begin
	    Insert into #querywork02 values(@rundate
					    ,@save_intrvl_daily_time_S
					    ,@save_dbid
					    ,@save_objectid
					    ,@new_total_worker_time
					    ,@new_total_elapsed_time
					    ,@new_total_physical_reads
					    ,@new_total_logical_reads
			    		    ,@new_total_logical_writes
					    ,@new_execution_count
					    ,@save_querytext
					    ,'n')
	   end


	--  Update this row in the "current" table
	UPDATE dbo.DMV_QueryDaily_current set rundate = @rundate
					    ,total_worker_time = @save_total_worker_time
					    ,total_elapsed_time = @save_total_elapsed_time
					    ,total_physical_reads = @save_total_physical_reads
					    ,total_logical_reads = @save_total_logical_reads
					    ,total_logical_writes = @save_total_logical_writes
					    ,execution_count = @save_execution_count
					where sql_handle = @save_sql_handle
					and plan_handle = @save_plan_handle
					and plan_generation_num = @save_plan_generation_num
					and statement_start_offset = @save_statement_start_offset
					and dbid = @save_dbid
					and objectid = @save_objectid
       end
    Else
       begin
	--  Save this rows' info in the work02 table (by dbid and objectid)
	If exists (select 1 from #querywork02 where dbid = @save_dbid 
					    and objectid = @save_objectid)
	   begin
	    Update #querywork02 set total_worker_time = total_worker_time + @save_total_worker_time
				    ,total_elapsed_time = total_elapsed_time + @save_total_elapsed_time
				    ,total_physical_reads = total_physical_reads + @save_total_physical_reads
				    ,total_logical_reads = total_logical_reads + @save_total_logical_reads
				    ,total_logical_writes = total_logical_writes + @save_total_logical_writes
				    ,execution_count = execution_count + @save_execution_count
				where dbid = @save_dbid
				and objectid = @save_objectid
	   end
        Else
	   begin
	    Insert into #querywork02 values(@rundate
					    ,@save_intrvl_daily_time_S
					    ,@save_dbid
					    ,@save_objectid
					    ,@save_total_worker_time
					    ,@save_total_elapsed_time
					    ,@save_total_physical_reads
					    ,@save_total_logical_reads
			    		    ,@save_total_logical_writes
					    ,@save_execution_count
					    ,@save_querytext
					    ,'n')
	   end

	--  Insert this row into the "current" table
	INSERT INTO dbo.DMV_QueryDaily_current values (@rundate
						    ,@save_sql_handle
						    ,@save_plan_handle
						    ,@save_plan_generation_num
						    ,@save_statement_start_offset
						    ,@save_total_worker_time
						    ,@save_total_elapsed_time
						    ,@save_total_physical_reads
						    ,@save_total_logical_reads
						    ,@save_total_logical_writes
						    ,@save_execution_count
						    ,@save_dbid
						    ,@save_objectid)
       end


    skip03:


    --  Check to see if there are more rows to process
    Delete from #querywork01 where qw01_id = @save_qw01_id

    If (select count(*) from #querywork01) > 0
       begin
        goto start_03
       end

   end



-- Insert the rows into the log table
If (select count(*) from #querywork02) > 0
  begin
    Select @query = 'Select rundate
			    ,intrvl_time_S
			    ,dbid
			    ,objectid
			    ,total_worker_time
			    ,(total_worker_time/execution_count)/1000.00
			    ,total_elapsed_time
			    ,(total_elapsed_time/execution_count)/1000.00
			    ,total_physical_reads
			    ,total_logical_reads
			    ,(total_logical_reads/execution_count)
			    ,total_logical_writes
			    ,(total_logical_writes/execution_count)
			    ,execution_count
			    ,QueryText
			from #querywork02
			where execution_count <> 0'

    Insert into dbo.DMV_QueryDaily_log exec (@query)

   end


--  Remove rows from the current Daily table that no longer exist
delete from dbo.DMV_QueryDaily_current where rundate <> @rundate

--  Purge old rows (90 days)
delete from dbo.DMV_QueryDaily_log where rundate < getdate()-90

end_daily:



--  Remove rows from the current table that no longer exist
delete from dbo.DMV_QueryStats_current where rundate <> @rundate

--  Purge old rows (90 days)
delete from dbo.DMV_QueryStats_log where rundate < getdate()-90

-----------------  Finalizations  ------------------

label99:

drop table #querywork01
drop table #querywork02




 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_spclsprocstats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_spclsprocstats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_spclsprocstats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_spclsprocstats

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_spclsprocstats                  
 **  Written by Jim Wilson, Getty Images                
 **  November 20, 2009                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis for designated user sprocs.
 ***************************************************************/
  as

set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/20/2009	Jim Wilson		New process (cloned from querystats).
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@query 			nvarchar(max)
	,@miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@save_dbname			sysname
	,@save_schemaname		sysname
	,@save_schema_id		int
	,@save_objectname		sysname
	,@save_last_rundate		datetime
	,@save_intrvl_time_S		bigint

Declare 
	 @save_dbid			smallint
	,@save_objectid			int
	,@save_qw01_id			int
	,@save_sql_handle		varbinary(64)
	,@save_plan_handle		varbinary(64)
	,@save_plan_generation_num	bigint
	,@save_statement_start_offset	bigint
	,@save_total_worker_time	bigint
	,@save_total_elapsed_time	bigint
	,@save_total_physical_reads	bigint
	,@save_total_logical_reads	bigint
	,@save_total_logical_writes	bigint
	,@save_execution_count		bigint
	,@save_querytext		nvarchar(max)
	,@save_last_execution_time	datetime
	,@old_qs_id			int
	,@old_total_worker_time		bigint
	,@old_total_elapsed_time	bigint
	,@old_total_physical_reads	bigint
	,@old_total_logical_reads	bigint
	,@old_total_logical_writes	bigint
	,@old_execution_count		bigint
	,@new_total_worker_time		bigint
	,@new_total_elapsed_time	bigint
	,@new_total_physical_reads	bigint
	,@new_total_logical_reads	bigint
	,@new_total_logical_writes	bigint
	,@new_execution_count		bigint


/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  Create temp table

CREATE TABLE #querywork01 (qw01_id int IDENTITY(1,1)
			,last_execution_time datetime
			,sql_handle varbinary(64)
			,plan_handle varbinary(64)
			,plan_generation_num bigint
			,statement_start_offset int
			,total_worker_time bigint
			,total_elapsed_time bigint
			,total_physical_reads bigint
			,total_logical_reads bigint
			,total_logical_writes bigint
			,execution_count bigint
			,dbid smallint null
			,objectid int null
			,querytext  nvarchar(max) null
			) 

CREATE CLUSTERED INDEX IX_01 on #querywork01 (dbid, objectid, qw01_id, sql_handle, plan_handle, plan_generation_num, statement_start_offset)


CREATE TABLE #querywork02 (qw02_id int IDENTITY(1,1)
			,rundate datetime
			,intrvl_time_S bigint
			,dbid smallint
			,objectid int
			,total_worker_time bigint
			,total_elapsed_time bigint
			,total_physical_reads bigint
			,total_logical_reads bigint
			,total_logical_writes bigint
			,execution_count bigint
			,querytext  nvarchar(max) null
			,saveflag char(1)
			) 

CREATE CLUSTERED INDEX IX_02 on #querywork02 (dbid, objectid, qw02_id)




--  If there are no designated objects to track, skip this process
If (select count(*) from dbo.DMV_always_track_these_objects) = 0
   begin
	goto label99
   end


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
   begin
    raiserror(15002,-1,-1,'dbasp_DMVcapture_spclsprocstats')
    goto label99
   end


--  Make sure the current and log tables exist
if not exists(select * from sys.objects where name = 'DMV_spclsprocstats_current' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_spclsprocstats failed.  Table dbo.DMV_spclsprocstats_current does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_spclsprocstats_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_spclsprocstats failed.  Table dbo.DMV_spclsprocstats_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end



--  Set the interval time in seconds (from the last execution)
Select @save_last_rundate = (select max(rundate) from dbo.DMV_spclsprocstats_current)
Select @save_intrvl_time_S = DATEDIFF(S, @save_last_rundate, @rundate)

If @save_last_rundate is null
   begin
	Select @save_last_rundate = getdate()
	Select @save_intrvl_time_S = 1
   end

	


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Get all the query info related to database objects
Select @query = 'SELECT qs.last_execution_time
    ,qs.sql_handle
    ,qs.plan_handle 
    ,qs.plan_generation_num
    ,qs.statement_start_offset
    ,qs.total_worker_time
    ,qs.total_elapsed_time
    ,qs.total_physical_reads
    ,qs.total_logical_reads
    ,qs.total_logical_writes
    ,qs.execution_count
    ,st.dbid 
    ,st.objectid 
    ,null
FROM sys.dm_exec_query_stats AS qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
where st.objectid is not null
and qs.last_execution_time >= ''' + convert(nvarchar(30), @save_last_rundate) + ''''


INSERT INTO #querywork01 exec (@query)
--select count(*) from #querywork01


delete from #querywork01
where qw01_id not in (select qw01_id 
			from #querywork01 q, dbo.DMV_always_track_these_objects d
			where q.dbid = DB_ID(d.DBname)
			and q.objectid = OBJECT_ID(d.ObjectName)
			)
--select * from #querywork01




--  Reset the rundate for rows not exectued since the last delta
UPDATE c set c.rundate = @rundate
	from dbo.DMV_spclsprocstats_current c, sys.dm_exec_query_stats AS qs
	CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
		where st.objectid is not null
		and c.sql_handle = qs.sql_handle
		and c.plan_handle = qs.plan_handle
		and c.plan_generation_num = qs.plan_generation_num
		and c.statement_start_offset = qs.statement_start_offset
		and c.dbid = st.dbid
		and c.objectid = st.objectid
		and qs.last_execution_time < @save_last_rundate



-- Loop through the querywork01 rows
If (select count(*) from #querywork01) > 0
   begin
    start_01:

    --  Get the top row from the query stats
    Select @save_dbid = (select top 1 dbid from #querywork01 order by dbid)
    Select @save_qw01_id = (select top 1 qw01_id from #querywork01 where dbid = @save_dbid order by qw01_id)
    Select @save_objectid = (select top 1 objectid from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_sql_handle = (select top 1 sql_handle from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_plan_handle = (select top 1 plan_handle from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_plan_generation_num = (select top 1 plan_generation_num from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_statement_start_offset = (select top 1 statement_start_offset from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_last_execution_time = (select top 1 last_execution_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_worker_time = (select total_worker_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_elapsed_time = (select total_elapsed_time from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_physical_reads = (select total_physical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_reads = (select total_logical_reads from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_total_logical_writes = (select total_logical_writes from #querywork01 where qw01_id = @save_qw01_id)
    Select @save_execution_count = (select execution_count from #querywork01 where qw01_id = @save_qw01_id)

    Select @save_dbname = (select name from master.sys.databases where database_id = @save_dbid)
    Select @cmd = 'use [' + @save_dbname + '] select @save_schema_id = schema_id from sys.objects where object_id = ' + convert(nvarchar(30), @save_objectid)
    EXEC sp_executesql @cmd, N'@save_schema_id int output', @save_schema_id output

    Select @cmd = 'use [' + @save_dbname + '] select @save_schemaname = name from sys.schemas where schema_id = ' + convert(nvarchar(30), @save_schema_id)
    EXEC sp_executesql @cmd, N'@save_schemaname sysname output', @save_schemaname output

    Select @cmd = 'use [' + @save_dbname + '] select @save_objectname = name from sys.objects where object_id = ' + convert(nvarchar(30), @save_objectid)
    EXEC sp_executesql @cmd, N'@save_objectname sysname output', @save_objectname output

    Select @save_querytext = @save_dbname + '.' + @save_schemaname + '.' + @save_objectname


    --  Get the matching info from the last run
    If exists (select 1 from dbo.DMV_spclsprocstats_current 
			where dbid = @save_dbid 
			and objectid = @save_objectid 
			and sql_handle = @save_sql_handle 
			and plan_handle = @save_plan_handle 
			and plan_generation_num = @save_plan_generation_num 
			and statement_start_offset = @save_statement_start_offset)
       begin
	Select @old_qs_id = (select top 1 qs_id from dbo.DMV_spclsprocstats_current 
						    where dbid = @save_dbid 
						    and objectid = @save_objectid 
						    and sql_handle = @save_sql_handle 
						    and plan_handle = @save_plan_handle 
						    and plan_generation_num = @save_plan_generation_num 
						    and statement_start_offset = @save_statement_start_offset)

	Select @old_total_worker_time = (select total_worker_time from dbo.DMV_spclsprocstats_current where qs_id = @old_qs_id)
	Select @old_total_elapsed_time = (select total_elapsed_time from dbo.DMV_spclsprocstats_current where qs_id = @old_qs_id)
	Select @old_total_physical_reads = (select total_physical_reads from dbo.DMV_spclsprocstats_current where qs_id = @old_qs_id)
	Select @old_total_logical_reads = (select total_logical_reads from dbo.DMV_spclsprocstats_current where qs_id = @old_qs_id)
	Select @old_total_logical_writes = (select total_logical_writes from dbo.DMV_spclsprocstats_current where qs_id = @old_qs_id)
	Select @old_execution_count = (select execution_count from dbo.DMV_spclsprocstats_current where qs_id = @old_qs_id)


	--  Calculate the delta change for this row
	Select @new_total_worker_time = Case when @save_total_worker_time > @old_total_worker_time 
					then @save_total_worker_time - @old_total_worker_time
					else 0
					end

	Select @new_total_elapsed_time = Case when @save_total_elapsed_time > @old_total_elapsed_time
					then @save_total_elapsed_time - @old_total_elapsed_time
					else 0
					end

	Select @new_total_physical_reads = Case when @save_total_physical_reads > @old_total_physical_reads 
					then @save_total_physical_reads - @old_total_physical_reads
					else 0
					end

	Select @new_total_logical_reads = Case when @save_total_logical_reads > @old_total_logical_reads 
					then @save_total_logical_reads - @old_total_logical_reads
					else 0
					end

	Select @new_total_logical_writes = Case when @save_total_logical_writes > @old_total_logical_writes 
					then @save_total_logical_writes - @old_total_logical_writes
					else 0
					end

	Select @new_execution_count = Case when @save_execution_count > @old_execution_count 
					then @save_execution_count - @old_execution_count
					else 0
					end



	--  Save this rows' info in the work02 table (by dbid and objectid)
	If exists (select 1 from #querywork02 where dbid = @save_dbid 
					    and objectid = @save_objectid)
	   begin
	    Update #querywork02 set total_worker_time = total_worker_time + @new_total_worker_time
				    ,total_elapsed_time = total_elapsed_time + @new_total_elapsed_time
				    ,total_physical_reads = total_physical_reads + @new_total_physical_reads
				    ,total_logical_reads = total_logical_reads + @new_total_logical_reads
				    ,total_logical_writes = total_logical_writes + @new_total_logical_writes
				    ,execution_count = execution_count + @new_execution_count
				where dbid = @save_dbid
				and objectid = @save_objectid
	   end
        Else
	   begin
	    Insert into #querywork02 values(@rundate
					    ,@save_intrvl_time_S
					    ,@save_dbid
					    ,@save_objectid
					    ,@new_total_worker_time
					    ,@new_total_elapsed_time
					    ,@new_total_physical_reads
					    ,@new_total_logical_reads
			    		    ,@new_total_logical_writes
					    ,@new_execution_count
					    ,@save_querytext
					    ,'y')
	   end


	--  Update this row in the "current" table
	UPDATE dbo.DMV_spclsprocstats_current set rundate = @rundate
					    ,total_worker_time = @save_total_worker_time
					    ,total_elapsed_time = @save_total_elapsed_time
					    ,total_physical_reads = @save_total_physical_reads
					    ,total_logical_reads = @save_total_logical_reads
					    ,total_logical_writes = @save_total_logical_writes
					    ,execution_count = @save_execution_count
					where sql_handle = @save_sql_handle
					and plan_handle = @save_plan_handle
					and plan_generation_num = @save_plan_generation_num
					and statement_start_offset = @save_statement_start_offset
					and dbid = @save_dbid
					and objectid = @save_objectid
       end
    Else
       begin
	INSERT INTO dbo.DMV_spclsprocstats_current values (@rundate
						    ,@save_sql_handle
						    ,@save_plan_handle
						    ,@save_plan_generation_num
						    ,@save_statement_start_offset
						    ,@save_total_worker_time
						    ,@save_total_elapsed_time
						    ,@save_total_physical_reads
						    ,@save_total_logical_reads
						    ,@save_total_logical_writes
						    ,@save_execution_count
						    ,@save_dbid
						    ,@save_objectid)
       end


    skip01:


    --  Check to see if there are more rows to process
    Delete from #querywork01 where qw01_id = @save_qw01_id

    If (select count(*) from #querywork01) > 0
       begin
        goto start_01
       end

   end



-- Insert the saved rows into the log table
If (select count(*) from #querywork02) > 0
  begin
    Select @query = 'Select rundate
			    ,intrvl_time_S
			    ,dbid
			    ,objectid
			    ,total_worker_time
			    ,(total_worker_time/execution_count)/1000.00
			    ,total_elapsed_time
			    ,(total_elapsed_time/execution_count)/1000.00
			    ,total_physical_reads
			    ,total_logical_reads
			    ,(total_logical_reads/execution_count)
			    ,total_logical_writes
			    ,(total_logical_writes/execution_count)
			    ,execution_count
			    ,QueryText
			from #querywork02
			where execution_count <> 0'

    Insert into dbo.DMV_spclsprocstats_log exec (@query)

   end






--  Remove rows from the current table that no longer exist
delete from dbo.DMV_spclsprocstats_current where rundate <> @rundate

--  Purge old rows (90 days)
delete from dbo.DMV_spclsprocstats_log where rundate < getdate()-90

-----------------  Finalizations  ------------------

label99:

drop table #querywork01
drop table #querywork02




 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_DMVcapture_waitstats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_DMVcapture_waitstats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_DMVcapture_waitstats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_DMVcapture_waitstats

/*********************************************************
 **  Stored Procedure dbasp_DMVcapture_waitstats                  
 **  Written by Jim Wilson, Getty Images                
 **  April 06, 2007                                      
 **  
 **  This dbasp is set up to capture statistical information
 **  for performance and problem analysis.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/06/2007	Jim Wilson		New process.
--	======================================================================================

-----------------  declares  ------------------

Declare 
	 @rundate			datetime
	,@waits 			nvarchar(max)
	,@miscprint			nvarchar(4000)
	,@save_last_rundate		datetime
	,@save_intrvl_time_S		bigint

Declare 
	 @save_wait_type		nvarchar(60)
	,@save_waiting_tasks_count	bigint
	,@save_wait_time_ms		bigint
	,@save_max_wait_time_ms		bigint
	,@save_signal_wait_time_ms	bigint
	,@old_waiting_tasks_count	bigint
	,@old_wait_time_ms		bigint
	,@old_max_wait_time_ms		bigint
	,@old_signal_wait_time_ms	bigint
	,@new_waiting_tasks_count	bigint
	,@new_wait_time_ms		bigint
	,@new_max_wait_time_ms		bigint
	,@new_signal_wait_time_ms	bigint



/*********************************************************************
 *                Initialization
 ********************************************************************/

select @rundate = getdate()


--  Create temp table

CREATE TABLE #waitswork01 (wait_type nvarchar(60)
			,waiting_tasks_count bigint
			,wait_time_ms bigint
			,max_wait_time_ms bigint
			,signal_wait_time_ms bigint
			) 


--  If we're in a transaction, disallow this since it might make recovery impossible.
set implicit_transactions off
if @@trancount > 0
   begin
    raiserror(15002,-1,-1,'dbasp_DMVcapture_WaitStats')
    goto label99
   end


--  Make sure the current and log tables exist
if not exists(select * from sys.objects where name = 'DMV_WaitStats_current' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_WaitStats failed.  Table dbo.DMV_WaitStats_current does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end
	

if not exists(select * from sys.objects where name = 'DMV_WaitStats_log' and type = 'U')
   begin
    Select @miscprint = 'DBA Error: dbasp_DMVcapture_WaitStats failed.  Table dbo.DMV_WaitStats_log does not exist'
    Print @miscprint
    raiserror(67016, 16, -1, @miscprint)
    goto label99
   end



--  Set the interval time in seconds (from the last execution)
Select @save_last_rundate = (select max(rundate) from dbo.DMV_WaitStats_current)
Select @save_intrvl_time_S = DATEDIFF(S, @save_last_rundate, @rundate)


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Get all the waits info related to database objects
Select @waits = 'SELECT wait_type
	    ,waiting_tasks_count
	    ,wait_time_ms
	    ,max_wait_time_ms
	    ,signal_wait_time_ms
FROM sys.dm_os_wait_stats
where waiting_tasks_count > 0'

INSERT INTO #waitswork01 exec (@waits)
--select * from #waitswork01


-- Loop through the waitswork01 rows
If (select count(*) from #waitswork01) > 0
   begin
    start_01:

    --  Get the top row from waitswork01
    Select @save_wait_type = (select top 1 wait_type from #waitswork01 order by wait_type)
    Select @save_waiting_tasks_count = (select waiting_tasks_count from #waitswork01 where wait_type = @save_wait_type)
    Select @save_wait_time_ms = (select wait_time_ms from #waitswork01 where wait_type = @save_wait_type)
    Select @save_max_wait_time_ms = (select max_wait_time_ms from #waitswork01 where wait_type = @save_wait_type)
    Select @save_signal_wait_time_ms = (select signal_wait_time_ms from #waitswork01 where wait_type = @save_wait_type)
    

    --  Get the matching info from the last run
    If exists (select 1 from dbo.DMV_WaitStats_current 
			where wait_type = @save_wait_type)
       begin
	Select @old_waiting_tasks_count = (select waiting_tasks_count from dbo.DMV_WaitStats_current 
								    where wait_type = @save_wait_type)
	Select @old_wait_time_ms = (select wait_time_ms from dbo.DMV_WaitStats_current 
								    where wait_type = @save_wait_type)
	Select @old_max_wait_time_ms = (select max_wait_time_ms from dbo.DMV_WaitStats_current 
								    where wait_type = @save_wait_type)
	Select @old_signal_wait_time_ms = (select signal_wait_time_ms from dbo.DMV_WaitStats_current 
								    where wait_type = @save_wait_type)



	--  Calculate the delta change for this row
	Select @new_waiting_tasks_count = Case when @save_waiting_tasks_count > @old_waiting_tasks_count 
					then @save_waiting_tasks_count - @old_waiting_tasks_count
					else 0
					end

	Select @new_wait_time_ms = Case when @save_wait_time_ms > @old_wait_time_ms
					then @save_wait_time_ms - @old_wait_time_ms
					else 0
					end

	Select @new_max_wait_time_ms = Case when @save_max_wait_time_ms > @old_max_wait_time_ms 
					then @save_max_wait_time_ms - @old_max_wait_time_ms
					else 0
					end

	Select @new_signal_wait_time_ms = Case when @save_signal_wait_time_ms > @old_signal_wait_time_ms 
					then @save_signal_wait_time_ms - @old_signal_wait_time_ms
					else 0
					end



	--  Save this rows' info 
	If @new_waiting_tasks_count > 0
	or @new_wait_time_ms > 0
	or @new_max_wait_time_ms > 0
	or @new_signal_wait_time_ms > 0
	   begin
	    Insert into dbo.DMV_WaitStats_log values(@rundate
					    ,@save_intrvl_time_S
					    ,@save_wait_type
					    ,@new_waiting_tasks_count
					    ,@new_wait_time_ms
					    ,@new_max_wait_time_ms
					    ,@new_signal_wait_time_ms)
	   end


	--  Update this row in the "current" table
	UPDATE dbo.DMV_WaitStats_current set rundate = @rundate
					    ,waiting_tasks_count = @save_waiting_tasks_count
					    ,wait_time_ms = @save_wait_time_ms
					    ,max_wait_time_ms = @save_max_wait_time_ms
					    ,signal_wait_time_ms = @save_signal_wait_time_ms
					where wait_type = @save_wait_type
       end
    Else
       begin
	INSERT INTO dbo.DMV_WaitStats_current values (@rundate
						    ,@save_wait_type
						    ,@save_waiting_tasks_count
						    ,@save_wait_time_ms
						    ,@save_max_wait_time_ms
						    ,@save_signal_wait_time_ms)

	Insert into dbo.DMV_WaitStats_log values(@rundate
					    ,@save_intrvl_time_S
					    ,@save_wait_type
					    ,@save_waiting_tasks_count
					    ,@save_wait_time_ms
					    ,@save_max_wait_time_ms
					    ,@save_signal_wait_time_ms)

       end



    --  Check to see if there are more rows to process
    Delete from #waitswork01 where wait_type = @save_wait_type

    If (select count(*) from #waitswork01) > 0
       begin
        goto start_01
       end

   end



--  Remove row from the current table that no longer exist
delete from dbo.DMV_WaitStats_current where rundate <> @rundate

--  Purge old rows (90 days)
delete from dbo.DMV_WaitStats_log where rundate < getdate()-90

-----------------  Finalizations  ------------------

label99:


drop table #waitswork01



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_extract_db_stats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_extract_db_stats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_extract_db_stats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_extract_db_stats

/*********************************************************
 **  Stored Procedure dbasp_extract_db_stats                  
 **  Written by Jim Wilson, Getty Images                
 **  April 17, 2000                                      
 **  
 **  This sql member is set up to extract data and log usage
 **  information.  Records from this process will be inserted
 **  into the 'db_stats_log' and 'fixeddisk_stats_log' tables in
 **  the database dbaadmin.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	07/29/2002	Jim Wilson		Check DB status prior to DBCC updateusage.
--	09/26/2002	Jim Wilson		Shortened long lines to 255
--	12/06/2006	Jim Wilson		Updated for SQL 2005.
--	08/07/2007	Jim Wilson		Updated for read-only DB's.
--	02/11/2008	Jim Wilson		Added skip for DB's not online.
--	07/14/2009	Jim Wilson		Added raiserror with nowait and disabled dbcc updateusage.
--	======================================================================================


-----------------  declares  ------------------
DECLARE
	 @miscprint		varchar(255)
	,@cmd			nvarchar(4000)
	,@CU10flag		smallint
	,@bytesperpage		dec(15,0)
	,@pagesperMB		dec(15,0)
	,@Uselogpct		char(5)
	,@dbsize		bigint
	,@logsize		bigint
	,@reservedpages		bigint
	,@usedpages		bigint 
	,@pages			bigint
	,@save_database_size	varchar(18)
	,@save_unalloc_space	varchar(18)
	,@save_reserved		varchar(18)
	,@save_data		varchar(18)
	,@save_index_size	varchar(18)
	,@save_unused		varchar(18)
	,@save_log_size		varchar(18)
	,@save_log_space_used	varchar(18)  
    
DECLARE
	 @cu10DRIVEname		varchar(30)
	,@cu10DRIVEfree		int

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint


DECLARE
	 @Save_Srvname		sysname
	,@Save_DBName		sysname
	,@Save_date		datetime
	,@Save_Drive01name	char(10)
	,@Save_Drive01free	int
	,@Save_Drive02name	char(10)
	,@Save_Drive02free	int
	,@Save_Drive03name	char(10)
	,@Save_Drive03free	int
	,@Save_Drive04name	char(10)
	,@Save_Drive04free	int
	,@Save_Drive05name	char(10)
	,@Save_Drive05free	int
	,@Save_Drive06name	char(10)
	,@Save_Drive06free	int
	,@Save_Drive07name	char(10)
	,@Save_Drive07free	int
	,@Save_Drive08name	char(10)
	,@Save_Drive08free	int

----------------  initial values  -------------------

select @bytesperpage = low from master.dbo.spt_values where number = 1 and type = 'E'
select @pagesperMB = 1048576 / @bytesperpage
Select @Save_Srvname = @@servername 
Select @Save_date    = getdate() 
Select @Uselogpct  = ' 0.00'

--  Create temp tables
create table #diskspace(drive char(1) null , space int null)
create table #sqlperf (dbname sysname
		    ,logsize float
		    ,logspace float
		    ,status smallint
		    )


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Purge process  ----------------------------------------------------------------

Delete from dbaadmin.dbo.db_stats_log where rundate < (dateadd(year, -2, getdate()))

Delete from dbaadmin.dbo.fixeddisk_stats_log where rundate < (dateadd(year, -2, getdate()))


--  Capture logspace info
Select @cmd = 'dbcc sqlperf(logspace)'
insert into #sqlperf EXEC (@cmd)



--  Start Disk Info Capture  ------------------------------------------------------

----------------------  load drive info table  ----------------------
insert into #diskspace exec master.sys.xp_fixeddrives


--------------------  Cursor 10  -----------------------
EXECUTE('DECLARE cursor_10DRIVEspace Insensitive Cursor For ' + 
  'SELECT d.drive, d.space 
   From #diskspace d ')

OPEN cursor_10DRIVEspace

Select @CU10flag = 0

WHILE (10=10)
   Begin
	FETCH Next From cursor_10DRIVEspace Into @cu10DRIVEname, @cu10DRIVEfree 
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_10DRIVEspace
	      BREAK
           end

	Select @CU10flag = @CU10flag + 1

	If @CU10flag = 1
	   begin
	     select @Save_Drive01name = @cu10DRIVEname
	     select @Save_Drive01free = @cu10DRIVEfree
	   end	
	Else If @CU10flag = 2
	   begin
	     select @Save_Drive02name = @cu10DRIVEname
	     select @Save_Drive02free = @cu10DRIVEfree
	   end	
	Else If @CU10flag = 3
	   begin
	     select @Save_Drive03name = @cu10DRIVEname
	     select @Save_Drive03free = @cu10DRIVEfree
	   end	
	Else If @CU10flag = 4
	   begin
	     select @Save_Drive04name = @cu10DRIVEname
	     select @Save_Drive04free = @cu10DRIVEfree
	   end	
	Else If @CU10flag = 5
	   begin
	     select @Save_Drive05name = @cu10DRIVEname
	     select @Save_Drive05free = @cu10DRIVEfree
	   end	
	Else If @CU10flag = 6
	   begin
	     select @Save_Drive06name = @cu10DRIVEname
	     select @Save_Drive06free = @cu10DRIVEfree
	   end	
	Else If @CU10flag = 7
	   begin
	     select @Save_Drive07name = @cu10DRIVEname
	     select @Save_Drive07free = @cu10DRIVEfree
	   end	
	Else If @CU10flag = 8
	   begin
	     select @Save_Drive08name = @cu10DRIVEname
	     select @Save_Drive08free = @cu10DRIVEfree
	   end	


End  -- loop 10
DEALLOCATE cursor_10DRIVEspace

---------------------------  Insert disk info  -----------------------
Insert dbaadmin.dbo.fixeddisk_stats_log
	   values (@Save_Srvname,@Save_Date,@Save_Drive01name,@Save_Drive01free,@Save_Drive02name,@Save_Drive02free,
			@Save_Drive03name,@Save_Drive03free,@Save_Drive04name,@Save_Drive04free,@Save_Drive05name,
			@Save_Drive05free,@Save_Drive06name,@Save_Drive06free,@Save_Drive07name,@Save_Drive07free,
			@Save_Drive08name,@Save_Drive08free)  



--  Start DB Info Capture  --------------------------------------------------------

--------------------  Cursor 11  -----------------------
EXECUTE('DECLARE cursor_11DBNames Insensitive Cursor For ' + 
  'SELECT d.name, d.database_id
   From master.sys.databases   d ' + 
  'Where d.name not in (''model'')
   Order By d.name For Read Only')


OPEN cursor_11DBNames

WHILE (11=11)
   Begin
	FETCH Next From cursor_11DBNames Into @cu11DBName, @cu11DBId
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11DBNames
	      BREAK
           end

    Select @Save_DBName = @cu11DBName


    if (SELECT DATABASEPROPERTYEX (@Save_DBName,'status')) <> 'ONLINE'
       begin
        goto skip_11
       end


    --  Updateusage
--    If (DATABASEPROPERTY(@cu11DBName, 'IsReadOnly') <> 1)
--       begin
--	Select @cmd = 'use [' + @cu11DBName + '] dbcc updateusage(0) with no_infomsgs'
--	Print @cmd
--	raiserror('', -1,-1) with nowait
--	exec (@cmd)
--       end

    Select @cmd = 'use [' + @cu11DBName + '] select @dbsize = sum(convert(bigint,case when status & 64 = 0 then size else 0 end)) from dbo.sysfiles'
    Print @cmd
    raiserror('', -1,-1) with nowait
    EXEC sp_executesql @cmd, N'@dbsize bigint output', @dbsize output


    Select @cmd = 'use [' + @cu11DBName + '] select @logsize = sum(convert(bigint,case when status & 64 <> 0 then size else 0 end)) from dbo.sysfiles'
    Print @cmd
    raiserror('', -1,-1) with nowait
    EXEC sp_executesql @cmd, N'@logsize bigint output', @logsize output


    Select @cmd = 'use [' + @cu11DBName + '] Select @reservedpages = sum(a.total_pages) from sys.partitions p join sys.allocation_units a on p.partition_id = a.container_id
						left join sys.internal_tables it on p.object_id = it.object_id'
    Print @cmd
    raiserror('', -1,-1) with nowait
    EXEC sp_executesql @cmd, N'@reservedpages bigint output', @reservedpages output



    Select @cmd = 'use [' + @cu11DBName + '] Select @usedpages = sum(a.used_pages) from sys.partitions p join sys.allocation_units a on p.partition_id = a.container_id
						left join sys.internal_tables it on p.object_id = it.object_id'
    Print @cmd
    raiserror('', -1,-1) with nowait
    EXEC sp_executesql @cmd, N'@usedpages bigint output', @usedpages output


    Select @cmd = 'use [' + @cu11DBName + '] Select @pages = sum(CASE
						-- XML-Index and FT-Index-Docid is not considered "data", but is part of "index_size"
						When it.internal_type IN (202,204) Then 0
						When a.type <> 1 Then a.used_pages
						When p.index_id < 2 Then a.data_pages
						Else 0
						END)
					from sys.partitions p join sys.allocation_units a on p.partition_id = a.container_id
					left join sys.internal_tables it on p.object_id = it.object_id'
    Print @cmd
    raiserror('', -1,-1) with nowait
    EXEC sp_executesql @cmd, N'@pages bigint output', @pages output



    Select @save_database_size = ltrim(str((convert (dec (15,2),@dbsize) + convert (dec (15,2),@logsize)) * 8192 / 1048576,15,2))

    Select @save_unalloc_space = ltrim(str((case when @dbsize >= @reservedpages then
			(convert (dec (15,2),@dbsize) - convert (dec (15,2),@reservedpages)) 
			* 8192 / 1048576 else 0 end),15,2))


    Select @save_reserved = ltrim(str(@reservedpages * 8192 / 1024.,15,0))
    Select @save_data = ltrim(str(@pages * 8192 / 1024.,15,0))
    Select @save_index_size = ltrim(str((@usedpages - @pages) * 8192 / 1024.,15,0))
    Select @save_unused = ltrim(str((@reservedpages - @usedpages) * 8192 / 1024.,15,0))

    Select @save_log_size = (select ltrim(str(logsize,15,3)) from #sqlperf where dbname = @Save_DBName)
    Select @save_log_space_used = (select ltrim(str(logspace,15,3)) from #sqlperf where dbname = @Save_DBName)


    Insert dbaadmin.dbo.db_stats_log
	   values (@Save_Srvname
		    ,@Save_DBName
		    ,@Save_Date
		    ,@save_database_size
		    ,@save_unalloc_space
		    ,@save_reserved
		    ,@save_data
		    ,@save_index_size
		    ,@Save_unused
		    ,@save_log_size
		    ,@save_log_space_used)  



skip_11:

End  -- loop 11
DEALLOCATE cursor_11DBNames


---------------------------  Finalization  -----------------------

drop table #diskspace
drop table #sqlperf


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_extract_table_stats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_extract_table_stats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_extract_table_stats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_extract_table_stats

/**************************************************************
 **  Stored Procedure dbasp_extract_table_stats                  
 **  Written by Jim Wilson, Getty Images                
 **  June 21, 2001                                      
 **  
 **  This dbasp is set up to extract table related stats and
 **  insert the information into the dbaadmin..table_stats_log table.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	02/03/2003	Jim Wilson		Added server parm to OSQL stmt.
--	04/21/2005	Jim Wilson		Major revision.  Removed cursors.  DBCC Showcontig
--						is now with tableresults.
--	08/29/2004	Jim Wilson		Added brackets around dbname variable in DBCC showcontig stmt.
--	12/05/2006	Jim Wilson		Converted for SQL 2005.
--	12/06/2006	Jim Wilson		Added purge process (2 year retention)
--	06/25/2007	Jim Wilson		Added schema name to sp_spaceused command
--	02/11/2008	Jim Wilson		Added skip for DB's not online.
--	08/04/2008	Jim Wilson		Added brackets for table names with spaces.
--	11/05/2008	Jim Wilson		Fixed bug with DBname capture.
--	08/27/2009	Jim Wilson		Fixed bug with duplicate results in the index section.
--	10/26/2009	Jim Wilson		Added nolock to avoid deadlocks.
--	04/06/2010	Jim Wilson		Removed processing for tables and indexes with zero rows.
--	======================================================================================


DECLARE
	 @miscprint				nvarchar(4000)
	,@query					nvarchar(4000)
	,@cmd					nvarchar(4000)
	,@save_object_id			int
	,@save_object_name			sysname 
	,@save_index_id				int
	,@save_partition_number			int
	,@save_index_type_desc			nvarchar (60)
	,@save_alloc_unit_type_desc		nvarchar (60)
	,@save_index_depth			tinyint
	,@save_index_level			tinyint
	,@save_avg_fragmentation_in_percent	float
	,@save_fragment_count			bigint
	,@save_avg_fragment_size_in_pages	float
	,@save_page_count			bigint
	,@save_avg_page_space_used_in_percent	float
	,@save_record_count			bigint
	,@save_ghost_record_count		bigint
	,@save_version_ghost_record_count	bigint
	,@save_min_record_size_in_bytes		int
	,@save_max_record_size_in_bytes		int
	,@save_avg_record_size_in_bytes		float
	,@save_forwarded_record_count		bigint
	,@save_reserved_space			varchar(18)
	,@save_data_space_used			varchar(18)
	,@save_index_size_used			varchar(18)
	,@save_unused_space			varchar(18)
	,@save_fullTBLname			sysname

DECLARE
	 @cu11DBName			sysname
	,@cu11DBId			smallint

DECLARE
	 @cu22TBLname			sysname
	,@cu22rows			bigint
	,@cu22rowmodctr			int
	,@cu22SCHname			sysname


----------------  initial values  -------------------

--  Create table variable
declare @dbnames table	(name		sysname
			,dbid		smallint
			)

create table #tables (TBLname sysname not null
			,TBLrows bigint not null
			,TBLrowmodctr int not null
			,SCHname sysname not null)


CREATE TABLE #index_data (
	[database_id] [smallint] NOT NULL ,
	[object_id] [int] NOT NULL ,
	[index_id] [int] NOT NULL ,
	[partition_number] [int] NOT NULL ,
	[index_type_desc] [nvarchar] (60) NOT NULL ,
	[alloc_unit_type_desc] [nvarchar] (60) NOT NULL ,
	[index_depth] [tinyint] NULL ,
	[index_level] [tinyint] NULL ,
	[avg_fragmentation_in_percent] [float] NULL ,
	[fragment_count] [bigint] NULL ,
	[avg_fragment_size_in_pages] [float] NULL ,
	[page_count] [bigint] NULL ,
	[avg_page_space_used_in_percent] [float] NULL ,
	[record_count] [bigint] NULL ,
	[ghost_record_count] [bigint] NULL ,
	[version_ghost_record_count] [bigint] NULL ,
	[min_record_size_in_bytes] [int] NULL ,
	[max_record_size_in_bytes] [int] NULL ,
	[avg_record_size_in_bytes] [float] NULL ,
	[forwarded_record_count] [bigint] NULL)

Create Table #spused (
	[name] [sysname] NOT NULL ,
	[rows] [char] (11) NULL ,
	[reserved] [varchar] (18) NULL ,
	[data] [varchar] (18) NULL ,
	[index_size] [varchar] (18) NULL ,
	[unused] [varchar] (18) NULL)


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Purge process  ----------------------------------------------------------------
Delete from dbaadmin.dbo.table_stats_log where rundate < (dateadd(year, -2, getdate()))

Delete from dbaadmin.dbo.index_stats_log where rundate < (dateadd(year, -2, getdate()))


--------------------  Capture DB names  -------------------
Insert into @dbnames (name, dbid)
SELECT d.name, d.database_id
From master.sys.databases d with (NOLOCK) 
Where d.name not in ('master', 'model', 'msdb', 'tempdb')


delete from @dbnames where name is null or name = ''
--select * from @dbnames


If (select count(*) from @dbnames) > 0
   begin
	start_dbnames:

	Select @cu11DBName = (select top 1 name from @dbnames)
	Select @cu11DBId = dbid from @dbnames where name = @cu11DBName

	If (SELECT DATABASEPROPERTYEX (@cu11DBName,'status')) <> 'ONLINE'
	   begin
		goto skip_db
	   end

	Print ' '
	Print ' '
	Print 'Start Database: ' + @cu11DBName + '  ' + convert(varchar(30),getdate(),9)
	Print '------------------------------------------------'
	raiserror('', -1,-1) with nowait

	
	--------------------  Capture table info  -----------------------
	delete from #tables
	
	Select @query = 'SELECT o.name, i.rowcnt, i.rowmodctr, s.name
	   From [' + @cu11DBName + '].sys.objects  o with (NOLOCK), [' + @cu11DBName + '].sys.sysindexes  i, [' + @cu11DBName + '].sys.schemas  s with (NOLOCK)
	   Where i.id = o.object_id
	      and o.type = ''u''
	     and i.indid in (0,1)
	     and i.rowcnt > 0
	     and o.parent_object_id = 0
	     and o.schema_id = s.schema_id
	     and o.name <> ''dtproperties''
	   Order By o.name, i.indid'

	insert into #tables exec (@query)
	--Select * from #tables

	If (select count(*) from #tables) > 0
	   begin
		start_tables:

		Select @cu22TBLname = (select top 1 TBLname from #tables)
		Select @cu22rows = TBLrows from #tables where TBLname = @cu22TBLname
		Select @cu22rowmodctr = TBLrowmodctr from #tables where TBLname = @cu22TBLname
		Select @cu22SCHname = SCHname from #tables where TBLname = @cu22TBLname

		
		Select @cmd = 'exec [' + @cu11DBName + '].sys.sp_executesql N''insert #spused exec sys.sp_spaceused ''''[' + @cu22SCHname + '].[' + @cu22TBLname + ']''''''';
		--print @cmd
		Delete from #spused
		EXEC (@cmd)


		If (select count(*) from #spused) > 0
		   begin
		    Select @save_reserved_space = (select top 1 reserved from #spused)
		    Select @save_data_space_used = (select top 1 data from #spused)
		    Select @save_index_size_used = (select top 1 index_size from #spused)
		    Select @save_unused_space = (select top 1 unused from #spused)
		   end

		Select @save_fullTBLname = @cu22SCHname + '.' + @cu22TBLname

		If not exists (select * from dbaadmin.dbo.table_stats_log where dbname = @cu11DBName and tblname = @save_fullTBLname and rows = @cu22rows and rowmodctr = @cu22rowmodctr and rundate > getdate()-1)
		   begin
			Print 'Processing table: ' + @cu22TBLname
			raiserror('', -1,-1) with nowait
			INSERT INTO dbaadmin.dbo.table_stats_log (rundate
								,DBName
								,TBLname
								,rows
								,rowmodctr
								,reserved_space
								,data_space_used
								,index_size_used
								,unused_space
								)
			VALUES 			(getdate()
						,@cu11DBName
						,@save_fullTBLname
						,@cu22rows
						,@cu22rowmodctr
						,@save_reserved_space
						,@save_data_space_used
						,@save_index_size_used
						,@save_unused_space
						)
		   end


		--  Remove this record from #tables and go to the next
		end_tables:
		delete from #tables where TBLname = @cu22TBLname and SCHname = @cu22SCHname
		If (select count(*) from #tables) > 0
		   begin
			goto start_tables
		   end


		--------------------  Capture Index info  -----------------------
		Print ''
		Print 'Start Capture Index Section: ' + @cu11DBName + '  ' + convert(varchar(30),getdate(),9)
		Print '------------------------------------------------'
		raiserror('', -1,-1) with nowait
		
		delete from #index_data
		
		Select @query = 'SELECT * from sys.dm_db_index_physical_stats (' + convert(varchar(10), @cu11DBId) + ', null, null, null, ''SAMPLED'')'  
	
		insert into #index_data exec (@query)
		delete from #index_data where record_count = 0
		--Select * from #index_data

		If (select count(*) from #index_data) > 0
		   begin
			start_indexes:

			Select @save_object_id = (select top 1 object_id from #index_data order by object_id)

			Select @cmd = 'USE ' + quotename(@cu11DBName) + ' SELECT @save_object_name = name from sys.objects with (NOLOCK) where object_id = ' + convert(nvarchar(20), @save_object_id)
			EXEC sp_executesql @cmd, N'@save_object_name sysname output', @save_object_name output
			Print 'Processing index: ' + @save_object_name
			raiserror('', -1,-1) with nowait

			Select @save_index_id = (select top 1 index_id from #index_data where object_id = @save_object_id order by index_id)
			Select @save_partition_number = (select top 1 partition_number from #index_data where object_id = @save_object_id and index_id = @save_index_id order by partition_number)
			Select @save_index_type_desc = (select top 1 index_type_desc from #index_data  where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number order by index_type_desc, alloc_unit_type_desc)
			Select @save_alloc_unit_type_desc = (select top 1 alloc_unit_type_desc from #index_data  where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc order by alloc_unit_type_desc)
			Select @save_partition_number = (select partition_number from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_index_depth = (select index_depth from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_index_level = (select index_level from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_avg_fragmentation_in_percent = (select avg_fragmentation_in_percent from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_fragment_count = (select fragment_count from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_avg_fragment_size_in_pages = (select avg_fragment_size_in_pages from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_page_count = (select page_count from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_avg_page_space_used_in_percent = (select avg_page_space_used_in_percent from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_record_count = (select record_count from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_ghost_record_count = (select ghost_record_count from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_version_ghost_record_count = (select version_ghost_record_count from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_min_record_size_in_bytes = (select min_record_size_in_bytes from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_max_record_size_in_bytes = (select max_record_size_in_bytes from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_avg_record_size_in_bytes = (select avg_record_size_in_bytes from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
			Select @save_forwarded_record_count = (select forwarded_record_count from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)


			INSERT INTO dbaadmin.dbo.index_stats_log (rundate
								,dbname
								,tblname
								,index_id
								,partition_number
								,index_type_desc
								,alloc_unit_type_desc
								,index_depth
								,index_level
								,avg_fragmentation_in_percent
								,fragment_count
								,avg_fragment_size_in_pages
								,page_count
								,avg_page_space_used_in_percent
								,record_count
								,ghost_record_count
								,version_ghost_record_count
								,min_record_size_in_bytes
								,max_record_size_in_bytes
								,avg_record_size_in_bytes
								,forwarded_record_count
								)
			VALUES 			(getdate()
						,@cu11DBName
						,@save_object_name
						,@save_index_id
						,@save_partition_number
						,@save_index_type_desc
						,@save_alloc_unit_type_desc
						,@save_index_depth
						,@save_index_level
						,@save_avg_fragmentation_in_percent
						,@save_fragment_count
						,@save_avg_fragment_size_in_pages
						,@save_page_count
						,@save_avg_page_space_used_in_percent
						,@save_record_count
						,@save_ghost_record_count
						,@save_version_ghost_record_count
						,@save_min_record_size_in_bytes
						,@save_max_record_size_in_bytes
						,@save_avg_record_size_in_bytes
						,@save_forwarded_record_count	
						)
			Select @save_page_count = (select page_count from #index_data where object_id = @save_object_id and index_id = @save_index_id and partition_number = @save_partition_number and index_type_desc = @save_index_type_desc and alloc_unit_type_desc = @save_alloc_unit_type_desc)
    
			--  Remove this record from #indexes and go to the next
			delete from #index_data where object_id = @save_object_id 
						and index_id = @save_index_id 
						and index_type_desc = @save_index_type_desc 
						and alloc_unit_type_desc = @save_alloc_unit_type_desc 
			If (select count(*) from #index_data) > 0
			   begin
				goto start_indexes
			   end
		   end
	   end


	skip_db:


	--  Remove this record from @dbname and go to the next
	delete from @dbnames where name = @cu11DBName
	If (select count(*) from @dbnames) > 0
	   begin
		goto start_dbnames
	   end
   end

---------------------------  Finalization  -----------------------
label99:


if (object_id('tempdb..#tables') is not null)
   begin
	drop table #tables
   end

if (object_id('tempdb..#index_data') is not null)
   begin
	drop table #index_data
   end

if (object_id('tempdb..#spused') is not null)
   begin
	drop table #spused
   end


 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_File_Transit
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_File_Transit]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_File_Transit]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_File_Transit (@source_name sysname = null
				,@source_path nvarchar(500) = null
				,@target_env sysname = null
				,@target_server sysname = null
				,@target_share sysname = null
				,@retry_limit smallint = 5)

/*********************************************************
 **  Stored Procedure dbasp_File_Transit                  
 **  Written by Jim Wilson, Getty Images                
 **  August 01, 2005                                      
 **  
 **  This procedure is used for copying files and folders from one Domain
 **  to another where there is no trust relationship.
 **
 **  This proc accepts the following input parms:
 **  - @source_name is the name of the source file or folder.
 **  - @source_path is the path where files are being copied from.
 **  - @target_env is the environment where files are being copied to.
 **  - @target_server is the server where files need to be copied to.
 **  - @target_share is the share name where files need to be copied to.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/14/2005	Jim Wilson		New process
--	10/11/2007	Jim Wilson		Added ability to transit to share sub folders.
--	09/16/2008	Jim Wilson		seafresqldba02 to seafresqldba01.
--	09/15/2009	Jim Wilson		Convert sqldeployer04 to seafresqldba01.
--	03/16/2010	Jim Wilson		Changed central server sqldeployer04 to sqldeployer05.
--	======================================================================================


/***
Declare @source_name nvarchar(500)
Declare @source_path nvarchar(500)
Declare @target_env sysname
Declare @target_server sysname
Declare @target_share nvarchar(500)
Declare @retry_limit smallint

select @source_name = 'aaatest.txt'
--select @source_name = 'weekly_defrag.txt'
Select @source_path = '\\seafresqldba01\seafresqldba01_contrib_prod_drop'
Select @target_env = 'production'
Select @target_server = 'seadcaspsqla'
Select @target_share = 'seadcaspsqla$a_contrib_upload'
Select @retry_limit = 5
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@error_count		int
	,@cmd	 		nvarchar(4000)
	,@retcode 		int
	,@filecount		smallint
	,@filename_wild		nvarchar(500)
	,@file_type		nvarchar(10)
	,@charpos		int
	,@savefilename		nvarchar(500)
	,@hold_filedate		nvarchar(12)
	,@save_filedate		nvarchar(12)
	,@save_filedate2	nvarchar(20)
	,@save_fileYYYY		nvarchar(4)
	,@save_fileMM		nvarchar(2)
	,@save_fileDD		nvarchar(2)
	,@save_fileHH		nvarchar(2)
	,@save_fileMN		nvarchar(2)
	,@save_fileAMPM		nvarchar(1)
	,@retry_counter		smallint
	,@save_domain_name	sysname
	,@save_central_server	sysname
	,@save_newname		nvarchar(500)
	,@save_fullpath		nvarchar(500)
	,@save_depart_path	nvarchar(500)
	
DECLARE
	 @cu11cmdoutput		nvarchar(255)



----------------  initial values  -------------------
Select @error_count = 0
select @save_domain_name = env_detail from dbo.Local_ServerEnviro where env_type = 'domain'

select @save_central_server = env_detail from dbo.Local_ServerEnviro where env_type = 'CentralServer'
If @save_central_server = 'sqldeployer05'
   begin
	select @save_central_server = 'seafresqldba01'
   end

Select @save_depart_path = '\\' + rtrim(@save_central_server) + '\' + 'Station_' + rtrim(@save_domain_name) + '_Depart'


create table #DirectoryTempTable(cmdoutput nvarchar(500) null)

create table #fileexists ( 
	doesexist smallint,
	fileindir smallint,
	direxist smallint)


--  Check input parms
if @source_name is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit.  @source_name is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @source_path is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit.  @source_path is required' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_env is null or @target_env not in ('production', 'stage', 'amer')
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. @target_env is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_server is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. @target_server is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_share is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. @target_share is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


--  Verify source path existance
Insert into #fileexists exec master.sys.xp_fileexist @source_path
--select * from #fileexists

If not exists (select 1 from #fileexists where fileindir = 1)
   begin
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit - Source Path does not exist.  Check input parameter.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end

--  Verify source file existance
Delete from #fileexists
Select @save_fullpath = rtrim(@source_path) + '\' + rtrim(@source_name)
Insert into #fileexists exec master.sys.xp_fileexist @save_fullpath
select * from #fileexists

If (select top 1 doesexist from #fileexists) = 0 and (select top 1 fileindir from #fileexists) = 0
   begin
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit - Source File does not exist.  Check input parameter.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
  end

--  Set file type (file or folder)
If (select top 1 doesexist from #fileexists) = 0 and (select top 1 fileindir from #fileexists) = 1
   begin
	Select @file_type = 'folder'
   end
Else 
   begin
	Select @file_type = 'file'
   end


--  Make sure the file does not alreay exist at the station depart folder
Delete from #fileexists
Select @save_fullpath = rtrim(@save_depart_path) + '\' + rtrim(@source_name)
Insert into #fileexists exec master.sys.xp_fileexist @save_fullpath
--select * from #fileexists

If (select top 1 doesexist from #fileexists) = 1 or (select top 1 fileindir from #fileexists) = 1
   begin
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit - File already exists in the central depart folder.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
  end


Select @target_share = replace(@target_share, '\', '_f_')

Delete from #fileexists
Select @save_newname = rtrim(@target_env) + '_x_' + rtrim(@target_server) + '_y_' + rtrim(@target_share) + '_z_' + rtrim(@source_name)
Select @save_fullpath = rtrim(@save_depart_path) + '\' + rtrim(@save_newname)
Insert into #fileexists exec master.sys.xp_fileexist @save_fullpath
--select * from #fileexists

If (select top 1 doesexist from #fileexists) = 1 or (select top 1 fileindir from #fileexists) = 1
   begin
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit - Renamed File already exists in the central Depart folder.' 
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
  end



/****************************************************************
 *                MainLine
 ***************************************************************/


If @file_type = 'folder'
   begin
	-- create the folder at the target location
	Select @cmd = 'mkdir "' + rtrim(@save_depart_path) + '\' + rtrim(@source_name) + '"'
	Print @cmd
	EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

	select @cmd = 'robocopy /Z /E /R:3 "' + rtrim(@source_path) + '\' + rtrim(@source_name) + '" "' + rtrim(@save_depart_path) + '\' + rtrim(@source_name) + '" "*.*"'
	Print @cmd
	EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
	print @retcode

	Select @cmd = 'ren "' + rtrim(@save_depart_path) + '\' + rtrim(@source_name) + '" "' + @save_newname + '"'
	Print @cmd
	EXEC @retcode = master.sys.xp_cmdshell @cmd, no_output
	print @retcode
   end
Else
   begin
	select @cmd = 'robocopy /Z /R:3 "' + rtrim(@source_path) + '" "' + rtrim(@save_depart_path) + '" "' + rtrim(@source_name) + '"'
	Print @cmd
	EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
	print @retcode

	Select @cmd = 'ren "' + rtrim(@save_depart_path) + '\' + rtrim(@source_name) + '" "' + @save_newname + '"'
	Print @cmd
	EXEC @retcode = master.sys.xp_cmdshell @cmd, no_output
	print @retcode
   end



-------------------   end   --------------------------

label99:


drop table #DirectoryTempTable
drop table #fileexists





If @error_count > 0
   begin
	raiserror(@miscprint,-1,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_File_Transit_Event
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_File_Transit_Event]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_File_Transit_Event]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_File_Transit_Event (@target_env sysname = null
				,@target_server sysname = null
				,@target_SQLserver sysname = null
				,@Fail_replyto sysname = 'tssqldba@gettyimages.com'
				,@SQLcode nvarchar(max) = '')

/*********************************************************
 **  Stored Procedure dbasp_File_Transit_Event                  
 **  Written by Jim Wilson, Getty Images                
 **  September 26, 2008                                      
 **  
 **  This procedure is used to create an action event from one Domain
 **  to another where there is no trust relationship.  This will
 **  create and output file (*.act) that will be copied to the target
 **  domain and processed by the central SQL server in that domain.
 **
 **  This proc accepts the following input parms:
 **  - @target_env is the environment where the action event will take place.
 **  - @target_server is the server the action is intended for.
 **  - @target_SQLserver is SQL server the the action is intended for.
 **  - @Fail_replyto is the email address the process will reply to if the target server is unavailable.
 **  - @SQLcode is the code to be executed as the action event (start job, etc.).
 ***************************************************************/
  as
  SET NOCOUNT ON

--	=====================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/26/2008	Jim Wilson		New process
--	09/15/2009	Jim Wilson		Convert sqldeployer04 to seafresqldba01.
--	03/16/2010	Jim Wilson		Changed central server sqldeployer04 to sqldeployer05.
--	=====================================================================================


/***
Declare @target_env sysname
Declare @target_server sysname
Declare @target_SQLserver sysname
Declare @Fail_replyto sysname
Declare @SQLcode nvarchar(max)

Select @target_env = 'production'
Select @target_server = 'g1sqla'
Select @target_SQLserver = 'g1sqla$a'
Select @Fail_replyto = 'tssqldba@gettyimages.com'
Select @SQLcode = 'use master 
exec sp_who2
go

--comments

xp_fixeddrives
go'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@error_count		int
	,@cmd	 		nvarchar(4000)
	,@retcode 		int
	,@charpos		int
	,@save_servername	sysname
	,@save_servername2	sysname
	,@savefilename		nvarchar(500)
	,@save_domain_name	sysname
	,@save_central_server	sysname
	,@save_fullpath		nvarchar(500)
	,@save_depart_path	nvarchar(500)
	,@DateStmp 		char(14)
	,@Hold_hhmmss		varchar(8)
	,@out_filename		nvarchar(2000)
	,@hold_SQLcode		nvarchar(4000)



----------------  initial values  -------------------
Select @error_count = 0
select @save_domain_name = env_detail from dbo.Local_ServerEnviro where env_type = 'domain'

select @save_central_server = env_detail from dbo.Local_ServerEnviro where env_type = 'CentralServer'
If @save_central_server = 'sqldeployer05'
   begin
	select @save_central_server = 'seafresqldba01'
   end

Select @save_depart_path = '\\' + rtrim(@save_central_server) + '\' + 'Station_' + rtrim(@save_domain_name) + '_Depart'

Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end



create table #DirectoryTempTable(cmdoutput nvarchar(500) null)

create table #fileexists ( 
	doesexist smallint,
	fileindir smallint,
	direxist smallint)


--  Check input parms
if @target_env is null or @target_env not in ('production', 'stage', 'amer')
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. @target_env is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_server is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. @target_server is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @target_SQLserver is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. @target_SQLserver is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @Fail_replyto is null or @Fail_replyto not like '%@%'
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. @Fail_replyto is invalid.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @SQLcode is null or @SQLcode = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit. No action found in @SQLcode input parm.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END



--  Set file name
Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @DateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

Select @savefilename = rtrim(@target_env) + '_x_' + rtrim(@target_server) + '_y_' + rtrim(@target_SQLserver) + '_z_' + rtrim(@DateStmp) + '.actn'


--  Make sure the file does not alreay exist at the station depart folder
Delete from #fileexists
Select @save_fullpath = rtrim(@save_depart_path) + '\' + rtrim(@savefilename)
Insert into #fileexists exec master.sys.xp_fileexist @save_fullpath
--select * from #fileexists

If (select top 1 doesexist from #fileexists) = 1 or (select top 1 fileindir from #fileexists) = 1
   begin
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_File_Transit - File already exists in the central depart folder. ' + rtrim(@savefilename)
	print @miscprint
	Select @error_count = @error_count + 1
	goto label99
  end


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Create the output file
Select @out_filename = '\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\' + @savefilename
Print  ' '
Select @cmd = 'copy nul ' + @out_filename
Print @cmd
EXEC master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'echo @Fail_replyto = "' + @Fail_replyto + '">>' + @out_filename
Print @cmd
EXEC master.sys.xp_cmdshell @cmd, no_output


If @SQLcode like '%' + CHAR(13)+CHAR(10) + '%'
   begin
	Select @cmd = 'echo @SQLcode = _x_>>' + @out_filename
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output

	SQLcode_loop:
	Select @charpos = charindex(CHAR(13)+CHAR(10), @SQLcode)
	IF @charpos <> 0
	   begin
		Select @hold_SQLcode = left(@SQLcode, @charpos-1)
		Select @SQLcode = substring(@SQLcode, @charpos+2, len(@SQLcode)-@charpos+2)

		If @hold_SQLcode <> ''
		   begin
			Select @cmd = 'echo ' + @hold_SQLcode + '>>' + @out_filename
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end	

	If @SQLcode like '%' + CHAR(13)+CHAR(10) + '%'
	   begin
		goto SQLcode_loop
	   end

	Select @cmd = 'echo ' + @SQLcode + '_y_>>' + @out_filename
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end
Else
   begin
	Select @cmd = 'echo @SQLcode = _x_' + @SQLcode + '_y_>>' + @out_filename
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end

select @cmd = 'robocopy /Z /R:3 /MOV "' + '\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports' + '" "' + @save_depart_path + '" "' + rtrim(@savefilename) + '"'
Print @cmd
EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
print @retcode



-------------------   end   --------------------------

label99:


drop table #DirectoryTempTable
drop table #fileexists



If @error_count > 0
   begin
	raiserror(@miscprint,-1,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_FileCleanup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_FileCleanup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_FileCleanup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create procedure dbo.dbasp_FileCleanup(@targetpath nvarchar(2000) = null
					,@retention int = 90
					,@process sysname = 'Report'
					,@filesonly char(1) = 'n')
			    
/*********************************************************
 **  Stored Procedure dbasp_FileCleanup                
 **  Written by David Spriggs, Getty Images                
 **  December 10,2008                                      
 **  
 **  This procedure is used to delete files older than the 
 **  specified retention value (in days).
 **  
 **
 **  This proc accepts several input parms (outlined below):
 **
 **  - @targetpath is the path where files are located. 
 **
 **  - @retention is the value of days back or days old. In others
 **    setting the parameter to 90 will delete files older than 90 days 
 **    from the current date.
 **
 **  - @process - 'Report' for a report of what will be processed.
 **               'Delete' will do the work.
 ** 
 **  - @filesonly 'y' will process files.  'n' will process both files and folders.
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/10/2008	David Spriggs		New process 
--	05/06/2010	Jim Wilson		Major revision  (rewrite)
--	======================================================================================

			    
/***	
declare @targetpath nvarchar(2000)
declare @retention int
declare @process sysname
declare @filesonly char(1)

set @targetpath = 'e:\AppData\'
set @retention = 50
--set @process = 'report'
set @process = 'delete'
set @filesonly = 'n'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@charpos		int
	,@cmd	 		nvarchar(4000)
	,@save_folder_date	datetime
	,@save_cmdoutput	nvarchar(2000)
	,@save_delete_cmd	nvarchar(2000)
	,@save_folder_cmd	nvarchar(2000)
	,@save_comp_cmd		nvarchar(2000)
	,@save_reverse_cmd	nvarchar(2000)
	,@save_reset_cmd	nvarchar(2000)
	,@retention_char	nvarchar(10)



----------------  initial values  -------------------
Select @retention_char = convert(nvarchar(10), @retention)


--  create temp tables
create table #DirectoryTempTable(cmdoutput nvarchar(500) null)
create table #DirTempTable2(cmdoutput nvarchar(500) null)
create table #DirTempTable3(cmdoutput nvarchar(500) null)


create table #fileexists ( 
	doesexist smallint,
	fileindir smallint,
	direxist smallint)



--  Verify source path existance
Insert into #fileexists exec master.sys.xp_fileexist @targetpath
--select * from #fileexists

If not exists (select 1 from #fileexists where fileindir = 1)
   begin
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_FileCleanup - Tource Path does not exist.  Check input parameter.' 
	print @miscprint
	goto label99
   end
	
	
select @cmd = 'forfiles /p '+@targetpath+' -s -m *.* -d -'+@retention_char+' -c "cmd /c echo del /q @path,@isdir"'
Print @cmd	

--  Table to process against
delete from #DirectoryTempTable
Insert into #DirectoryTempTable(cmdoutput) exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Check for rows to process
If (select count(*) from #DirectoryTempTable) = 0
   begin
	goto label99
   end

If @process <> 'delete'
   begin
	Select @miscprint = 'Here are the files and folders older than ' + @retention_char + ' days.'
	Print @miscprint
	Select @miscprint = 'Use the input parm @process = ''delete'' to delete these files and empty folders.'
	Print @miscprint

	If @filesonly = 'y'
	   begin
		Delete from #DirectoryTempTable where cmdoutput like '%,TRUE%'
	   end

	select * from #DirectoryTempTable
	goto label99
   end
   

--  At this point we are in delete mode
If (select count(*) from #DirectoryTempTable) > 0
   begin
	start_delete:
	Select @save_cmdoutput = (select top 1 cmdoutput from #DirectoryTempTable order by cmdoutput)
	
		
	If @save_cmdoutput like '%,FALSE%'
	   begin
		--  File process
		--  Check to see if there are other files in this folder not within the retention date
		--  If so, skip the delete for this file		
		Select @save_comp_cmd = replace(@save_cmdoutput, ',FALSE', '')
		Select @save_reverse_cmd = reverse(@save_comp_cmd)

		Select @charpos = charindex('\', @save_reverse_cmd)
		IF @charpos <> 0
		   begin
			Select @save_reverse_cmd = substring(@save_reverse_cmd, @charpos+1, len(@save_reverse_cmd)-@charpos)
			Select @save_comp_cmd = reverse(@save_reverse_cmd) + '"'
		   end
		   
		Select @save_comp_cmd = replace(@save_comp_cmd, 'del /q', '')
		Select @save_comp_cmd = ltrim(@save_comp_cmd)
		
		select @cmd = 'forfiles /p '+@save_comp_cmd+' -s -m *.* -d -'+@retention_char+' -c "cmd /c echo del /q @path,@isdir"'
		--Print @cmd	
		delete from #DirTempTable2
		Insert into #DirTempTable2(cmdoutput) exec master.sys.xp_cmdshell @cmd
		delete from #DirTempTable2 where cmdoutput is null
		delete from #DirTempTable2 where cmdoutput like '%,TRUE%'
		--select * from ##DirTempTable2
	
		select @cmd = 'forfiles /p '+@save_comp_cmd+' -s -m *.* -d -0 -c "cmd /c echo del /q @path,@isdir"'
		--Print @cmd	
		delete from #DirTempTable3
		Insert into #DirTempTable3(cmdoutput) exec master.sys.xp_cmdshell @cmd
		delete from #DirTempTable3 where cmdoutput is null
		delete from #DirTempTable3 where cmdoutput like '%,TRUE%'
		--select * from ##DirTempTable3
		
		If (Select count(*) from #DirTempTable3) > (Select count(*) from #DirTempTable2)
		   begin 
			Select @miscprint = 'Skipping delete for files in folder ' + @save_comp_cmd + ' because other files in this folder are not past retention.'
			Print @miscprint
			goto skip_delete
		   end
		   

		--  Verify the folder this file lives in is also past the retention period
		--  If not, skip the delete for this file
		Select @save_folder_date = dbo.dbaudf_GetFileProperty (replace(@save_comp_cmd, '"', ''), 'Folder', 'DateCreated')
		If datediff(dd, @save_folder_date, getdate()) < @retention
		   begin
			Select @miscprint = 'Skipping delete for files in folder ' + @save_comp_cmd + ' because the folder is not past retention.'
			Print @miscprint
			goto skip_delete
		   end
		
		
	   
		--  File delete process
		Select @save_reset_cmd = replace(@save_cmdoutput, ',FALSE', '')
		Select @save_reset_cmd = replace(@save_reset_cmd, 'del /q', 'attrib -r -h -s')
		--Print @save_reset_cmd
		exec master.sys.xp_cmdshell @save_reset_cmd

		Select @save_delete_cmd = replace(@save_cmdoutput, ',FALSE', '')
		Print @save_delete_cmd
		exec master.sys.xp_cmdshell @save_delete_cmd
	   end
	Else If @save_cmdoutput like '%,TRUE%' and @filesonly = 'n'
	   begin
		--  Folder process
		Select @save_delete_cmd = replace(@save_cmdoutput, ',TRUE', '')
		--Print @save_delete_cmd
		Select @save_folder_cmd = replace(@save_delete_cmd, 'del /q', 'DIR')
		Select @save_folder_cmd = @save_folder_cmd + ' /B'
		delete from #DirTempTable3
		Insert into #DirTempTable3(cmdoutput) exec master.sys.xp_cmdshell @save_folder_cmd
		delete from #DirTempTable3 where cmdoutput is null
		--select * from #DirTempTable3
		
		If (select count(*) from #DirTempTable3) > 0
		   begin
			Select @miscprint = 'Skipping delete for folder ' + @save_comp_cmd + ' because the folder is not empty.'
			Print @miscprint
			goto skip_delete
		   end

		--  Delete this folder		   
		Select @save_delete_cmd = replace(@save_delete_cmd, 'del /q', 'rmdir /Q')
		Print @save_delete_cmd
		exec master.sys.xp_cmdshell @save_delete_cmd 
	   end
	Else If @save_cmdoutput not like '%,TRUE%' and @save_cmdoutput not like '%,FALSE%'
	   begin
		Select @miscprint = 'Unknown data (skipping): ' + @save_cmdoutput
		Print @miscprint
	   end


	skip_delete:
	--  check for more rows to process
	delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto start_delete
	   end	   
   end
	




---------------------------  Finalization  -----------------------
label99:

drop table #DirectoryTempTable
drop table #DirTempTable2
drop table #DirTempTable3
drop table #fileexists

 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_FileNameEncodeDecode
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_FileNameEncodeDecode]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_FileNameEncodeDecode]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROC [dbo].[dbasp_FileNameEncodeDecode]
			(
			@OriginalFileName	nvarchar(4000) = NULL OUT
			,@Data			nvarChar(4000) = NULL OUT
			,@EncodedFileName	nvarChar(4000) = NULL OUT
			)
AS
BEGIN
	DECLARE @FileAndData XML	
	IF @Data IS NULL
	BEGIN
		PRINT '@Data is Null : DECODE MODE'		

		SELECT @FileAndData = [dbaadmin].[dbo].[dbaudf_base64_decode] (@EncodedFileName)
		
		
		SELECT	@OriginalFileName = a.b.value('FileName[1]','nVarChar(4000)')
			, @Data = a.b.value('Data[1]','nVarChar(4000)')
		FROM @FileAndData.nodes('/root') a(b)
		
	END
	ELSE
	BEGIN
		PRINT '@Data is NOT Null : ENCODE MODE'
		SELECT @EncodedFileName = [dbaadmin].[dbo].[dbaudf_base64_encode] ('<root><FileName>'+@OriginalFileName+'</FileName><Data>'+@Data+'</Data></root>') 
	END

END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Filescan_Central_Report
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Filescan_Central_Report]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Filescan_Central_Report]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Filescan_Central_Report
/***************************************************************
 **  Stored Procedure dbasp_Filescan_Central_Report                  
 **  Written by Jim Wilson, Getty Images                
 **  July 3, 2001                                      
 **  
 **  This dbasp is set up to create the daily filescan report. 
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==================================================
--	04/26/2002	Jim Wilson		Revision History added
--	09/24/2002	Jim Wilson		Modified output share default
--	10/11/2002	Jim Wilson		Limit output to a width of 255
--	04/18/2003	Jim Wilson		Modified to use filescan share
--	05/04/2006	Jim Wilson		Updated for SQL 2005
--	06/21/2006	Jim Wilson		Added blank line for each new server.
--	08/16/2006	Jim Wilson		Added blank space after file path end
--	06/06/2007	Jim Wilson		Combined failed logins into one line per server if over 50
--	07/10/2007	Anne Varnes		Changed nvarchar(4000) to nvarchar(MAX) on @cu11fulltext AND ##filescanHeader
--	12/29/2008	David Spriggs		Added functionality to exclude certain items via a pre
--					        pre-determined threshold.
--	06/17/2009	Jim Wilson		Major revision to support local filescan process.
--	07/01/2009	Jim Wilson		Seperate section for production and non-production.
--	08/10/2009	Jim Wilson		Moved the nocheck section to the local filescan process.
--	======================================================================================

--/*
--*/

-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@hold_scantext		nvarchar(100)
	,@hold_header		nvarchar(255)
	,@SQLString		nvarchar(255)
	,@Result		int
	,@error_flag		int
	,@save_servername	sysname
	,@match_name		nvarchar(255)
	,@hold_name		sysname
	,@charpos		int
	,@failed_login_count	int


DECLARE
	 @cu10servername	sysname
	,@cu11fulltext		nvarchar(MAX)
	,@cu12fulltext		nvarchar(MAX)
	,@cnt			int
	,@dt01			sysname
	,@dt02			sysname
        ,@dt03			sysname
	,@dt04			sysname


----------------  Initialize values  -------------------
Select @error_flag = 0
Select @hold_name = ''
Select @failed_login_count = 0

Select @save_servername		= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
   end




Select @hold_header = '** SQL FileScan for All Environments:  MSSQL Logs, SQL Agent Logs, Job Logs, Reporting Files, Archive Files.'

----------------  Print headers for filescan report  -------------------
Print  ' '
Print  '************************************************************************************************************'
Print  @hold_header
Print  '************************************************************************************************************'
Select @miscprint = '** Date: ' + convert(char(30), getdate(), 109)
Print  @miscprint
Print  '************************************************************************************************************'

update dbaadmin.dbo.filescan_central set reported = 'y' where reported = 'n'


----------------  Cursor10  -------------------
EXECUTE('DECLARE cu10_current Insensitive Cursor For ' + 
  'SELECT s.ServerName
   From dbaadmin.dbo.DBA_ServerInfo  s 
   Where s.active = ''y''
   and s.SQLEnv = ''production''
   Order by s.ServerName For Read Only')


OPEN cu10_current

WHILE (10=10)
 Begin
	FETCH Next From cu10_current Into @cu10servername
	IF (@@fetch_status < 0)
           begin
              CLOSE cu10_current
	      BREAK
           end
	

	--  Set all rows that include this servername
	update dbaadmin.dbo.filescan_central set reported = 'x' where fulltext like '\\' + @cu10servername + '%'


 End  -- loop 10
DEALLOCATE cu10_current





--  Report production issues

Print  ' '
Print  '************************************************************************************************************'
Print  '--  Production Section'
Print  '************************************************************************************************************'
Print  ' '


----------------  Cursor for filescan upload data  -------------------
EXECUTE('DECLARE cu11_current Insensitive Cursor For ' + 
  'SELECT c.fulltext
   From dbaadmin.dbo.filescan_central  c 
   Where c.reported = ''x''
   Order by c.fulltext For Read Only')


OPEN cu11_current

WHILE (11=11)
 Begin
	FETCH Next From cu11_current Into @cu11fulltext
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_current
	      BREAK
           end
	

	--  Add a blank line to the report if this is a line from a different server
	Select @match_name = left(@cu11fulltext, 255)
	If left(@match_name, 2) = '\\'
	   begin
		Select @charpos = charindex('\', @match_name, 3)
		IF @charpos <> 0
		   begin
			Select @match_name = substring(@match_name, 1, @charpos)
			--print @match_name
			If @match_name <> @hold_name
			   begin
				If @failed_login_count > 50
				   begin
				    Print @hold_name + ' Failed Logins: ' + convert(varchar(10), @failed_login_count)
				   end
				Print ''
				Select @hold_name = @match_name
				Select @failed_login_count = 0
			   end
		   end
	   end


	--  add blank space after first ":"
	Select @charpos = charindex(':', @cu11fulltext)
	IF @charpos <> 0
	   begin
		Select @cu11fulltext = stuff(@cu11fulltext, @charpos, 1, ' :')
	   end


	If @cu11fulltext like '%Login failed for user%'
	   begin
	    Select @failed_login_count = @failed_login_count + 1
	   end
	Else
	   begin
	    Print left(@cu11fulltext, 255)
	   end


 End  -- loop 11
DEALLOCATE cu11_current


delete from dbaadmin.dbo.filescan_central where reported = 'x'





--  Report non-production issues

Print  ' '
Print  '************************************************************************************************************'
Print  '--  Non-Production Section'
Print  '************************************************************************************************************'


----------------  Cursor for filescan upload data  -------------------
EXECUTE('DECLARE cu12_current Insensitive Cursor For ' + 
  'SELECT c.fulltext
   From dbaadmin.dbo.filescan_central  c 
   Where c.reported = ''y''
   Order by c.fulltext For Read Only')


OPEN cu12_current

WHILE (12=12)
 Begin
	FETCH Next From cu12_current Into @cu12fulltext
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_current
	      BREAK
           end
	

	--  Add a blank line to the report if this is a line from a different server
	Select @match_name = left(@cu12fulltext, 255)
	If left(@match_name, 2) = '\\'
	   begin
		Select @charpos = charindex('\', @match_name, 3)
		IF @charpos <> 0
		   begin
			Select @match_name = substring(@match_name, 1, @charpos)
			--print @match_name
			If @match_name <> @hold_name
			   begin
				If @failed_login_count > 50
				   begin
				    Print @hold_name + ' Failed Logins: ' + convert(varchar(10), @failed_login_count)
				   end
				Print ''
				Select @hold_name = @match_name
				Select @failed_login_count = 0
			   end
		   end
	   end


	--  add blank space after first ":"
	Select @charpos = charindex(':', @cu12fulltext)
	IF @charpos <> 0
	   begin
		Select @cu12fulltext = stuff(@cu12fulltext, @charpos, 1, ' :')
	   end


	If @cu12fulltext like '%Login failed for user%'
	   begin
	    Select @failed_login_count = @failed_login_count + 1
	   end
	Else
	   begin
	    Print left(@cu12fulltext, 255)
	   end


End  -- loop 12
DEALLOCATE cu12_current


delete from dbaadmin.dbo.filescan_central where reported = 'y'




---------------------------  Finalization  -----------------------



Print  ' '
Print  '**********************************************************************'
Print  '** End of File Scan Report'
Print  '**********************************************************************'


label99:

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_filescan_local_process
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_filescan_local_process]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_filescan_local_process]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_filescan_local_process

/**************************************************************
 **  Stored Procedure dbasp_filescan_local_process                  
 **  Written by Jim Wilson, Getty Images                
 **  June 16, 2009                                      
 **  
 **  This dbasp is set up to run the filescan process locally.
 ***************************************************************/
  as
  SET NOCOUNT ON
  SET ANSI_WARNINGS OFF

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	06/18/2009	Jim Wilson		New filescan process.
--	06/19/2009	Jim Wilson		Several fixes.
--	07/07/2009	Jim Wilson		Code to remove trailing single quotes, 
--						added Update dbo.dba_serverinfo set Filescan.
--	07/10/2009	Jim Wilson		Always send file to central server. 
--	07/13/2009	Jim Wilson		Added delay of 30 seconds for intial file creation. 
--	08/11/2009	Jim Wilson		New section for local exclude using the no_check table. 
--	03/23/2010	Jim Wilson		Limit scan to dba_reports, dba_archive and sqljob_logs
--						and raise DBA Filescan messages to the SQL errorlog (no output files)
--	======================================================================================

/*

--*/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd 				nvarchar(4000)
	,@save_servername		sysname
	,@save_servername2		sysname
	,@charpos			int
	,@save_nocheck_nocheckID	int
	,@save_nocheck_detail01		sysname
	,@save_nocheck_detail02		sysname
	,@save_nocheck_detail03		sysname
	,@save_nocheck_detail04		sysname
	,@save_nocheck_num		int

DECLARE
	 @save_scantext			nvarchar(256)
	,@hold_scantext			nvarchar(125)
	,@cu12fulltext			nvarchar(256)
	,@central_server 		sysname


----------------  initial values  -------------------
Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


Select @central_server = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'CentralServer'
If @central_server is null
   begin
	Select @miscprint = 'DBA WARNING: The central SQL Server is not defined for ' + @@servername + '.  The local filescan process failed'
	Print @miscprint
	raiserror(@miscprint,-1,-1)
	goto label99
   end


--  Clear filescan work tables
delete from dbo.filescan_bcpin

delete from dbo.filescan_temp 



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Copy the include and exclude files from the central server
Select @cmd = 'copy \\' + @central_server + '\' + @central_server + '_builds\dbaadmin\filescan\*.*  \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan /Y'
print @cmd
exec master.sys.xp_cmdshell @cmd



--  Scan the SQLjob_logs folder for asci
Select @cmd = 'findstr /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\includescan.txt \\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs\*.* | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\exclude_joblogs.txt >\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_SQLjob_logs.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 

--  Scan the SQLjob_logs folder for unicode
Select @cmd = 'strings \\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs\*.* | findstr /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\includescan.txt | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\exclude_joblogs.txt >\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_SQLjob_logs2.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 

--  Scan the Archive folder for ascii
Select @cmd = 'findstr /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\includescan02.txt \\' + @save_servername + '\' + @save_servername2 + '_dba_archive\*.* | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_archive.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 

--  Scan the Archive folder for unicode
Select @cmd = 'strings \\' + @save_servername + '\' + @save_servername2 + '_dba_archive\*.* | findstr /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\includescan02.txt | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_archive_uni.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 

--  Scan the Reports folder for ascii
Select @cmd = 'findstr /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\includescan02.txt \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\*.log | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_reports.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 


Select @miscprint = 'Filescan completed for SQL Server ' + @save_servername2
Print  @miscprint

Print ' '



--  Combine files for this server
Select @cmd = 'copy /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_SQLjob_logs.rpt + /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_SQLjob_logs2.rpt  \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 

Select @cmd = 'copy /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt + /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_archive.rpt  \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 

Select @cmd = 'copy /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt + /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_archive_uni.rpt  \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 

Select @cmd = 'copy /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt      + /B \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '_reports.rpt  \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt'
print @cmd
EXEC master.sys.xp_cmdshell @cmd--, no_output 


Select @miscprint = 'Filescan files combined for SQL Server ' + @save_servername2
Print  @miscprint



----------------  Upload file process  -------------------
select @cmd = 'type \\' + @save_servername + '\' + @save_servername2 + '_dbasql\filescan\filescan_temp\Filescan_' + @save_servername2 + '.rpt'
print @cmd

Delete from dbaadmin.dbo.filescan_bcpin
insert into dbaadmin.dbo.filescan_bcpin exec master.sys.xp_cmdshell @cmd
delete from dbaadmin.dbo.filescan_bcpin where fulltext is null
delete from dbaadmin.dbo.filescan_bcpin where fulltext = ''
--select * from dbaadmin.dbo.filescan_bcpin

If (select count(*) from dbaadmin.dbo.filescan_bcpin) = 0
   begin
	select @miscprint = 'DBA Note:  No filescan rows to process for server ' + @@servername
	print @miscprint
	goto label99
   end


--  Transfer data from the temp table to the filescan_temp table (varchar(max) to varchar(125)
insert into dbaadmin.dbo.filescan_temp select convert(nvarchar(256),fulltext) from dbaadmin.dbo.filescan_bcpin

delete from dbaadmin.dbo.filescan_temp where fulltext = char(9)

delete from dbaadmin.dbo.filescan_temp where fulltext not like '\\%'

delete from dbaadmin.dbo.filescan_temp where fulltext like '%.mdmp%'



--  Local Exclude section
If exists (select 1 from dbo.No_Check where NoCheck_Type = 'Filescan_noreport')
   begin
	Select @save_nocheck_nocheckID = 0
	start_local_exclude01:
	Select @save_nocheck_nocheckID = (select top 1 nocheckID from dbo.No_Check where NoCheck_Type = 'Filescan_noreport' and nocheckID > @save_nocheck_nocheckID order by nocheckID)
	Select @save_nocheck_detail01 = (select detail01 from dbo.No_Check where NoCheck_Type = 'Filescan_noreport' and nocheckID = @save_nocheck_nocheckID)
	Select @save_nocheck_detail02 = (select detail02 from dbo.No_Check where NoCheck_Type = 'Filescan_noreport' and nocheckID = @save_nocheck_nocheckID)
	Select @save_nocheck_detail03 = (select detail03 from dbo.No_Check where NoCheck_Type = 'Filescan_noreport' and nocheckID = @save_nocheck_nocheckID)
	Select @save_nocheck_detail04 = (select detail04 from dbo.No_Check where NoCheck_Type = 'Filescan_noreport' and nocheckID = @save_nocheck_nocheckID)

	If (select isnumeric(@save_nocheck_detail04)) = 0
	   begin
		Select @save_nocheck_num = 0
	   end
	Else
	   begin
		Select @save_nocheck_num = @save_nocheck_detail04
	   end

	If @save_nocheck_num = 0
	   begin
		If (@save_nocheck_detail02 is null or @save_nocheck_detail02 = '') and (@save_nocheck_detail03 is null or @save_nocheck_detail03 = '')
		   begin
			delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01
		   end
		Else If @save_nocheck_detail03 is null or @save_nocheck_detail03 = ''
		   begin
			delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext like @save_nocheck_detail02
		   end 
		Else If @save_nocheck_detail02 is null or @save_nocheck_detail02 = ''
		   begin
			delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext not like @save_nocheck_detail03
		   end 
		Else
		   begin
			delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext like @save_nocheck_detail02 and fulltext not like @save_nocheck_detail03
		   end 
	   end
	Else
	   begin
		If (@save_nocheck_detail02 is null or @save_nocheck_detail02 = '') and (@save_nocheck_detail03 is null or @save_nocheck_detail03 = '')
		   begin
			If (select count(*) from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01) < @save_nocheck_num
			   begin
				delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01
			   end
		   end
		Else If @save_nocheck_detail03 is null or @save_nocheck_detail03 = ''
		   begin
			If (select count(*) from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext like @save_nocheck_detail02) < @save_nocheck_num
			   begin
				delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext like @save_nocheck_detail02
			   end
		   end 
		Else If @save_nocheck_detail02 is null or @save_nocheck_detail02 = ''
		   begin
			If (select count(*) from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext not like @save_nocheck_detail03) < @save_nocheck_num
			   begin
				delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext not like @save_nocheck_detail03
			   end
		   end 
		Else
		   begin
			If (select count(*) from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext like @save_nocheck_detail02 and fulltext not like @save_nocheck_detail03) < @save_nocheck_num
			   begin
				delete from dbaadmin.dbo.filescan_temp where fulltext like @save_nocheck_detail01 and fulltext like @save_nocheck_detail02 and fulltext not like @save_nocheck_detail03
			   end
		   end 
	   end


	If exists (select 1 from dbo.No_Check where NoCheck_Type = 'Filescan_noreport' and nocheckID > @save_nocheck_nocheckID)
	   begin
		goto start_local_exclude01
	   end
   end



----------------  Delete all rows from the filescan_current table  -------------------
delete from dbaadmin.dbo.filescan_current 


----------------  Delete all dba_reports and dba_archive related rows from the filescan_exclude table  -------------------
delete from dbaadmin.dbo.filescan_exclude where scantext like '%dba_archive%' 
delete from dbaadmin.dbo.filescan_exclude where scantext like '%dba_reports%' 


----------------  Set filescan_exclude use flag  -------------------
update dbaadmin.dbo.filescan_exclude set useflag = 'n' 



--  Start data compare  -------------------
start_loop01:

Select @save_scantext = (select top 1 fulltext from dbaadmin.dbo.filescan_temp)
Select @hold_scantext = left(@save_scantext, 125)
--print @hold_scantext
--raiserror('', -1,-1) with nowait	

If exists (select 1 from dbaadmin.dbo.filescan_exclude where scantext = @hold_scantext)
   begin
	update dbaadmin.dbo.filescan_exclude set useflag = 'y' where scantext = @hold_scantext
   end
Else
   begin
	insert into dbaadmin.dbo.filescan_exclude values (@hold_scantext, 'y')
	insert into dbaadmin.dbo.filescan_current values (@save_scantext)
   end


--  Look for more rows to process
delete from dbaadmin.dbo.filescan_temp where fulltext = @save_scantext 
If (select count(*) from dbaadmin.dbo.filescan_temp) > 0
   begin
	goto start_loop01
   end


delete from dbaadmin.dbo.filescan_exclude where useflag = 'n' 


If (select count(*) from dbaadmin.dbo.filescan_current) = 0
   begin
	select @miscprint = 'DBA Note:  No filescan rows to process for server ' + @@servername
	print @miscprint
	goto label99
   end



--  cursor to raise filescan results to the sql error log
EXECUTE('DECLARE cu12_cursor Insensitive Cursor For ' +
  'SELECT fc.fulltext
   From dbaadmin.dbo.filescan_current  fc ' +
  'for Read Only')

OPEN cu12_cursor

WHILE (12=12)
 Begin
	FETCH Next From cu12_cursor Into @cu12fulltext
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_cursor
	      BREAK
           end


	Print @cu12fulltext
	RAISERROR (68001, -1, -1, @cu12fulltext) with log



 End  -- loop 12
DEALLOCATE cu12_cursor




----------------  End  -------------------
label99:


Print  ' '
Select @miscprint = 'Filescan process completed.'
Print  @miscprint




 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_filescan_logparser
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_filescan_logparser]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_filescan_logparser]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_filescan_logparser

/**************************************************************
 **  Stored Procedure dbasp_filescan_logparser                  
 **  Written by Steve Ledridge and Jim Wilson, Getty Images                
 **  April 29, 2010                                      
 **  
 **  This dbasp is set up to run the local filescan log parser process.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/29/2009	SteveL, JimW		New process.
--	======================================================================================

/*

--*/


-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd				VarChar(8000)
	,@charpos			int
	,@central_server		sysname
	,@save_servername		sysname
	,@save_servername2		sysname
	,@Machine			sysname
	,@Instance			sysname
	,@Last				DateTime
	,@LastDate			VarChar(12)
	,@LastTime			VarChar(8)
	,@LogBufferMin			INT
	,@new_runtime_char		nvarchar(20)
	,@old_runtime_char		nvarchar(20)
	,@old_runtime			datetime



----------------  initial values  -------------------
SET @LogBufferMin = -20


Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_logparser_time')
   begin
	Select @old_runtime_char = (select top 1 env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_logparser_time')
	Select @old_runtime = convert(datetime, @old_runtime_char)
   end
Else
   begin
	Select @old_runtime = getdate()
   end

Select @new_runtime_char = convert(nvarchar(20), getdate(), 120)


SET @Last = DATEADD(mi,@LogBufferMin,@old_runtime)

SET @Last = COALESCE(@Last,GetDate()-30)

SELECT		@Machine	= REPLACE(@@servername,'\'+@@SERVICENAME,'')
		,@Instance	= REPLACE(@@SERVICENAME,'MSSQLSERVER','')
		,@LastDate	= LEFT(CONVERT(VarChar(20),@Last,120),10)
		,@LastTime	= RIGHT(CONVERT(VarChar(20),@Last,120),8)
		,@central_server = env_detail 
from		dbaadmin.dbo.Local_ServerEnviro 
where		env_type = 'CentralServer'


If @central_server is null
   begin
	Select @miscprint = 'DBA WARNING: The central SQL Server is not defined for ' + @@servername + '.  The local filescan process failed'
	Print @miscprint
	raiserror(@miscprint,-1,-1)
	goto label99
   end




/****************************************************************
 *                MainLine
 ***************************************************************/

Print  ' '
Select @miscprint = 'Filescan Log Parser process starting. ' + convert(varchar(30),getdate(),9)
Print  @miscprint


--  Process SQL Errorlog
Select	@cmd = '%windir%\system32\LogParser "file:\\'
		+ @central_server + '\' + @central_server 
		+ '_filescan\Aggregates\Queries\'
		+ 'SQLErrorLog2.sql?startdate=' + @LastDate + '+starttime='
		+ @LastTime +'+machine='
		+ @Machine + '+instance='
		+ @Instance + '+machineinstance='
		+ UPPER(REPLACE(@@servername,'\','$')) + '+OutputFile=\\' 
		+ @central_server + '\' + @central_server 
		+ '_filescan\Aggregates\SQLErrorLOG_'
		+ UPPER(REPLACE(@@servername,'\','$'))
		+ '.w3c" -i:TEXTLINE -o:W3C -fileMode:0 -encodeDelim'

Print 'Process SQL Errorlog'
Print @cmd	
exec master.sys.xp_cmdshell @cmd



--  Set Instance for the next two commands
IF @Instance = ''
   begin
	SET @Instance = '-'
   end


--  Process SQL Agent logs
Select	@cmd = '%windir%\system32\LogParser "file:\\'
		+ @central_server + '\' + @central_server 
		+ '_filescan\Aggregates\Queries\'
		+ 'SQLAGENT.sql?startdate=' + @LastDate + '+starttime='
		+ @LastTime +'+machine='
		+ @Machine + '+instance='
		+ @Instance + '+machineinstance='
		+ UPPER(REPLACE(@@servername,'\','$')) + '+OutputFile=\\' 
		+ @central_server + '\' + @central_server 
		+ '_filescan\Aggregates\SQLAGENT_'
		+ UPPER(REPLACE(@@servername,'\','$'))
		+ '.w3c" -i:TSV -o:W3C -fileMode:0 -iSeparator:space'
		+ ' -iHeaderFile:"\\'
		+ @central_server + '\' + @central_server 
		+ '_filescan\Aggregates\Queries\SQLAGENT.tsv"'
		

Print 'Process SQL Agent Logs'
Print @cmd	
exec master.sys.xp_cmdshell @cmd




--  Process Server Event Logs
Select	@cmd = '%windir%\system32\LogParser "file:\\'
		+ @central_server + '\' + @central_server 
		+ '_filescan\Aggregates\Queries\'
		+ 'ServerEvent.sql?startdate=' + @LastDate + '+starttime='
		+ @LastTime +'+machine='
		+ @Machine + '+instance='
		+ @Instance + '+machineinstance='
		+ UPPER(REPLACE(@@servername,'\','$')) + '+OutputFile=\\' 
		+ @central_server + '\' + @central_server 
		+ '_filescan\Aggregates\ServerEvent_'
		+ UPPER(REPLACE(@@servername,'\','$'))
		+ '.w3c" -i:EVT -o:W3C -fileMode:0 -binaryFormat:ASC -oDQuotes:ON -encodeDelim:ON -resolveSIDs:ON'


Print 'Process Server Event Logs'
Print @cmd	
exec master.sys.xp_cmdshell @cmd



delete from dbaadmin.dbo.Local_ServerEnviro where env_type = 'check_logparser_time'
insert into dbaadmin.dbo.Local_ServerEnviro(env_type, env_detail) Values ('check_logparser_time', @new_runtime_char)


----------------  End  -------------------
label99:



Print  ' '
Select @miscprint = 'Filescan Log Parser process completed. ' + convert(varchar(30),getdate(),9)
Print  @miscprint





 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_filescan_process
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_filescan_process]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_filescan_process]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_filescan_process (@save_SQLEnv sysname = '')

/**************************************************************
 **  Stored Procedure dbasp_filescan_process                  
 **  Written by Jim Wilson, Getty Images                
 **  December 26, 2002                                      
 **  
 **  This dbasp is set up to run the filescan process.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/26/2002	Jim Wilson		New filescan process.
--	04/22/2003	Jim Wilson		Changes for new instance share names.
--	05/04/2006	Jim Wilson		Converted for SQL 2005.
--	06/13/2006	Jim Wilson		Fixed dba_reports related syntax.
--	06/14/2006	Jim Wilson		Only scan for dba_reports *.log files.
--	05/11/2007	Jim Wilson		Added Unicode scan for archive folder.
--	07/15/2008	Jim Wilson		Added scan for SQL job_logs share.
--	08/22/2008	Jim Wilson		New table dba_serverinfo.
--	08/22/2008	Jim Wilson		New input parm @save_SQLEnv.
--	10/08/2008	Jim Wilson		Added ascii check for sqljob_logs and separate exclude file.
--	======================================================================================

/*
declare @save_SQLEnv sysname

Select @save_SQLEnv = 'production'
--*/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@command 			nvarchar(4000)
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_domain			sysname
	,@charpos			int

DECLARE
	 @cu11sqlservername		sysname
	,@cu11sqlservername2		sysname

DECLARE
	 @cu12sqlservername		sysname
	,@cu12sqlservername2		sysname


----------------  initial values  -------------------
Select @save_servername = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Cursor for SQL Servers to scan
EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
  'SELECT u.SQLName
   From dbaadmin.dbo.DBA_ServerInfo u ' +
  'Where u.active = ''y''
     and u.filescan = ''y''
     and u.DomainName = ''' + @save_domain + '''
     and u.SQLEnv like ''%' + @save_SQLEnv + '%''
   Order by u.SQLName for Read Only')

OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11sqlservername
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end


	Select @cu11sqlservername2 = @cu11sqlservername

	Select @charpos = charindex('\', @cu11sqlservername)
	IF @charpos <> 0
	   begin
		Select @cu11sqlservername = substring(@cu11sqlservername, 1, (CHARINDEX('\', @cu11sqlservername)-1))

		Select @cu11sqlservername2 = stuff(@cu11sqlservername2, @charpos, 1, '$')
	   end




	--  Scan the LOG folder for asci
	Select @command = 'findstr /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\includescan.txt \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_LOG\*.* | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu11sqlservername2 + '_asc.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	--  Scan the Log folder for unicode
	Select @command = 'strings \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_LOG\*.* | findstr /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\includescan.txt | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu11sqlservername2 + '_uni.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 


	--  Scan the SQLjob_logs folder for asci
	Select @command = 'findstr /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\includescan.txt \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_SQLjob_logs\*.* | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\exclude_joblogs.txt >\\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu11sqlservername2 + '_SQLjob_logs.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	--  Scan the SQLjob_logs folder for unicode
	Select @command = 'strings \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_SQLjob_logs\*.* | findstr /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\includescan.txt | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\exclude_joblogs.txt >\\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu11sqlservername2 + '_SQLjob_logs2.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 


	--  Scan the Archive folder for ascii
	Select @command = 'findstr /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\includescan02.txt \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_dba_archive\*.* | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu11sqlservername2 + '_archive.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	--  Scan the Archive folder for unicode
	Select @command = 'strings \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_dba_archive\*.* | findstr /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\includescan02.txt | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu11sqlservername2 + '_archive_uni.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 


	--  Scan the Reports folder for ascii
	Select @command = 'findstr /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\includescan02.txt \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_dbasql\dba_reports\*.log | findstr /v /i /g:\\' + @save_servername + '\' + @save_servername + '_filescan\excludeall.txt >\\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu11sqlservername2 + '_reports.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 



Select @miscprint = 'Filescan completed for SQL Server ' + @cu11sqlservername2
Print  @miscprint


 End  -- loop 11
DEALLOCATE cu11_cursor


Print ' '

--  Prepare the new combined result file
Select @command = 'del \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall6.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 

Select @command = 'ren \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall5.rpt Filescanall6.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 

Select @command = 'ren \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall4.rpt Filescanall5.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 

Select @command = 'ren \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall3.rpt Filescanall4.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 

Select @command = 'ren \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall2.rpt Filescanall3.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 

Select @command = 'ren \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall1.rpt Filescanall2.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 

Select @command = 'ren \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall_temp.rpt Filescanall1.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 

Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\uploadheader.txt \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall_temp.rpt'
print @command
EXEC master.sys.xp_cmdshell @command--, no_output 



--  cursor to combine files
EXECUTE('DECLARE cu12_cursor Insensitive Cursor For ' +
  'SELECT u.SQLName
   From dbaadmin.dbo.DBA_ServerInfo  u ' +
  'Where u.active = ''y''
     and u.filescan = ''y''
     and u.DomainName = ''' + @save_domain + '''
     and u.SQLEnv like ''%' + @save_SQLEnv + '%''
   Order by u.SQLName for Read Only')

OPEN cu12_cursor

WHILE (12=12)
 Begin
	FETCH Next From cu12_cursor Into @cu12sqlservername
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_cursor
	      BREAK
           end


	Select @cu12sqlservername2 = @cu12sqlservername

	Select @charpos = charindex('\', @cu12sqlservername)
	IF @charpos <> 0
	   begin
		Select @cu12sqlservername = rtrim(substring(@cu12sqlservername, 1, (CHARINDEX('\', @cu12sqlservername)-1)))

		Select @cu12sqlservername2 = stuff(@cu12sqlservername2, @charpos, 1, '$')
	   end

print @cu12sqlservername2


	--  Combine files for this server
	Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '_asc.rpt  + /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '_uni.rpt \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt + /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '_SQLjob_logs.rpt  \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt + /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '_SQLjob_logs2.rpt  \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt + /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '_archive.rpt  \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt + /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '_archive_uni.rpt  \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 

	Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt      + /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '_reports.rpt  \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 


	--  Combine files for all servers
	Select @command = 'copy /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall_temp.rpt + /B \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_temp\Filescan_' + @cu12sqlservername2 + '.rpt  \\' + @save_servername + '\' + @save_servername + '_filescan\filescan_result\Filescanall_temp.rpt'
	print @command
	EXEC master.sys.xp_cmdshell @command--, no_output 


Select @miscprint = 'Filescan files combined for SQL Server ' + @cu11sqlservername2
Print  @miscprint



 End  -- loop 12
DEALLOCATE cu12_cursor


----------------  End  -------------------

Print  ' '
Select @miscprint = 'Filescan process completed.'
Print  @miscprint





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Filescan_Report
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Filescan_Report]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Filescan_Report]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE [dbo].[dbasp_Filescan_Report]
    @outshare varchar (255) = null     /** file output share name override **/
/***************************************************************
 **  Stored Procedure dbasp_Filescan_Report                  
 **  Written by Jim Wilson, Getty Images                
 **  July 3, 2001                                      
 **  
 **  This dbasp is set up to create the daily filescan report. 
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==================================================
--	04/26/2002	Jim Wilson		Revision History added
--	09/24/2002	Jim Wilson		Modified output share default
--	10/11/2002	Jim Wilson		Limit output to a width of 255
--	04/18/2003	Jim Wilson		Modified to use filescan share
--	05/04/2006	Jim Wilson		Updated for SQL 2005
--	06/21/2006	Jim Wilson		Added blank line for each new server.
--	08/16/2006	Jim Wilson		Added blank space after file path end
--	06/06/2007	Jim Wilson		Combined failed logins into one line per server if over 50
--	07/10/2007	Anne Varnes		Changed nvarchar(4000) to nvarchar(MAX) on @cu11fulltext AND ##filescanHeader
--	12/29/2008	David Spriggs		Added functionality to exclude certain items via a pre
--					        pre-determined threshold.
--	======================================================================================

/*
Declare @outshare varchar (255)
Select @outshare = null
--*/

-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@hold_scantext		nvarchar(100)
	,@hold_header		nvarchar(255)
	,@SQLString		nvarchar(255)
	,@Result		int
	,@error_flag		int
	,@save_servername	sysname
	,@match_name		nvarchar(255)
	,@hold_name		sysname
	,@charpos		int
	,@failed_login_count	int


DECLARE
	 @cu11fulltext		nvarchar(MAX)
	,@cnt			int
	,@dt01			sysname
	,@dt02			sysname
        ,@dt03			sysname
	,@dt04			sysname


----------------  Initialize values  -------------------
Select @error_flag = 0
Select @hold_name = ''
Select @failed_login_count = 0

Select @save_servername		= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
   end

If @outshare is null
   begin
	Select @outshare = @save_servername + '_filescan'
   end 

---------------- Before creating the report, we process to get rid of non-reportable items--------


if(select count(*) from dbaadmin.dbo.No_Check where NoCheck_Type = 'Filescan_noreport') > 0
begin

    declare tempcheck_cur cursor for
    select
       detail01,
       detail02, 
       detail03, 
       detail04
    from dbaadmin.dbo.No_Check
    where NoCheck_Type = 'Filescan_noreport'

    open tempcheck_cur

    fetch next from tempcheck_cur into @dt01,@dt02,@dt03,@dt04

    while @@fetch_status = 0
    begin

	set @cnt = convert(int,@dt04) 

        if (select COUNT(*) from dbaadmin.dbo.filescan_current where FullText like @dt01 and FullText like @dt02 and FullText like @dt03)< @cnt
	    begin
		delete
		from dbo.filescan_current 
		where fulltext like @dt01 
		      and FullText like @dt02 
		      and FullText like @dt03
	    end

	 fetch next from tempcheck_cur into @dt01,@dt02,@dt03,@dt04
    end
    close tempcheck_cur
    deallocate tempcheck_cur

end


----------------  Create temp table for upload  -------------------
create table ##filescanHeader (fulltext nvarchar (MAX) NULL)


----------------  Upload file to process  -------------------
Select @SQLString = 'bulk insert ##filescanHeader from  ''\\' + @save_servername + '\' + @outshare + '\uploadheader.txt'''
--Print @SQLString
EXEC @Result = master.sys.sp_executesql @SQLString
--select * from ##filescanHeader

IF @Result <> 0 
   begin
	select @miscprint = 'DBA WARNING: Filescan header file upload error on server ' + @@servername
	raiserror(@miscprint,-1,-1) with log
	Select @error_flag = 1
	goto label99 
   end


Select @hold_header = (select fulltext from ##filescanHeader)

----------------  Print headers for filescan report  -------------------
Print  ' '
Print  '**********************************************************************'
Print  @hold_header
Print  '**********************************************************************'
Select @miscprint = '** Date: ' + convert(char(30), getdate(), 109)
Print  @miscprint
Print  '**********************************************************************'
Print  ' '


----------------  Cursor for filescan upload data  -------------------
EXECUTE('DECLARE cu11_current Insensitive Cursor For ' + 
  'SELECT c.fulltext
   From dbaadmin.dbo.filescan_current  c 
   Order by c.fulltext For Read Only')


OPEN cu11_current

WHILE (11=11)
 Begin
	FETCH Next From cu11_current Into @cu11fulltext
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_current
	      BREAK
           end
	

	--  Add a blank line to the report if this is a line from a different server
	Select @match_name = left(@cu11fulltext, 255)
	If left(@match_name, 2) = '\\'
	   begin
		Select @charpos = charindex('\', @match_name, 3)
		IF @charpos <> 0
		   begin
			Select @match_name = substring(@match_name, 1, @charpos)
			--print @match_name
			If @match_name <> @hold_name
			   begin
				If @failed_login_count > 50
				   begin
				    Print @hold_name + ' Failed Logins: ' + convert(varchar(10), @failed_login_count)
				   end
				Print ''
				Select @hold_name = @match_name
				Select @failed_login_count = 0
			   end
		   end
	   end


	--  add blank space after first ":"
	Select @charpos = charindex(':', @cu11fulltext)
	IF @charpos <> 0
	   begin
		Select @cu11fulltext = stuff(@cu11fulltext, @charpos, 1, ' :')
	   end


	If @cu11fulltext like '%Login failed for user%'
	   begin
	    Select @failed_login_count = @failed_login_count + 1
	   end
	Else
	   begin
	    Print left(@cu11fulltext, 255)
	   end


 End  -- loop 11
DEALLOCATE cu11_current

---------------------------  Finalization  -----------------------

Print  ' '
Print  '**********************************************************************'
Print  '** End of File Scan Report'
Print  '**********************************************************************'


label99:

drop table ##filescanHeader

If @error_flag <> 0
   begin
       return(1)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Filescan_Upload
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Filescan_Upload]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Filescan_Upload]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_Filescan_Upload
    @outshare varchar (255) = null     /** file output share name override **/
/***************************************************************
 **  Stored Procedure dbasp_Filescan_Upload                  
 **  Written by Jim Wilson, Getty Images                
 **  July 3, 2001                                      
 **  
 **  This dbasp is set up to upload and process the daily 
 **  filescan temp file.
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	05/06/2002	Jim Wilson		Added code to delete dba_archive and dba_reports
--                                              related data from the filescan_exclude table.
--	06/21/2002	Jim Wilson		Modified @@servername usage.
--	09/24/2002	Jim Wilson		Modified output share default
--	04/18/2003	Jim Wilson		Modified to use filescan share
--	05/04/2006	Jim Wilson		Updated for SQL 2005
--	07/10/2007	Anne Varnes		Changed fulltext column setting from nvarchar (4000) to nvarchar(MAX)
--	09/25/2008	Jim Wilson		Bulk Insert changed to BCP and cursor removed.
--	======================================================================================

/*
declare @outshare nvarchar(255)

--*/

-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(255)
	,@save_scantext		nvarchar(256)
	,@hold_scantext		nvarchar(125)
	,@SQLString		nvarchar(255)
	,@Result		int
	,@error_flag		int
	,@save_servername	sysname
	,@charpos		int
	,@cmd			nvarchar(500)


----------------  Initialize values  -------------------
Select @error_flag = 0

Select @save_servername		= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
   end

If @outshare is null
   begin
	Select @outshare = @save_servername + '_filescan'
   end 

--  Create temp table for upload
create table ##filescanTemp (fulltext nvarchar (MAX) NULL)



delete from dbaadmin.dbo.filescan_temp 

----------------  Upload file to process  -------------------
Select @cmd = 'bcp ##filescanTemp in "\\' + @save_servername + '\' + @outshare + '\filescan_result\filescanall_temp.rpt" -c -T' 
Print @cmd
EXEC @Result = master.sys.xp_cmdshell @cmd

--select * from ##filescanTemp

IF @Result <> 0 
   begin
	select @miscprint = 'DBA WARNING: Filescan file upload error on server ' + @@servername
	raiserror(@miscprint,-1,-1) with log
	Select @error_flag = 1
	goto label99 
   end

If (select count(*) from ##filescanTemp) = 0
   begin
	goto label99
   end


--  Transfer data from the temp table to the filescan_temp table (varchar(max) to varchar(125)
delete from dbaadmin.dbo.filescan_temp 

insert into dbaadmin.dbo.filescan_temp select convert(nvarchar(256),fulltext) from ##filescanTemp

delete from dbaadmin.dbo.filescan_temp where fulltext = char(9)

delete from dbaadmin.dbo.filescan_temp where fulltext not like '\\%'

delete from dbaadmin.dbo.filescan_temp where fulltext like '%.mdmp%'


----------------  Delete all rows from the filescan_current table  -------------------
delete from dbaadmin.dbo.filescan_current 


----------------  Delete all dba_reports and dba_archive related rows from the filescan_exclude table  -------------------
delete from dbaadmin.dbo.filescan_exclude where scantext like '%dba_archive%' 
delete from dbaadmin.dbo.filescan_exclude where scantext like '%dba_reports%' 


----------------  Set filescan_exclude use flag  -------------------
update dbaadmin.dbo.filescan_exclude set useflag = 'n' 


--  Start data compare  -------------------
start_loop01:

Select @save_scantext = (select top 1 fulltext from dbaadmin.dbo.filescan_temp)
Select @hold_scantext = left(@save_scantext, 125)
--print @hold_scantext
--raiserror('', -1,-1) with nowait	

If exists (select 1 from dbaadmin.dbo.filescan_exclude where scantext = @hold_scantext)
   begin
	update dbaadmin.dbo.filescan_exclude set useflag = 'y' where scantext = @hold_scantext
   end
Else
   begin
	insert into dbaadmin.dbo.filescan_exclude values (@hold_scantext, 'y')
	insert into dbaadmin.dbo.filescan_current values (@save_scantext)
   end


--  Look for more rows to process
delete from dbaadmin.dbo.filescan_temp where fulltext = @save_scantext 
If (select count(*) from dbaadmin.dbo.filescan_temp) > 0
   begin
	goto start_loop01
   end


---------------------------  Finalization  -----------------------

delete from dbaadmin.dbo.filescan_exclude where useflag = 'n' 

label99:

drop table ##filescanTemp


If @error_flag <> 0
   begin
        return(1)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_FileTransit_deliver
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_FileTransit_deliver]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_FileTransit_deliver]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE dbo.dbasp_FileTransit_deliver

/*********************************************************
 **  Stored Procedure dbasp_FileTransit_deliver                  
 **  Written by Jim Wilson, Getty Images                
 **  November 21, 2005                                      
 **  
 **  This procedure is used for delivering files as the final part
 **  of the file transit process which moves files from one server
 **  to another where there is no trust relationship.
 **
 **  This procedure also will process action/event files (*.actn)
 **
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/21/2005	Jim Wilson		New process
--	05/15/2006	Jim Wilson		Updated from SQL 2005.
--	10/11/2007	Jim Wilson		Added ability to transit to share sub folders.
--	09/26/2008	Jim Wilson		Added code for action/event file processing.
--	10/03/2008	Jim Wilson		Removed out of place goto.
--	======================================================================================

-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@error_count		int
	,@charpos		int
	,@retcode		int
	,@cmd 			nvarchar(4000)
	,@filename_wild		nvarchar(500)
	,@filename_wild2	nvarchar(500)
	,@charpos_x		int
	,@charpos_y		int
	,@charpos_z		int
	,@local_servername	sysname
	,@local_servername2	sysname
	,@local_domain		sysname
	,@save_filename		nvarchar(500)
	,@save_target_share	nvarchar(500)
	,@save_target_share2	nvarchar(500)
	,@save_target_server	sysname
	,@save_servername	sysname
	,@save_SQLserver	sysname
	,@Hold_filename		nvarchar(500)
	,@tempcount		int
	,@check_path		nvarchar(500)
	,@save_targetpath	nvarchar(500)
	,@folder_flag		nchar(1)
	,@invalid_server	nchar(1)
	,@first_flag		nchar(1)
	,@end_flag		nchar(1)
	,@Fail_replyto		nvarchar(255)
	,@save_subject		nvarchar(500)
	,@save_message		nvarchar(500)
	,@save_SQLcode		nvarchar(4000)
	,@hold_SQLcode		nvarchar(255)
	,@sqlcmd		nvarchar(4000)
	,@save_pt_row		int
	,@DateStmp 		char(14)
	,@Hold_hhmmss		varchar(8)


----------------  initial values  -------------------
Select @error_count = 0
select @invalid_server = 'n'

Select @local_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')

select @filename_wild = '%' + rtrim(@local_domain) + '_x_%'

select @filename_wild2 = rtrim(@local_domain) + '_x_'

Select @local_servername = @@servername
Select @local_servername2 = @@servername

Select @charpos = charindex('\', @local_servername)
IF @charpos <> 0
   begin
	Select @local_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @local_servername2 = stuff(@local_servername2, @charpos, 1, '$')
   end


Create table #DirectoryTempTable(cmdoutput nvarchar(500) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

CREATE TABLE #temp_tbl1	(text01	nvarchar(400))

create table #action_Info_bulk(ParmText nvarchar(max) null)

create table #action_Info(
			 ParmText nvarchar(max) null
			,pt_row [int] IDENTITY (1, 1) NOT NULL
			)





/****************************************************************
 *                MainLine
 ***************************************************************/


--  Process Files to be moved
Label01:
 
select @cmd = 'dir \\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive\' + rtrim(@local_domain) + '_x_*.*'
--print @cmd

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%.actn'
--select * from #DirectoryTempTable

--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	

		--  Check to see if this is a folder
		Select @folder_flag = 'n'
		Select @charpos = charindex('<DIR>', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @folder_flag = 'y'
		   end	

		--  Capture the filename
		Select @charpos_z = charindex('_z_', @Hold_filename)
		IF @charpos_z <> 0
		   begin
	 		Select @save_filename = substring(@Hold_filename, @charpos_z+3, 250)
		   end	
		--print @save_filename

		--  Capture the sharename
		Select @charpos_y = charindex('_y_', @Hold_filename)
		IF @charpos_y <> 0
		   begin
	 		Select @save_target_share = substring(@Hold_filename, @charpos_y+3, (@charpos_z-@charpos_y-3))
			Select @save_target_share2 = replace(@save_target_share, '_f_', '\')
		   end	
		--print @save_target_share
		--print @save_target_share2

		--  Capture the servername
		Select @charpos_x = charindex('_x_', @Hold_filename)
		IF @charpos_y <> 0
		   begin
	 		Select @save_target_server = substring(@Hold_filename, @charpos_x+3, (@charpos_y-@charpos_x-3))
		   end	
		--print @save_target_server



		--  Make sure the file doesn't already exist at the target location.  If it does, delete it.
		Select @check_path = '\\' + rtrim(@save_target_server) + '\' + rtrim(@save_target_share2) + '\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "\\' + rtrim(@save_target_server) + '\' + rtrim(@save_target_share2) + '\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "\\' + rtrim(@save_target_server) + '\' + rtrim(@save_target_share2) + '\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end


		Select @check_path = '\\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "\\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "\\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end


		--  Rename the file prior to delivery
		Select @cmd = 'REN \\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive\' + rtrim(@local_domain) 
				+ '_x_' + rtrim(@save_target_server) 
				+ '_y_' + rtrim(@save_target_share) 
				+ '_z_' + rtrim(@save_filename) + ' ' + rtrim(@save_filename)	
		Print @cmd
		EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 


		--  Move the file from the source to the target
		If @folder_flag = 'y'
		   begin
			-- create the folder at the target location
			Select @cmd = 'mkdir "\\' + rtrim(@save_target_server) + '\' + rtrim(@save_target_share2) + '\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

			select @cmd = 'robocopy /Z /E /R:3 /MOV "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) 
					+ '" "\\' + rtrim(@save_target_server) + '\' + rtrim(@save_target_share2) + '\' + rtrim(@save_filename) + '" "*.*"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			Select @cmd = 'rmdir /S /Q "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
		   end
		Else
		   begin
			select @cmd = 'robocopy /Z /R:3 /MOV \\' + @local_servername + '\Station_' + @local_domain + '_Arrive \\' 
					+ rtrim(@save_target_server) + '\' + rtrim(@save_target_share2) + ' ' + rtrim(@save_filename)
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd
		   end


		--  Log the process
		Select @save_targetpath = '\\' + rtrim(@save_target_server) + '\' + rtrim(@save_target_share2)
		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @save_targetpath, 'Deliver', getdate())


		process_more:
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end
   END


--------------------------------------------------------------------------------------------------
--  Process Action/Event files
--------------------------------------------------------------------------------------------------
Label02:
 
select @cmd = 'dir /b \\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive\' + rtrim(@local_domain) + '_x_*.actn'

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where cmdoutput not like '%.actn%'
--select * from #DirectoryTempTable

--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @save_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
		Select @Hold_filename = @save_filename
	

		--  Capture the server name
		Select @charpos = charindex('_x_', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @Hold_filename = substring(@Hold_filename, @charpos+3, len(@Hold_filename)-@charpos+3)
		   end	
		--print @Hold_filename


		Select @charpos = charindex('_y_', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @save_servername = left(@Hold_filename, @charpos-1)
	 		Select @Hold_filename = substring(@Hold_filename, @charpos+3, len(@Hold_filename)-@charpos+3)
		   end	
		--print @save_servername
		--print @Hold_filename


		--  Capture the SQLserver name
		Select @charpos = charindex('_z_', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @save_SQLserver = left(@Hold_filename, @charpos-1)
		   end	
		--print @save_SQLserver

		If @save_SQLserver like '%$%'
		   begin
			Select @save_SQLserver = replace(@save_SQLserver, '$', '\')
		   end


		--  Make sure the servername is valid (do a ping)
		delete from #temp_tbl1
		Select @cmd = 'ping ' + @save_servername
		insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
		Delete from #temp_tbl1 where text01 is null or text01 = ''
		Delete from #temp_tbl1 where text01 not like '%Reply from%'
		--select * from #temp_tbl1
                	
		If (select count(*) from #temp_tbl1 where text01 like '%Reply from%') = 0
		   begin
			--  Server name not valid.  Send error email
			select @invalid_server = 'y'
		   end


		--  Load the contents of the file into a temp table
		Delete from #action_Info_bulk
		Select @cmd = 'bulk insert #action_Info_bulk from  ''\\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive\' + @save_filename + ''''
		--Print @cmd
		exec master.sys.sp_executesql @cmd
		delete from #action_Info_bulk where ParmText = char(9)
		--select * from #action_Info_bulk

		Delete from #action_Info
		Insert into #action_Info select ParmText from #action_Info_bulk
		--select * from #action_Info

		Select @Fail_replyto = (select top 1 convert(nvarchar(255), ParmText) from #action_Info where ParmText like '%@Fail_replyto%')
		delete from #action_Info where ParmText like '%@Fail_replyto%'

		Select @charpos = charindex('"', @Fail_replyto)
		IF @charpos <> 0
		   begin
			Select @Fail_replyto = rtrim(substring(@Fail_replyto, @charpos+1, len(@Fail_replyto)-@charpos+1))
		   end

		Select @Fail_replyto = replace(@Fail_replyto, '"', '')
		--Print @Fail_replyto

		If @invalid_server = 'y'
		   begin
			select @save_subject = 'DBA File Transit Error - From: ' + @@servername
			select @save_message = 'Invalid server name [' + @save_servername + '] for action file [' + @save_filename + ']' 
			Print @save_subject
			Print @save_message
			EXEC dbaadmin.dbo.dbasp_sendmail 
				@recipients = @Fail_replyto,  
				@subject = @save_subject,
				@message = @save_message

			select @cmd = 'robocopy /Z /R:3 /MOV \\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive \\'
					+ rtrim(@local_servername) + '\' + rtrim(@local_servername2) + '_SQLjob_logs ' + rtrim(@save_filename)
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			--  Log the process
			Select @save_targetpath = '\\' + rtrim(@save_servername) + '\' + rtrim(@save_SQLserver)
			insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @save_targetpath, 'Action-Failed', getdate())


			goto process_next_action
		   end


		--  Process the requested action
		Select @first_flag = 'y'
		Select @end_flag = 'n'
		Select @save_SQLcode = ''

		If (select count(*) from #action_Info) > 0
		   begin
			SQLcode_loop:

			Select @save_pt_row = (select top 1 pt_row from #action_Info order by pt_row)
			Select @hold_SQLcode = (select top 1 convert(nvarchar(255), ParmText) from #action_Info where pt_row = @save_pt_row)
			Select @hold_SQLcode = replace(@hold_SQLcode, char(13), '')
			Select @hold_SQLcode = replace(@hold_SQLcode, char(10), '')
			--print @hold_SQLcode

			If @first_flag = 'y'
			   begin
				Select @first_flag = 'n'
				Select @charpos = charindex('_x_', @hold_SQLcode)
				IF @charpos <> 0
				   begin
					Select @hold_SQLcode = substring(@hold_SQLcode, @charpos+3, len(@hold_SQLcode)-@charpos+3)
				   end
				Else
				   begin
					select @save_subject = 'DBA File Transit Error - From: ' + @@servername
					select @save_message = 'Invalid SQLcode.  Code must start with @SQLcode = _x_.' 
					Print @save_subject
					Print @save_message
					EXEC dbaadmin.dbo.dbasp_sendmail 
						@recipients = @Fail_replyto,  
						@subject = @save_subject,
						@message = @save_message

					select @cmd = 'robocopy /Z /R:3 /MOV \\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive \\'
							+ rtrim(@local_servername) + '\' + rtrim(@local_servername2) + '_SQLjob_logs ' + rtrim(@save_filename)
					Print @cmd
					EXEC @retcode = master.sys.xp_cmdshell @cmd

					--  Log the process
					Select @save_targetpath = '\\' + rtrim(@save_servername) + '\' + rtrim(@save_SQLserver)
					insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @save_targetpath, 'Action-Failed', getdate())

					goto process_next_action
				   end
			   end

			Select @hold_SQLcode = rtrim(@hold_SQLcode)


			--  Remove inline coments
			Select @charpos = charindex('--', @hold_SQLcode)
			IF @charpos <> 0
			   begin
				Select @hold_SQLcode = LEFT(@hold_SQLcode, @charpos-1)
			   end

			Select @hold_SQLcode = rtrim(@hold_SQLcode)


			--  Check for end of code marker
			Select @charpos = charindex('_y_', @hold_SQLcode)
			IF @charpos <> 0
			   begin
				Select @end_flag = 'y'
				Select @hold_SQLcode = LEFT(@hold_SQLcode, @charpos-1)
			   end

			Select @hold_SQLcode = rtrim(@hold_SQLcode)


			--  Remove go
			IF @hold_SQLcode = 'go'
			   begin
				Select @hold_SQLcode = ''
			   end

			Select @hold_SQLcode = rtrim(@hold_SQLcode)



			--  Append the code here
			If len(@hold_SQLcode) > 0
			   begin
				select @save_SQLcode = @save_SQLcode + ' ' + @hold_SQLcode
			   end


			--  check for more code			
			delete from #action_Info where pt_row = @save_pt_row
			If (select count(*) from #action_Info) > 0 and @end_flag = 'n'
			   begin
				goto SQLcode_loop
			   end

		   end


		--  Execute the SQL code
		Select @save_SQLcode = ltrim(@save_SQLcode)
		Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
		Set @DateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

		Print 'Processing file ' + rtrim(@save_filename)
		SELECT @sqlcmd = 'sqlcmd -S' + @save_SQLserver + ' -u -Q"' + @save_SQLcode + '" -E -o\\' + @local_servername + '\' + @local_servername2 + '_SQLjob_logs\FileTransit_Action_' + rtrim(@DateStmp) + '.txt'
		PRINT  @sqlcmd
		EXEC master.sys.xp_cmdshell @sqlcmd



		select @cmd = 'robocopy /Z /R:3 /MOV \\' + rtrim(@local_servername) + '\Station_' + rtrim(@local_domain) + '_Arrive \\'
				+ rtrim(@local_servername) + '\' + rtrim(@local_servername2) + '_SQLjob_logs ' + rtrim(@save_filename)
		Print @cmd
		EXEC @retcode = master.sys.xp_cmdshell @cmd


		--  Log the process
		Select @save_targetpath = '\\' + rtrim(@save_servername) + '\' + rtrim(@save_SQLserver)
		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @save_targetpath, 'Action', getdate())


		process_next_action:
		delete from #DirectoryTempTable where cmdoutput = @save_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end
   END


-------------------   end   --------------------------


label99:


drop table #DirectoryTempTable
drop table #fileexists
drop TABLE #temp_tbl1
drop table #action_Info_bulk
drop table #action_Info




If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_FileTransit_mover
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_FileTransit_mover]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_FileTransit_mover]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE dbo.dbasp_FileTransit_mover ( @source_server sysname = '\\seaexsqlmail'
					,@retry_limit int = 3 )

/*********************************************************
 **  Stored Procedure dbasp_FileTransit_mover                  
 **  Written by Jim Wilson, Getty Images                
 **  November 21, 2005                                      
 **  
 **  This procedure is used for copying files from one server
 **  to another where there is no trust relationship.
 **
 **  This proc accepts the following input parm(s):
 **  - @source_server is the \\servername where files are being copied from.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/21/2005	Jim Wilson		New process
--	05/15/2006	Jim Wilson		Updated for SQL 2005.
--	07/12/2006	Jim Wilson		Added push process from AMER to Stage and Production.
--	07/20/2007	Jim Wilson		Change stage user.
--	10/11/2007	Jim Wilson		Increased the size of several variables.
--	09/22/2008	Jim Wilson		Added code for AMER processing.
--	10/24/2008	Jim Wilson		Removed passwords. 
--	02/06/2009	Jim Wilson		New code to force action files be processed last. 
--	03/16/2009	Jim Wilson		Added process to move not targeted files for this domain. 
--	03/17/2009	Jim Wilson		Added skip for new non-target process. 
--	03/26/2009	Jim Wilson		Check local_control table before deleting net use connection. 
--	======================================================================================


/***
Declare @source_server sysname
Declare @retry_limit int

--select @source_server = '\\seafrestgsql'
select @source_server = '\\seaexsqlmail'
select @retry_limit = 3
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@error_count		int
	,@retcode		int 
	,@cmd 			nvarchar(4000)
	,@filename_wild		nvarchar(500)
	,@filename_wild2	nvarchar(500)
	,@charpos		int
	,@local_servername	sysname
	,@local_domain		sysname
	,@source_domain		sysname
	,@save_filename		nvarchar(500)
	,@source_user 		sysname
	,@source_pw 		sysname
	,@Hold_filename		nvarchar(500)
	,@reverse_filename	nvarchar(500)
	,@tempcount		int
	,@check_path		nvarchar(500)
	,@folder_flag		nchar(1)
	,@hold_string		sysname
	,@newid 		sysname



----------------  initial values  -------------------
Select @error_count = 0
select @newid = convert(sysname, newid())


Select @local_servername = (select env_detail from dbo.Local_ServerEnviro where env_type = 'SRVname')
Select @local_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')

select @filename_wild = '%' + rtrim(@local_domain) + '_x_%'

select @filename_wild2 = rtrim(@local_domain) + '_x_'



Create table #DirectoryTempTable(cmdoutput nvarchar(500) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)



--  Check input parms
if @source_server is null
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_FileTransit_mover. @source_server is required.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


--  Set login and password
If @source_server = '\\seaexsqlmail' 
   begin
	Select @source_domain = 'PRODUCTION'
	Select @source_user = 'PRODuction\SQLTransSVCAcct'
	Select @hold_string  = 'pw_' + @source_user
	Select @source_pw  = (select top 1 detail01 from dbo.local_control where subject = @hold_string)
	If @source_pw is null or @source_pw = ''
	   begin
		Select @miscprint = 'DBA ERROR: Password not found for ' + @source_user + '.' 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end

	select @cmd = 'net use'
	EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output


	--  Connect to the remote server share
	select @cmd = 'net use ' + @source_server + ' /user:' + @source_user + ' ' + @source_pw
	--print @cmd
	EXEC @retcode = master.sys.xp_cmdshell @cmd, no_output

	If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid)
	   begin
		insert into dbo.local_control values ('net_use', @source_server, @newid, '')
	   end


	select @cmd = 'net use'
	EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output
   end
Else If @source_server = '\\seafrestgsql' 
   begin
	Select @source_domain = 'STAGE'
	Select @source_user = 'stage\sqlnxtpusher'
	Select @hold_string  = 'pw_' + @source_user
	Select @source_pw  = (select top 1 detail01 from dbo.local_control where subject = @hold_string)
	If @source_pw is null or @source_pw = ''
	   begin
		Select @miscprint = 'DBA ERROR: Password not found for ' + @source_user + '.' 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end

	select @cmd = 'net use'
	EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output


	--  Connect to the remote server share
	select @cmd = 'net use ' + @source_server + ' /user:' + @source_user + ' ' + @source_pw
	--print @cmd
	EXEC @retcode = master.sys.xp_cmdshell @cmd, no_output

	If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid)
	   begin
		insert into dbo.local_control values ('net_use', @source_server, @newid, '')
	   end


	select @cmd = 'net use'
	EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output
   end
Else If @source_server = '\\seafresqldba01' 
   begin
	Select @source_domain = 'AMER'
   end
Else
   begin
	Select @miscprint = 'DBA WARNING: Invalid source_ server. ' +  @source_server
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end





/****************************************************************
 *                MainLine
 ***************************************************************/

--  Start Pull Section (non-action files)  -----------------------------------------------------------
Print 'Start Pull Section (non-action files)'
select @cmd = 'dir ' + @source_server + '\Station_' + @source_domain + '_Depart\*.*'
print @cmd

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%.actn'
select * from #DirectoryTempTable


--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
		Select @charpos = charindex(@filename_wild2, @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @save_filename = substring(@Hold_filename, @charpos, 250)
		   end	

		--  Check to see if this is a folder
		Select @folder_flag = 'n'
		Select @charpos = charindex('<DIR>', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @folder_flag = 'y'
		   end	


		--  Make sure the file doesn't already exist at the target location.  If is does, delete it.
		Select @check_path = '\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		--Select * from #fileexists
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end



		--  Move the file from the source to the target
		If @folder_flag = 'y'
		   begin
			-- create the folder at the target location
			Select @cmd = 'mkdir "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

			select @cmd = 'robocopy /Z /E /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '" "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '" "*.*"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			Select @cmd = 'rmdir /S /Q "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
		  end
		Else
		   begin
			select @cmd = 'robocopy /Z /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart" "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive" "' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd
		  end


		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @source_domain, 'Arrive', getdate())


		-- process more
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end
   END



--  Start Pull Section (non-action files, not targeted for this domain)  -----------------------------------------------------------

If @source_server = '\\' + @local_servername
   begin
	goto skip_non_target01
   end


Print 'Start Pull Section (non-action files, not targeted for this domain)'
select @cmd = 'dir ' + @source_server + '\Station_' + @source_domain + '_Depart\*.*'
print @cmd

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%.actn'
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%_x_%'
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%Volume in drive%'
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%Directory of%'
select * from #DirectoryTempTable


--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
		Select @reverse_filename = reverse(@Hold_filename)
		Select @charpos = charindex(' ', @reverse_filename)
		IF @charpos <> 0
		   begin
	 		Select @reverse_filename = substring(@reverse_filename, 1, @charpos-1)
		   end	
		Select @save_filename = reverse(@reverse_filename)

		--  Check to see if this is a folder
		Select @folder_flag = 'n'
		Select @charpos = charindex('<DIR>', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @folder_flag = 'y'
		   end	

		--  Make sure the file doesn't already exist at the target location.  If is does, delete it.
		Select @check_path = '\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		--Select * from #fileexists
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end



		--  Move the file from the source to the target
		If @folder_flag = 'y'
		   begin
			-- create the folder at the target location
			Select @cmd = 'mkdir "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

			select @cmd = 'robocopy /Z /E /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '" "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '" "*.*"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			Select @cmd = 'rmdir /S /Q "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
		  end
		Else
		   begin
			select @cmd = 'robocopy /Z /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart" "\\' + @local_servername + '\Station_' + @local_domain + '_Depart" "' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd
		  end


		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @source_domain, 'Depart', getdate())


		-- process more
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end

   END

skip_non_target01:


--  Start Pull Section (action files)  -----------------------------------------------------------
Print 'Start Pull Section (action files)'
select @cmd = 'dir ' + @source_server + '\Station_' + @source_domain + '_Depart\*.*'
print @cmd

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%.actn'
select * from #DirectoryTempTable


--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
		Select @charpos = charindex(@filename_wild2, @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @save_filename = substring(@Hold_filename, @charpos, 250)
		   end	

		--  Check to see if this is a folder
		Select @folder_flag = 'n'
		Select @charpos = charindex('<DIR>', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @folder_flag = 'y'
		   end	


		--  Make sure the file doesn't already exist at the target location.  If is does, delete it.
		Select @check_path = '\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		--Select * from #fileexists
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end



		--  Move the file from the source to the target
		If @folder_flag = 'y'
		   begin
			-- create the folder at the target location
			Select @cmd = 'mkdir "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

			select @cmd = 'robocopy /Z /E /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '" "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive\' + rtrim(@save_filename) + '" "*.*"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			Select @cmd = 'rmdir /S /Q "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
		  end
		Else
		   begin
			select @cmd = 'robocopy /Z /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart" "\\' + @local_servername + '\Station_' + @local_domain + '_Arrive" "' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd
		  end


		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @source_domain, 'Arrive', getdate())


		-- process more
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end

   END



--  Start Pull Section (action files, not targeted for this domain)  -----------------------------------------------------------
If @source_server = '\\' + @local_servername
   begin
	goto skip_non_target02
   end

Print 'Start Pull Section (action files, not targeted for this domain)'
select @cmd = 'dir ' + @source_server + '\Station_' + @source_domain + '_Depart\*.*'
print @cmd

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%.actn'
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%_x_%'
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%Volume in drive%'
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%Directory of%'
select * from #DirectoryTempTable


--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
		Select @reverse_filename = reverse(@Hold_filename)
		Select @charpos = charindex(' ', @reverse_filename)
		IF @charpos <> 0
		   begin
	 		Select @reverse_filename = substring(@reverse_filename, 1, @charpos-1)
		   end	
		Select @save_filename = reverse(@reverse_filename)

		--  Check to see if this is a folder
		Select @folder_flag = 'n'
		Select @charpos = charindex('<DIR>', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @folder_flag = 'y'
		   end	

		--  Make sure the file doesn't already exist at the target location.  If is does, delete it.
		Select @check_path = '\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		--Select * from #fileexists
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end



		--  Move the file from the source to the target
		If @folder_flag = 'y'
		   begin
			-- create the folder at the target location
			Select @cmd = 'mkdir "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

			select @cmd = 'robocopy /Z /E /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '" "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '" "*.*"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			Select @cmd = 'rmdir /S /Q "' + @source_server + '\Station_' + @source_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
		  end
		Else
		   begin
			select @cmd = 'robocopy /Z /R:3 /MOV "' + @source_server + '\Station_' + @source_domain + '_Depart" "\\' + @local_servername + '\Station_' + @local_domain + '_Depart" "' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd
		  end


		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @source_domain, 'Depart', getdate())


		-- process more
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end

   END

skip_non_target02:




--  Start Push Section (non-action)  -----------------------------------------------------------
select @filename_wild = '%' + rtrim(@source_domain) + '_x_%'
select @filename_wild2 = rtrim(@source_domain) + '_x_'

select @cmd = 'dir \\' + @local_servername + '\Station_' + @local_domain + '_Depart\*.*'
print @cmd

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) like '%.actn'
select * from #DirectoryTempTable


--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
		Select @charpos = charindex(@filename_wild2, @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @save_filename = substring(@Hold_filename, @charpos, 250)
		   end	

		--  Check to see if this is a folder
		Select @folder_flag = 'n'
		Select @charpos = charindex('<DIR>', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @folder_flag = 'y'
		   end	


		--  Make sure the file doesn't already exist at the target location.  If is does, delete it.
		Select @check_path = @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		--Select * from #fileexists
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "' + @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "' + @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end



		--  Move the file from the source to the target
		If @folder_flag = 'y'
		   begin
			-- create the folder at the target location
			Select @cmd = 'mkdir "' + @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

			select @cmd = 'robocopy /Z /E /R:3 /MOV "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '" "' 
						+ @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '" "*.*"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			Select @cmd = 'rmdir /S /Q "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
		  end
		Else
		   begin
			select @cmd = 'robocopy /Z /R:3 /MOV "\\' + @local_servername + '\Station_' + @local_domain + '_Depart" "' 
						+ @source_server + '\Station_' + @source_domain + '_Arrive" "' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd
		  end


		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @local_domain, 'Arrive', getdate())


		--push more
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end

   END


--  Start Push Section (action)  -----------------------------------------------------------
select @filename_wild = '%' + rtrim(@source_domain) + '_x_%'
select @filename_wild2 = rtrim(@source_domain) + '_x_'

select @cmd = 'dir \\' + @local_servername + '\Station_' + @local_domain + '_Depart\*.*'
print @cmd

delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
--select * from #DirectoryTempTable

delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like @filename_wild
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%.actn'
select * from #DirectoryTempTable


--  If there are files to process
if (select count(*) from #DirectoryTempTable) > 0
   BEGIN
	Select @tempcount = (select count(*) from #DirectoryTempTable)

	While (@tempcount > 0)
	   begin
		Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)
	
		Select @charpos = charindex(@filename_wild2, @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @save_filename = substring(@Hold_filename, @charpos, 250)
		   end	

		--  Check to see if this is a folder
		Select @folder_flag = 'n'
		Select @charpos = charindex('<DIR>', @Hold_filename)
		IF @charpos <> 0
		   begin
	 		Select @folder_flag = 'y'
		   end	


		--  Make sure the file doesn't already exist at the target location.  If is does, delete it.
		Select @check_path = @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @check_path
		--Select * from #fileexists
		If (select doesexist from #fileexists) = 1 or (select fileindir from #fileexists) = 1
		   begin
			If @folder_flag = 'y'
			   begin
				Select @cmd = 'rmdir /S /Q "' + @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
			Else
			   begin
				Select @cmd = 'DEL /Q /F "' + @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '"'
				Print @cmd
				EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
			   end
		   end



		--  Move the file from the source to the target
		If @folder_flag = 'y'
		   begin
			-- create the folder at the target location
			Select @cmd = 'mkdir "' + @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 

			select @cmd = 'robocopy /Z /E /R:3 /MOV "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '" "' 
						+ @source_server + '\Station_' + @source_domain + '_Arrive\' + rtrim(@save_filename) + '" "*.*"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd

			Select @cmd = 'rmdir /S /Q "\\' + @local_servername + '\Station_' + @local_domain + '_Depart\' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd--, no_output 
		  end
		Else
		   begin
			select @cmd = 'robocopy /Z /R:3 /MOV "\\' + @local_servername + '\Station_' + @local_domain + '_Depart" "' 
						+ @source_server + '\Station_' + @source_domain + '_Arrive" "' + rtrim(@save_filename) + '"'
			Print @cmd
			EXEC @retcode = master.sys.xp_cmdshell @cmd
		  end


		insert into dbaadmin.dbo.FileTransit_LOG(ftFileName, ftSourceDomain, ftStatus, ftProcessDate) Values (@save_filename, @local_domain, 'Arrive', getdate())


		--push more
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
		Select @tempcount = (select count(*) from #DirectoryTempTable)

	   end

   END


-------------------   end   --------------------------

label99:


If @source_server = '\\seaexsqlmail' or @source_server = '\\seafrestgsql' 
   begin
	If exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid)
	   begin
		delete from dbo.local_control where subject = 'net_use' and Detail01 = @source_server and Detail02 = @newid
	   end

	If not exists(select 1 from dbo.local_control where subject = 'net_use' and Detail01 = @source_server)
	   begin
		select @cmd = 'net use /DELETE ' + @source_server
		print @cmd
		exec master.sys.xp_cmdshell @cmd--, no_output
	   end
   end



drop table #DirectoryTempTable
drop table #fileexists


If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_FileVerify
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_FileVerify]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_FileVerify]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_FileVerify ( @full_path nvarchar(500) = null, 
					@premask sysname = '', 
					@midmask sysname = '', 
					@postmask sysname = '', 
					@Fail_ifnotfound char(1) = 'y',
					@Fail_ifdupfound char(1) = 'y'
					)

/*********************************************************
 **  Stored Procedure dbasp_FileVerify                 
 **  Written by Jim Wilson, Getty Images                
 **  JULY 23, 2008                                      
 **  
 **  This procedure is used for Verifying the existance of a file.
 **
 **  This proc accepts the following input parms:
 **  - @full_path is the path where the file can be found
 **    example - "\\seafresqlwcds\seafresqlwcds_dbasql"
 **  - @premask is the mask for the beginning of the backup file name (i.e. 'wcds_db')
 **  - @midmask is the mask for the midpart of the file name (i.e. '_db_2')
 **  - @postmask is the mask for the last part of the file name (i.e. '.bak')
 **  - @Fail_ifnotfound is a flag to fail the process if a file is not found.
 **  - @Fail_ifdupfound is a flag to fail the process if more than one file is found.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	07/23/2008	Jim Wilson		New process
--	09/16/2008	Jim Wilson		seafresqldba02 to seafresqldba01.
--	======================================================================================


/***
Declare @full_path nvarchar(500)
Declare @premask sysname
Declare @midmask sysname
Declare @postmask sysname
Declare @Fail_ifnotfound char(1)
Declare @Fail_ifdupfound char(1)

Select @full_path = '\\seafresqldba01\seafresqldba01_backup'
Select @premask = 'run'
Select @midmask = '_db'
Select @postmask = '5.BAK'
Select @Fail_ifnotfound = 'y'
Select @Fail_ifdupfound = 'y'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@error_count			int
	,@cmd 				nvarchar(4000)
	,@filecount			smallint
	,@filename_wild			nvarchar(100)


----------------  initial values  -------------------
Select @error_count = 0
Select @filename_wild = ''


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)


--  Check input parms
if @full_path is null or @full_path = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_autorestore - @full_path is invaild.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @premask = ''and @midmask = '' and @postmask = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters - input parm @premask or @midmask or @postmask must be used' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


If @premask is not null and @premask <> ''
   begin
	Select @filename_wild = @filename_wild + @premask
   end

If @midmask is not null and @midmask <> ''
   begin
	Select @filename_wild = @filename_wild + '*' + @midmask
   end

If @postmask is not null and @postmask <> ''
   begin
	Select @filename_wild = @filename_wild + '*' + @postmask
   end
Else
   begin
	Select @filename_wild = @filename_wild + '*'
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

select @cmd = 'dir /B ' + @full_path + '\' + @filename_wild
print @cmd

start_dir:
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd

delete from #DirectoryTempTable where cmdoutput like '%File Not Found%'
delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable

Select @filecount = (select count(*) from #DirectoryTempTable)

If @filecount = 0
   begin
	Select @miscprint = 'DBA Warning: FileVerify process could not find a file at "' + @full_path + '" using mask ''' + @filename_wild + '''.'
	Print @miscprint
	If @Fail_ifnotfound = 'y'
	   begin
		Select @error_count = @error_count + 1
		goto label99
	   end
   end
Else If @filecount = 1
   begin
	Select @miscprint = 'DBA Message: FileVerify process found one file at "' + @full_path + '" using mask ''' + @filename_wild + '''.'
	Print @miscprint
   end
Else If @filecount > 1
   begin
	Select @miscprint = 'DBA Warning: FileVerify process found more than one file at "' + @full_path + '" using mask ''' + @filename_wild + '''.'
	Print @miscprint
	If @Fail_ifdupfound = 'y'
	   begin
		Select @error_count = @error_count + 1
		goto label99
	   end
   end



-------------------   end   --------------------------

label99:

drop table #DirectoryTempTable


If @error_count > 0
   begin
	--print @miscprint
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	--print @miscprint
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_FixJobOutput
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_FixJobOutput]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_FixJobOutput]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_FixJobOutput

/***************************************************************
 **  Stored Procedure dbasp_FixJobOutput                  
 **  Written by Jim Wilson, Getty Images                
 **  December 27, 2005                                      
 **  
 **  This dbasp is set up to;
 ** 
 **  Change job output path from c:\ to the sqljob_logs share.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==================================================
--	12/27/2005	Jim Wilson		New process.
--	02/15/2006	Jim Wilson		Modified fro sql2005.
--	======================================================================================



-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(4000)
	,@parm01		varchar(100)
	,@outpath 		varchar(255)
	,@new_filename		nvarchar(500)
	,@save_filename		nvarchar(500)
	,@save_job_id		uniqueidentifier
	,@save_step_id		int
	,@save_servername	sysname
	,@save_servername2	sysname
	,@charpos		int
	,@error_count		int


/*********************************************************************
 *                Initialization
 ********************************************************************/

Select @error_count = 0

Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end



--  Verify the sqljob_logs shares and get the path
Select @parm01 = @save_servername2 + '_SQLjob_logs'
exec dbaadmin.dbo.dbasp_get_share_path @parm01, @outpath output

If @outpath is null or @outpath = ''
   begin
	Print 'Warning:  The standard share to the ''sqljob_logs'' folder has not been defined.'
	Select @error_count = @error_count + 1
	Goto label99
   end

--  Create table variable
declare @tblv_filename table	(
				 job_id			uniqueidentifier
				,step_id		int
				,output_file_name	sysname
				)


/****************************************************************
 *                MainLine
 ***************************************************************/

Insert into @tblv_filename (job_id, step_id, output_file_name)
select job_id, step_id, output_file_name from msdb.dbo.sysjobsteps
where output_file_name like 'c:\%'

--select * from @tblv_filename

start_filename_process:

Select @save_job_id = (select top 1 job_id from @tblv_filename)
Select @save_step_id = (select top 1 step_id from @tblv_filename where job_id = @save_job_id)
Select @save_filename = (select output_file_name from @tblv_filename where job_id = @save_job_id and step_id = @save_step_id)


select @new_filename = substring(@save_filename, 4, 500)


--  Make sure this is a file being written to the root of c:\.  If so, convert it to point to the sqljob_logs folder.
Select @charpos = charindex('\', @new_filename)
IF @charpos = 0
   begin
	select @new_filename = @outpath + '\' + @new_filename
	Print 'Update SQL job output file name from ' + @save_filename + ' to ' + @new_filename
	update msdb.dbo.sysjobsteps set output_file_name = @new_filename where job_id = @save_job_id and step_id = @save_step_id
   end



-- Check for more rows to process
Delete from @tblv_filename where job_id = @save_job_id and step_id = @save_step_id and output_file_name = @save_filename

If (select count(*) from @tblv_filename) > 0
   begin
	goto start_filename_process
   end




---------------------------  Finalization  -----------------------

label99:


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_get_file_existence
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_get_file_existence]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_get_file_existence]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


create procedure dbo.dbasp_get_file_existence (
						@filename nvarchar(260),
						@exists bit = 0 output
						)

/*********************************************************
 **  Stored Procedure dbasp_get_file_existence                  
 **  From MSSQL2000 master database                
 **  
 **  This dbasp is set up to check for the existance of a file.  
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	02/16/2006	Jim Wilson		New sproc for dbaadmin.  This existed in master
--						in sql2000, but was not included in sql 2005.
--	======================================================================================


-----------------  declares  ------------------

/**
Declare @filename nvarchar(260)
Declare @exists bit

Declare @filename = '\\lkhslaslkhds'
Declare @exists = 0
--**/

    DECLARE @command nvarchar(512)
    DECLARE @retcode int
	declare @echo_text nvarchar(20)

	select @echo_text = 'file_exists'

    /*
    ** The return code from xp_cmdshell is not a reliable way to check whether the file exists or
    ** not. It is always 0 on Win95 as long as xp_cmdshell succeeds.
    */  

	select @command = N'if exist "' + @filename + N'" echo ' + @echo_text

    create table #text_ret(cmdoutput nvarchar(20) collate database_default null)

    insert into #text_ret exec @retcode = master..xp_cmdshell @command
	if @@error <> 0 or @retcode <> 0
		return 1

    if exists (select * from #text_ret where ltrim(rtrim(cmdoutput)) = @echo_text)
        select @exists = 1
    else 
        select @exists = 0

    drop table #text_ret
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_get_share_path
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_get_share_path]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_get_share_path]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_get_share_path (@share_name varchar(255),@phy_path varchar(100) OUTPUT)

/*********************************************************
 **  Stored Procedure dbasp_get_share_path                  
 **  Written by Francis Stanisci & Jim Wilson, Getty Images                
 **  10/28/2002                                      
 **  
 **  This procedure gets the drive path for a defined share.
 ***************************************************************/
  as

set nocount on


--     Created: 10-28-2002
--
--      Author: Francis Stanisci, Jim Wilson
--
--     Purpose: Retreive the physical path for a given share.
--
--        Note: This is only meant to work with servers that use the following share naming
--              convention \\<server_name>\<server_name>_<share_name>
--
--    Required: Share name, per convention above, i.e. only the share name as it would appear above
--
--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/28/2002	Francis Stanisci	New process 
--	02/15/2005	Jim Wilson		Modified fro sql2005. 
--	08/02/2007	Jim Wilson		Added some diag lines. 
--     	04/16/2010	Steve Ledridge          Added logic to Return Directory if it is passed in as
--                                              a Share Name.
--	======================================================================================

/*
declare @share_name varchar(255)
declare @phy_path varchar(100)

select @share_name = 'pcsqldev01$a_nxt'
select @phy_path = ''
--*/


DECLARE	 
	 @netuse_servername	sysname
	,@cmd			varchar(255)

IF CHARINDEX(':',@share_name) > 0 -- IF CONTAINS A ":" THEN IT MUST BE A DIRECTORY PATH
BEGIN
	SET @phy_path = @share_name
END
ELSE
BEGIN
	Select @netuse_servername = case charindex('\', @@servername)
	                            when 0 then @@servername
	                            else substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	                            end

	--PRINT @netuse_servername /* for debugging */

	Create table #ShareTempTable(path nvarchar(500) null)
	Select @cmd = 'RMTSHARE \\' + @netuse_servername + '\' + @share_name

	Insert into #ShareTempTable 
	exec master.sys.xp_cmdshell @cmd

	--select * from #ShareTempTable


	Select @phy_path = substring(path,charindex('h',path)+1,len(path)-charindex('h',path))
	from #ShareTempTable
	where path like 'path%'

	select @phy_path = ltrim(rtrim(@phy_path))
	--print @phy_path

	drop table #ShareTempTable

END

--PRINT @phy_path

/* Sample

declare @outpath varchar(255)

exec dbo.dbasp_get_share_path 'builds', @outpath output

select @outpath 

*/


 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_GetBuildInfo
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_GetBuildInfo]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_GetBuildInfo]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE dbo.dbasp_GetBuildInfo 
 
/***************************************************************
 **  Stored Procedure dbasp_GetBuildInfo                  
 **  Written by David Spriggs, Getty Images                
 **  11/18/2008                                     
 **
 **  This procedure is used to gather the build information from
 **  databases on the server. 
 ** 
 ***************************************************************/
as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/18/2008	David Spriggs		New Process
--	11/24/2008	David Spriggs		Added check for Build Table and Database
--						availability status. 
--						Added datetime and guid hash
--						to output filename to ensure uniqueness.
--	12/11/2008	David Spriggs		Changed how @dbStatus was populated.
--	07/07/2009	Jim Wilson		Added rmtshare cmd if showacls result is blank.
--	10/09/2009	Jim Wilson		Changed code from systeminfo to DEPLinfo.
--	02/22/2010	Steve Ledridge		Modified Check for Build table to only look in
--						databases that are in the db_sequence table.
--	======================================================================================

/*********************************************************************
 *                Variable Declaration
 ********************************************************************/
declare  
          @cmd					nvarchar(4000)
         ,@cmd2					nvarchar(4000)
	 ,@cmd3					nvarchar(4000)
         ,@miscprint				nvarchar(4000)
         ,@miscprint2				sysname
         ,@hold_source_path			sysname
         ,@central_server 			sysname
	 ,@BkUpDateStmp 			char(14)
	 ,@Hold_hhmmss				varchar(8)
         ,@dbName				sysname
         ,@dbName2				sysname
	 ,@dbStatus				sysname
         ,@parm1def				nvarchar(500)
         ,@parm2def				nvarchar(500)
	 ,@parm3def				nvarchar(500)
         ,@baselinedt				varchar(20)
         ,@dmn					sysname
         ,@buildNumber				varchar(50)
         ,@buildDate				varchar(20)
	 ,@bExist				int
         ,@Enviro_Type				varchar(50)
         ,@outfile_name				sysname
         ,@outfile_name2			sysname
	 ,@outfile_path				nvarchar(250)
         ,@fileexist_path			sysname
         ,@save_servername			sysname
	 ,@save_servername2			sysname
         ,@save_domain_name			sysname
         ,@save_Administrators			sysname
         ,@charpos				int
	 ,@charpos2				int



/*********************************************************************
 *                Initialization
 ********************************************************************/
Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

create table #regresults (results nvarchar(1500) null)
create table #onlineStatus (dName sysname)
	
Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
iF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_domain_name = (select env_detail from dbaadmin.dbo.local_serverenviro where env_type = 'domain')
If @save_domain_name is not null
   begin
	Select @dmn = @save_domain_name
   end
Else
   begin
	Select @dmn = 'UnKnown'
   end


--Check for Domain and Environment information
select @Enviro_Type = null

if exists(select 1 from master.sys.databases where name = 'DEPLinfo')
   begin
	select @Enviro_Type = env_name from DEPLinfo.dbo.enviro_info where env_type = 'ENVnum'
    end

If @Enviro_Type is null
   begin
	select @Enviro_Type = env_detail from dbaadmin.dbo.local_serverenviro where env_type = 'ENVname'
    end



Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2)+ substring(@Hold_hhmmss, 7, 2) 

--Create the output file
Select @outfile_name = 'BuildInformationTableUpdate_'+@BkUpDateStmp+'_'+@save_servername2 + '.gsql'
Select @outfile_name2 = 'BuildInformationTableUpdate_*.gsql'
Select @outfile_path = '\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\' + @outfile_name

--first delete pre-existing output file
Select @cmd2 = 'del \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\' + @outfile_name2+' /Q '
EXEC master.sys.xp_cmdshell @cmd2, no_output

--Create fresh copy of the output file
Select @cmd = 'copy nul ' + @outfile_path
EXEC master.sys.xp_cmdshell @cmd, no_output

Select @miscprint = '--  Build Information Table Update Script from server: ''' + @@servername + ''''
Print  @miscprint
Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
EXEC master.sys.xp_cmdshell @cmd, no_output

Select @miscprint = '--  Created: '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
exec master.sys.xp_cmdshell @cmd, no_output

Select @miscprint = ' '
Print  @miscprint
Select @cmd = 'echo.>>' + @outfile_path
exec master.sys.xp_cmdshell @cmd, no_output

----------------------------------------------------------------------------------------------
-- General Environment verification
----------------------------------------------------------------------------------------------
--  Check to see if the 'builds' folder exists

Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername + '_builds'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = 'DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = 'DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = 'DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'mdf' share exists

Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_mdf'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = 'DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
			goto label99
		   end
	   end
	Else 
	   begin
		Select @miscprint = 'DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
		goto label99
	   end
   end
Else
   begin
	Select @miscprint = 'DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
	goto label99
   end

--  Check to see if the 'nxt' share exists

Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_nxt'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = 'DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
			goto label99
		   end
	   end
	Else 
	   begin
		Select @miscprint = 'DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
		goto label99
	   end
   end
Else
   begin
	Select @miscprint = 'DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
	goto label99
   end

/****************************************************************
 *                MainLine
 ***************************************************************/
----------------------------------------------------------------------------------------------
--  Check whether the database is online or not. If not, record status
----------------------------------------------------------------------------------------------
declare offlineCur cursor for
select distinct
     s.name
    ,s.state_desc
from master.sys.databases as s
join dbaadmin.dbo.db_sequence c on s.name = c.db_name 

open offlineCur

fetch next from offlineCur into @dbName,@dbStatus

while @@fetch_status = 0
begin
	if @dbStatus <> 'ONLINE'
	    begin    
		
		Select @miscprint = 'delete from dbaadmin.dbo.DBA_DeplInfo where SQLName = '''+@@servername+''' and dbName = '''+@dbName+ ''''
		Print  @miscprint
		Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		exec master.sys.xp_cmdshell @cmd, no_output

		Select @miscprint = 'GO '
		Print  @miscprint
		Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		exec master.sys.xp_cmdshell @cmd, no_output

		Select @miscprint = 'insert into dbaadmin.dbo.DBA_DeplInfo (Domain, Enviro_Type, ServerName, SQLName, DBName, Build_Number, Build_Date,  Baseline_Date,  Record_Date)' 
		Print  @miscprint
		Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		exec master.sys.xp_cmdshell @cmd, no_output

		Select @miscprint = 'VALUES ('''+@save_domain_name+''', '''+@Enviro_Type+''',''' + @save_servername + ''',''' + UPPER(@@servername) + ''', ''' + @dbName + ''', ''NOT ONLINE(' + @dbStatus + ')'','''+CONVERT(VARCHAR(20),getdate())+''','''+CONVERT(VARCHAR(20),getdate())+''','''+CONVERT(VARCHAR(20),getdate())+''')'
		print 'VALUES ('''+@save_domain_name+''', '''+@Enviro_Type+''',''' + @save_servername + ''',''' + UPPER(@@servername) + ''', ''' + @dbName + ''', ''NOT ONLINE(' + @dbStatus + ')'','''+CONVERT(VARCHAR(20),getdate())+''','''+CONVERT(VARCHAR(20),getdate())+''','''+CONVERT(VARCHAR(20),getdate())+''')'
		Print  @miscprint
		Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		exec master.sys.xp_cmdshell @cmd, no_output

		Select @miscprint = 'GO '
		Print  @miscprint 
		Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		exec master.sys.xp_cmdshell @cmd, no_output

		Select @miscprint = ' '
		Print  @miscprint
		Select @cmd = 'echo.>>' + @outfile_path
		exec master.sys.xp_cmdshell @cmd, no_output
		fetch next from offlineCur into @dbName,@dbStatus
		break
	    end
	else
	    --Since added check for database status, now will place the online databases
	    --into a temporary table.
	    begin
		insert into #onlineStatus (dName) values (@dbname)
		 fetch next from offlineCur into @dbName,@dbStatus
	    end
       

end
close offlineCur
deallocate offlineCur

----------------------------------------------------------------------------------------------
--  Start the Capture Process
----------------------------------------------------------------------------------------------
--get databases while I do not like cursors, a cursor, given the size of the dataset, is acceptable.

declare dbCur cursor for 
select
    dname
from #onlineStatus

open dbCur

fetch next from dbCur into @dbName

while @@fetch_status = 0

	begin
	    --Check for existence of "Build" table. If no "Build" table, raise warning and move on.

	set @cmd3 = N'Use '+quotename(@dbname)+ ' select @buildExist = count(*) from sys.sysobjects where name = ''build'''
        set @parm3def = N'@buildExist int OUTPUT'
        execute sp_executesql @cmd3,@parm3def, @buildExist = @bExist output

	if (@bExist = 0)
	    begin
		Select @miscprint = 'DBA WARNING: '+ @dbName + ' is missing the "Build" table.'
		--Print @miscprint
		raiserror(@miscprint,-1,-1) with log
		break
		fetch next from dbCur into @dbName
	    end 
	else
	    begin
		    --Get Baseline Date
		 set @cmd = N'Use '+quotename(@dbName)+' select @bDate = dtBuildDate from dbo.build where vchLabel = ''Baseline Backup'' or vchLabel=''Backup, Detach & Move'''
		 set @parm1def = N'@bDate varchar(20)OUTPUT'
		 execute sp_executesql @cmd, @parm1def, @bDate = @baselinedt output
        		
		 if(@baselinedt is null)
		    begin
			select @baselinedt = 'No Baseline'
		    end

		    --Get most recent Build Date and Build Number

		    set @cmd = N'Use '+quotename(@dbName)+' SELECT @build = vchLabel, @buDate = dtbuildDate FROM dbo.build WHERE  vchlabel not like ''%backup%'' and dtBuildDate =(SELECT MAX(dtBuildDate)FROM build)'
		    set @parm2def = N'@buDate varchar(20)OUTPUT, @build varchar(50) OUTPUT'
		    execute sp_executesql @cmd, @parm2def, @buDate = @buildDate output, @build = @buildNumber output

		    --Write out the data

		    Select @miscprint = 'delete from dbaadmin.dbo.DBA_DeplInfo where SQLName = '''+@@servername+''' and dbName = '''+@dbName+ ''''
		    Print  @miscprint
		    Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		    exec master.sys.xp_cmdshell @cmd, no_output

		    Select @miscprint = 'GO '
		    Print  @miscprint
		    Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		 exec master.sys.xp_cmdshell @cmd, no_output

		    Select @miscprint = 'insert into dbaadmin.dbo.DBA_DeplInfo (Domain, Enviro_Type, ServerName, SQLName, DBName, Build_Number, Build_Date,  Baseline_Date,  Record_Date)' 
		    Print  @miscprint
		    Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		    exec master.sys.xp_cmdshell @cmd, no_output

		    Select @miscprint = 'VALUES (''' + upper(@dmn) + ''', '''+UPPER(@Enviro_type)+''',''' + @save_servername + ''',''' + UPPER(@@servername) + ''', ''' + @dbName + ''', ''' + @buildNumber + ''','''+@buildDate+''','''+@baselinedt+''','''+CONVERT(VARCHAR(20),getdate())+''')'
		    Print  @miscprint
		    Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		    exec master.sys.xp_cmdshell @cmd, no_output

		    Select @miscprint = 'GO '
		    Print  @miscprint 
		    Select @cmd = 'echo ' + @miscprint + '>>' + @outfile_path
		    exec master.sys.xp_cmdshell @cmd, no_output

		    Select @miscprint = ' '
		    Print  @miscprint
		    Select @cmd = 'echo.>>' + @outfile_path
		    exec master.sys.xp_cmdshell @cmd, no_output

		    fetch next from dbCur into @dbName
	    end
	end 
close dbCur
deallocate dbCur


-- Copy the file to the main central server, in this case SEAFRESQLDBA01
If @save_domain_name not in ('production', 'stage')
   begin
	Select @cmd = 'xcopy "' + rtrim(@outfile_path) + '" "\\seafresqldba01\seafresqldba01_SQL_Register"'
	Select @cmd = @cmd + ' /Y /R'
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output 
   end
Else
   begin
	Select @hold_source_path = '\\' + upper(@save_servername) + '\' + upper(@save_servername2) + '_dbasql\dba_reports'
	exec dbaadmin.dbo.dbasp_File_Transit @source_name = @outfile_name
		,@source_path = @hold_source_path
		,@target_env = 'AMER'
		,@target_server = 'seafresqldba01'
		,@target_share = 'seafresqldba01_SQL_Register'
   end

---------------------------  Finalization  -----------------------

label99:

drop table #fileexists
drop table #regresults
drop table #onlineStatus


 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_IndexMaint
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_IndexMaint]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_IndexMaint]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_IndexMaint (@PlanName varchar(500) = null
					,@maxfrag DECIMAL = 15.0
					,@ARITHABORT_ON char(1) = 'n'
					,@QUOTED_ID_ON char(1) = 'n'
					,@tranlog_bkp_flag char(1) = 'y'
					,@Limit_flag char(1) = 'n'
					,@Limit_tables smallint = null
					,@Limit_pages int = null
					,@Small_Limit_pages int = 11
					,@page_thresh int = 100
					,@TblLevel_UpdateStats char(1) = 'y'
					,@process_all_small char(1) = 'n'
					,@process_clust_index char(1) = 'n'
					,@sample_percent smallint = 20
				    )
 
/***************************************************************
 **  Stored Procedure dbasp_IndexMaint                  
 **  Written by Jim Wilson, Getty Images                
 **  November 24, 2003                                      
 **
 **  This proc accepts the following input parms:
 **  @PlanName      	- name of the maintenance plan that will specify
 **                       the list of databases to process.
 **  @maxfrag       	- maximum fagmentation threshold allowed.
 **  @ARITHABORT_ON 	- 'y' or 'n' to indicate if this set command should
 **			  be run. 
 **  @QUOTED_ID_ON  	- 'y' or 'n' to indicate if this set command should
 **			  be run. 
 **
 **  @tranlog_bkp_flag	- 'y' or 'n' to indicate if this set command should
 **			  be run. 
 **  @Limit_flag	- 'y' or 'n' to indicate if processing should be limited
 **			  @limit_tables and @limit_pages must also be specified.
 **  @Limit_tables	- The number of large tables to process.  Limit Size is 
 **			  set using @limit_pages. smallint = null
 **  @Limit_pages	- Set the size (in pages) for large tables 
 **
 **  @Small_Limit_pages	- Indexes with a page count lower than this will be skipped. 
 **
 **  @page_thresh	- Set the cut off point between doing a dbreindex and a defrag (in pages) 
 **
 **  @TblLevel_UpdateStats - 'y' or 'n' to indicate that table level update stats will be done 
 **
 **  @process_all_small - 'y' or 'n' to indicate that all small indexes should be processed.
 **			  Small indexes is defined by @page_thresh and this overrides the input
 **			  parm @small_limit_pages. 
 **
 **  @process_clust_index - 'y' or 'n' to indicate that all clustered indexes should be processed.
 **			  The default is 'n'.
 **
 **  @sample_percent      - number from 0 to 100.  Note: 0 will format the update stats without
 **                         a specific percent (it lets SQL decide)
 **
 **  This procedure creates a file to run the index maint process 
 **  for each database specified in the selected maintenance plan.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     				Desc
--	==========	====================	=============================================
--	12/10/2003	Jim Wilson		Revised process
--	02/02/2004	Jim Wilson		Added scan density to the process
--	02/04/2004	Jim Wilson		Added tranlog backup to the process
--	04/26/2004	Jim Wilson		Aded insert to table for seperate update stats process.
--	08/30/2004	Jim Wilson		Brackets around DB names in cursor.
--	10/12/2004	Jim Wilson		Added insert to table for fragmentation log data.
--	10/21/2004	Jim Wilson		Added purge for fragmentation log table.
--	12/01/2004	Jim Wilson		Added input parm for tranlog backup.
--	12/06/2004	Jim Wilson		Added input parms for limiting large tables.
--	03/30/2005	Jim Wilson		Removed cursors and xp_cmdshell.
--	04/22/2005	Jim Wilson		Fix sub query that returned mutiple results
--	05/17/2005	Jim Wilson		Added fragmentation threshold override process
--	07/19/2005	Jim Wilson		Changed page_thresh to an input variable
--	09/28/2005	Jim Wilson		Added table level update stats input parm.
--	10/05/2005	Jim Wilson		New input parm for small table limit and new code for
--						fragmentation_nocheck table processing.
--	10/18/2005	Jim Wilson		Added object owner info to commands
--	02/07/2006	Jim Wilson		New code ( and input parm) to process all small indexes and
--						added 'with 20%' to update stats at table level.
--	02/16/2006	Jim Wilson		Modified for sql 2005
--	06/13/2006	Jim Wilson		Increased sixe of variables from varchar(500) to 1500.
--	06/14/2006	Jim Wilson		Added check for disabled indexs.  Fixed @process_all_small logic.
--	06/19/2006	Jim Wilson		Moved temp table create stmts.
--	08/11/2006	Jim Wilson		Added standard header insert to table fragmentation_LOG.
--	08/18/2006	Jim Wilson		Added code for SET QUOTED_IDENTIFIER ON
--	09/07/2006	Jim Wilson		Added brackets to ALTER commands
--	01/26/2007	Jim Wilson		Removed scan density from process
--						added @process_clust_index parm.
--	02/29/2008	Jim Wilson		Added sample percent input parm.
--	09/22/2008	Jim Wilson		Fixed owner issue.  Now looking at sys.schemas.
--	10/26/2009	Jim Wilson		Turn off tranlog backup for simple DB's.
--	======================================================================================

/***
declare @PlanName varchar(500)
declare @ARITHABORT_ON char(1)
declare @QUOTED_ID_ON char(1)
declare @maxfrag DECIMAL
declare @tranlog_bkp_flag char(1)
declare @Limit_flag char(1)
declare @Limit_tables smallint
declare @Limit_pages int
declare @Small_Limit_pages int
declare @page_thresh int
declare @TblLevel_UpdateStats char(1)
declare @process_all_small char(1)
declare @process_clust_index char(1)
declare @sample_percent smallint


select @PlanName = 'mplan_user_defrag'
select @maxfrag = 15.0
select @ARITHABORT_ON = 'n'
select @QUOTED_ID_ON = 'n'
select @tranlog_bkp_flag = 'y'
select @Limit_flag = 'n'
--select @Limit_tables = 1
--select @Limit_pages = 500000
select @Small_Limit_pages = 11
select @page_thresh = 100
select @TblLevel_UpdateStats = 'y'
select @process_all_small = 'n'
select @process_clust_index = 'n'
select @sample_percent = 0
--***/


Declare	 
	 @miscprint			nvarchar(4000)
	,@error_count			int
	,@sqlcmd			nvarchar(1500)
	,@cmd				nvarchar(1500)
	,@save_ObjectName		sysname
	,@owner				sysname
	,@backup_tran_limit		int
	,@page_count			int
	,@Limit_table_count		smallint
	,@Limit_reached_flag		char(1)
	,@newe_ObjectName_flag		char(1)
	,@tranlog_bkp_flag_internal	char(1)
	,@save_maxfrag			nvarchar(10)
	,@save_minscan			nvarchar(10)
	,@db_id				smallint

DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu16ObjectName	sysname
	,@cu16ObjectId		int
	,@cu16IndexName		sysname
	,@cu16IndexId		int
	,@cu16partitionnum	bigint
	,@cu16CountPages	int
	,@cu16ScanDensity	DECIMAL
	,@cu16LogicalFrag	DECIMAL
	,@cu16is_disabled	bit
	,@cu16allow_page_locks 	bit


----------------  initial values  -------------------
Select @error_count = 0
Select @save_ObjectName = ' '
Select @backup_tran_limit = 50000
Select @Limit_table_count = 0
Select @limit_reached_flag = 'n'
Select @newe_ObjectName_flag = 'n'
Select @save_maxfrag = convert(nvarchar(10), @maxfrag)
Select @tranlog_bkp_flag_internal = 'n'

If @sample_percent not between 0 and 100
   or @sample_percent is null
   begin
	select @sample_percent = 20
   end


-- Create temp table to hold output information
declare @tvar_dbnames table(dbname sysname)

CREATE TABLE #fraglist
(
 ObjectName nvarchar(255)
,ObjectId int
,owner nvarchar(255)
,IndexName nvarchar(255)
,IndexId int
,partitionnum bigint
,LogicalFrag FLOAT
,CountPages bigint
,is_disabled bit
,allow_page_locks bit
,Process_flag char(1) null
)


--  Check input parameters
If @PlanName is null
   begin
	raiserror('DBA WARNING: Invaild parameter passed to dbasp_IndexMaint - @PlanName cannot be null',-1,-1)
	Select @error_count = @error_count + 1
	goto label99
   end

If not exists (select * from msdb.dbo.sysdbmaintplans Where plan_name = @PlanName)
   begin
	raiserror('DBA WARNING: Invaild parameter passed to dbasp_IndexMaint - @PlanName parm is invalid',-1,-1)
	Select @error_count = @error_count + 1
	goto label99
   end

If @Limit_flag = 'y' and (@Limit_tables is null or @Limit_pages is null)
   begin
	raiserror('DBA WARNING: Invaild parameter passed to dbasp_IndexMaint - @Limit_tables and @Limit_pages must be specified',-1,-1)
	Select @error_count = @error_count + 1
	goto label99
   end

If @Small_Limit_pages is null
   begin
	raiserror('DBA WARNING: Invaild parameter passed to dbasp_IndexMaint - @Small_Limit_pages must be numeric',-1,-1)
	Select @error_count = @error_count + 1
	goto label99
   end

If @Limit_flag = 'y' and @Limit_tables = 0
   begin
	Select @limit_reached_flag = 'y'
   end




--  Clean out privious defrag table info
delete from dbaadmin.dbo.defrag_table_info


--  Purge old records from the fragmentation_LOG table (6 months)
delete from dbaadmin.dbo.fragmentation_LOG where datediff(dd, frag_recdate, getdate()) > 180



/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'SQL Index Maint Process'  
Print  @miscprint
Select @miscprint = 'Created For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
If @process_clust_index = 'n'
   begin
	Select @miscprint = 'Note: Clustered Indexes will be skipped.'
	Print  @miscprint
   end
Print  '************************************************************************/'
Print  ' '
Select @miscprint = '--  Insert Start record into the fragmentation_LOG table'  
Print  @miscprint
Select @miscprint = 'insert into dbaadmin.dbo.fragmentation_LOG values (''dbaadmin'', ''Start Defrag Process'', '''', 0, 0, 0, 0, getdate())'  
Print  @miscprint
Print  'go'
Print  ' '


--------------------  Cursor for DB names in the maintenance plan  -------------------
insert @tvar_dbnames select distinct(d.database_name) 
			From msdb.dbo.sysdbmaintplan_databases  d, msdb.dbo.sysdbmaintplans  s 
			Where d.plan_id = s.plan_id
			  and s.plan_name = @PlanName

Delete from @tvar_dbnames where dbname is null or dbname = ''
--select * from @tvar_dbnames

If (select count(*) from @tvar_dbnames) > 0
   begin
	start_dbname:
	Select @cu11DBName = (Select top 1 dbname from @tvar_dbnames)

	Select @page_count = 0
	Delete from #fraglist

	Select @miscprint = 'Use ' + @cu11DBName 
	Print @miscprint
	Print 'go'
	Print ' '


	-- Set tranlog backup flag
	If @tranlog_bkp_flag = 'y' and databaseproperty(@cu11DBName, 'IsTrunclog') = 0

	   begin
		Select @tranlog_bkp_flag_internal = 'y'
	   end
	Else

	   begin
		Select @tranlog_bkp_flag_internal = 'n'
	   end



	Select @miscprint = 'SET QUOTED_IDENTIFIER ON' 
	Print @miscprint
	Print 'go'
	Print ' '

	Print  '/************************************************************************'
	Select @miscprint = 'Index Maint Process Start for database ' + @cu11DBName
	Print  @miscprint
	Print  '************************************************************************/'

	Select @miscprint = 'Print ''Start Index Maint on database ' + @cu11DBName + ''''
	Print @miscprint
	Print 'Select getdate()'
	Print 'go'
	Print ' '

	--  Gather fragmentation info for this databases tables and indexes
	SET @db_id = DB_ID(@cu11DBName)

	If @process_clust_index = 'n'
	   begin
		Select @sqlcmd = 'Insert into #fraglist SELECT ob.name, dm.object_id, sc.name, ix.name, dm.index_id, dm.partition_number, dm.avg_fragmentation_in_percent, dm.page_count, ix.is_disabled, ix.allow_page_locks, ''x'' 
FROM master.sys.dm_db_index_physical_stats(' + convert(nvarchar(10), @db_id) 
	+ ', NULL, NULL, NULL, ''limited'')  dm, ' + @cu11DBName + '.sys.indexes  ix, ' 
	+ @cu11DBName + '.sys.objects ob, ' + @cu11DBName + '.sys.schemas  sc
where dm.index_type_desc NOT IN( ''HEAP'', ''CLUSTERED INDEX'')
  and dm.object_id = ix.object_id
  and dm.index_id = ix.index_id
  and dm.object_id = ob.object_id
  and sc.schema_id = ob.schema_id
  and dm.index_id > 0
  and dm.page_count > 0'
	   end
	Else
	   begin
		Select @sqlcmd = 'Insert into #fraglist SELECT ob.name, dm.object_id, sc.name, ix.name, dm.index_id, dm.partition_number, dm.avg_fragmentation_in_percent, dm.page_count, ix.is_disabled, ix.allow_page_locks, ''x'' 
FROM master.sys.dm_db_index_physical_stats(' + convert(nvarchar(10), @db_id) 
	+ ', NULL, NULL, NULL, ''limited'')  dm, ' + @cu11DBName + '.sys.indexes  ix, ' 
	+ @cu11DBName + '.sys.objects ob, ' + @cu11DBName + '.sys.schemas  sc
where dm.index_type_desc NOT IN( ''HEAP'')
  and dm.object_id = ix.object_id
  and dm.index_id = ix.index_id
  and dm.object_id = ob.object_id
  and sc.schema_id = ob.schema_id
  and dm.index_id > 0
  and dm.page_count > 0'
	   end


	--print @sqlcmd


	EXEC dbo.sp_executesql @sqlcmd

	delete from #fraglist where ObjectName is null or ObjectName = ''
	--select * from #fraglist

	--  Delete tables that should not be processed based on the nocheck table
	If (select count(*) from #fraglist) > 0
	   begin
		Delete from #fraglist where ObjectName in (select frag_TBLname from dbo.fragmentation_nocheck where frag_DBname = @cu11DBName)
	   end


	Update #fraglist set Process_flag = 'x'


	--  Process indexes for this database
	If (select count(*) from #fraglist where Process_flag = 'x') > 0
	   begin
		start_check_fraglist:
		Select @cu16ObjectId = (Select top 1 ObjectId from #fraglist where Process_flag = 'x')
		Select @cu16ObjectName = (Select top 1 ObjectName from #fraglist where ObjectId = @cu16ObjectId)
		Select @cu16IndexId = (Select top 1 IndexId from #fraglist where ObjectId = @cu16ObjectId and Process_flag = 'x')
		Select @cu16LogicalFrag = (Select top 1 LogicalFrag from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId order by LogicalFrag desc)
		Select @cu16countpages = (Select sum(CountPages) from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId)


		If exists (select * from fragmentation_override where frag_DBname = @cu11DBName and frag_TBLname = @cu16ObjectName)
		   begin
			If (select frag_MaxFrag from fragmentation_override where frag_DBname = @cu11DBName and frag_TBLname = @cu16ObjectName) < @cu16LogicalFrag
			   begin
				Update #fraglist set Process_flag = 'y' where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId
			   end
			Else
			   begin
				Update #fraglist set Process_flag = 'n' where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId
			   end
		   end
		Else
		   begin
			If (@save_maxfrag < @cu16LogicalFrag)
			   begin
				Update #fraglist set Process_flag = 'y' where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId
			   end
			Else If @cu16countpages < @page_thresh and @process_all_small = 'y'
			   begin
				Update #fraglist set Process_flag = 'y' where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId
			   end
			Else
			   begin
				Update #fraglist set Process_flag = 'n' where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId
			   end
		   end

		--  Check to see if there are more rows to process
		If (select count(*) from #fraglist where Process_flag = 'x') > 0
		   begin
			goto start_check_fraglist
		   end

	   end


	If @process_all_small = 'y'
	   begin
		update #fraglist set Process_flag = 'y' where CountPages < @Small_Limit_pages
	   end
	--select * from #fraglist



	Delete from #fraglist where Process_flag = 'n'
	--select * from #fraglist




	--  Now run the IndexMaint process for the tables and indexes that need it
	If (select count(*) from #fraglist) > 0
	   begin
		start_fraglist:

		Select @cu16ObjectId = (Select top 1 ObjectId from #fraglist)
		Select @cu16ObjectName = (Select top 1 ObjectName from #fraglist where ObjectId = @cu16ObjectId)
		Select @cu16IndexId = (Select top 1 IndexId from #fraglist where ObjectId = @cu16ObjectId)
		Select @cu16IndexName = (Select top 1 IndexName from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId)
		Select @cu16partitionnum = (Select top 1 partitionnum from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId)
		Select @cu16CountPages = (Select sum(CountPages) from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId and partitionnum = @cu16partitionnum)
		Select @cu16LogicalFrag = (Select top 1 LogicalFrag from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId and partitionnum = @cu16partitionnum order by LogicalFrag desc)
		Select @cu16is_disabled = (Select top 1 is_disabled from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId and partitionnum = @cu16partitionnum)
		Select @cu16allow_page_locks = (Select top 1 allow_page_locks from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId and partitionnum = @cu16partitionnum)


		--  Update stats process for previous table if we are using the table level update stats process
		If @cu16ObjectName <> @save_ObjectName
		   begin
			If @save_ObjectName <> ' ' and @TblLevel_UpdateStats = 'y'
			   begin
				Select @miscprint = '-- UPDATING STATISTICS for table ' + @owner + '.' + (rtrim(@save_ObjectName))
				Print  @miscprint

				If @sample_percent = 0
				   begin
					Select @cmd = 'UPDATE STATISTICS ' + @owner + '.[' + rtrim(@save_ObjectName) + ']'
					Print @cmd
				   end
				Else
				   begin
					Select @cmd = 'UPDATE STATISTICS ' + @owner + '.[' + rtrim(@save_ObjectName) + '] WITH SAMPLE ' + convert(nvarchar(5), @sample_percent) + ' PERCENT'
					Print @cmd
				   end

				Print  'go'
				Print  ' '

				select @miscprint = 'Waitfor delay ''00:00:02'''
				print  @miscprint
				select @miscprint = 'go'
				print  @miscprint
				Print  ' '
				Print  ' '
			   end
		   end

		Select @owner = (Select top 1 owner from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId and partitionnum = @cu16partitionnum)

		Select @cmd = 'USE ' + quotename(@cu11DBName) 
				+ ' SELECT @owner = (select su.name from sys.schemas su, sys.objects so where su.schema_id = so.schema_id and so.object_id = ' 
				+ convert(varchar(20), @cu16ObjectId) + ')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@owner sysname output', @owner output
		--print @owner


		Select @miscprint = '/***'
		Print  @miscprint
		Select @miscprint = 'For table ''' + @owner + '.' + rtrim(@cu16ObjectName) + ''' with ' + convert(varchar(20), @cu16CountPages) + ' pages.'
		Print  @miscprint
		Select @miscprint = '  Fragmentation currently ' + RTRIM(CONVERT(varchar(15),@cu16LogicalFrag)) + '% for index ' + rtrim(@cu16IndexName)
		Print  @miscprint
		Select @miscprint = '***/'
		Print  @miscprint



		If @limit_flag = 'y' 
		   and @cu16CountPages > @Limit_pages 
		   and @limit_reached_flag = 'y'
		   begin
			Print  ' '
			Select @miscprint = '-------------------------------------------------------------------------------------'
			Print  @miscprint
			Select @miscprint = '--  Limit for large tables has been reached.  This table/index will not be processed.'
			Print  @miscprint
			Select @miscprint = '-------------------------------------------------------------------------------------'
			Print  @miscprint
			Print  ' '
			goto label59
		   end


		If @limit_flag = 'y'
		   and @cu16CountPages > @Limit_pages
		   and @Limit_table_count < @Limit_tables
		   begin
			Select @Limit_table_count = @Limit_table_count + 1
			Select @limit_reached_flag = 'y'
		   end



		Select @miscprint = 'Print convert(varchar(30),getdate(),9)'
		Print  @miscprint

		If @cu16CountPages > @page_thresh
		   begin
			Select @miscprint = 'Print ''Running ALTER INDEX REORGANIZE for ' + @owner + '.' + rtrim(@cu16ObjectName) + ' ' + rtrim(@cu16IndexName) + ''''
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = 'Print ''Running ALTER INDEX REBUILD for ' + @owner + '.' + rtrim(@cu16ObjectName) + ' ' + rtrim(@cu16IndexName) + ''''
			Print  @miscprint
		   end


		If @ARITHABORT_ON = 'y'
		   begin
			Print 'SET ARITHABORT ON'
		   end

		If @QUOTED_ID_ON = 'y'
		   begin
			Print 'SET QUOTED_IDENTIFIER ON'
		   end


		If @cu16CountPages > @page_thresh
		   begin
			Select @cmd = 'ALTER INDEX [' + rtrim(@cu16IndexName) + '] ON [' + @owner + '].[' + rtrim(@cu16ObjectName) + '] REORGANIZE'
		    IF @cu16partitionnum > 1
			   begin
				SELECT @cmd = @cmd + ' PARTITION=' + CONVERT (CHAR, @cu16partitionnum)
			   end

			If @cu16is_disabled = 1
			   begin
				Print '-- Warning: The following index is disabled. REORGANIZE is not allowed.'
				Select @cmd = '--' + @cmd 
				Print @cmd
				Print  'go'
				Print  ' '
			   end
			Else If @cu16allow_page_locks = 0
			   begin
				Print '-- Warning: The following index is set to NOT allow page locks. REORGANIZE is not allowed.'
				Select @cmd = '--' + @cmd
				Print @cmd
				Print  'go'
				Print  ' '
			   end
			Else
			   begin
				Print @cmd
				Print  'go'
				Print  ' '
			   end
		   end
		Else
		   begin
			Select @cmd = 'ALTER INDEX [' + rtrim(@cu16IndexName) + '] ON [' + @owner + '].[' + rtrim(@cu16ObjectName) + '] REBUILD'
		    IF @cu16partitionnum > 1
			   begin
				SELECT @cmd = @cmd + ' PARTITION=' + CONVERT (CHAR, @cu16partitionnum)
			   end
			Print @cmd
			Print  'go'
			Print  ' '
		   end


		--  This table is used for a more complete update stats process
		insert into dbaadmin..defrag_table_info (defrag_dbname, defrag_tablename, defrag_indexname) values (@cu11DBName, @cu16ObjectName, @cu16IndexName)


		--  This table is used to track historical fragmentation information
		insert into dbaadmin..fragmentation_LOG (frag_DBname, frag_TBLname, frag_IDXname, frag_IDX_ID, frag_pages, frag_frag_pct, frag_sdensity_pct, frag_recdate) 
			values (@cu11DBName, @cu16ObjectName, @cu16IndexName, @cu16IndexId, @cu16CountPages, @cu16LogicalFrag, @cu16ScanDensity, getdate())



		If @TblLevel_UpdateStats <> 'y'
		   begin
			Select @miscprint = '-- UPDATING STATISTICS for table ' + @owner + '.' + (rtrim(@cu16ObjectName))
			Print  @miscprint

			If @sample_percent = 0
			   begin
				Select @cmd = 'UPDATE STATISTICS ' + @owner + '.[' + rtrim(@save_ObjectName) + ']'
				Print @cmd
			   end
			Else
			   begin
				Select @cmd = 'UPDATE STATISTICS ' + @owner + '.[' + rtrim(@save_ObjectName) + '] WITH SAMPLE ' + convert(nvarchar(5), @sample_percent) + ' PERCENT'
				Print @cmd
			   end


			Print  'go'
			Print  ' '

			If @cu16CountPages > 1000
			   begin
				select @miscprint = 'Waitfor delay ''00:00:05'''
				print  @miscprint
				select @miscprint = 'go'
				print  @miscprint
				Print  ' '
			   end

			Print  ' '
		   end


		Select @page_count = @page_count + @cu16CountPages
		If @page_count > @backup_tran_limit and @tranlog_bkp_flag_internal = 'y'
		   begin
			Select @page_count = 0

			Select @miscprint = '-- BACKING up the Transaction Log for database ' + rtrim(@cu11DBName)
			Print  @miscprint
			Select @miscprint = 'exec dbaadmin.dbo.dbasp_Backup_Tranlog @DBName = ''' + rtrim(@cu11DBName) + ''''
			Print  @miscprint

			Print  'go'
			Print  ' '
			select @miscprint = 'Waitfor delay ''00:00:05'''
			print  @miscprint
			Print  'go'
			Print  ' '
		   end

		label59:


		Select @save_ObjectName = rtrim(@cu16ObjectName)

		--  Check to see if there are more index maint records to process
		Delete from #fraglist where ObjectId = @cu16ObjectId and IndexId = @cu16IndexId and partitionnum = @cu16partitionnum
		If (select count(*) from #fraglist) > 0
		   begin
			goto start_fraglist
		   end


	   end


	--  One last update stats if we are doing it at the table level
	If @TblLevel_UpdateStats = 'y' and @save_ObjectName <> ' '
	   begin
		Select @miscprint = '-- UPDATING STATISTICS for table ' + @owner + '.' + (rtrim(@save_ObjectName))
		Print  @miscprint

		If @sample_percent = 0
		   begin
			Select @cmd = 'UPDATE STATISTICS ' + @owner + '.[' + rtrim(@save_ObjectName) + ']'
			Print @cmd
		   end
		Else
		   begin
			Select @cmd = 'UPDATE STATISTICS ' + @owner + '.[' + rtrim(@save_ObjectName) + '] WITH SAMPLE ' + convert(nvarchar(5), @sample_percent) + ' PERCENT'
			Print @cmd
		   end


		Print  'go'
		Print  ' '
		Print  ' '
	   end


	Print 'Print '' '''
	Select @miscprint = 'Print ''End of Index Maint on database ' + @cu11DBName + ''''
	Print @miscprint
	Print 'Select getdate()'
	Print 'go'
	Print ' '

	Print  '/************************************************************************'
	Select @miscprint = 'Index Maint Process Complete for database ' + @cu11DBName
	Print  @miscprint
	Print  '************************************************************************/'
	Print  ' '


	Select @save_ObjectName = ' '


	--  Check to see if there are more databases to process
	Delete from @tvar_dbnames where dbname = @cu11DBName
	If (select count(*) from @tvar_dbnames) > 0
	   begin
		goto start_dbname
	   end

   end


-----------------------------------------------------------------------------------------------------------------
--  Finalization  -----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------

label99:

drop table #fraglist


Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'SQL Index Maint Process Complete '
Print  @miscprint
Print  '************************************************************************/'

 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_internalGetDBName
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_internalGetDBName]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_internalGetDBName]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[dbasp_internalGetDBName]
 
/**************************************************************
 **  Stored Procedure dbasp_internalGetDBName                  
 **  Written by David Spriggs, Getty Images                
 **  September 25, 2008                                      
 **  
 **  Returns the database names from dbo.DBA_DBInfo
 **  table.
 **
 ***************************************************************/
  as
BEGIN

	SET NOCOUNT ON;
	SELECT
		DBName
	FROM dbo.DBA_DBInfo
	GROUP BY DBName
	ORDER BY DBName
END
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_internalGetEnviroByDB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_internalGetEnviroByDB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_internalGetEnviroByDB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[dbasp_internalGetEnviroByDB]
				 (@db sysname) 
/**************************************************************
 **  Stored Procedure dbasp_internalGetEnviroByDB                  
 **  Written by David Spriggs, Getty Images                
 **  September 25, 2008                                      
 **  
 **  Returns the SQL Instance, database name and
 **  Environment by database.
 **
 ***************************************************************/
  as
BEGIN

	SET NOCOUNT ON;
		
	  SELECT
		SQLNAME,
		Envnum,
        'BaseLineFolder'=
		CASE BaseLineFolder
			WHEN '  ' THEN 'No BaseLineFolder'
			ELSE BaseLineFolder
        END,
		BaselineServerName
	FROM dbo.DBA_DBInfo
	WHERE DBNAme = @db
	ORDER BY Envnum
	
END
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_internalGetEnviroInfoByApp
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_internalGetEnviroInfoByApp]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_internalGetEnviroInfoByApp]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[dbasp_internalGetEnviroInfoByApp] 
				 (@appl sysname)
/**************************************************************
 **  Stored Procedure dbasp_internalGetEnviroInfoByApp                  
 **  Written by David Spriggs, Getty Images                
 **  September 25, 2008                                      
 **  
 **  Returns the baseline folder, SQL Instance, 
 **  database name and environment by Application.
 **
 ***************************************************************/
  as
BEGIN

	SET NOCOUNT ON;
	SELECT
		DISTINCT
		 'BaseLineFolder'=
		CASE BaseLineFolder
			WHEN '  ' THEN 'No BaseLineFolder'
			ELSE BaseLineFolder
        END,
		BaseLineServerName,
		SQLName,
	    ENVnum
	FROM dbo.DBA_DBInfo
	WHERE Appl_desc = @appl
      AND BaseLineFolder <> ' '
	ORDER BY ENVnum
END
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_JobController
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_JobController]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_JobController]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_JobController (@JobNameMask sysname = 'BASE'
					 ,@ControlName sysname = 'job_control'
					 ,@restore_StartTime int = 600
					 ,@auto_reset char(1) = 'n'
					 )
 
/*********************************************************
 **  Stored Procedure dbasp_JobController                  
 **  Written by Jim Wilson, Getty Images                
 **  September 11, 2008                                      
 **  
 **  This dbasp is set up to run a series of jobs (job stream), each
 **  job one after the other.
 **
 **  Input Parms:
 **  @JobNameMask - The first Part of the job name (all jobs must start with the same name mask)
 **
 **  @ControlName - This will be the subject value in the control table.
 ** 
 **  @restore_StartTime - For restore jobs, the time they can start (605 would be 6:05AM)
 **
 **  @auto_reset - When 'y', this will reset the process to the current running job.
 **
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/11/2008	Jim Wilson		New process
--	======================================================================================


/**
declare @JobNameMask sysname
declare @ControlName sysname
declare @restore_StartTime int
declare @auto_reset char(1)

select @JobNameMask = 'BASE'
Select @ControlName = 'job_control'
select @restore_StartTime = 600
select @auto_reset = 'n'
--**/


DECLARE
	 @miscprint			nvarchar(500)
	,@is_sysadmin			int
	,@job_owner			sysname
	,@message			nvarchar(500)
	,@save_current_jobname		sysname
	,@save_next_jobname		sysname
	,@save_current_jobid		UNIQUEIDENTIFIER
	,@save_next_jobid		UNIQUEIDENTIFIER
	,@save_instance_id		int
	,@hhmm				nvarchar(5)
	,@hhmm_int			int


/*********************************************************************
 *                Initialization
 ********************************************************************/

CREATE TABLE #xp_results (job_id                UNIQUEIDENTIFIER NOT NULL,
                          last_run_date         INT              NOT NULL,
                          last_run_time         INT              NOT NULL,
                          next_run_date         INT              NOT NULL,
                          next_run_time         INT              NOT NULL,
                          next_run_schedule_id  INT              NOT NULL,
                          requested_to_run      INT              NOT NULL, -- BOOL
                          request_source        INT              NOT NULL,
                          request_source_id     sysname          NULL,
                          running               INT              NOT NULL, -- BOOL
                          current_step          INT              NOT NULL,
                          current_retry_attempt INT              NOT NULL,
                          job_state             INT              NOT NULL)

SELECT @is_sysadmin = ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0)
SELECT @job_owner = SUSER_SNAME()
  
INSERT INTO #xp_results
   EXECUTE master.sys.xp_sqlagent_enum_jobs @is_sysadmin, @job_owner


--  Remove rows that dont match the job mask
delete from #xp_results where job_id not in (select job_id from msdb.dbo.sysjobs where name like @JobNameMask + '%')
--select * from #xp_results



/****************************************************************
 *  Main Process
 ***************************************************************/

--  Auto reset process
If @auto_reset = 'y'
   begin
	If not exists (select 1 from #xp_results where job_state = 1)
	   begin
		Print 'Job Controller Auto Reset failed.  No matching jobs are running at this time.'
		raiserror(67016, 16, -1, @message)
		goto label99
	   end

	If (select count(*) from #xp_results where job_state = 1) > 1
	   begin
		Print 'Job Controller Auto Reset failed.  More than one job is running at this time.'
		raiserror(67016, 16, -1, @message)
		goto label99
	   end

	Select @save_current_jobid = (select top 1 job_id from #xp_results where job_state = 1)
	Select @save_current_jobname = (select top 1 name from msdb.dbo.sysjobs where job_id = @save_current_jobid)
	Delete from dbo.Local_Control where subject = @ControlName
	Insert into dbo.Local_Control values(@ControlName, @save_current_jobname, '', '')
	goto label99	
   end

	

-- If no rows are found in the dbo.Local_Control table, error out 
If (select count(*) from dbo.Local_Control where subject = @ControlName) = 0
   begin
	Select @message = 'No job_control record exists in the DBAADMIN Local_Control table'
	Print @message
	raiserror(67016, 16, -1, @message)
	goto label99
   end

-- If more than one row is found in the dbo.Local_Control table, error out 
If (select count(*) from dbo.Local_Control where subject = @ControlName) > 1
   begin
	Select @message = 'More than one job_control record exists in the DBAADMIN Local_Control table'
	Print @message
	raiserror(67016, 16, -1, @message)
	goto label99
   end


--  Check to see what job has been started
Set @save_current_jobname = null
Select @save_current_jobname = (select detail01 from dbo.Local_Control where subject = @ControlName)




--  Get the job_id for this job
Set @save_current_jobid = null
Select @save_current_jobid = (select job_id from msdb.dbo.sysjobs where name = @save_current_jobname and originating_server_id = 0)

-- If no rows were found in the dbo.Local_Control table, error out 
If @save_current_jobid is null
   begin
	Select @message = 'Unable to find job_id for job ''' + @save_current_jobname + '''. '
	Print @message
	raiserror(67016, 16, -1, @message)
	goto label99
   end


--  Check the status of the current job

--  If the current job is running, end this process
If (select job_state from #xp_results where job_id = @save_current_jobid) in (1, 2, 3, 7)
   begin
	Print 'Current job ''' + @save_current_jobname + ''' is running. ' + convert(varchar(30),getdate(),120)
	goto label99
   end


--  If the current job is not idle, error out
 If (select job_state from #xp_results where job_id = @save_current_jobid) <> 4
   begin
	Print 'Current job ''' + @save_current_jobname + ''' is in a bad state. ' + convert(varchar(30),getdate(),120)
	raiserror(67016, 16, -1, @message)
	goto label99
   end



--  If the current job is idle (at this point it must be), get the history info
Select @save_instance_id = (Select top 1 instance_id from msdb.dbo.sysjobhistory where job_id = @save_current_jobid order by instance_id desc)

-- check to see if the job is still running
If (select run_status from msdb.dbo.sysjobhistory where instance_id = @save_instance_id) = 4 -- in-process
   begin
	Print 'Current job ''' + @save_current_jobname + ''' is running. ' + convert(varchar(30),getdate(),120)
	goto label99
   end

-- check to see if the job is in retry mode
If (select run_status from msdb.dbo.sysjobhistory where instance_id = @save_instance_id) = 2 -- retry
   begin
	Print 'Current job ''' + @save_current_jobname + ''' is retrying. ' + convert(varchar(30),getdate(),120)
	goto label99
   end

-- check to see if the job has failed
If (select run_status from msdb.dbo.sysjobhistory where instance_id = @save_instance_id) = 0 -- failed
   begin
	Print 'Current job ''' + @save_current_jobname + ''' has failed. ' + convert(varchar(30),getdate(),120)
	raiserror(67016, 16, -1, @message)
	goto label99
   end

-- check to see if the job has been cancelled
If (select run_status from msdb.dbo.sysjobhistory where instance_id = @save_instance_id) = 3 -- cancelled
   begin
	Print 'Current job ''' + @save_current_jobname + ''' has been cancelled. ' + convert(varchar(30),getdate(),120)
	raiserror(67016, 16, -1, @message)
	goto label99
   end

-- check to make sure the job succeeded
If (select run_status from msdb.dbo.sysjobhistory where instance_id = @save_instance_id) <> 1 -- success
   begin
	Print 'Current job ''' + @save_current_jobname + ''' has unknown history run status. ' + convert(varchar(30),getdate(),120)
	raiserror(67016, 16, -1, @message)
	goto label99
   end


--  At this point we know the job succeeded.  Check to see if there is another job to start.
If exists (select 1 from msdb.dbo.sysjobs where name like @JobNameMask + '%' and name > @save_current_jobname)
   begin
	Select @save_next_jobname = (select top 1 name from msdb.dbo.sysjobs where name like @JobNameMask + '%' and name > @save_current_jobname order by name) 

	--  Get the Next job job_id.
	Set @save_next_jobid = null
	Select @save_next_jobid = (select job_id from msdb.dbo.sysjobs where name = @save_next_jobname and originating_server_id = 0)

	-- If no rows were found in the dbo.Local_Control table, error out 
	If @save_next_jobid is null
	   begin
		Select @message = 'Unable to find job_id for next job ''' + @save_next_jobname + '''. '
		Print @message
		raiserror(67016, 16, -1, @message)
		goto label99
	   end

	--  If the next job is running, error out
	If (select job_state from #xp_results where job_id = @save_next_jobid) in (1, 2, 3, 7)
	   begin
		Select @message = 'Next job ''' + @save_next_jobname + ''' is running. ' + convert(varchar(30),getdate(),120)
		Print @message
		raiserror(67016, 16, -1, @message)
		goto label99
	   end


	--  Check to see if the next job is a restore.
	If @save_next_jobname like '%Restore%'
	   begin
		--  check current time against input parm.  If it's not time yet, end the process.
		select @hhmm = convert(nvarchar(5), getdate(), 8)
		select @hhmm = replace(@hhmm, ':', '')
		select @hhmm_int = convert(int, @hhmm)

		If @hhmm_int < @restore_StartTime
		   begin
			Select @message = 'Not time to start restore jobs yet.  Job ''' + @save_next_jobname + '''. ' + convert(varchar(30),getdate(),120)
			Print @message
			goto label99
		   end
	   end
	

	--  Start the next job and reset the control table
	Select @message = 'Starting job ''' + @save_next_jobname + '''. ' + convert(varchar(30),getdate(),120)
	Print @message

	exec msdb.dbo.sp_start_job @job_name = @save_next_jobname

	Update dbo.Local_Control set detail01 = @save_next_jobname where subject = @ControlName

   end
Else
   begin
	Print 'Current job ''' + @save_current_jobname + ''' has completed and no further jobs were found. ' + convert(varchar(30),getdate(),120)
	raiserror(67016, 16, -1, @message)
	goto label99
   end



---------------------------  Finalization  -----------------------

label99:


DROP TABLE #xp_results


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[dbasp_LogEvent]
	(
	-- REQUIRED VALUES --
	
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	
	-- OPTIONAL VALUES --
	,@cE_ThrottleType	VarChar(50)		=null
	,@cE_ThrottleNumber	INT			=null
	,@cE_ThrottleGrouping	VarChar(255)		=null
	
	,@cE_ForwardTo		VarChar(2048)		=null
	,@cE_RedirectTo		VarChar(2048)		=null
	
	,@cEStat_Rows		BigInt			=null
	,@cEStat_Duration	FLOAT			=null
	
	,@cERE_ForceScreen	BIT			= 0
	,@cERE_Severity		INT			= 16
	,@cERE_State		INT			= 1
	,@cERE_With		VarChar(2048)		= 'WITH LOG' -- NOT NULL FOR EASY CONCATONATION TO COMMAND
	
	,@cEMail_Subject	VarChar(2048)		=null
	,@cEMail_To		VarChar(2048)		=null
	,@cEMail_CC		VarChar(2048)		=null
	,@cEMail_BCC		VarChar(2048)		=null
	,@cEMail_Urgent		BIT			= 1
	
	,@cEFile_Name		VarChar(2048)		=null
	,@cEFile_Path		VarChar(2048)		=null
	,@cEFile_OverWrite	BIT			= 0
	
	,@cEPage_Subject	VarChar(2048)		=null
	,@cEPage_To		VarChar(2048)		=null
	
	-- METHODS TO USE TO LOG THE MESSAGE MUST USE ONE OR MORE--

	,@cEMethod_Screen	BIT			= 1
	,@cEMethod_TableLocal	BIT			= 0
	,@cEMethod_TableCentral	BIT			= 0
	,@cEMethod_RaiseError	BIT			= 0
	,@cEMethod_EMail	BIT			= 0
	,@cEMethod_File		BIT			= 0
	,@cEMethod_Twitter	BIT			= 0
	,@cEMethod_DBAPager	BIT			= 0
	)

/***************************************************************
 **  Stored Procedure dbasp_LogEvent                 
 **  Written by Steve Ledridge, Getty Images                
 **  MAY 8, 2010                                      
 **
 **  
 **  Description: Creates a common interface to perform all event logging and messaging across all 
 **  Opperations databases, code and proccesses.
 **
 **
 **  This proc accepts the following input parameters:
 **  
 	@cEModule		= GENERIC NAME OF SPROC, JOB, OR GENERAL TASK TO USE FOR GROUPING
	@cECategory		= THE CATEGORY KEYWORD 
	@cEEvent		= THE EVENT KEYWORD
	@cEGUID			= GUID USED TO LINK RELATED EVENTS AS A PROCCESS OR INSTANCE ex (one execution of a sproc)
	@cEMessage		= THE ACTUAL MESSAGE BEING LOGGED
	
	-- OPTIONAL VALUES --
	@cE_ThrottleType	= ex('FilterPerXMin','FilterPerXSec','DelayPerXMin','DelayPerXSec')
					"Filter%"	= Will drop extra messages.
					"Delay%"	= Will queue messages and deliver at interval. 
					"X"		= Value in @cE_ThrottleNumber Parameter
					
	@cE_ThrottleNumber	= Number used in ThrottleType Calculation.
	@cE_ThrottleGrouping	= Value Used to Identify Similar Message to be Throttled.
	
	@cE_ForwardTo		= A Comma Delimited String of Servers That will also execute this LogEvent (Event is also Logged Here)
	@cE_RedirectTo		= A Comma Delimited String of Servers That will execute this LogEvent instead of being Executed Here. (Event is not Logged Here)
	
	@cEStat_Rows		= PASS IN @@ROWCOUNT IF APPROPRIATE
	@cEStat_Duration	= USE FLOAT VALUE FOR MINUTES IF CALCULATED IN PROCCESS

	@cERE_ForceScreen	= RAISEERROR: FORCES ALL VALUES FOR RAISEERROR TO "raiserror('', -1,-1) with nowait" WICH CAUSES IMEDIATE SCREEN UPDATE
	@cERE_Severity		= RAISEERROR: SEVERITY VALUE
	@cERE_State		= RAISEERROR: STATE VALUE
	@cERE_With		= RAISEERROR: 'with nowait' or LOG,SETERROR
	
	@cEMail_Subject		= Subject Line For Email
	@cEMail_To		= Delimited List of Recipients
	@cEMail_CC		= Delimited List of Recipients
	@cEMail_BCC		= Delimited List of Recipients
	@cEMail_Urgent		= 1 IF UGENT 0 IF NORMAL

	@cEFile_Name		= FileName to write
	@cEFile_Path		= Path to Write File
	@cEFile_OverWrite	= 1 TO OVERWRITE 0 TO APPEND

	@cEPage_Subject	VarChar	= Subject Line For Page (SMS)
	@cEPage_To		= Delimited List of Recipients or CODEWORDS used to calculate Recipient ex(ONCALLDBA,ALLDBAS,CURENTDEPLDBA...)
	
	-- METHODS TO USE TO LOG THE MESSAGE MUST USE ONE OR MORE--

	@cEMethod_Screen	= Prints Message to screen prefixed wit "--" to make sure it doesnt interfere with scripting.
	@cEMethod_TableLocal	= Write to the Local [dbo].EventLog Table.
	@cEMethod_TableCentral	= Write to the Central dbacentral.dbo.EventLog Table
	@cEMethod_RaiseError	= Raises an Error
	@cEMethod_EMail		= Sends Email
	@cEMethod_File		= Writes to a File
	@cEMethod_Twitter	= Send a Twitter Update
	@cEMethod_DBAPager	= Send a Page
	
	EACH LOG_METHOD OTHER THAN SCREEN SHOULD BE WRITTEN AS A SEPERATE SPROC WHICH IS CALLED BY THIS ONE 
	AND THEY SHOULD ALL BE CALLED BEFORE THE SCREEN LOG_METHOD IS EXECUTED SO THAT IT CAN RETURN ANY INFO 
	GATHERED FROM THE OTHER LOG_METHOD's
	SO THAT THIS DOESNT GET TOO LARGE AND CONFUSING
 **
 ***************************************************************
 IDEAS:
	If logging to table, you could have it calculate duration on 'stop,end,finnish...' entries by looking at related 'start,begin..' entries

 ***************************************************************/
AS
BEGIN
	
	/*--------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------
	INITALIZE VARIABLES
	----------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------*/
	SET NOCOUNT ON
	DECLARE		@cLogDBName		[sys].[sysname]
			,@cLogSysuser		[sys].[sysname]
			,@cLogModuleVersion	nvarchar(32)
			,@cESpace		varchar(32)
			,@lRC			int

	SET		@cLogDBName		=db_name()
	SET		@cLogSysuser		=system_user
	SET		@cLogModuleVersion	= '0.01'
	SET		@cESpace		='EVT_NDX'
	
	-- IF @cEGUID IS NULL THEN CREATE ONE AND THIS EVENT WILL NOT BE LINKED TO ANY OTHERS
	IF @cEGUID is null 
		set @cEGUID=newid()

	/*--------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------
	CHECK FOR FORWARD AND REDIRECT FLAGS
	----------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------*/

	if @cE_ForwardTo IS NOT NULL OR @cE_RedirectTo IS NOT NULL
	BEGIN
----------------------------------------------------
---------- CALL SPROC ON REMOTE TABLES
----------------------------------------------------
		SET @cE_ForwardTo = @cE_ForwardTo
		--TODO:
		--	GENERATE CURSOR OF SERVERS TO SEND SPROC CALL TO.
		--	DELIVER COMMAND TO FIRE SPROC ON REMOTE SERVER.

	END
	
	if @cE_RedirectTo IS NOT NULL
	BEGIN
----------------------------------------------------
---------- EXIT NOW IF REDIRECT
----------------------------------------------------
		RETURN 0
	END

	/*--------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------
	START CALLING LOG_METHOD's
	----------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------*/

----------------------------------------------------
---------- LOG_METHOD:	TABLE_LOCAL
----------------------------------------------------	

	IF @cEMethod_TableLocal = 1
	BEGIN
		EXEC [dbo].[dbasp_LogEvent_Method_TableLocal]
			@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
			,@cEStat_Rows
			,@cEStat_Duration

	END
	
----------------------------------------------------
---------- LOG_METHOD:	TABLE_CENTRAL
----------------------------------------------------	

	IF @cEMethod_TableCentral = 1
	BEGIN
		EXEC [dbo].[dbasp_LogEvent_Method_TableCentral]
			@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
			,@cEStat_Rows
			,@cEStat_Duration

	END

----------------------------------------------------
---------- LOG_METHOD:	RAISEERROR
----------------------------------------------------	

	IF @cEMethod_RaiseError = 1 or @cERE_ForceScreen = 1
	BEGIN
		-- Declare here because only used here
		DECLARE @cEMessage2		VarChar(MAX)
		
		-- RESET VAULES IF @cERE_ForceScreen = 1
		SELECT	@cEMessage2		= CASE @cERE_ForceScreen
							WHEN 1 THEN ''
							ELSE @cEMessage END
			,@cERE_Severity		= CASE @cERE_ForceScreen
							WHEN 1 THEN -1
							ELSE @cERE_Severity END 
			,@cERE_State		= CASE @cERE_ForceScreen
							WHEN 1 THEN -1
							ELSE @cERE_State END
			,@cERE_With	= CASE @cERE_ForceScreen
							WHEN 1 THEN 'WITH NOWAIT'
							ELSE @cERE_With END

		EXEC [dbo].[dbasp_LogEvent_Method_RaiseError]
			@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage2
			,@cERE_Severity
			,@cERE_State
			,@cERE_With

	END
	
----------------------------------------------------
---------- LOG_METHOD:	EMAIL
----------------------------------------------------	

	IF @cEMethod_Email = 1
	BEGIN
		EXEC [dbo].[dbasp_LogEvent_Method_EMail]
			@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
			,@cEStat_Rows
			,@cEMail_To
			,@cEMail_CC
			,@cEMail_BCC
			,@cEMail_Urgent

	END

----------------------------------------------------
---------- LOG_METHOD:	FILE
----------------------------------------------------	

	IF @cEMethod_File = 1
	BEGIN
		EXEC [dbo].[dbasp_LogEvent_Method_File]
			@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
			,@cEFile_Name
			,@cEFile_Path
			,@cEFile_OverWrite
	END
	
----------------------------------------------------
---------- LOG_METHOD:	TWITTER
----------------------------------------------------	

	IF @cEMethod_Twitter = 1
	BEGIN
		EXEC [dbo].[dbasp_LogEvent_Method_Twitter]
			@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage

	END
	
----------------------------------------------------
---------- LOG_METHOD:	DBAPager
----------------------------------------------------	

	IF @cEMethod_DBAPager = 1
	BEGIN
		EXEC [dbo].[dbasp_LogEvent_Method_DBAPager]
			@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
			,@cEPage_Subject
			,@cEPage_To

	END	
	
----------------------------------------------------
---------- LOG_METHOD:	SCREEN
----------------------------------------------------	

	if @cEMethod_Screen=1
	BEGIN
		PRINT	'-- Module=' + @cEModule
			+ N'  Date=' + CONVERT(nvarchar(50),GETUTCDATE(),120)
			+ N'  Category=' +coalesce(@cECategory,N'(undefined)')
			+ N'  Event=' +coalesce(@cEEvent,N'(undefined)')
			+ COALESCE(N'  Message=' + @cEMessage, N'')
			+ COALESCE(N'  RowCount=' + cast(@cEStat_Rows as nvarchar), N'')
			+ COALESCE(N'  Duration=' + cast(@cEStat_Duration as nvarchar), N'')

	END
	
	/*--------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------
	DONE
	----------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------*/
	return 0
end

/*
USAGE:

	--------------------------------------------------
	-- DECLARE ALL cE VARIABLES AT HEAD OF PROCCESS --
	--------------------------------------------------
	DECLARE	@cEModule		sysname
		,@cECategory		sysname
		,@cEEvent		sysname
		,@cEGUID		uniqueidentifier
		,@cEMessage		nvarchar(max)
		,@cERE_ForceScreen	BIT
		,@cERE_Severity		INT
		,@cERE_State		INT
		,@cERE_With		VarChar(2048)
		,@cEStat_Rows		BigInt
		,@cEStat_Duration	FLOAT
		,@cEMethod_Screen	BIT
		,@cEMethod_TableLocal	BIT
		,@cEMethod_TableCentral	BIT
		,@cEMethod_RaiseError	BIT
		,@cEMethod_Twitter	BIT
	--------------------------------------------------
	--           SET GLOBAL cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cEModule		= 'TestLogingProccess'	-- SHOULD BE SET ONCE AT BEGINNING OF PROCCESS
		,@cEGUID		= NEWID()		-- SHOULD BE SET ONCE AT BEGINNING OF PROCCESS



--------------------------------------------------
--     \/         PER EVENT CODE        \/      --
--------------------------------------------------


	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cECategory		= 'STEP'
		,@cEEvent		= 'INITALIZE VARIABLES'
		,@cEMessage		= 'Initializing Variables'
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec [dbo].[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	-- OPTIONAL VALUES  ONLY UNCOMMENT IF NONDEFAULT--
				--,@cEStat_Rows		= @@ROWCOUNT
				--,@cEStat_Duration	= DATEDIFF(ss,@StartDate,@StopDate) / 60.0000			-- GRANULARITY IN SECONDS
							--= DATEDIFF(ms,@StartDate,@StopDate) / 1000.0000 / 60.0000	-- GRANULARITY IN MILISECONDS	
				--,@cERE_ForceScreen	
				--,@cERE_Severity		
				--,@cERE_State		
				--,@cERE_With	
				--,@cEMethod_Screen
				--,@cEMethod_TableLocal
				--,@cEMethod_TableCentral
				--,@cEMethod_RaiseError
				,@cEMethod_Twitter	= 1
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------


--------------------------------------------------
--   /\         END PER EVENT CODE      /\      --
--------------------------------------------------

	
--*/
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent_Method_DBAPager
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent_Method_DBAPager]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent_Method_DBAPager]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[dbasp_LogEvent_Method_DBAPager]
	(
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	,@cEPage_Subject	VarChar(2048)		=null
	,@cEPage_To		VarChar(2048)		=null
	)
AS
BEGIN
	DECLARE	@OnCallDBA	VarChar(50)
		,@OnDeplDBA	VarChar(50)
		,@AllDBA	VarChar(2048)

	/* -- PUT BACK IN WHEN THE WHOWSONFIRST Issue is Resolved

	SELECT	@OnCallDBA	= [dbo].[WhosOnFirst_Really].[EMail_Mobile]
	FROM	[dbo].[WhosOnFirst_Really](GetDate(), 'OnCall')

	SELECT	@OnDeplDBA	= [dbo].[WhosOnFirst_Really].[EMail_Mobile]
	FROM	[dbo].[WhosOnFirst_Really](GetDate(), 'OnDepl')

	SELECT	@AllDBA		= [dbo].[dbaudf_Concatenate](COALESCE([dbo].[WhosOnFirst_Members].[EMail_Mobile]+';',''))
	FROM	[dbo].[WhosOnFirst_Members]
	*/

	SET	@cEPage_To	= REPLACE(REPLACE(REPLACE(@cEPage_To
				,'OnCallDBA',COALESCE(@OnCallDBA,'OnCallDBA-NOT RESOLVED'))
				,'OnDeplDBA',COALESCE(@OnDeplDBA,'OnDeplDBA-NOT RESOLVED'))
				,'AllDBA',COALESCE(@AllDBA,'AllDBA-NOT RESOLVED'))

	SET	@cEMessage	= 'Module:   ' + @cEModule +CHAR(13)+CHAR(10)
				+ 'Category: ' + @cECategory +CHAR(13)+CHAR(10)
				+ 'Event:    ' + @cEEvent +CHAR(13)+CHAR(10)
				+ 'GUID:     ' + CAST(@cEGUID AS VarChar(50)) +CHAR(13)+CHAR(10)+CHAR(13)+CHAR(10)
				+ @cEMessage

	EXEC [dbo].[dbasp_sendmail] 
	   @recipients			= @cEPage_To
	  ,@subject			= @cEPage_Subject
	  ,@message			= @cEMessage


	RETURN 0
END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent_Method_EMail
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent_Method_EMail]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent_Method_EMail]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[dbasp_LogEvent_Method_EMail]
	(
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	,@cEMail_Subject	VarChar(2048)		=null
	,@cEMail_To		VarChar(2048)		=null
	,@cEMail_CC		VarChar(2048)		=null
	,@cEMail_BCC		VarChar(2048)		=null
	,@cEMail_Urgent		BIT			=null
	
	)
AS
BEGIN

	SET	@cEMessage	= 'Module:   ' + @cEModule +CHAR(13)+CHAR(10)
				+ 'Category: ' + @cECategory +CHAR(13)+CHAR(10)
				+ 'Event:    ' + @cEEvent +CHAR(13)+CHAR(10)
				+ 'GUID:     ' + CAST(@cEGUID AS VarChar(50)) +CHAR(13)+CHAR(10)+CHAR(13)+CHAR(10)
				+ @cEMessage

	EXEC [dbo].[dbasp_sendmail] 
	   @recipients			= @cEMail_To
	  ,@copy_recipients		= @cEMail_CC
	  ,@blind_copy_recipients	= @cEMail_BCC
	  ,@subject			= @cEMail_Subject
	  ,@message			= @cEMessage


	RETURN 0
END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent_Method_File
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent_Method_File]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent_Method_File]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE procedure [dbo].[dbasp_LogEvent_Method_File]
	(
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	,@cEFile_Name		VarChar(2048)		=null
	,@cEFile_Path		VarChar(2048)		=null
	,@cEFile_OverWrite	BIT			=null
	
	)
AS
BEGIN

	EXEC [dbo].[dbasp_FileAccess_Write] 
	   @String	= @cEMessage
	  ,@Path	= @cEFile_Path
	  ,@Filename	= @cEFile_Name



	RETURN 0
END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent_Method_RaiseError
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent_Method_RaiseError]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent_Method_RaiseError]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[dbasp_LogEvent_Method_RaiseError]
	(
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	,@cERE_Severity		INT			=null
	,@cERE_State		INT			=null
	,@cERE_With		VarChar(2048)		=null
	)
AS
BEGIN
	DECLARE @TSQL VarChar(8000)
	
	SET @TSQL = 'RAISERROR (' + QUOTENAME(@cEMessage,'''') +', ' + CAST(@cERE_Severity AS VarChar(20)) + ', ' + CAST(@cERE_State AS VarChar(20)) + ') ' + COALESCE(@cERE_With,'')
	EXEC (@TSQL)

	RETURN 0
END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent_Method_TableCentral
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent_Method_TableCentral]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent_Method_TableCentral]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [dbo].[dbasp_LogEvent_Method_TableCentral]
	(
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	,@cEStat_Rows		BigInt			=null
	,@cEStat_Duration	FLOAT			=null	
	)
AS
BEGIN
	DECLARE		@CentralServer	[sys].[sysname]
			,@TSQL		VarChar(8000)
	SELECT		@CentralServer	= [dbo].[Local_ServerEnviro].[env_detail] 
	from		[dbo].[Local_ServerEnviro] 
	where		[dbo].[Local_ServerEnviro].[env_type]	= 'CentralServer'

	IF NOT EXISTS (SELECT srv.name FROM [sys].[servers] srv WHERE srv.server_id != 0 AND srv.name = N'CentralServer')
	BEGIN
		EXEC master.dbo.sp_addlinkedserver
				@server		= N'CentralServer'
				, @srvproduct	=N'SQL'
				, @provider	=N'SQLNCLI'
				, @datasrc	=@CentralServer
				
		EXEC master.dbo.sp_addlinkedsrvlogin	
				@rmtsrvname	=N'CentralServer'
				,@useself	=N'True'
				,@locallogin	=NULL
				,@rmtuser	=NULL
				,@rmtpassword	=NULL
				
		EXEC master.dbo.sp_serveroption @server=N'CentralServer', @optname=N'collation compatible'	, @optvalue=N'true'
		EXEC master.dbo.sp_serveroption @server=N'CentralServer', @optname=N'data access'		, @optvalue=N'true'
		EXEC master.dbo.sp_serveroption @server=N'CentralServer', @optname=N'rpc'			, @optvalue=N'true'
		EXEC master.dbo.sp_serveroption @server=N'CentralServer', @optname=N'rpc out'			, @optvalue=N'true'
		EXEC master.dbo.sp_serveroption @server=N'CentralServer', @optname=N'connect timeout'		, @optvalue=N'0'
		EXEC master.dbo.sp_serveroption @server=N'CentralServer', @optname=N'query timeout'		, @optvalue=N'0'
		EXEC master.dbo.sp_serveroption @server=N'CentralServer', @optname=N'use remote collation'	, @optvalue=N'true'

	END

	SET @TSQL = '
	INSERT INTO	[dbo].EventLog (cEModule,cECategory,cEEvent,cEGUID,cEMessage,cEStat_Rows,cEStat_Duration)
	SELECT		cEModule		= ' + QUOTENAME(@cEModule,'''') + '
			,cECategory		= ' + QUOTENAME(@cECategory,'''') + '
			,cEEvent		= ' + QUOTENAME(@cEEvent,'''') + '
			,cEGUID			= ' + QUOTENAME(CAST(@cEGUID AS VarChar(50)),'''') + '
			,cEMessage		= ' + QUOTENAME(@cEMessage,'''') + '
			,cEStat_Rows		= ' + QUOTENAME(CAST(@cEStat_Rows AS VarChar(50)),'''') + '
			,cEStat_Duration	= ' + QUOTENAME(CAST(@cEStat_Duration AS VarChar(50)),'''') + '
'
			
	EXEC	(@TSQL) AT CentralServer

	RETURN 0

END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent_Method_TableLocal
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent_Method_TableLocal]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent_Method_TableLocal]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE procedure [dbo].[dbasp_LogEvent_Method_TableLocal]
	(
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	,@cEStat_Rows		BigInt			=null
	,@cEStat_Duration	FLOAT			=null	
	)
AS
BEGIN
	INSERT INTO	[dbo].[EventLog] (cEModule,cECategory,cEEvent,cEGUID,cEMessage,cEStat_Rows,cEStat_Duration)
	SELECT		@cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
			,@cEStat_Rows
			,@cEStat_Duration
	If @@ROWCOUNT = 1			
		RETURN 0
	ELSE
		RETURN -1		
END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_LogEvent_Method_Twitter
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_LogEvent_Method_Twitter]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_LogEvent_Method_Twitter]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE procedure [dbo].[dbasp_LogEvent_Method_Twitter]
	(
	 @cEModule		sysname			=null
	,@cECategory		sysname			=null
	,@cEEvent		sysname			=null
	,@cEGUID		uniqueidentifier	=null
	,@cEMessage		nvarchar(max)		=null
	)
AS
BEGIN
	-- MAKE SURE THERE IS A TIMESTAMP IN THE MESSAGE SO IT DOESNT THINK THEY ARE DUPES.
	--TWITTER WILL DENY DUPES
	SET @cEMessage = LEFT(@cEModule+CHAR(10)
			+ CONVERT(nvarchar(50),GETUTCDATE(),120)+CHAR(10)
			+ @cECategory+CHAR(10)
			+ @cEEvent+CHAR(10)
			+ COALESCE(@cEMessage,''),140)

	EXECUTE [dbo].[dbasp_SendTweet] 
		   @TwitterUser = 'TSSQLDBA'
		  ,@TwitterPass = 'L84Lunch'
		  ,@message = @cEMessage

	RETURN 0
END
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_pong
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_pong]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_pong]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_pong (@rq_servername sysname = null
				,@rq_stamp sysname = null
				,@rq_type sysname = null
				,@rq_detail01 nvarchar(4000) = null
				,@rq_detail02 sysname = null)
			

/***************************************************************
 **  Stored Procedure dbasp_pong                  
 **  Written by Jim Wilson, Getty Images                
 **  May 30, 2007                                      
 **  
 **  This sproc is set up to;
 ** 
 **  Accepts a request from a central server and returns data to
 **  the pong_return table. 
 **
 **  This proc accepts several input parms: 
 **
 **  - @rq_servername is the name of the requesting sql server instance.
 **
 **  - @rq_stamp is the timestamp for this request. Use: convert(sysname, getdate(), 121) + convert(nvarchar(40), newid())
 **
 **  - @rq_type is the request type.  ('job', 'db_status', 'db_query')
 **
 **  - @rq_detail01 is information related to the request type.
 **    For job - job name (or at least the first part of the job name)
 **    For db_status - DB name
 **
 **  - @rq_detail02 is for future use.
 **
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	05/30/2007	Jim Wilson		New process.
--	05/31/2007	Jim Wilson		Updated for sql 2005.
--	12/19/2007	Jim Wilson		Added code for generic DB queries that return a single value.
--	10/01/2008	Jim Wilson		Updated example with newid() in the req_stamp.
--	======================================================================================

/***
Declare @rq_servername sysname
Declare @rq_stamp sysname
Declare @rq_type sysname
Declare @rq_detail01 nvarchar(4000)
Declare @rq_detail02 sysname

Select @rq_servername = 'sqldeployer02'
Select @rq_stamp = '2007-12-21 12:10:03.077'
Select @rq_type = 'db_query'
Select @rq_detail01 = 'select top 1 name from master.sys.databases'
Select @rq_detail02 = ''
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd	 		nvarchar(4000)
	,@error_count		int
	,@hold_detail01		nvarchar(4000)
	,@save_detail01		nvarchar(4000)
	,@save_detail02		sysname
	,@save_jobname		sysname
	,@save_current_step	int
	,@save_run_date		nvarchar(10)
	,@save_run_time		nvarchar(10)
	,@query			nvarchar(4000)
	,@query_out		sysname

DECLARE
	 @is_sysadmin		INT
	,@job_owner		sysname



----------------  initial values  -------------------
Select @error_count = 0



--  Check input parameters
If @rq_servername is null or @rq_servername = ''
   begin
	Print 'DBA Warning:  Invalid input parameter.  @rq_servername parm must be a valid SQL instance name.'
	Select @error_count = @error_count + 1
	Goto label99
   end

If @rq_stamp is null or @rq_stamp = ''
   begin
	Print 'DBA Warning:  Invalid input parameter.  @rq_stamp parm must be a valid time stamp from the requesting server.'
	Select @error_count = @error_count + 1
	Goto label99
   end

If @rq_type is null or @rq_type not in ('job', 'db_status', 'db_query')
   begin
	Print 'DBA Warning:  Invalid input parameter.  @rq_type parm must be ''job'' or ''db_query''.'
	Select @error_count = @error_count + 1
	Goto label99
   end

If @rq_detail01 is null
   begin
	Print 'DBA Warning:  Invalid input parameter.  @rq_detail01 parm cannot be null.'
	Select @error_count = @error_count + 1
	Goto label99
   end


-- Create intermediate work tables for job info
CREATE TABLE #xp_results (job_id                UNIQUEIDENTIFIER NOT NULL,
                          last_run_date         INT              NOT NULL,
                          last_run_time         INT              NOT NULL,
                          next_run_date         INT       NOT NULL,
                          next_run_time         INT              NOT NULL,
                          next_run_schedule_id  INT              NOT NULL,
                          requested_to_run      INT              NOT NULL, -- BOOL
                          request_source        INT              NOT NULL,
                          request_source_id     sysname          NULL,
                          running               INT              NOT NULL, -- BOOL
                          current_step          INT              NOT NULL,
                          current_retry_attempt INT              NOT NULL,
                          job_state             INT              NOT NULL)

CREATE TABLE #db_query (detail01    sysname) 



--  Create table variables
declare @jobinfo table	(jobname		sysname
			,instance_ID		int
			,Job_ID			varchar(50) 
			,step_name		sysname
			,step_id		int
			,sql_message_id		int
			,sql_severity		int
			,message		nvarchar(1024)
			,run_status		int
			,run_date		int
			,run_time		int
			,primary key 	(instance_ID)
			)

declare @jobstatus table (jobname		sysname
			,last_run_date		INT
			,last_run_time		INT
			,running		INT
			,current_step		INT
			,current_retry_attempt	INT
			,job_state		INT
			)


/****************************************************************
 *                MainLine
 ***************************************************************/

If @rq_type = 'job'
   begin
	Select @hold_detail01 = @rq_detail01 + '%'
	Select @save_detail01 = ''
	Select @save_detail02 = ''


	-- Capture job execution information (for local jobs only since that's all SQLServerAgent caches)
	SELECT @is_sysadmin = ISNULL(IS_SRVROLEMEMBER(N'sysadmin'), 0)
	SELECT @job_owner = SUSER_SNAME()
  
	INSERT INTO #xp_results exec master.sys.xp_sqlagent_enum_jobs @is_sysadmin, @job_owner

	--select * from #xp_results

	-- Refine job execution information and include job names
	Insert into @jobstatus (jobname, last_run_date, last_run_time, running, current_step, current_retry_attempt, job_state)
	SELECT j.name, x.last_run_date, x.last_run_time, x.running, x.current_step, x.current_retry_attempt, x.job_state
	From #xp_results x,  msdb.dbo.sysjobs j with (NOLOCK)
	Where x.job_id = j.job_id
	  and j.name like @hold_detail01

	--select * from @jobstatus


	--  Capture job history info
	Insert into @jobinfo (jobname, instance_ID, Job_ID, step_name, step_id, sql_message_id, sql_severity, message, run_status, run_date, run_time)
	SELECT j.name, h.instance_ID, convert(varchar(50),h.Job_ID), h.step_name, h.step_id, h.sql_message_id, h.sql_severity, h.message, h.run_status, h.run_date, h.run_time
	From msdb.dbo.sysjobhistory  h with (NOLOCK),  msdb.dbo.sysjobs j with (NOLOCK)
	Where h.job_id = j.job_id
	  and j.name like @hold_detail01

	--select * from @jobinfo



	--  Do the job(s) esist?  If no jobs are found, report that and we are done
	If (select count(*) from @jobstatus) = 0
	   begin
		Select @save_detail01 = 'No jobs found on ' + @@servername + ' like ''''' + @rq_detail01 + ''''''
		goto return_data
	   end


	--  Is the job running now?  If the job is currently running, report the job name and step name.
	If (select count(*) from @jobstatus where running > 0) > 0
	   begin
		Select @save_jobname = (select top 1 jobname from @jobstatus where running > 0 order by jobname)
		Select @save_current_step = (select current_step from @jobstatus where jobname = @save_jobname)
		Select @save_detail01 = 'JOB Running on ' + @@servername + ': ' + @save_jobname + '  STEP#: ' + convert(varchar(5), @save_current_step)
		goto return_data
	   end


	--  Have the job(s) ever run?  If no previous execution is found, report that and we are done
	If (select count(*) from @jobstatus where last_run_date > 0) = 0
	   begin
		Select @save_detail01 = 'Requested job(s) on ' + @@servername + ' have never run (i.e. ''''' + @rq_detail01 + ''''')'
		goto return_data
	   end
		

	--  Do we have a job failure?  If we see a job failure, report that and we are done
	If (select top 1 run_status from @jobinfo where step_name <> '(Job outcome)' order by instance_ID desc) = 0  -- 0 is for failed job step
	   begin
		Select @save_jobname = (select top 1 jobname from @jobinfo where run_status = 0 and step_name <> '(Job outcome)' order by instance_ID desc)
		Select @save_current_step = (select top 1 step_id from @jobinfo where jobname = @save_jobname and run_status = 0 and step_name <> '(Job outcome)' order by instance_ID desc)
		Select @save_detail01 = 'JOB Failed on ' + @@servername + ': ' + @save_jobname + '  STEP#: ' + convert(varchar(5), @save_current_step)
		goto return_data
	   end


	--  Just report the last job and step that ran
	Select @save_jobname = (select top 1 jobname from @jobinfo where step_name <> '(Job outcome)' order by instance_ID desc)
	Select @save_current_step = (select top 1 step_id from @jobinfo where jobname = @save_jobname and step_name <> '(Job outcome)' order by instance_ID desc)
	Select @save_run_date = (select top 1 run_date from @jobinfo where jobname = @save_jobname and step_name <> '(Job outcome)' order by instance_ID desc)
	Select @save_run_time = (select top 1 run_time from @jobinfo where jobname = @save_jobname and step_name <> '(Job outcome)' order by instance_ID desc)
	If len(@save_run_time) = 5
	   begin
		Select @save_run_time = '0' + @save_run_time
	   end
	Else If len(@save_run_time) = 4
	   begin
		Select @save_run_time = '00' + @save_run_time
	   end
	Else If len(@save_run_time) = 3
	   begin
		Select @save_run_time = '000' + @save_run_time
	   end
	Else If len(@save_run_time) = 2
	   begin
		Select @save_run_time = '0000' + @save_run_time
	   end
	Else If len(@save_run_time) = 1
	   begin
		Select @save_run_time = '00000' + @save_run_time
	   end

	Select @save_detail01 = 'Last Job Completed on ' + @@servername + ': ' + @save_jobname + '  STEP#: ' + convert(varchar(5), @save_current_step) + '  RAN: ' + @save_run_date + '_' + @save_run_time


	return_data:

	--  Return data to the requesting sql instance
	select @query = 'Insert dbaadmin.dbo.pong_return values (''' + @rq_stamp + ''', ''' + @@servername + ''', ''' + @save_detail01 + ''', ''' + @save_detail02 + ''')' 
	--Print @query
	Select @cmd = 'sqlcmd -S' + @rq_servername + ' -ddbaadmin -E -Q"' + @query + '"'
	print @cmd
	EXEC master.sys.xp_cmdshell @cmd--, no_output

	goto label99
   end





If @rq_type = 'db_query'
   begin
	insert into #db_query exec (@rq_detail01)

	If (select count(*) from #db_query) > 0
	   begin
		--  Return data to the requesting sql instance
	    	Select @save_detail01 = (select top 1 detail01 from #db_query)
		Select @save_detail02 = ''
		select @query = 'Insert dbaadmin.dbo.pong_return values (''' + @rq_stamp + ''', ''' + @@servername + ''', ''' + @save_detail01 + ''', ''' + @save_detail02 + ''')' 
		--Print @query
		Select @cmd = 'sqlcmd -S' + @rq_servername + ' -ddbaadmin -E -Q"' + @query + '"'
		print @cmd
		EXEC master.sys.xp_cmdshell @cmd--, no_output
	   end

	goto label99
   end




If @rq_type = 'db_status'
   begin

	--  To be developed...

	goto label99
   end



--  Finalization  ----------------------------------------------------------------------
label99:

drop table #xp_results
drop table #db_query



/***
how to execute a type 'db_query'

Select @save_rq_stamp = convert(sysname, getdate(), 121) + convert(nvarchar(40), newid())
Select @db_query1 = 'select top 1 name from master.sys.databases'
Select @db_query2 = ''
select @query = 'exec dbaadmin.dbo.dbasp_pong @rq_servername = ''' + @@servername 
	    + ''', @rq_stamp = ''' + @save_rq_stamp 
	    + ''', @rq_type = ''db_query'', @rq_detail01 = ''' + @db_query1 + ''', @rq_detail02 = ''' + @db_query2 + ''''
Select @miscprint = 'Requesting info from serverxyz.'
Print @miscprint
Select @cmd = 'sqlcmd -Sserverxyz -E -Q"' + @query + '"'
print @cmd
EXEC master.sys.xp_cmdshell @cmd, no_output 

--  capture pong results
select @pong_count = 0
start_pong_result:
Waitfor delay '00:00:05'
If exists (select 1 from dbaadmin.dbo.pong_return where pong_stamp = @save_rq_stamp)
   begin
	Select @save_more_info = (select pong_detail01 from dbaadmin.dbo.pong_return where pong_stamp = @save_rq_stamp)
   end
Else If @pong_count < 5
   begin
	Select @pong_count = @pong_count + 1
	goto start_pong_result
   end
***/








 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_prerestore
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_prerestore]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_prerestore]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_prerestore ( @full_path nvarchar(500) = null, 
					@dbname sysname = null,
					@ALTdbname sysname = null,
					@backupname sysname = null, 
					@backmidmask sysname = '_db_2', 
					@diffmidmask sysname = '_dfntl_2', 
					@datapath nvarchar(100) = null, 
					@data2path nvarchar(100) = null, 
					@logpath nvarchar(100) = null, 
					@db_norecovOnly_flag char(1) = 'n',
					@post_shrink char(1) = 'n',
					@complete_on_diffOnly_fail char(1) = 'n')

/*********************************************************
 **  Stored Procedure dbasp_prerestore                  
 **  Written by Jim Wilson, Getty Images                
 **  December 29, 2008                                      
 **  
 **  This procedure is used for automated database
 **  restore processing for the pre-restore method.
 **  The pre-restore method is where we restore the
 **  DB along side of the DB of the same name using "_new"
 **  added to the DBname.  The mdf and ldf file names are 
 **  changed as well.  When the restore is completed, the old
 **  DB is droped and the "_new" DB is renamed, completing the
 **  restore.  This gives the end user greater DB availability.
 **
 **  This proc accepts the following input parms:
 **  - @full_path is the path where the backup file can be found
 **    example - "\\seafresqlwcds\seafresqlwcds_dbasql"
 **  - @dbname is the name of the database being restored.
 **  - @ALTdbname is the "new" name of the database being restored (e.g. DBname_new).
 **  - @backupname is the name pattern of the backup file to be restored.
 **  - @backmidmask is the mask for the midpart of the backup file name (i.e. '_db_2')
 **  - @diffmidmask is the mask for the midpart of the differential file name (i.e. '_dfntl_2')
 **  - @datapath is the target path for the data files (optional)
 **  - @logpath is the target path for the log files (optional)
 **  - @db_norecovOnly_flag indicates a DB recovery with the norecovery parm,
 **    which should be followed later by a differential only restore.
 **  - @post_shrink is for a post restore file shrink (y or n)
 **  - @complete_on_diffOnly_fail will finish the restore of a DB after a failed 
 **    differential restore'
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/29/2008	Jim Wilson		New process based on dbasp_autorestore.
--	======================================================================================


/***
Declare @full_path nvarchar(100)
Declare @dbname sysname
Declare @ALTdbname sysname
Declare @backupname sysname
Declare @backmidmask sysname
Declare @diffmidmask sysname 
Declare @datapath nvarchar(100)
Declare @data2path nvarchar(100)
Declare @logpath nvarchar(100)
Declare @db_norecovOnly_flag char(1)
Declare @post_shrink char(1)
Declare @complete_on_diffOnly_fail char(1)

select @full_path = '\\seaprylrpt01\seaprylrpt01_restore'
select @dbname = 'RM_Integration'
select @ALTdbname = 'RM_Integration_new'
--Select @backupname = 'RM_Integration_db'
Select @backmidmask = '_db_2' 
Select @diffmidmask = '_dfntl_2' 
select @datapath = 'e:\data'
select @data2path = 'e:\data'
select @logpath = 'f:\log'
select @db_norecovOnly_flag = 'y'
Select @post_shrink = 'y'
Select @complete_on_diffOnly_fail = 'n'
--***/



-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@error_count			int
	,@retry_count			int
	,@cmd 				nvarchar(4000)
	,@Restore_cmd			nvarchar(4000)
	,@filecount			smallint
	,@filename_wild			nvarchar(100)
	,@diffname_wild			nvarchar(100)
	,@charpos			int
	,@query 			nvarchar(4000)
	,@mssql_data_path		nvarchar(255)
	,@savePhysicalNamePart		nvarchar(260)
	,@savefilepath			nvarchar(260)
	,@hold_filedate			nvarchar(12)
	,@save_filedate			nvarchar(12)
	,@save_fileYYYY			nvarchar(4)
	,@save_fileMM			nvarchar(2)
	,@save_fileDD			nvarchar(2)
	,@save_fileHH			nvarchar(2)
	,@save_fileMN			nvarchar(2)
	,@save_fileAMPM			nvarchar(1)
	,@save_cmdoutput		nvarchar(255)
	,@save_subject			sysname
	,@save_message			nvarchar(500)
	,@hold_backupfilename		sysname
	,@hold_diff_file_name		sysname
	,@fileseq			smallint
	,@diffname			sysname
	,@BkUpMethod			nvarchar(5)
	,@DateStmp 			nvarchar(15)
	,@Hold_hhmmss			nvarchar(8)
	,@check_dbname 			sysname
	
DECLARE
	 @cu11cmdoutput			nvarchar(255)

DECLARE
	 @cu21LogicalName		nvarchar(128)
	,@cu21PhysicalName		nvarchar(260)
	,@cu21Type			char(1)
	,@cu21FileGroupName		nvarchar(128)

DECLARE
	 @cu22LogicalName		nvarchar(128)
	,@cu22PhysicalName		nvarchar(260)
	,@cu22Type			char(1)
	,@cu22FileGroupName		nvarchar(128)

DECLARE
	 @cu25cmdoutput			nvarchar(255)



----------------  initial values  -------------------
Select @retry_count = 0
Select @error_count = 0
Select @hold_filedate = '200001010001'
Select @BkUpMethod = 'MS'
select @filename_wild = ''
select @diffname_wild = ''
select @DateStmp = ''


Select @check_dbname = @ALTdbname 


Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @DateStmp = '_' + convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 


create table #DirectoryTempTable(cmdoutput nvarchar(255) null)
create table #filelist(LogicalName nvarchar(128) null, 
						PhysicalName nvarchar(260) null, 
						Type char(1), 
						FileGroupName nvarchar(128) null, 
						Size numeric(20,0), 
						MaxSize numeric(20,0),
						FileId bigint,
						CreateLSN numeric(25,0),
						DropLSN numeric(25,0),
						UniqueId uniqueidentifier,
						ReadOnlyLSN numeric(25,0),
						ReadWriteLSN numeric(25,0),
						BackupSizeInBytes bigint,
						SourceBlockSize int,
						FileGroupId int,
						LogGroupGUID uniqueidentifier null,
						DifferentialBaseLSN numeric(25,0),
						DifferentialBaseGUID uniqueidentifier,
						IsReadOnly bit,
						IsPresent bit
						)

create table #filelist_ls (LogicalName nvarchar(128) null, 
						PhysicalName nvarchar(260) null, 
						Type char(1), 
						FileGroupName nvarchar(128) null, 
						Size numeric(20,0), 
						MaxSize numeric(20,0)
						)

create table #filelist_rg(LogicalName nvarchar(128) null, 
						PhysicalName nvarchar(260) null, 
						Type char(1), 
						FileGroupName nvarchar(128) null, 
						Size numeric(20,0), 
						MaxSize numeric(20,0),
						FileId bigint,
						CreateLSN numeric(25,0),
						DropLSN numeric(25,0),
						UniqueId uniqueidentifier,
						ReadOnlyLSN numeric(25,0),
						ReadWriteLSN numeric(25,0),
						BackupSizeInBytes bigint,
						SourceBlockSize int,
						FileGroupId int,
						LogGroupGUID sysname null,
						DifferentialBaseLSN numeric(25,0),
						DifferentialBaseGUID uniqueidentifier,
						IsReadOnly bit,
						IsPresent bit
						)



--  Check input parms
if @full_path is null or @full_path = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_prerestore - @full_path must be specified.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @dbname is null or @dbname = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_prerestore - @dbname must be specified.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if @ALTdbname is null or @ALTdbname = ''
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid parameters to dbasp_prerestore - @ALTdbname must be specified.' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END





If @backupname is null or @backupname = ''
   begin
	select @filename_wild = @filename_wild + @dbname + @backmidmask + '*'
	select @diffname_wild = @diffname_wild + @dbname + @diffmidmask + '*'
   end
Else
   begin
	Select @diffname = REPLACE(@backupname, '_db_', '_dfntl_')
	select @filename_wild = @filename_wild + @backupname
	select @diffname_wild = @diffname_wild + @diffname
   end



If @data2path is null
   begin
	select @data2path = @datapath
   end



/****************************************************************
 *                MainLine
 ***************************************************************/





select @cmd = 'dir ' + @full_path + '\' + @filename_wild
--print @cmd

start_dir:
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
delete from #DirectoryTempTable where cmdoutput like '%<DIR>%'
delete from #DirectoryTempTable where cmdoutput like '%Directory of%'
delete from #DirectoryTempTable where cmdoutput like '% File(s) %'
delete from #DirectoryTempTable where cmdoutput like '% Dir(s) %'
delete from #DirectoryTempTable where cmdoutput like '%Volume in drive%'
delete from #DirectoryTempTable where cmdoutput like '%Volume Serial Number%'
--select * from #DirectoryTempTable


select @filecount = (select count(*) from #DirectoryTempTable)

If @filecount < 1
   BEGIN
	If @retry_count < 5
	   begin
		Select @retry_count = @retry_count + 1
		Waitfor delay '00:00:10'
		delete from #DirectoryTempTable
		goto start_dir
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: No files found for dbasp_prerestore at ' + @full_path + ' using mask "' + @filename_wild + '"'
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   END
Else
   BEGIN
	Start_cmdoutput01:
	Select @save_cmdoutput = (Select top 1 cmdoutput from #DirectoryTempTable order by cmdoutput)
	Select @cu11cmdoutput = @save_cmdoutput

	select @save_fileYYYY = substring(@cu11cmdoutput, 7, 4)
	select @save_fileMM = substring(@cu11cmdoutput, 1, 2)
	select @save_fileDD = substring(@cu11cmdoutput, 4, 2)
	select @save_fileHH = substring(@cu11cmdoutput, 13, 2)
	Select @save_fileAMPM = substring(@cu11cmdoutput, 18, 1)
	If @save_fileAMPM = 'a' and @save_fileHH = '12'
	   begin
		Select @save_fileHH = '00'
	   end
	Else If @save_fileAMPM = 'p' and @save_fileHH <> '12'
	   begin
		Select @save_fileHH = @save_fileHH + 12
	   end
	select @save_fileMN = substring(@cu11cmdoutput, 16, 2)
	Select @save_filedate = @save_fileYYYY + @save_fileMM + @save_fileDD + @save_fileHH + @save_fileMN

	If @hold_filedate < @save_filedate
	   begin
		select @hold_backupfilename = ltrim(rtrim(substring(@cu11cmdoutput, 40, 200)))
	   end

	Delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto Start_cmdoutput01
	   end
   END



--  Check file name to determin if we can process the file
If @hold_backupfilename like '%.bkp'
   begin
	If exists (select 1 from master.sys.objects where name = 'xp_backup_database' and type = 'x')
	   begin
		Print '--  Note:  LiteSpeed Syntax will be used for this request'
		Print ' '
		Select @BkUpMethod = 'LS'
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: LiteSpeed backups cannot be processed by dbasp_prerestore on this server. ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   end

If @hold_backupfilename like '%.SQB%'
   begin
	If exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
	   begin
		Print '--  Note:  RedGate Syntax will be used for this request'
		Print ' '
		Select @BkUpMethod = 'RG'
	   end
	Else
	   begin
		Select @miscprint = 'DBA WARNING: RedGate backups cannot be processed by dbasp_prerestore on this server. ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end
   end



--  Check to see if DBname_new exists, is in loading mode, and was restored using the current DB backup file
--  If so, skip to the differential restore section
If DATABASEPROPERTYEX (@check_dbname,'status') = 'RESTORING'
   begin
	If @hold_backupfilename in (select detail02 from dbo.No_Check where nocheck_type = 'prerestore' and detail01 = @check_dbname)
	   begin
		goto diff_start
	   end
   end
 

--  At this point, if the database "DBname_new" exists, drop it
If exists (select 1 from master.sys.databases where name = @check_dbname)
   begin
	Select @cmd = 'drop database [' + @check_dbname + ']'
	Print  @cmd
	Exec(@cmd)

	waitfor delay '00:00:05'
   end

--  Verify the DB no longer exists
If exists (select 1 from master.sys.databases where name = @check_dbname)
   BEGIN
	Select @miscprint = 'DBA ERROR: Unable to drop database ' + @check_dbname + '.  The prerestore process is not able to continue.' 
	Print  @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END


--  Reset any related rows in the no_check table
delete from dbo.No_Check where nocheck_type = 'prerestore' and detail01 = @check_dbname

insert into dbo.No_Check (nocheck_type, detail01, detail02) values ('prerestore', @check_dbname, @hold_backupfilename) 



--  Restore DB for Litespeed	
If @BkUpMethod = 'LS'
   begin
	select @miscprint = 'EXEC master.dbo.xp_restore_database'
	print  @miscprint
	select @miscprint = '  @database =  ''' + @check_dbname + ''''
	print  @miscprint
	select @miscprint = ', @filename = ''' + @full_path + '\' + @hold_backupfilename + ''''
	print  @miscprint

	select @Restore_cmd = ''
	select @Restore_cmd = @Restore_cmd + 'EXEC master.dbo.xp_restore_database'
	select @Restore_cmd = @Restore_cmd + '  @database =  ''' + @check_dbname + ''''
	select @Restore_cmd = @Restore_cmd + ', @filename = ''' + @full_path + '\' + @hold_backupfilename + ''''

	select @miscprint = ', @with = NORECOVERY'
	print  @miscprint
	select @miscprint = ', @with = ''REPLACE'''
	print  @miscprint

	select @Restore_cmd = @Restore_cmd + ', @with = NORECOVERY'
	select @Restore_cmd = @Restore_cmd + ', @with = ''REPLACE'''

	delete from #filelist_ls

	Select @query = 'EXEC master.dbo.xp_restore_filelistonly @filename = ''' + rtrim(@full_path) + '\' + rtrim(@hold_backupfilename) + ''''
	insert into #filelist_ls exec (@query)
	If (select count(*) from #filelist_ls) = 0
	   begin
		Select @miscprint = 'DBA Error: Unable to process LiteSpeed filelistonly for file ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end

	--  set the default path just in case we need it
	Select @mssql_data_path = (select filename from master.sys.sysfiles where fileid = 1)
	select @charpos = charindex('master', @mssql_data_path)
	select @mssql_data_path = left(@mssql_data_path, @charpos-1)
	select @fileseq = 1


	EXECUTE('DECLARE cu21_cursor Insensitive Cursor For ' +
	  'SELECT f.LogicalName, f.PhysicalName, f.Type, f.FileGroupName
	   From #filelist_ls   f ' +
	  'for Read Only')

	OPEN cu21_cursor
	
	WHILE (21=21)
	 Begin
		FETCH Next From cu21_cursor Into @cu21LogicalName, @cu21PhysicalName, @cu21Type, @cu21FileGroupName
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu21_cursor
		      BREAK
	           end


		select @savePhysicalNamePart = @cu21PhysicalName
		label01:

		select @charpos = charindex('\', @savePhysicalNamePart)
		IF @charpos <> 0
		   begin
  		    select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
		   end	
	
		select @charpos = charindex('\', @savePhysicalNamePart)
		IF @charpos <> 0
		   begin
		    goto label01
 		   end


		If @savePhysicalNamePart like '%.mdf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.mdf', @DateStmp + '.mdf')
		   end
		Else If @savePhysicalNamePart like '%.ndf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ndf', @DateStmp + '.ndf')
		   end
		Else If @savePhysicalNamePart like '%.ldf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ldf', @DateStmp + '.ldf')
		   end
		Else
		   begin		
			Select @savePhysicalNamePart = @savePhysicalNamePart + @DateStmp
		   end


		If @datapath is not null and @cu21Type in ('D', 'F')
		   begin
			If @savePhysicalNamePart not like '%mdf' and @data2path is not null
			   begin
				Select @savefilepath = @data2path + '\' + @savePhysicalNamePart
			   end
			Else
			   begin
				Select @savefilepath = @datapath + '\' + @savePhysicalNamePart
			   end
		   end
		Else IF @logpath is not null and @cu21Type = 'L'
		   begin
			Select @savefilepath = @logpath + '\' + @savePhysicalNamePart
		   end
		Else
		   begin
			Select @savefilepath = @mssql_data_path + @savePhysicalNamePart
		   end


		select @miscprint = ', @with = ''MOVE "' + @cu21LogicalName + '" to "' + @savefilepath + '"'''
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ', @with = ''MOVE "' + @cu21LogicalName + '" to "' + @savefilepath + '"'''


		select @fileseq = @fileseq + 1



	End  -- loop 21
	DEALLOCATE cu21_cursor



	select @miscprint = ', @with = ''stats'''
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @Restore_cmd = @Restore_cmd + ', @with = ''stats'''


	-- Restore the database
	select @cmd = @Restore_cmd
	Print 'Here is the restore command being executed;'
	Print @cmd
	raiserror('', -1,-1) with nowait

	Exec (@cmd)

	If @@error<> 0
	   begin
		Print 'DBA Error:  Restore Failure (LiteSpeed) for command ' + @cmd
		Select @error_count = @error_count + 1
		goto label99
	   end


	If @db_norecovOnly_flag = 'y'
	   begin
		Print ' '
		select @miscprint = '--  Note:  This will leave the database in recovery pending mode.'
		print  @miscprint
		goto label99
	   end
   end



--  Restore DB for Redgate	
If @BkUpMethod = 'RG'
   begin
	select @miscprint = 'Declare @cmd nvarchar(4000)'
	print  @miscprint
	select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @check_dbname + ']'
	print  @miscprint
	select @miscprint = '	 FROM DISK = ''''' + @full_path + '\' + @hold_backupfilename + ''''''
	print  @miscprint

	select @Restore_cmd = ''
	select @Restore_cmd = @Restore_cmd + '-SQL "RESTORE DATABASE [' + @check_dbname + ']'
	select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_backupfilename + ''''

	select @miscprint = '	 WITH NORECOVERY'
	print  @miscprint

	select @Restore_cmd = @Restore_cmd + ' WITH NORECOVERY'


	-- Get file header info from the SQB backup file
	delete from #filelist_rg

	Select @query = 'Exec master.dbo.sqlbackup ''-SQL "RESTORE FILELISTONLY FROM DISK = ''''' + rtrim(@full_path) + '\' + rtrim(@hold_backupfilename) + '''''"'''
	insert into #filelist_rg exec (@query)
	If (select count(*) from #filelist_rg) = 0
	   begin
		Select @miscprint = 'DBA Error: Unable to process RedGate filelistonly for file ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end

	--  set the default path just in case we need it
	Select @mssql_data_path = (select filename from master.sys.sysfiles where fileid = 1)
	select @charpos = charindex('master', @mssql_data_path)
	select @mssql_data_path = left(@mssql_data_path, @charpos-1)
	select @fileseq = 1


	EXECUTE('DECLARE cu21_cursor Insensitive Cursor For ' +
	  'SELECT f.LogicalName, f.PhysicalName, f.Type, f.FileGroupName
	   From #filelist_rg   f ' +
	  'for Read Only')

	OPEN cu21_cursor
	
	WHILE (21=21)
	 Begin
		FETCH Next From cu21_cursor Into @cu21LogicalName, @cu21PhysicalName, @cu21Type, @cu21FileGroupName
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu21_cursor
		      BREAK
	           end


		select @savePhysicalNamePart = @cu21PhysicalName
		label02:
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
	  		    select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
			   end	
	
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
			    goto label02
	 		   end


		If @savePhysicalNamePart like '%.mdf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.mdf', @DateStmp + '.mdf')
		   end
		Else If @savePhysicalNamePart like '%.ndf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ndf', @DateStmp + '.ndf')
		   end
		Else If @savePhysicalNamePart like '%.ldf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ldf', @DateStmp + '.ldf')
		   end
		Else
		   begin		
			Select @savePhysicalNamePart = @savePhysicalNamePart + @DateStmp
		   end



		If @datapath is not null and @cu21Type in ('D', 'F')
		   begin
			If @savePhysicalNamePart not like '%mdf' and @data2path is not null
			   begin
				Select @savefilepath = @data2path + '\' + @savePhysicalNamePart
			   end
			Else
			   begin
				Select @savefilepath = @datapath + '\' + @savePhysicalNamePart
			   end
		   end
		Else IF @logpath is not null and @cu21Type = 'L'
		   begin
			Select @savefilepath = @logpath + '\' + @savePhysicalNamePart
		   end
		Else
		   begin
			Select @savefilepath = @mssql_data_path + @savePhysicalNamePart
		   end


		select @miscprint = '	,MOVE ''''' + rtrim(@cu21LogicalName) + ''''' to ''''' + rtrim(@savefilepath) + ''''''
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ', MOVE ''' + rtrim(@cu21LogicalName) + ''' to ''' + rtrim(@savefilepath) + ''''


		select @fileseq = @fileseq + 1



	End  -- loop 21
	DEALLOCATE cu21_cursor



	select @miscprint = '	,REPLACE"'''
	print  @miscprint
	select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
	print  @miscprint
	select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
	print  @miscprint
	select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @Restore_cmd = @Restore_cmd + ' ,REPLACE"'


	-- Restore the database
	select @cmd = 'Exec master.dbo.sqlbackup ' + @Restore_cmd
	Print 'Here is the restore command being executed;'
	Print @cmd
	raiserror('', -1,-1) with nowait

	Exec master.dbo.sqlbackup @Restore_cmd

	If DATABASEPROPERTYEX (@check_dbname,'status') <> 'RESTORING'
	   begin
		select @miscprint = 'DBA Error:  Restore Failure (Redgate partial restore) for command ' + @cmd
		print  @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end

	If @db_norecovOnly_flag = 'y'
	   begin
		Print ' '
		select @miscprint = '--  Note:  This will leave the database in recovery pending mode.'
		print  @miscprint
		goto label99
	   end
   end


--  If not a LiteSpeed or RedGate file, restore DB for standard
If @BkUpMethod = 'MS'
   begin
	select @miscprint = 'RESTORE DATABASE ' + @check_dbname
	print  @miscprint
	select @miscprint = 'FROM DISK = ''' + @full_path + '\' + @hold_backupfilename + ''''
	print  @miscprint

	select @Restore_cmd = ''
	select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname
	select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_backupfilename + ''''

	select @miscprint = 'WITH NORECOVERY,'
	print  @miscprint
	select @miscprint = 'REPLACE,'
	print  @miscprint

	select @Restore_cmd = @Restore_cmd + ' WITH NORECOVERY,'
	select @Restore_cmd = @Restore_cmd + ' REPLACE,'

	delete from #filelist

	select @query = 'RESTORE FILELISTONLY FROM Disk = ''' + @full_path + '\' + @hold_backupfilename + ''''
	insert into #filelist exec (@query)
	--select * from #filelist
	If (select count(*) from #filelist) = 0
	   begin
		Select @miscprint = 'DBA Error: Unable to process standard filelistonly for file ' + @full_path + '\' + @hold_backupfilename 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end


	--  set the default path just in case we need it
	Select @mssql_data_path = (select filename from master.sys.sysfiles where fileid = 1)
	select @charpos = charindex('master', @mssql_data_path)
	select @mssql_data_path = left(@mssql_data_path, @charpos-1)
	select @fileseq = 1


	EXECUTE('DECLARE cu22_cursor Insensitive Cursor For ' +
	  'SELECT f.LogicalName, f.PhysicalName, f.Type, f.FileGroupName
	   From #filelist   f ' +
	  'for Read Only')

	OPEN cu22_cursor
	
	WHILE (22=22)
	 Begin
		FETCH Next From cu22_cursor Into @cu22LogicalName, @cu22PhysicalName, @cu22Type, @cu22FileGroupName
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu22_cursor
		      BREAK
	           end


		select @savePhysicalNamePart = @cu22PhysicalName
		label03:
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
	  		    select @savePhysicalNamePart = substring(@savePhysicalNamePart, @charpos + 1, 100)
			   end	
	
			select @charpos = charindex('\', @savePhysicalNamePart)
			IF @charpos <> 0
			   begin
			    goto label03
	 		   end


		If @savePhysicalNamePart like '%.mdf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.mdf', @DateStmp + '.mdf')
		   end
		Else If @savePhysicalNamePart like '%.ndf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ndf', @DateStmp + '.ndf')
		   end
		Else If @savePhysicalNamePart like '%.ldf'
		   begin		
			Select @savePhysicalNamePart = replace(@savePhysicalNamePart, '.ldf', @DateStmp + '.ldf')
		   end
		Else
		   begin		
			Select @savePhysicalNamePart = @savePhysicalNamePart + @DateStmp
		   end


		If @datapath is not null and @cu22Type in ('D', 'F')
		   begin
			If @savePhysicalNamePart not like '%mdf' and @data2path is not null
			   begin
				Select @savefilepath = @data2path + '\' + @savePhysicalNamePart
			   end
			Else
			   begin
				Select @savefilepath = @datapath + '\' + @savePhysicalNamePart
			   end
		   end
		Else IF @logpath is not null and @cu22Type = 'L'
		   begin
			Select @savefilepath = @logpath + '\' + @savePhysicalNamePart
		   end
		Else
		   begin
			Select @savefilepath = @mssql_data_path + @savePhysicalNamePart
		   end

		select @miscprint = 'MOVE ''' + @cu22LogicalName + ''' to ''' + @savefilepath + ''','
		print  @miscprint

		select @Restore_cmd = @Restore_cmd + ' MOVE ''' + @cu22LogicalName + ''' to ''' + @savefilepath + ''','

		select @fileseq = @fileseq + 1



	End  -- loop 22
	DEALLOCATE cu22_cursor



	select @miscprint = 'stats'
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '

	select @Restore_cmd = @Restore_cmd + ' stats'


	-- Restore the database
	select @cmd = @Restore_cmd
	Print 'Here is the restore command being executed;'
	Print @cmd
	raiserror('', -1,-1) with nowait

	Exec (@cmd)

	If @@error<> 0
	   begin
		Print 'DBA Error:  Restore Failure (Standard Restore) for command ' + @cmd
		Select @error_count = @error_count + 1
		goto label99
	   end



	If @db_norecovOnly_flag = 'y'
	   begin
		Print ' '
		select @miscprint = '--  Note:  This will leave the database in recovery pending mode.'
		print  @miscprint
		goto label99
	
	   end

   end







diff_start:

-- Differentail Processing
If @db_norecovOnly_flag <> 'y'
   begin

	If DATABASEPROPERTYEX (@check_dbname,'status') <> 'RESTORING'
	   begin
		select @miscprint = 'DBA ERROR:  A differential restore cannot be completed because the database is not in ''RESTORING'' mode.'
		print  @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   end


	select @cmd = 'dir ' + @full_path + '\' + @diffname_wild
	--print @cmd

	Delete from #DirectoryTempTable
	insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
	delete from #DirectoryTempTable where cmdoutput is null
	delete from #DirectoryTempTable where cmdoutput like '%<DIR>%'
	delete from #DirectoryTempTable where cmdoutput like '%Directory of%'
	delete from #DirectoryTempTable where cmdoutput like '% File(s) %'
	delete from #DirectoryTempTable where cmdoutput like '% Dir(s) %'
	delete from #DirectoryTempTable where cmdoutput like '%Volume in drive%'
	delete from #DirectoryTempTable where cmdoutput like '%Volume Serial Number%'
	--select * from #DirectoryTempTable

	select @filecount = (select count(*) from #DirectoryTempTable)

	if @filecount < 1
	   BEGIN
		Select @miscprint = 'DBA WARNING: No differential files found for dbasp_prerestore at ' + @full_path 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   END


	Start_cmdoutput02:
	Select @save_cmdoutput = (Select top 1 cmdoutput from #DirectoryTempTable order by cmdoutput)
	Select @cu25cmdoutput = @save_cmdoutput

	select @save_fileYYYY = substring(@cu25cmdoutput, 7, 4)
	select @save_fileMM = substring(@cu25cmdoutput, 1, 2)
	select @save_fileDD = substring(@cu25cmdoutput, 4, 2)
	select @save_fileHH = substring(@cu25cmdoutput, 13, 2)
	Select @save_fileAMPM = substring(@cu25cmdoutput, 18, 1)
	If @save_fileAMPM = 'a' and @save_fileHH = '12'
	   begin
		Select @save_fileHH = '00'
	   end
	Else If @save_fileAMPM = 'p' and @save_fileHH <> '12'
	   begin
		Select @save_fileHH = @save_fileHH + 12
	   end
	select @save_fileMN = substring(@cu25cmdoutput, 16, 2)
	Select @save_filedate = @save_fileYYYY + @save_fileMM + @save_fileDD + @save_fileHH + @save_fileMN

	If @hold_filedate < @save_filedate
	   begin
		select @hold_diff_file_name = ltrim(rtrim(substring(@cu25cmdoutput, 40, 200)))
	   end

	Delete from #DirectoryTempTable where cmdoutput = @save_cmdoutput
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto Start_cmdoutput02
	   end



	If @hold_diff_file_name is null or @hold_diff_file_name = ''
	   BEGIN
		Select @miscprint = 'DBA ERROR: Unable to determine differential file for dbasp_prerestore at ' + @full_path 
		Print @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   END


	If @hold_diff_file_name like '%.DFL'
	   begin
		--  This code is for LiteSpeed files
		select @miscprint = 'EXEC master.dbo.xp_restore_database'
		print  @miscprint
		select @miscprint = '  @database = ''' + @check_dbname + ''''
		print  @miscprint
		select @miscprint = ', @filename = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		print  @miscprint
		select @miscprint = ', @with = RECOVERY'
		print  @miscprint
		select @miscprint = ', @with = ''stats'''
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '

		select @Restore_cmd = ''
		select @Restore_cmd = @Restore_cmd + 'EXEC master.dbo.xp_restore_database'
		select @Restore_cmd = @Restore_cmd + '  @database = ''' + @check_dbname + ''''
		select @Restore_cmd = @Restore_cmd + ', @filename = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		select @Restore_cmd = @Restore_cmd + ', @with = RECOVERY'
		select @Restore_cmd = @Restore_cmd + ', @with = ''stats'''

		-- Restore the differential
		select @cmd = @Restore_cmd
		Print 'Here is the restore command being executed;'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec (@cmd)

		If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
		   begin
			If @complete_on_diffOnly_fail = 'y'
			   begin
				--  finish the restore and send the DBA's an email
				Select @save_subject = 'DBAADMIN:  prerestore Failure for server ' + @@servername
				Select @save_message = 'Unable to restore the differential file for database ''' + @check_dbname + ''', the restore will be completed without the differential.'
				EXEC dbaadmin.dbo.dbasp_sendmail 
					@recipients = 'jim.wilson@gettyimages.com',  
					--@recipients = 'tssqldba@gettyimages.com',  
					@subject = @save_subject,
					@message = @save_message

				select @Restore_cmd = ''
				select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname + ' WITH RECOVERY'

				select @cmd = @Restore_cmd
				Print 'The differential restore failed.  Completing restore for just the database using the following command;'
				Print @cmd
				raiserror('', -1,-1) with nowait

				Exec (@cmd)

				If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
				   begin
					Print 'DBA Error:  Restore Failure (LiteSpeed DFL restore - Unable to finish restore without the DFL) for command ' + @cmd
					Select @error_count = @error_count + 1
					goto label99
				   end
			   end
			Else
			   begin
				Print 'DBA Error:  Restore Failure (LiteSpeed DFL restore) for command ' + @cmd
				Select @error_count = @error_count + 1
				goto label99
			   end
		   end
	   end
	Else If @hold_diff_file_name like '%.SQD'
	   begin
		--  This code is for RedGate files
		select @miscprint = 'Declare @cmd nvarchar(4000)'
		print  @miscprint
		select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @check_dbname + ']'
		print  @miscprint
		select @miscprint = ' FROM DISK = ''''' + @full_path + '\' + @hold_diff_file_name + ''''''
		print  @miscprint
		select @miscprint = ' WITH RECOVERY"'''
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
		print  @miscprint
		select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '

		select @Restore_cmd = ''
		select @Restore_cmd = @Restore_cmd + '-SQL "RESTORE DATABASE [' + @check_dbname + ']'
		select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		select @Restore_cmd = @Restore_cmd + ' WITH RECOVERY"'

		-- Restore the differential
		select @cmd = 'Exec master.dbo.sqlbackup ' + @Restore_cmd
		Print 'Here is the restore command being executed;'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec master.dbo.sqlbackup @Restore_cmd

		If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
		   begin
			If @complete_on_diffOnly_fail = 'y'
			   begin
				--  finish the restore and send the DBA's an email
				Select @save_subject = 'DBAADMIN:  prerestore Failure for server ' + @@servername
				Select @save_message = 'Unable to restore the differential file for database ''' + @check_dbname + ''', the restore will be completed without the differential.'
				EXEC dbaadmin.dbo.dbasp_sendmail 
					@recipients = 'jim.wilson@gettyimages.com',  
					--@recipients = 'tssqldba@gettyimages.com',  
					@subject = @save_subject,
					@message = @save_message

				select @Restore_cmd = ''
				select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname + ' WITH RECOVERY'

				select @cmd = @Restore_cmd
				Print 'The differential restore failed.  Completing restore for just the database using the following command;'
				Print @cmd
				raiserror('', -1,-1) with nowait

				Exec (@cmd)

				If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
				   begin
					Print 'DBA Error:  Restore Failure (Redgate SQD restore - Unable to finish restore without the SQD) for command ' + @cmd
					Select @error_count = @error_count + 1
					goto label99
				   end
			   end
			Else
			   begin
				Print 'DBA Error:  Restore Failure (Redgate SQD restore) for command ' + @cmd
				Select @error_count = @error_count + 1
				goto label99
			   end
		   end
	   end
	Else
	   begin
		--  This code is for non-LiteSpeed and non-RadGate files
		select @miscprint = 'RESTORE DATABASE ' + @check_dbname
		print  @miscprint
		select @miscprint = 'FROM DISK = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		print  @miscprint
		select @miscprint = 'WITH RECOVERY,'
		print  @miscprint
		select @miscprint = 'stats'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '

		select @Restore_cmd = ''
		select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname
		select @Restore_cmd = @Restore_cmd + ' FROM DISK = ''' + @full_path + '\' + @hold_diff_file_name + ''''
		select @Restore_cmd = @Restore_cmd + ' WITH RECOVERY,'
		select @Restore_cmd = @Restore_cmd + ' stats'

		-- Restore the differential
		select @cmd = @Restore_cmd
		Print 'Here is the restore command being executed;'
		Print @cmd
		raiserror('', -1,-1) with nowait

		Exec (@cmd)

		If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
		   begin
			If @complete_on_diffOnly_fail = 'y'
			   begin
				--  finish the restore and send the DBA's an email
				Select @save_subject = 'DBAADMIN:  prerestore Failure for server ' + @@servername
				Select @save_message = 'Unable to restore the differential file for database ''' + @check_dbname + ''', the restore will be completed without the differential.'
				EXEC dbaadmin.dbo.dbasp_sendmail 
					@recipients = 'jim.wilson@gettyimages.com',  
					--@recipients = 'tssqldba@gettyimages.com',  
					@subject = @save_subject,
					@message = @save_message

				select @Restore_cmd = ''
				select @Restore_cmd = @Restore_cmd + 'RESTORE DATABASE ' + @check_dbname + ' WITH RECOVERY'

				select @cmd = @Restore_cmd
				Print 'The differential restore failed.  Completing restore for just the database using the following command;'
				Print @cmd
				raiserror('', -1,-1) with nowait

				Exec (@cmd)

				If DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
				   begin
					Print 'DBA Error:  Restore Failure (Standard DIF restore - Unable to finish restore without the DIF) for command ' + @cmd
					Select @error_count = @error_count + 1
					goto label99
				   end
			   end
			Else
			   begin
				Print 'DBA Error:  Restore Failure (Standard DIF restore) for command ' + @cmd
				Select @error_count = @error_count + 1
				goto label99
			   end
		   end
	   end
   end




--  Trun off auto shrink and auto stats for ALTdbname restores
If @ALTdbname is not null and @ALTdbname <> '' and DATABASEPROPERTYEX (@check_dbname,'status') = 'ONLINE'
   begin
	select @miscprint = '--  ALTER DATABASE OPTIONS'
	Print @miscprint
	select @miscprint = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_CREATE_STATISTICS OFF WITH NO_WAIT'
	Print @miscprint
	Print ''
	select @miscprint = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_UPDATE_STATISTICS OFF WITH NO_WAIT'
	Print @miscprint
	Print ''
	select @miscprint = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_SHRINK OFF WITH NO_WAIT'
	Print @miscprint
	Print ''


	Print 'Here are the Alter Database Option commands being executed;'
	select @cmd = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_CREATE_STATISTICS OFF WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait

	Exec (@cmd)

	select @cmd = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_UPDATE_STATISTICS OFF WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait

	Exec (@cmd)

	select @cmd = 'ALTER DATABASE [' + @ALTdbname + '] SET AUTO_SHRINK OFF WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait

	Exec (@cmd)
   end





-- Shrink DB LDF Files if requested
If @post_shrink = 'y' and DATABASEPROPERTYEX (@check_dbname,'status') = 'ONLINE'
   begin
	Print '--NOTE:  Post Restore LDF file shrink was requested'
	Print ' '

	Select @miscprint = 'exec dbaadmin.dbo.dbasp_ShrinkLDFFiles @DBname = ''' + @check_dbname + ''''
	print  @miscprint
	Select @cmd = 'exec dbaadmin.dbo.dbasp_ShrinkLDFFiles @DBname = ''' + @check_dbname + ''''

	select @miscprint = 'go'
	print  @miscprint
	Print ' '


	If DATABASEPROPERTYEX (@check_dbname,'status') = 'ONLINE'
	   begin
		select @miscprint = 'Shrink file using command: ' + @cmd
		print  @miscprint
		exec(@cmd)
	   end
   end




-------------------   end   --------------------------

label99:

--  Check to make sure the DB is in 'restoring' mode if requested
If @db_norecovOnly_flag = 'y' and DATABASEPROPERTYEX (@check_dbname,'status') <> 'RESTORING'
   begin
	select @miscprint = 'DBA ERROR:  A norecovOnly restore was requested and the database is not in ''RESTORING'' mode.'
	print  @miscprint
	Select @error_count = @error_count + 1
   end

If @error_count = 0 and @db_norecovOnly_flag = 'n' and DATABASEPROPERTYEX (@check_dbname,'status') <> 'ONLINE'
   begin
	select @miscprint = 'DBA ERROR:  The prerestore process has failed for database ' + @check_dbname + '.  That database is not ''ONLINE'' at this time.'
	print  @miscprint
	Select @error_count = @error_count + 1
   end

drop table #DirectoryTempTable
drop table #filelist
drop table #filelist_ls
drop table #filelist_rg




If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_ProcessUpdateFiles
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_ProcessUpdateFiles]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_ProcessUpdateFiles]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_ProcessUpdateFiles

/*********************************************************
 **  Stored Procedure dbasp_ProcessUpdateFiles                  
 **  Written by Jim Wilson, Getty Images                
 **  June 08, 2009                                      
 **  
 **  This sproc will process files in the local dba_UpdateFiles
 **  folder under the dbasql share.  The process will rename the 
 **  files once they have been processed and purge old files as well.
 **
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	06/08/2009	Jim Wilson		New process.
--	======================================================================================



-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd 				nvarchar(4000)
	,@sqlcmd			nvarchar(4000)
	,@filename_wild			nvarchar(100)
	,@tempcount			int
	,@Hold_filename			sysname
	,@Hold_filedate			varchar(14)
	,@charpos			bigint
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_share			sysname
	,@SaveDays			smallint
	,@Retention_filedate		varchar(14)
	,@new_ext			nvarchar(30)
	,@BkUpDateStmp 			char(14)
	,@Hold_hhmmss			varchar(8)
	,@new_filename			sysname


DECLARE
	 @cu12cmdoutput			nvarchar(255)


----------------  initial values  -------------------
select @SaveDays = 15

Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @BkUpDateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 
Set @new_ext = '_' + @BkUpDateStmp + '.old'


create table #DirectoryTempTable (cmdoutput nvarchar(255) null)



/****************************************************************
 *                MainLine
 ***************************************************************/

Select @save_share = '\\'+ @save_servername + '\' + @save_servername2 + '_dbasql\dba_UpdateFiles'

------------------------------------------------------------------------------------------
--  Start BAIupdate process  -------------------------------------------------------------
------------------------------------------------------------------------------------------
Print 'Start DBA UpdateFile Processing'

-- Process *.sql files
--  Check for files in the DEPLcontrol folder for this server
Delete from #DirectoryTempTable
Select @cmd = 'dir ' + @save_share + '\*.* /B'
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null or cmdoutput = ''
--select * from #DirectoryTempTable
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%.sql'
--select * from #DirectoryTempTable


--  If any files were found, process them
If (select count(*) from #DirectoryTempTable) > 0
   begin
	start_cmdoutput01:

	Select @cu12cmdoutput = (select top 1 cmdoutput from #DirectoryTempTable)

	select @sqlcmd = 'sqlcmd -S' + @@servername + ' -i' + @save_share + '\' + rtrim(@cu12cmdoutput) + ' -o\\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs\DBA_UpdateFile_' + rtrim(@cu12cmdoutput) + ' -E'
	print @sqlcmd
	exec master.sys.xp_cmdshell @sqlcmd

	Select @new_filename = replace(@cu12cmdoutput, '.sql' , @new_ext)

	Select @cmd = 'ren "' + @save_share + '\' + rtrim(@cu12cmdoutput) + '" "' + rtrim(@new_filename) + '"'
	print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output


	--  Remove this record from #DirectoryTempTable and go to the next
	delete from #DirectoryTempTable where cmdoutput = @cu12cmdoutput
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto start_cmdoutput01
	   end
   end



-- Process *.gsql files
--  Check for files in the DEPLcontrol folder for this server
Delete from #DirectoryTempTable
Select @cmd = 'dir ' + @save_share + '\*.* /B'
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null or cmdoutput = ''
--select * from #DirectoryTempTable
delete from #DirectoryTempTable where ltrim(rtrim(cmdoutput)) not like '%.gsql'
--select * from #DirectoryTempTable


--  If any files were found, process them
If (select count(*) from #DirectoryTempTable) > 0
   begin
	start_cmdoutput02:

	Select @cu12cmdoutput = (select top 1 cmdoutput from #DirectoryTempTable)

	select @sqlcmd = 'sqlcmd -S' + @@servername + ' -i' + @save_share + '\' + rtrim(@cu12cmdoutput) + ' -o\\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs\DBA_UpdateFile_' + rtrim(@cu12cmdoutput) + ' -E'
	print @sqlcmd
	exec master.sys.xp_cmdshell @sqlcmd

	Select @new_filename = replace(@cu12cmdoutput, '.gsql' , @new_ext)

	Select @cmd = 'ren "' + @save_share + '\' + rtrim(@cu12cmdoutput) + '" "' + rtrim(@new_filename) + '"'
	print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output


	--  Remove this record from #DirectoryTempTable and go to the next
	delete from #DirectoryTempTable where cmdoutput = @cu12cmdoutput
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto start_cmdoutput02
	   end
   end




--  Process to delete old files  -------------------
Print 'Start Delete Old Files Processing - dba_UpdateFiles folder'

Select @save_share = '\\'+ @save_servername + '\' + @save_servername2 + '_dbasql\dba_UpdateFiles'

Set @Retention_filedate = convert(char(8), getdate()-@SaveDays, 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

select @cmd = 'dir ' + @save_share + '\*.old /B'

Delete from #DirectoryTempTable
insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
Delete from #DirectoryTempTable where cmdoutput is null

Select @tempcount = (select count(*) from #DirectoryTempTable)

While (@tempcount > 0)
   begin
	Select @Hold_filename = (select TOP 1 cmdoutput from #DirectoryTempTable)

	Select @charpos = charindex('.old', @Hold_filename)
	IF @charpos <> 0
	   begin
 		Select @Hold_filedate = substring(@Hold_filename, @charpos -14, 14)
	   end	

	If @Retention_filedate > @Hold_filedate
	   begin
		select @cmd = 'del ' + @save_share + '\' + @Hold_filename
		Print @cmd
		Exec master.sys.xp_cmdshell @cmd

		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
	   end
	Else
	   begin
		delete from #DirectoryTempTable where cmdoutput = @Hold_filename
	   end

	Select @tempcount = (select count(*) from #DirectoryTempTable)

   end




----------------  End  -------------------
label99:

drop table #DirectoryTempTable





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_regread
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_regread]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_regread]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_regread (@in_key sysname = 'HKEY_LOCAL_MACHINE'
				,@in_path sysname = null
				,@in_value sysname = null
				,@result_value nvarchar(500) OUTPUT)

/*********************************************************
 **  Stored Procedure dbasp_regread                  
 **  Written by Jim Wilson, Getty Images                
 **  04/06/2006                                      
 **  
 **  This procedure gets values from the registry.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/06/2006	Jim Wilson		New process for sql2005. 
--	11/06/2007	Jim Wilson		Added double quotes and xp_regread section. 
--	12/13/2007	Jim Wilson		Addewd return(0). 
--	08/22/2007	Jim Wilson		Addewd return(0). 
--	08/26/2007	Jim Wilson		Force reg2 for x64. 
--	======================================================================================

/***
declare @in_key sysname
declare @in_path sysname
declare @in_value sysname
declare @result_value nvarchar(500)

select @in_key = 'HKEY_LOCAL_MACHINE'
select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'
select @in_value = 'a'
Select @result_value = null
--***/


DECLARE
	 @miscprint			nvarchar(250)
	,@save_servername		sysname
	,@save_servername2		sysname
	,@charpos			int
	,@cmd				nvarchar(2000)
	,@save_value_result		nvarchar(500)


----------------  initial values  -------------------
Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Create table #regresults(results nvarchar(1500) null)


--  Check input values
If @in_key is null or @in_key not in ('HKLM', 'HKEY_LOCAL_MACHINE', 'HKCU', 'HKEY_CURRENT_USER', 'HKCR', 'HKEY_CLASSES_ROOT', 'HKU', 'HKEY_USERS', 'HKCC', 'HKEY_CURRENT_CONFIG')
   begin
	Select @miscprint = 'DBA WARNING: dbasp_regread - Invalid input parm for @in_key (Must be ''HKLM'', ''HKCU'', ''HKCR'', ''HKU'' or ''HKCC'')' 
	print @miscprint
	raiserror(@miscprint,-1,-1) with log
	goto label99
   end

If @in_path is null
   begin
	Select @miscprint = 'DBA WARNING: dbasp_regread - No input parm specified for @in_path' 
	print @miscprint
	raiserror(@miscprint,-1,-1) with log
	goto label99
   end

If @in_value is null
   begin
	Select @miscprint = 'DBA WARNING: dbasp_regread - No input parm specified for @in_value' 
	print @miscprint
	raiserror(@miscprint,-1,-1) with log
	goto label99
   end


/****************************************************************
 *                MainLine
 ***************************************************************/
If @@version like '%x64%'
   begin
	Select @cmd = 'reg2 query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /v ' + @in_value
   end
Else
   begin
	Select @cmd = 'reg query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /v ' + @in_value
   end

--print @cmd

insert into #regresults exec master.sys.xp_cmdshell @cmd
delete from #regresults where results is null
delete from #regresults where results like '%but is for a machine type%'
delete from #regresults where results like '%ERROR:%'
delete from #regresults where results like '%' + @in_path + '%'
delete from #regresults where results not like '%' + @in_value + '%'
--select * from #regresults

If (select count(*) from #regresults) = 0
   begin
		Select @cmd = 'reg2 query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /v ' + @in_value
		--print @cmd

		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		delete from #regresults where results like '%but is for a machine type%'
		delete from #regresults where results like '%ERROR:%'
		delete from #regresults where results like '%' + @in_path + '%'
		delete from #regresults where results not like '%' + @in_value + '%'
		--select * from #regresults
   end

select @save_value_result = (select top 1 results from #regresults)
--print @save_value_result


select @charpos = charindex('reg_', @save_value_result)
IF @charpos <> 0
   begin
	select @save_value_result = substring(@save_value_result, @charpos + 1, 500)
	select @charpos = charindex('  ', @save_value_result)
	IF @charpos <> 0
	   begin
		select @save_value_result = rtrim(substring(@save_value_result, @charpos + 1, 500))
		select @save_value_result = ltrim(@save_value_result)
	   end
   end

If @save_value_result like '%ERROR%' or @save_value_result is null or @save_value_result = ''
   begin
	--  using xp_regread as a last resort because reg query doesn't always work
	EXEC master.sys.xp_regread @rootkey = @in_key, @key = @in_path, @value_name = @in_value, @value = @save_value_result OUTPUT
   end

Select @result_value = @save_value_result
--print @result_value


--  Finalization  -------------------------------------------------------------------

label99:

drop table #regresults

return(0)


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_renameDB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_renameDB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_renameDB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_renameDB ( @current_dbname sysname = null,
					@new_dbname sysname = null,
					@force_newldf char(1) = 'n',
					@auto_create_stats_on char(1) = 'y',
					@auto_update_stats_on char(1) = 'y',
					@auto_shrink_on char(1) = 'n')

/*********************************************************
 **  Stored Procedure dbasp_renameDB                  
 **  Written by Jim Wilson, Getty Images                
 **  August 06, 2008                                      
 **  
 **  This procedure is used to rename a DB using detach and reattach.
 **
 **  This proc accepts the following input parms:
 **  - @current_dbname is the name of the current database being renamed.
 **  - @new_dbname will be the name of the database after the rename.
 **  - @force_newldf is a flag to force the creation of a new ldf file
 **  - @auto_create_stats_on is a flag to set this DB option after the rename.
 **  - @auto_update_stats_on is a flag to set this DB option after the rename.
 **  - @auto_shrink_on is a flag to set this DB option after the rename.
 ***************************************************************/
  as

  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/06/2008	Jim Wilson		New process.
--	09/25/2009	Jim Wilson		Add kill process.
--	09/29/2009	David Spriggs		Increased the SPID default from 6 to 10.
--	10/26/2009	Jim Wilson		Increased the SPID default from 10 to 49.
--	10/28/2009	Jim Wilson		Removed code to set offline and then back to online.
--	======================================================================================


/***
Declare @current_dbname sysname
Declare @new_dbname sysname
Declare @force_newldf char(1)
Declare @auto_create_stats_on char(1)
Declare @auto_update_stats_on char(1)
Declare @auto_shrink_on char(1)

Select @current_dbname = 'ArtistListing_new'
Select @new_dbname = 'ArtistListing'
Select @force_newldf = 'y'
Select @auto_create_stats_on = 'y'
Select @auto_update_stats_on = 'y'
Select @auto_shrink_on = 'n'
--***/


-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@error_count			int
	,@cmd 				nvarchar(4000)
	,@charpos			int
	,@savepos			int
	,@save_file_path		nvarchar(500)
	,@hold_ldfpath			nvarchar(260)
	,@fileseed			smallint
	,@attach_cmd			nvarchar(4000)
	,@iSPID				int
	,@DBID				int

DECLARE
	 @cu12fileid			smallint
	,@cu12groupid			smallint
	,@cu12name			nvarchar(128)
	,@cu12filename			nvarchar(260)


----------------  initial values  -------------------
Select @error_count = 0


Create table #db_files (
		fileid smallint,
		groupid smallint,
		size int,
		maxsize int,
		growth int,
		status int,
		perf int,
		name nchar(128),
		filename nchar(260))


--  Check input parms
if DATABASEPROPERTYEX (@current_dbname,'status') <> 'ONLINE' or DATABASEPROPERTYEX (@current_dbname,'status') is null
   BEGIN
	Select @miscprint = 'DBA WARNING: @current_dbname must be a vaild (online) database' 
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

if exists (select 1 from master.sys.databases where name = @new_dbname)
   BEGIN
	Select @miscprint = 'DBA WARNING: The value for input parm @new_dbname currently exists as a database.  Please drop that DB and rerun this process.'
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   END

--  Inset DBfile info into the #db_files table
Delete from #db_files

Select @cmd = 'Insert into #db_files  select * from [' + @current_dbname + '].sys.sysfiles'
exec (@cmd)
--select * from #db_files

If (select count(*) from #db_files) = 0
   begin
	Select @miscprint = 'DBA WARNING: No entries in the sys.sysfiles table for the current database ' + @current_dbname + '.'
	Print @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end



/****************************************************************
 *                MainLine
 ***************************************************************/


Print '--  DB Rename Process Starting'
Print ' '
Select @miscprint = '--  Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print ' '


--  First we format the atach command
Select @attach_cmd = 'CREATE DATABASE [' + rtrim(@new_dbname) + '] ON '

Select @fileseed = 1

--------------------  Cursor for 12DB  -----------------------
select @cmd = 'DECLARE cu12_file Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.name, f.filename
   From #db_files  f ' + 
  'Order By f.fileid For Read Only'

EXECUTE(@cmd)

OPEN cu12_file

WHILE (12=12)
   Begin
	FETCH Next From cu12_file Into @cu12fileid, @cu12groupid, @cu12name, @cu12filename 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_file
	      BREAK
           end
	

	If @fileseed = 1
	   begin
		If @cu12groupid <> 0 or @force_newldf = 'n'
		   begin
			SELECT @attach_cmd = @attach_cmd + '(FILENAME = ''' + rtrim(@cu12filename) + ''')'

			--  parse and save the file path
			Select @save_file_path = ''
			Select @savepos = 1
			label12a:
			Select @charpos = charindex('\', @cu12filename, @savepos)
			IF @charpos <> 0
			   begin
				Select @savepos = @charpos+1
				goto label12a
			   end	

			Select @save_file_path = @save_file_path + substring(@cu12filename, 1, @savepos-2)
		   end
	   end
	Else
	   begin
		If @cu12groupid <> 0 or @force_newldf = 'n'
		   begin
			SELECT @attach_cmd = @attach_cmd + ', (FILENAME = ''' + rtrim(@cu12filename) + ''')'  
		   end
	   end

	Select @fileseed = @fileseed + 1

   End  -- loop 12
   DEALLOCATE cu12_file


If @force_newldf = 'n'
   begin
	SELECT @attach_cmd = @attach_cmd + ' FOR ATTACH'
   end
Else
   begin
	SELECT @attach_cmd = @attach_cmd + ' FOR ATTACH_REBUILD_LOG'
   end


If (select is_db_chaining_on from master.sys.databases where name = @current_dbname) = 1 
  and (select is_trustworthy_on from master.sys.databases where name = @current_dbname) = 1
   begin
	SELECT @attach_cmd = @attach_cmd + ' WITH TRUSTWORTHY ON, DB_CHAINING ON; '
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @current_dbname) = 0 
  and (select is_trustworthy_on from master.sys.databases where name = @current_dbname) = 0
   begin
	SELECT @attach_cmd = @attach_cmd + ' WITH TRUSTWORTHY OFF, DB_CHAINING OFF; '
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @current_dbname) = 1 
  and (select is_trustworthy_on from master.sys.databases where name = @current_dbname) = 0
   begin
	SELECT @attach_cmd = @attach_cmd + ' WITH TRUSTWORTHY OFF, DB_CHAINING ON; '
   end
Else If (select is_db_chaining_on from master.sys.databases where name = @current_dbname) = 0 
  and (select is_trustworthy_on from master.sys.databases where name = @current_dbname) = 1
   begin
	SELECT @attach_cmd = @attach_cmd + ' WITH TRUSTWORTHY ON, DB_CHAINING OFF; '
   end


--  Kill process
Select @DBID = dbid FROM master.sys.sysdatabases where name = @current_dbname

Select @iSPID = 49
WHILE @iSPID IS NOT NULL
   begin
	Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID and spid > @iSPID
	IF @iSPID IS NOT NULL
	   begin
		Select @cmd = 'KILL ' + convert(varchar(12), @iSPID )
		Print @cmd
		exec(@cmd)
	   end
   end


--  Now we start the detach process
select @cmd = 'alter database [' + @current_dbname + '] set RESTRICTED_USER WITH NO_WAIT'
Print 'Set current DB restricted user - command being executed;'
Print @cmd
raiserror('', -1,-1) with nowait
Exec (@cmd)

select @cmd = 'alter database [' + @current_dbname + '] SET SINGLE_USER WITH NO_WAIT'
Print 'Set current DB single user - command being executed;'
Print @cmd
raiserror('', -1,-1) with nowait
Exec (@cmd)

Select @cmd = 'exec master.sys.sp_detach_db ''' + rtrim(@current_dbname) + ''', @skipchecks = ''true'''
Print 'Here is the Detach command being executed;'
Print @cmd
raiserror('', -1,-1) with nowait
Exec (@cmd)

If @@error<> 0
   begin
	select @miscprint = 'DBA Error:  Detach failure for command ' + @cmd
	print  @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end


-- Pause before we re-attach
Waitfor delay '00:00:02'


If @force_newldf = 'y'
   begin
	If exists (select 1 from #db_files where groupid = 0)
	   begin
		start_ldf01:
		select @hold_ldfpath = (select top 1 filename from #db_files where groupid = 0)

		select @cmd = 'Del ' + @hold_ldfpath
		Print 'Delete current LDF file using command;'
		Print @cmd
		raiserror('', -1,-1) with nowait
		Exec master.sys.xp_cmdshell @cmd

		Delete from #db_files where filename = @hold_ldfpath
		If exists (select 1 from #db_files where groupid = 0)
		   begin
			goto start_ldf01
		   end
	   end

	select @cmd = 'Del ' + @save_file_path + '\' + @new_dbname + '_log.ldf'
	Print 'Make sure the new LDF file does not exist using command;'
	Print @cmd
	raiserror('', -1,-1) with nowait
	Exec master.sys.xp_cmdshell @cmd
   end


-- reattach the DB
Print 'Here is the Attach command being executed;'
Print @attach_cmd
raiserror('', -1,-1) with nowait
Exec (@attach_cmd)

If @@error<> 0
   begin
	select @miscprint = 'DBA Error:  ReAttach Failure for command ' + @attach_cmd
	print  @miscprint
	Select @error_count = @error_count + 1
	goto label99
   end


-- Pause after we re-attach
Waitfor delay '00:00:02'

--  Check to make sure the DB is 'online'
If DATABASEPROPERTYEX (@new_dbname,'status') <> 'ONLINE'
   begin
	select @miscprint = 'DBA ERROR:  The database rename was not successful.'
	print  @miscprint
	Select @error_count = @error_count + 1
   end


--  Set DB options
Print ''
Print 'Here are the Alter Database Option commands being executed;'

If @auto_create_stats_on = 'y'
   begin
	select @cmd = 'ALTER DATABASE [' + @new_dbname + '] SET AUTO_CREATE_STATISTICS ON WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait
	Exec (@cmd)
   end
Else
   begin
	select @cmd = 'ALTER DATABASE [' + @new_dbname + '] SET AUTO_CREATE_STATISTICS OFF WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait
	Exec (@cmd)
   end

If @auto_update_stats_on = 'y'
   begin
	select @cmd = 'ALTER DATABASE [' + @new_dbname + '] SET AUTO_UPDATE_STATISTICS ON WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait
	Exec (@cmd)
   end
Else
   begin
	select @cmd = 'ALTER DATABASE [' + @new_dbname + '] SET AUTO_UPDATE_STATISTICS OFF WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait
	Exec (@cmd)
   end

If @auto_shrink_on = 'y'
   begin
	select @cmd = 'ALTER DATABASE [' + @new_dbname + '] SET AUTO_SHRINK ON WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait
	Exec (@cmd)
   end
Else
   begin
	select @cmd = 'ALTER DATABASE [' + @new_dbname + '] SET AUTO_SHRINK OFF WITH NO_WAIT'
	Print @cmd
	raiserror('', -1,-1) with nowait
	Exec (@cmd)
   end


select @cmd = 'ALTER DATABASE [' + @new_dbname + '] SET MULTI_USER WITH NO_WAIT'
Print @cmd
raiserror('', -1,-1) with nowait
Exec (@cmd)

select @cmd = 'ALTER AUTHORIZATION ON DATABASE::' + @new_dbname + ' TO sa;'
Print @cmd
raiserror('', -1,-1) with nowait
Exec (@cmd)



Print '--  DB Rename Process Completed'
Print ' '
Select @miscprint = '--  ' + convert(varchar(30),getdate(),9)
Print  @miscprint



-------------------   end   --------------------------

label99:


drop table #db_files


If @error_count > 0
   begin
	raiserror(@miscprint,16,-1) with log
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORT_SQLhealth
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORT_SQLhealth]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORT_SQLhealth]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_REPORT_SQLhealth (@rpt_recipient sysname = 'tssqldba@gettyimages.com'
						,@checkin_grace_hours smallint = 32
						,@recycle_grace_days smallint = 120
						,@reboot_grace_days smallint = 120
						,@userDB_size_cutoff_MB int = 25000
						,@save_SQLEnv sysname = '')

/*********************************************************
 **  Stored Procedure dbasp_REPORT_SQLhealth                  
 **  Written by Jim Wilson, Getty Images                
 **  December 14, 2007                                      
 **  
 **  This dbasp is set up to monitor SQL health by reviewing the
 **  central util_server table. 
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/14/2007	Jim Wilson		New report
--	08/22/2008	Jim Wilson		Convertion to new dba_*info tables
--	08/27/2008	Jim Wilson		New input parm @save_sqlenv
--	12/17/2008	Jim Wilson		Added 'default' as valid backup type
--	03/25/2009	Jim Wilson		New section to check for compression backup software trial versions.
--	03/26/2009	Jim Wilson		Fixed bug with printing wrong memory setting for x64 servers.
--	05/13/2009	Jim Wilson		Added clusterinfo check processing.
--	07/10/2009	Jim Wilson		Added mom verify check.
--	03/12/2010	Jim Wilson		Added support for active = 'm'.
--	03/17/2010	Jim Wilson		Changed pagefile_size to pagefile_inuse.
--	======================================================================================

/*
declare @rpt_recipient sysname
declare @checkin_grace_hours smallint
declare @recycle_grace_days smallint
declare @reboot_grace_days smallint
declare @userDB_size_cutoff_MB int
declare @save_SQLEnv sysname

select @rpt_recipient = 'jim.wilson@gettyimages.com'
Select @checkin_grace_hours = 32
select @recycle_grace_days = 120
select @reboot_grace_days = 120
select @userDB_size_cutoff_MB = 25000
Select @save_SQLEnv = 'production'
--*/

-----------------  declares  ------------------
Declare 
	 @miscprint			nvarchar(255)
	,@cmd				nvarchar(4000)
	,@charpos			int
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_sqlservername		sysname
	,@save_sqlservername2		sysname
	,@save_SQLmax_memory_all	bigint
	,@save_moddate			datetime
	,@date_control			datetime
	,@save_SQLrecycle_date		datetime
	,@save_OSuptime			sysname
	,@save_reboot_days		nvarchar(10)
	,@save_dbaadmin_Version		sysname
	,@save_size_of_userDBs_MB	int
	,@save_litespeed		sysname
	,@save_RedGate			sysname 
	,@save_backuptype		sysname
	,@save_SQLmax_memory		nvarchar(20)
	,@save_Memory			sysname
	,@save_awe			nchar(1)
	,@save_boot_pae			nchar(1)
	,@save_boot_3gb			nchar(1)
	,@save_boot_userva		nchar(1)
	,@version_control		sysname
	,@rpt_flag			char(1)
	,@first_flag			char(1)
	,@subject			nvarchar(255)
	,@message			nvarchar(4000)
	,@out_filename			sysname
	,@save_domain			sysname
	,@save_Name2			sysname
	,@save_momverifydate		datetime


----------------  initial values  -------------------
Select @subject = 'SQL Health Check from [' + upper(@@servername) + '] on ' + convert(nvarchar(19), getdate(), 121)
Select @message = ''
Select @rpt_flag = 'n'

--  Set servername variables
Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')


--  Create the output file
Select @out_filename = '\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\SQLhealth_report_' + @save_servername2 + '.txt'
Print  ' '
Select @cmd = 'copy nul ' + @out_filename
EXEC master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'echo ' + @subject + '>>' + @out_filename
EXEC master.sys.xp_cmdshell @cmd, no_output

Select @message = '.'
Select @cmd = 'echo' + @message + '>>' + @out_filename
EXEC master.sys.xp_cmdshell @cmd, no_output



--  create the temp table
declare @tblv_DBA_Serverinfo table (SQLServerName sysname
			    ,SQLServerENV sysname
			    ,Active char(1)
			    ,modDate datetime
			    ,SQL_Version nvarchar (500) null
			    ,dbaadmin_Version sysname null
			    ,backup_type sysname null
			    ,LiteSpeed sysname null
			    ,RedGate sysname NULL
			    ,DomainName sysname NULL
			    ,SQLrecycle_date sysname NULL
			    ,awe_enabled char(1) NULL
			    ,MAXdop_value nvarchar(5) NULL
			    ,SQLmax_memory nvarchar(20) NULL
			    ,tempdb_filecount nvarchar(10) NULL
			    ,iscluster char(1) NULL
			    ,Port nvarchar(10) NULL
			    ,IPnum sysname NULL
			    ,CPUcore sysname NULL
			    ,CPUtype sysname NULL
			    ,Memory sysname NULL
			    ,OSname sysname NULL
			    ,OSver sysname NULL
			    ,OSuptime sysname NULL
			    ,boot_3gb char(1) NULL
			    ,boot_pae char(1) NULL
			    ,boot_userva char(1) NULL
			    ,Pagefile_inuse sysname NULL
			    ,SystemModel sysname NULL
			    ,momverifydate datetime NULL
			    )

declare @tblv_moddate table (SQLServerName sysname
			    ,modDate datetime
			    )

declare @tblv_recycle table (SQLServerName sysname
			    ,SQLrecycle_date sysname NULL
			    )

declare @tblv_reboot table (SQLServerName sysname
			    ,OSuptime sysname NULL
			    )

declare @tblv_version table (SQLServerName sysname
			    ,dbaadmin_Version sysname null
			    )

declare @tblv_backup_usage table (SQLServerName sysname
			    ,size_of_userDBs_MB int null
			    )

declare @tblv_std_backup_check table (SQLServerName sysname
			    ,LiteSpeed char(1) null
			    ,RedGate char(1) NULL
			    )

declare @tblv_cmp_backup_check table (SQLServerName sysname
			    ,backup_type sysname null
			    ,LiteSpeed char(1) null
			    ,RedGate char(1) NULL
			    )


declare @tblv_memory table (SQLServerName sysname
			    ,awe_enabled char(1) NULL
			    ,SQLmax_memory nvarchar(20) NULL
			    ,Memory sysname NULL
			    ,boot_3gb char(1) NULL
			    ,boot_pae char(1) NULL
			    ,boot_userva char(1) NULL
			    )

declare @tblv_mom01 table (SQLServerName sysname
			    ,momverifydate datetime NULL)


declare @tblv_cluster table (SQLServerName sysname
			    ,Name2 sysname NULL
			    )




/****************************************************************
 *                MainLine
 ***************************************************************/

--  Load data into temp table
delete from @tblv_DBA_Serverinfo
insert into @tblv_DBA_Serverinfo (SQLServerName
			    ,SQLServerENV
			    ,Active
			    ,modDate
			    ,SQL_Version
			    ,dbaadmin_Version
			    ,backup_type
			    ,LiteSpeed
			    ,RedGate
			    ,DomainName
			    ,SQLrecycle_date
			    ,awe_enabled
			    ,MAXdop_value
			    ,SQLmax_memory
			    ,tempdb_filecount
			    ,iscluster
			    ,Port
			    ,IPnum
			    ,CPUcore
			    ,CPUtype
			    ,Memory
			    ,OSname
			    ,OSver
			    ,OSuptime
			    ,boot_3gb
			    ,boot_pae
			    ,boot_userva
			    ,Pagefile_inuse
			    ,SystemModel
			    ,momverifydate)
select SQLName
	,SQLEnv
	,Active
	,modDate
	,SQLver
	,dbaadmin_Version
	,backup_type
	,LiteSpeed
	,RedGate
	,DomainName
	,SQLrecycleDate
	,awe_enabled
	,MAXdop_value
	,SQLmax_memory
	,tempdb_filecount
	,iscluster
	,Port
	,IPnum
	,CPUcore
	,CPUtype
	,Memory
	,OSname
	,OSver
	,OSuptime
	,boot_3gb
	,boot_pae
	,boot_userva
	,Pagefile_inuse
	,SystemModel
	,momverifydate
From dbo.DBA_Serverinfo
Where DomainName = @save_domain
 and  SQLEnv like '%' + @save_SQLEnv + '%'

delete from @tblv_DBA_Serverinfo where SQL_Version like '%7.00%'
delete from @tblv_DBA_Serverinfo where active = 'n'

--Select * from @tblv_DBA_Serverinfo



--  MAINT MODE Check mod date (looking for servers that have stopped checking in)
Select @date_control = dateadd(hour, -336, getdate())

delete from @tblv_moddate
insert into @tblv_moddate (SQLServerName, modDate) 
select SQLServerName, modDate
From @tblv_DBA_Serverinfo
where modDate < @date_control
and active = 'm'

If (select count(*) from @tblv_moddate) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) in Maintenance Mode have not checked into [' + @@servername + '] within the past ' + convert(nvarchar(5), @checkin_grace_hours) + ' hours.'
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_moddate:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_moddate order by SQLServerName)
	select @save_moddate = (select moddate from @tblv_moddate where sqlservername = @save_sqlservername)


	Select @message = convert(char(30), @save_sqlservername) + convert(nvarchar(30), @save_moddate, 121)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_moddate where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_moddate) > 0
	   begin
		goto start_moddate
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



--  Check mod date (looking for servers that have stopped checking in)
Select @date_control = dateadd(hour, -@checkin_grace_hours, getdate())

delete from @tblv_moddate
insert into @tblv_moddate (SQLServerName, modDate) 
select SQLServerName, modDate
From @tblv_DBA_Serverinfo
where modDate < @date_control
and active = 'y'

If (select count(*) from @tblv_moddate) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) have not checked into [' + @@servername + '] within the past ' + convert(nvarchar(5), @checkin_grace_hours) + ' hours.'
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_moddate2:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_moddate order by SQLServerName)
	select @save_moddate = (select moddate from @tblv_moddate where sqlservername = @save_sqlservername)


	Select @message = convert(char(30), @save_sqlservername) + convert(nvarchar(30), @save_moddate, 121)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_moddate where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_moddate) > 0
	   begin
		goto start_moddate2
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end


--  Check last sql recycle date
Select @date_control = dateadd(day, -@recycle_grace_days, getdate())

delete from @tblv_recycle
insert into @tblv_recycle (SQLServerName, SQLrecycle_date) 
select SQLServerName, SQLrecycle_date
From @tblv_DBA_Serverinfo
where SQLrecycle_date < @date_control
  and Active = 'y'

If (select count(*) from @tblv_recycle) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) have not been recycled in the past ' + convert(nvarchar(10), @recycle_grace_days) + ' day(s).'
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_recycle:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_recycle order by SQLServerName)
	select @save_SQLrecycle_date = (select SQLrecycle_date from @tblv_recycle where sqlservername = @save_sqlservername)


	Select @message = convert(char(30), @save_sqlservername) + convert(nvarchar(30), @save_SQLrecycle_date, 121)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_recycle where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_recycle) > 0
	   begin
		goto start_recycle
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check last OS Reboot date
delete from @tblv_reboot
insert into @tblv_reboot (SQLServerName, OSuptime) 
select SQLServerName, OSuptime
From @tblv_DBA_Serverinfo
where OSuptime is not null
  and Active = 'y'

If (select count(*) from @tblv_reboot) > 0
   begin
	Select @save_sqlservername = ''
	start_reboot01:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_reboot where sqlservername > @save_sqlservername order by SQLServerName)
	select @save_OSuptime = (select OSuptime from @tblv_reboot where sqlservername = @save_sqlservername)

	Select @charpos = charindex(' Day', @save_OSuptime)
	IF @charpos <> 0
	   begin
		select @save_reboot_days = left(@save_OSuptime, @charpos-1)
		If convert(int, @save_reboot_days) < @reboot_grace_days
		   begin
			delete from @tblv_reboot where sqlservername = @save_sqlservername
		   end
	   end

	If (select count(*) from @tblv_reboot where sqlservername > @save_sqlservername) > 0
	   begin
		goto start_reboot01
	   end
   end


If (select count(*) from @tblv_reboot) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) have not been rebooted in the past ' + convert(nvarchar(10), @reboot_grace_days) + ' day(s).'
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_reboot02:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_reboot order by SQLServerName)
	select @save_OSuptime = (select OSuptime from @tblv_reboot where sqlservername = @save_sqlservername)


	Select @message = convert(char(30), @save_sqlservername) + convert(nvarchar(30), @save_OSuptime)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_reboot where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_reboot) > 0
	   begin
		goto start_reboot02
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for old DBAADMIN version
Select @version_control = (select top 1 vchLabel from dbaadmin.dbo.build where vchname = 'dbaadmin' order by iBuildID desc)

delete from @tblv_version
insert into @tblv_version (SQLServerName, dbaadmin_Version) 
select SQLServerName, dbaadmin_Version
From @tblv_DBA_Serverinfo
where dbaadmin_Version <> rtrim(@version_control)
  and Active = 'y'

Delete from @tblv_DBA_Serverinfo where dbaadmin_Version is null

If (select count(*) from @tblv_version) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) do not have the latest version of DBAADMIN; [' + @version_control + '].' 
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_version:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_version order by SQLServerName)
	select @save_dbaadmin_Version = (select dbaadmin_Version from @tblv_version where sqlservername = @save_sqlservername)


	Select @message = convert(char(30), @save_sqlservername) + @save_dbaadmin_Version
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_version where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_version) > 0
	   begin
		goto start_version
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for Litspeed or Redgate usage
delete from @tblv_backup_usage
insert into @tblv_backup_usage (SQLServerName) 
select SQLServerName
From @tblv_DBA_Serverinfo
where SQLServerENV = @save_SQLEnv
  and backup_type in ('standard', 'default')
  and Active = 'y'

set @first_flag = 'y'

If (select count(*) from @tblv_backup_usage) > 0
   begin
	start_comp_backup01:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_backup_usage)
	Select @save_size_of_userDBs_MB = (select sum(convert(float, data_size_MB) + convert(float, log_size_MB)) from dbo.dba_dbinfo where SQLname = @save_sqlservername)
    
	If @save_size_of_userDBs_MB > @userDB_size_cutoff_MB
	   begin
		Select @rpt_flag = 'y'

		If @first_flag = 'y'
		   begin
			Select @first_flag = 'n'
			Select @message = 'The following SQL server(s) should be using Litespeed or RedGate for backup processing (DB size issues).' 
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end

		Select @message = convert(char(30), @save_sqlservername) + convert(nvarchar(30), @save_size_of_userDBs_MB)
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output

	   end

	Delete from @tblv_backup_usage where SQLServerName = @save_sqlservername
	If (select count(*) from @tblv_backup_usage) > 0
	   begin
		goto start_comp_backup01
	   end

	If @first_flag = 'n'
	   begin
		Select @message = '.'
		Select @cmd = 'echo' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output

		Select @message = '.'
		Select @cmd = 'echo' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end
   end




--  Check for unused compression backup types
delete from @tblv_std_backup_check
insert into @tblv_std_backup_check (SQLServerName, litespeed, RedGate) 
select SQLServerName, litespeed, RedGate
From @tblv_DBA_Serverinfo
where backup_type in ('standard', 'default')
  and SQLServerENV = @save_SQLEnv
  and (LiteSpeed = 'y' or RedGate = 'y')
  and Active = 'y'


If (select count(*) from @tblv_std_backup_check) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) should be using Litespeed or RedGate for backup processing (software is installed).' 
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_std_backup_check:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_std_backup_check order by SQLServerName)
	select @save_litespeed = (select LiteSpeed from @tblv_std_backup_check where sqlservername = @save_sqlservername)
	select @save_litespeed = 'LiteSpeed: ' + @save_litespeed
	select @save_RedGate = (select RedGate from @tblv_std_backup_check where sqlservername = @save_sqlservername)
	select @save_RedGate = 'RedGate: ' + @save_RedGate


	Select @message = convert(nchar(30), @save_sqlservername) + convert(nchar(25), @save_RedGate) + convert(nvarchar(25), @save_litespeed)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_std_backup_check where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_std_backup_check) > 0
	   begin
		goto start_std_backup_check
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for compression backup types with software not installed
delete from @tblv_cmp_backup_check
insert into @tblv_cmp_backup_check (SQLServerName, backup_type, LiteSpeed, RedGate) 
select SQLServerName, backup_type, LiteSpeed, RedGate
From @tblv_DBA_Serverinfo
where backup_type not in ('standard', 'default') 
  and SQLServerENV = @save_SQLEnv
  and Active = 'y'

Delete from @tblv_cmp_backup_check where backup_type is null
Delete from @tblv_cmp_backup_check where backup_type = 'LiteSpeed' and LiteSpeed = 'y'
Delete from @tblv_cmp_backup_check where backup_type = 'RedGate' and RedGate = 'y'
If (select count(*) from @tblv_cmp_backup_check) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) are set up to use backup compression software that is not installed.' 
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_cmp_backup_check:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_cmp_backup_check order by SQLServerName)
	select @save_backuptype = (select backup_type from @tblv_cmp_backup_check where sqlservername = @save_sqlservername)
	select @save_backuptype = 'Backup Type: ' + @save_backuptype
	select @save_litespeed = (select LiteSpeed from @tblv_cmp_backup_check where sqlservername = @save_sqlservername)
	select @save_litespeed = 'LiteSpeed: ' + @save_litespeed
	select @save_RedGate = (select RedGate from @tblv_cmp_backup_check where sqlservername = @save_sqlservername)
	select @save_RedGate = 'RedGate: ' + @save_RedGate


	Select @message = convert(nchar(30), @save_sqlservername) + convert(nchar(30), @save_backuptype) + convert(nchar(25), @save_RedGate) + convert(nvarchar(25), @save_litespeed)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_cmp_backup_check where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_cmp_backup_check) > 0
	   begin
		goto start_cmp_backup_check
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end


--  Check for compression backup types in Trail version mode
delete from @tblv_cmp_backup_check
insert into @tblv_cmp_backup_check (SQLServerName, backup_type, LiteSpeed, RedGate) 
select s.SQLName, s.backup_type, s.LiteSpeed, s.RedGate
From dbo.DBA_Serverinfo s, dbo.Compress_BackupInfo cb
where (s.redgate = 'y' or s.LiteSpeed = 'y') 
  and s.SQLENV = @save_SQLEnv
  and s.Active = 'y'
  and s.SQLName = cb.SQLname
  and cb.versiontype like '%trial%'



Delete from @tblv_cmp_backup_check where backup_type is null
If (select count(*) from @tblv_cmp_backup_check) > 0
   begin
	Select @rpt_flag = 'y'

	Select @message = 'The following SQL server(s) are using a trial version of backup compression software.' 
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	start_cmp_trial_check:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_cmp_backup_check order by SQLServerName)


	Select @message = convert(nchar(30), @save_sqlservername)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_cmp_backup_check where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_cmp_backup_check) > 0
	   begin
		goto start_cmp_trial_check
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



--  Check for memory issues - limit settings
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where Active = 'y'

Delete from @tblv_memory where SQLmax_memory is null or SQLmax_memory = 'error'
Delete from @tblv_memory where Memory is null or Memory = 'error'

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory01:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	select @save_SQLmax_memory = (select SQLmax_memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	Select @charpos = charindex('.', @save_Memory)
	IF @charpos <> 0
	   begin
		select @save_Memory = left(@save_Memory, @charpos-1)
		If convert(int, @save_Memory) < convert(int, @save_SQLmax_memory)
		   begin
			If @first_flag = 'y'
			   begin
				Select @rpt_flag = 'y'
				Select @first_flag = 'n'

				Select @message = 'The following SQL server(s) memory limit setting is greater than the available memory on the server.' 
				Select @cmd = 'echo ' + @message + '>>' + @out_filename
				EXEC master.sys.xp_cmdshell @cmd, no_output
			   end

			Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + ' Limit Set: ' + convert(nchar(25), @save_SQLmax_memory)
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end



	delete from @tblv_memory where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory01
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for memory issues - limit settings for all instances greater than memory installed
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where Active = 'y'

Delete from @tblv_memory where SQLmax_memory is null or SQLmax_memory = 'error' or SQLmax_memory = 'Unknown' or SQLmax_memory = ''
Delete from @tblv_memory where Memory is null or Memory = 'error'
--select * from @tblv_DBA_Serverinfo

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory02:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	Select @save_sqlservername2 = @save_sqlservername
	Select @charpos = charindex('\', @save_sqlservername2)
	IF @charpos <> 0
	   begin
		select @save_sqlservername2 = left(@save_sqlservername2, @charpos-1)
	   end

	Select @save_SQLmax_memory_all = (select sum(convert(bigint, SQLmax_memory)) from @tblv_DBA_Serverinfo where SQLServerName like @save_sqlservername2 + '%' and Active = 'y')

	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	Select @charpos = charindex('.', @save_Memory)
	IF @charpos <> 0
	   begin
		select @save_Memory = left(@save_Memory, @charpos-1)
		If convert(int, @save_Memory) < @save_SQLmax_memory_all
		   begin
			If @first_flag = 'y'
			   begin
				Select @rpt_flag = 'y'
				Select @first_flag = 'n'

				Select @message = 'The following SQL server(s) (all instances) memory limit setting is greater than the available memory on the server.' 
				Select @cmd = 'echo ' + @message + '>>' + @out_filename
				EXEC master.sys.xp_cmdshell @cmd, no_output
			   end

			Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + ' Total Limit(s) Set: ' + convert(nchar(25), @save_SQLmax_memory_all)
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end


	delete from @tblv_memory where sqlservername like @save_sqlservername2 + '%'
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory02
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for memory issues - limit settings plus 4GB for all instances less than memory installed
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where Active = 'y'

Delete from @tblv_memory where SQLmax_memory is null or SQLmax_memory = 'error' or SQLmax_memory = 'Unknown' or SQLmax_memory = ''
Delete from @tblv_memory where Memory is null or Memory = 'error'

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory03:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	Select @save_sqlservername2 = @save_sqlservername
	Select @charpos = charindex('\', @save_sqlservername2)
	IF @charpos <> 0
	   begin
		select @save_sqlservername2 = left(@save_sqlservername2, @charpos-1)
	   end

	Select @save_SQLmax_memory_all = (select sum(convert(bigint, SQLmax_memory)) from @tblv_DBA_Serverinfo where SQLServerName like @save_sqlservername2 + '%' and Active = 'y')

	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	Select @charpos = charindex('.', @save_Memory)
	IF @charpos <> 0
	   begin
		select @save_Memory = left(@save_Memory, @charpos-1)
		If convert(int, @save_Memory) > @save_SQLmax_memory_all + 4096
		   begin
			If @first_flag = 'y'
			   begin
				Select @rpt_flag = 'y'
				Select @first_flag = 'n'

				Select @message = 'The following SQL server(s) (all instances) memory limit settings are not high enough related to the available memory on the server.' 
				Select @cmd = 'echo ' + @message + '>>' + @out_filename
				EXEC master.sys.xp_cmdshell @cmd, no_output
			   end

			Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + ' Total Limit(s) Set: ' + convert(nchar(25), @save_SQLmax_memory_all)
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end


	delete from @tblv_memory where sqlservername like @save_sqlservername2 + '%'
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory03
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for memory settings - for 64 bit servers
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where sql_version like '%X64%'
  and Active = 'y'

Delete from @tblv_memory where Memory is null or Memory = 'error' or Memory = 'Unknown' or Memory = ''

select * from @tblv_memory

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory04:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	Select @save_awe = (select awe_enabled from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_pae = (select boot_pae from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_3gb = (select boot_3gb from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_userva = (select boot_userva from @tblv_memory where SQLServerName = @save_sqlservername)

	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	If @save_awe = 'y' or @save_boot_pae = 'y' or @save_boot_3gb = 'y' or @save_boot_userva = 'y'
	   begin
		If @first_flag = 'y'
		   begin
			Select @rpt_flag = 'y'
			Select @first_flag = 'n'

			Select @message = 'The following 64 bit SQL server(s) should have these memory related settings all set to ''n''.' 
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end

		Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + ' AWE: ''' + @save_awe + '''   PAE: ''' + @save_boot_pae +  '''   3GB: ''' + @save_boot_3gb +  '''   UserVA: ''' + @save_boot_userva + ''''
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end

	delete from @tblv_memory where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory04
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for memory 3GB and userva settings when memory is low - for 32 bit servers
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where sql_version not like '%X64%'
  and Active = 'y'

Delete from @tblv_memory where Memory is null or Memory = 'error' or Memory = 'Unknown' or Memory = ''

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory05:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	Select @save_awe = (select awe_enabled from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_pae = (select boot_pae from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_3gb = (select boot_3gb from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_userva = (select boot_userva from @tblv_memory where SQLServerName = @save_sqlservername)

	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	Select @charpos = charindex('.', @save_Memory)
	IF @charpos <> 0
	   begin
		select @save_Memory = left(@save_Memory, @charpos-1)
		If (convert(int, @save_Memory) < 3500 and @save_boot_3gb = 'y') or
		   (convert(int, @save_Memory) < 3000 and @save_boot_userva = 'y')
		   begin
			If @first_flag = 'y'
			   begin
				Select @rpt_flag = 'y'
				Select @first_flag = 'n'

				Select @message = 'The following SQL server(s) have incorrect settings related to the boot.ini 3gb or userva parms.  They should not be set.' 
				Select @cmd = 'echo ' + @message + '>>' + @out_filename
				EXEC master.sys.xp_cmdshell @cmd, no_output
			   end

			Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + '  3GB: ''' + @save_boot_3gb +  '''   UserVA: ''' + @save_boot_userva + ''''
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end


	delete from @tblv_memory where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory05
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for memory 3GB and userva settings when memory is high - for 32 bit servers
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where sql_version not like '%X64%'
  and Active = 'y'

Delete from @tblv_memory where Memory is null or Memory = 'error' or Memory = 'Unknown' or Memory = ''

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory06:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	Select @save_awe = (select awe_enabled from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_pae = (select boot_pae from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_3gb = (select boot_3gb from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_userva = (select boot_userva from @tblv_memory where SQLServerName = @save_sqlservername)

	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	Select @charpos = charindex('.', @save_Memory)
	IF @charpos <> 0
	   begin
		select @save_Memory = left(@save_Memory, @charpos-1)
		If convert(int, @save_Memory) > 16000 and (@save_boot_3gb = 'y' or @save_boot_userva = 'y')
		   begin
			If @first_flag = 'y'
			   begin
				Select @rpt_flag = 'y'
				Select @first_flag = 'n'

				Select @message = 'The following SQL server(s) have incorrect settings related to the boot.ini 3gb or userva parms.  They should not be set.' 
				Select @cmd = 'echo ' + @message + '>>' + @out_filename
				EXEC master.sys.xp_cmdshell @cmd, no_output
			   end

			Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + ' 3GB: ''' + @save_boot_3gb +  '''   UserVA: ''' + @save_boot_userva + ''''
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end


	delete from @tblv_memory where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory06
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for memory AWE and PAE settings when memory is low - for 32 bit servers
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where sql_version not like '%X64%'
  and Active = 'y'

Delete from @tblv_memory where Memory is null or Memory = 'error' or Memory = 'Unknown' or Memory = ''

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory07:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	Select @save_awe = (select awe_enabled from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_pae = (select boot_pae from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_3gb = (select boot_3gb from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_userva = (select boot_userva from @tblv_memory where SQLServerName = @save_sqlservername)

	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	Select @charpos = charindex('.', @save_Memory)
	IF @charpos <> 0
	   begin
		select @save_Memory = left(@save_Memory, @charpos-1)
		If convert(int, @save_Memory) < 4100 and (@save_awe = 'y' or @save_boot_pae = 'y')
		   begin
			If @first_flag = 'y'
			   begin
				Select @rpt_flag = 'y'
				Select @first_flag = 'n'

				Select @message = 'The following SQL server(s) have incorrect settings related to the boot.ini pae or SQL awe parms.  They should both be set to ''n''.' 
				Select @cmd = 'echo ' + @message + '>>' + @out_filename
				EXEC master.sys.xp_cmdshell @cmd, no_output
			   end

			Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + ' AWE: ''' + @save_awe +  '''   PAE: ''' + @save_boot_pae + ''''
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end


	delete from @tblv_memory where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory07
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end




--  Check for memory AWE and PAE settings when memory is high - for 32 bit servers
delete from @tblv_memory
insert into @tblv_memory (SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva) 
select SQLServerName, awe_enabled, SQLmax_memory, Memory, boot_3gb, boot_pae, boot_userva
From @tblv_DBA_Serverinfo
where sql_version not like '%X64%'
  and Active = 'y'

Delete from @tblv_memory where Memory is null or Memory = 'error' or Memory = 'Unknown' or Memory = ''

If (select count(*) from @tblv_memory) > 0
   begin
	Select @first_flag = 'y'
	start_memory08:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_memory order by SQLServerName)
	Select @save_awe = (select awe_enabled from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_pae = (select boot_pae from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_3gb = (select boot_3gb from @tblv_memory where SQLServerName = @save_sqlservername)
	Select @save_boot_userva = (select boot_userva from @tblv_memory where SQLServerName = @save_sqlservername)

	select @save_Memory = (select Memory from @tblv_memory where sqlservername = @save_sqlservername)
	select @save_Memory = replace(@save_Memory, ',', '')
	select @save_Memory = replace(@save_Memory, 'MB', '')
	select @save_Memory = rtrim(@save_Memory)

	Select @charpos = charindex('.', @save_Memory)
	IF @charpos <> 0
	   begin
		select @save_Memory = left(@save_Memory, @charpos-1)
		If convert(int, @save_Memory) > 4096 and (@save_awe = 'n' or @save_boot_pae = 'n')
		   begin
			If @first_flag = 'y'
			   begin
				Select @rpt_flag = 'y'
				Select @first_flag = 'n'

				Select @message = 'The following SQL server(s) have incorrect settings related to the boot.ini pae or SQL awe parms.  They should both be set to ''y''.' 
				Select @cmd = 'echo ' + @message + '>>' + @out_filename
				EXEC master.sys.xp_cmdshell @cmd, no_output
			   end

			Select @message = convert(nchar(30), @save_sqlservername) + ' Memory: ' + convert(nchar(15), @save_Memory) + ' AWE: ''' + @save_awe +  '''   PAE: ''' + @save_boot_pae + ''''
			Select @cmd = 'echo ' + @message + '>>' + @out_filename
			EXEC master.sys.xp_cmdshell @cmd, no_output
		   end
	   end


	delete from @tblv_memory where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_memory) > 0
	   begin
		goto start_memory08
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



--  Check the MOM verify date for production servers.
delete from @tblv_mom01
insert into @tblv_mom01 (SQLServerName, momverifydate) 
select SQLServerName, momverifydate
From @tblv_DBA_Serverinfo
where SQLServerENV = 'production'
  and Active = 'y'
  and momverifydate < getdate()-2

Delete from @tblv_mom01 where SQLServerName is null or SQLServerName = ''

If (select count(*) from @tblv_mom01) > 0
   begin
	Select @first_flag = 'y'
	start_mom01:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_mom01 order by SQLServerName)
	Select @save_momverifydate = (select momverifydate from @tblv_mom01 where SQLServerName = @save_sqlservername)

	If @first_flag = 'y'
	   begin
		Select @rpt_flag = 'y'
		Select @first_flag = 'n'
		Select @message = 'The following production SQL server(s) are no longer being checked by MOM.' 
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end

	Select @message = convert(nchar(30), @save_sqlservername) + '  Last Checked: ' + convert(nvarchar(16), @save_momverifydate, 121)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	delete from @tblv_mom01 where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_mom01) > 0
	   begin
		goto start_mom01
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



delete from @tblv_mom01
insert into @tblv_mom01 (SQLServerName, momverifydate) 
select SQLServerName, momverifydate
From @tblv_DBA_Serverinfo
where SQLServerENV = 'production'
  and Active = 'y'
  and momverifydate is null

Delete from @tblv_mom01 where SQLServerName is null or SQLServerName = ''

If (select count(*) from @tblv_mom01) > 0
   begin
	Select @first_flag = 'y'
	start_mom02:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_mom01 order by SQLServerName)

	If @first_flag = 'y'
	   begin
		Select @rpt_flag = 'y'
		Select @first_flag = 'n'
		Select @message = 'The following production SQL server(s) are not being checked by MOM.' 
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end

	Select @message = convert(nchar(30), @save_sqlservername)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	delete from @tblv_mom01 where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_mom01) > 0
	   begin
		goto start_mom02
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



--  Check the dba_clusterinfo table  ------------------------------------------------------------------------
--  Check Quorum Group
delete from @tblv_cluster
insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.quorumgroup_node 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.quorumgroup_status <> 'online'

If (select count(*) from @tblv_cluster) > 0
   begin
	Select @first_flag = 'y'
	start_cluster01:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_cluster order by SQLServerName)
	Select @save_Name2 = (select top 1 Name2 from @tblv_cluster where SQLServerName = @save_sqlservername)

	If @first_flag = 'y'
	   begin
		Select @rpt_flag = 'y'
		Select @first_flag = 'n'

		Select @message = 'The following SQL server(s) have status issues related to the quorum group in the cluster.' 
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end

	Select @message = convert(nchar(30), @save_sqlservername) + ' Quorum Group: ' + convert(nchar(15), @save_Name2)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_cluster where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_cluster) > 0
	   begin
		goto start_cluster01
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



--  Check DTC Group
delete from @tblv_cluster
insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.DTCgroup_node 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.DTCgroup_status <> 'online'


If (select count(*) from @tblv_cluster) > 0
   begin
	Select @first_flag = 'y'
	start_cluster02:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_cluster order by SQLServerName)
	Select @save_Name2 = (select top 1 Name2 from @tblv_cluster where SQLServerName = @save_sqlservername)

	If @first_flag = 'y'
	   begin
		Select @rpt_flag = 'y'
		Select @first_flag = 'n'

		Select @message = 'The following SQL server(s) have status issues related to the DTC group in the cluster.' 
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end

	Select @message = convert(nchar(30), @save_sqlservername) + ' DTC Group: ' + convert(nchar(15), @save_Name2)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_cluster where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_cluster) > 0
	   begin
		goto start_cluster02
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



--  Check Virtual Server Group(s)
delete from @tblv_cluster
insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.VirtSrv01_node 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.VirtSrv01_node <> ''
and dc.VirtSrv01_node is not null
and dc.VirtSrv01_status <> 'online'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.VirtSrv02_node 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.VirtSrv02_node <> ''
and dc.VirtSrv02_node is not null
and dc.VirtSrv02_status <> 'online'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.VirtSrv03_node 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.VirtSrv03_node <> ''
and dc.VirtSrv03_node is not null
and dc.VirtSrv03_status <> 'online'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.VirtSrv04_node 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.VirtSrv04_node <> ''
and dc.VirtSrv04_node is not null
and dc.VirtSrv04_status <> 'online'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.VirtSrv05_node 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.VirtSrv05_node <> ''
and dc.VirtSrv05_node is not null
and dc.VirtSrv05_status <> 'online'


If (select count(*) from @tblv_cluster) > 0
   begin
	Select @first_flag = 'y'
	start_cluster03:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_cluster order by SQLServerName)
	Select @save_Name2 = (select top 1 Name2 from @tblv_cluster where SQLServerName = @save_sqlservername)

	If @first_flag = 'y'
	   begin
		Select @rpt_flag = 'y'
		Select @first_flag = 'n'

		Select @message = 'The following SQL server(s) have status issues related to a Virtual Server in the cluster.' 
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end

	Select @message = convert(nchar(30), @save_sqlservername) + ' Virtual Server: ' + convert(nchar(15), @save_Name2)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_cluster where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_cluster) > 0
	   begin
		goto start_cluster03
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



--  Check Physical Node(s)
delete from @tblv_cluster
insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.clustNode01 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.clustNode01 <> ''
and dc.clustNode01 is not null
and dc.clustNode01_status <> 'Up'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.clustNode02 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.clustNode02 <> ''
and dc.clustNode02 is not null
and dc.clustNode02_status <> 'Up'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.clustNode03 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.clustNode03 <> ''
and dc.clustNode03 is not null
and dc.clustNode03_status <> 'Up'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.clustNode04 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.clustNode04 <> ''
and dc.clustNode04 is not null
and dc.clustNode04_status <> 'Up'

insert into @tblv_cluster (SQLServerName, Name2) 
Select dc.sqlname, dc.clustNode05 
from @tblv_DBA_Serverinfo ds, dbo.DBA_Clusterinfo dc
where ds.SQLServerName = dc.sqlname
and ds.Active = 'y'
and dc.clustNode05 <> ''
and dc.clustNode05 is not null
and dc.clustNode05_status <> 'Up'


If (select count(*) from @tblv_cluster) > 0
   begin
	Select @first_flag = 'y'
	start_cluster04:
	Select @save_sqlservername = (select top 1 SQLServerName from @tblv_cluster order by SQLServerName)
	Select @save_Name2 = (select top 1 Name2 from @tblv_cluster where SQLServerName = @save_sqlservername)

	If @first_flag = 'y'
	   begin
		Select @rpt_flag = 'y'
		Select @first_flag = 'n'

		Select @message = 'The following SQL server(s) have status issues related to a Physical node in the cluster.' 
		Select @cmd = 'echo ' + @message + '>>' + @out_filename
		EXEC master.sys.xp_cmdshell @cmd, no_output
	   end

	Select @message = convert(nchar(30), @save_sqlservername) + ' Physical Node: ' + convert(nchar(15), @save_Name2)
	Select @cmd = 'echo ' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output


	delete from @tblv_cluster where sqlservername = @save_sqlservername
	If (select count(*) from @tblv_cluster) > 0
	   begin
		goto start_cluster04
	   end

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @message = '.'
	Select @cmd = 'echo' + @message + '>>' + @out_filename
	EXEC master.sys.xp_cmdshell @cmd, no_output
   end



send_report:


If @rpt_flag = 'y'
   begin
	--print @subject
	--print @message

	--  Email TS SQL DBA with this information
	EXEC dbaadmin.dbo.dbasp_sendmail 
	    @recipients = @rpt_recipient,  
	    @subject = @subject,
	    @message = @subject,
	    @attachments = @out_filename
   end



--print @subject
--print @message


---------------------------  Finalization for process  -----------------------
label99:

 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORTcomp_backup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORTcomp_backup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORTcomp_backup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_REPORTcomp_backup

/*********************************************************
 **  Stored Procedure dbasp_REPORTcomp_backup                 
 **  Written by Jim Wilson, Getty Images                
 **  August 20, 2009                                      
 **  
 **  This dbasp is set up to create a report documenting
 **  compression backup license usage for all SQL servers. 
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/20/2009	Jim Wilson		New report.
--	08/25/2009	Jim Wilson		Changed display for OSname.
--	08/27/2009	Jim Wilson		Added code for status.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@charpos		int
	,@save_BU_ID		int
	,@save_servername	sysname
	,@save_SQLname		sysname
	,@save_CompType		sysname
	,@save_Version		sysname
	,@save_VersionType	sysname
	,@save_License		sysname
	,@save_VendorName	sysname
	,@save_Product		sysname
	,@save_LI_Version	sysname
	,@save_LI_Type		sysname
	,@save_LicenseNum	int
	,@save_Support_ExpDate	datetime
	,@save_active		char(1)
	,@hold_License		sysname
	,@save_detail_count	int
	,@save_detail01_ID	int
	,@save_OSname		sysname
	,@save_SQLver		sysname
	,@save_Status		sysname


----------------  initial values  -------------------

      

--  Create temp table
CREATE TABLE #temp_BackupInfo ([BU_ID] [int] IDENTITY(1,1) NOT NULL
			    ,[servername] [sysname] NULL
			    ,[SQLname] [sysname] NULL
			    ,[CompType] [sysname] NULL
			    ,[Version] [sysname] NULL
			    ,[VersionType] [sysname] NULL
			    ,[License] [sysname] NULL
			    )

CREATE TABLE #temp_detail01 ([detail01_ID] [int] IDENTITY(1,1) NOT NULL
			    ,[servername] [sysname] NULL
			    ,[SQLname] [sysname] NULL
			    ,[Version] [sysname] NULL
			    ,[VersionType] [sysname] NULL
			    )


--  load the temp table
Insert into #temp_BackupInfo
select servername, SQLname, CompType, Version, VersionType, License
from dbo.Compress_BackupInfo
--select * from #temp_BackupInfo order by comptype, License



/****************************************************************
 *                MainLine
 ***************************************************************/

 
----------------------  Print the headers  ----------------------
Print  '/*******************************************************************'
Select @miscprint = '   REPORT COMPERSSION BACKUP USAGE & LICENSE INFO'
Print  @miscprint
Print  ' '
Select @miscprint = '-- Generated on ' + convert(varchar(30),getdate())
Print  @miscprint
Print  '*******************************************************************/'
Print  ''
Print  ''


If (select count(*) from #temp_BackupInfo) = 0
   begin
	Select @miscprint = 'No License rows to report.'
	Print  @miscprint
   end
Else
   begin
	Select @hold_License = ''

	Start01:
	Select @save_BU_ID = (select top 1 BU_ID from #temp_BackupInfo order by CompType, VersionType, License, servername)
	Select @save_License = (select License from #temp_BackupInfo where BU_ID = @save_BU_ID)
	Select @save_CompType = (select CompType from #temp_BackupInfo where BU_ID = @save_BU_ID)

	If exists (select 1 from dbo.LicenseInfo where LicenseKey = @save_License)
	   begin
		Select @save_VendorName = (select VendorName from dbo.LicenseInfo where LicenseKey = @save_License)
		Select @save_Product = (select Product from dbo.LicenseInfo where LicenseKey = @save_License)
		Select @save_LI_Version = (select Version from dbo.LicenseInfo where LicenseKey = @save_License)
		Select @save_LI_Type = (select Type from dbo.LicenseInfo where LicenseKey = @save_License)
		Select @save_LicenseNum = (select LicenseNum from dbo.LicenseInfo where LicenseKey = @save_License)
		Select @save_Support_ExpDate = (select Support_ExpDate from dbo.LicenseInfo where LicenseKey = @save_License)
		Select @save_active = (select active from dbo.LicenseInfo where LicenseKey = @save_License)
	   end
	Else
	   begin
		Select @save_VendorName = @save_CompType
		Select @save_Product = 'unknown'
		Select @save_LI_Version = 'unknown'
		Select @save_LI_Type = 'unknown'
		Select @save_LicenseNum = 0
		Select @save_Support_ExpDate = '01-01-1900'
		Select @save_active = 'n'
	   end

	Select @save_Status = 'Active'

	If datediff(d, @save_Support_ExpDate, getdate()) > 0
	   begin
		Select @save_Status = 'Support Expired'
	   end

	If @save_LicenseNum = 0
	   begin
		Select @save_Status = 'Not Valid'
	   end


	If @save_License <> @hold_License
	   begin
		Select @miscprint = 'Vendor: ' + @save_VendorName
		Print  @miscprint
		If getdate() > @save_Support_ExpDate
		  begin
			Select @miscprint = 'License Key: ' + @save_License + '   Type: ' + @save_LI_Type + '   Support Expired: ' + convert(nvarchar(12), @save_Support_ExpDate, 101)
			Print  @miscprint
		   end
		Else
		  begin
			Select @miscprint = 'License Key: ' + @save_License + '   Type: ' + @save_LI_Type + '   Support Expires: ' + convert(nvarchar(12), @save_Support_ExpDate, 101)
			Print  @miscprint
		   end
		Select @miscprint = 'Version: ' + @save_LI_Version
		Print  @miscprint
		Select @miscprint = 'Status: ' + @save_Status
		Print  @miscprint
		Select @miscprint = 'License Total: ' + convert(nvarchar(10), @save_LicenseNum)
		Print  @miscprint

		Select @hold_License = @save_License
	   end


		--  Load detail for this license key
		delete from #temp_detail01

		start02:
		Select @save_servername = (select servername from #temp_BackupInfo where BU_ID = @save_BU_ID)
		Select @save_SQLname = (select SQLname from #temp_BackupInfo where BU_ID = @save_BU_ID)
		Select @save_Version = (select Version from #temp_BackupInfo where BU_ID = @save_BU_ID)
		Select @save_VersionType = (select VersionType from #temp_BackupInfo where BU_ID = @save_BU_ID)

		Insert into #temp_detail01 values(@save_servername, @save_SQLname, @save_Version, @save_VersionType)


		--  Check for more detail rows to process
		delete from #temp_BackupInfo where servername = @save_servername and License = @hold_License

		If (select count(*) from #temp_BackupInfo where License = @hold_License) > 0
		   begin
			Select @save_BU_ID = (select top 1 BU_ID from #temp_BackupInfo where License = @hold_License order by CompType, VersionType, License, servername)
			goto Start02
		   end


		Select @save_detail_count = (select count(*) from #temp_detail01)
		If @save_detail_count is null
		    begin
			Select @save_detail_count = 0
		   end

		Select @miscprint = 'License''s Used: ' + convert(nvarchar(10), @save_detail_count)
		Print  @miscprint
		Print  ' '


		If @save_detail_count > 0
		   begin
			Select @miscprint = 'Server Name           SQL Name                   OS Version                      Version          Type'
			Print  @miscprint
			Select @miscprint = '====================  =========================  ==============================  ===============  ===================='
			Print  @miscprint

			detail01:
			
			Select @save_detail01_ID = (select top 1 detail01_ID from #temp_detail01 order by servername)
			Select @save_servername = (select servername from #temp_detail01 where detail01_ID = @save_detail01_ID)
			Select @save_SQLname = (select SQLname from #temp_detail01 where detail01_ID = @save_detail01_ID)
			Select @save_Version = (select Version from #temp_detail01 where detail01_ID = @save_detail01_ID)
			Select @save_VersionType = (select VersionType from #temp_detail01 where detail01_ID = @save_detail01_ID)

			Select @save_OSname = (select top 1 OSname from dbo.DBA_serverinfo where SQLname = @save_SQLname)
			If @save_OSname like '% 20%'
			   begin
				Select @charpos = charindex(' 20', @save_OSname)
				IF @charpos <> 0
				   begin
					Select @save_OSname = substring(@save_OSname, @charpos, 50)
				   end

				Select @save_SQLver = (select top 1 SQLver from dbo.DBA_serverinfo where SQLname = @save_SQLname)
				If @save_SQLver like '%x64%' and @save_OSname not like '%x64%'
				   begin
					Select @save_OSname = @save_OSname + 'x64'
				   end 
			   end
			Else
			   begin
				Select @charpos = charindex('Standard', @save_OSname)
				IF @charpos <> 0
				   begin
					Select @save_OSname = substring(@save_OSname, @charpos, 50)
				   end
				Select @charpos = charindex('Enterprise', @save_OSname)
				IF @charpos <> 0
				   begin
					Select @save_OSname = substring(@save_OSname, @charpos, 50)
				   end
			   end


			Select @save_OSname = replace(@save_OSname, ',', '')
			Select @save_OSname = ltrim(@save_OSname)


			Select @miscprint = convert(char(20), @save_servername) + '  ' + convert(char(25), @save_SQLname) + '  ' + convert(char(30), @save_OSname) + '  ' + convert(char(15), @save_Version) + '  ' + convert(char(21), @save_VersionType)
			Print  @miscprint


			--  check for more rows
			delete from #temp_detail01 where detail01_ID = @save_detail01_ID
			If (select count(*) from #temp_detail01) > 0
			   begin
				goto detail01
			   end



		   end
	



	Print ''
	Print ''


	--  check for more rows to process
	delete from #temp_BackupInfo where License = @hold_License

	If (select count(*) from #temp_BackupInfo) > 0
	   begin
		goto Start01
	   end

   end


-----------------  Finalizations  ------------------
label99:

Print  ' '
Print  '/*******************************************************************'
Select @miscprint = '         END OF REPORT - FOR SERVER: ' + @@servername
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


drop table #temp_BackupInfo
drop table #temp_detail01


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORTjobs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORTjobs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORTjobs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_REPORTjobs

/*********************************************************
 **  Stored Procedure dbasp_REPORTjobs                  
 **  Written by Jim Wilson, Getty Images                
 **  July 25, 2001                                      
 **  
 **  This dbasp is set up to create a report documenting
 **  enabled jobs on a specific SQL server. 
 **        
 ***************************************************************/
  as
set nocount on


--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	04/26/2002	Jim Wilson		Revision History added
--	05/20/2002	Jim Wilson		Fix the 'single quotes in the job name' problem
--	05/28/2002	Jim Wilson		Changed hours to four didgit possible
--	06/21/2002	Jim Wilson		Added code to handel negitive job step durrations.
--	09/26/2002	Jim Wilson		Shortened long lines to 255
--	10/16/2008	Jim Wilson		Updated for SQL 2005.
--	======================================================================================



-----------------  declares  ------------------

DECLARE
	 @miscprint			varchar(255)
	,@cmd				varchar(4000)
	,@savecursor			varchar(4000)
	,@save_count			int
	,@save_runduration		int
	,@save_tot_seconds		int
	,@save_hr			int
	,@save_min			int
	,@save_sec			int
	,@save_dur_text			char (12)
	,@save_start_time		char (05)
	,@save_end_time			char (05)
	,@starthour			char (04)
	,@startmin			char (02)
	,@startsec			char (02)
	,@starttime			char (08)
	,@starthour1			char (01)
	,@starthour2			char (01)
	,@starthour3			char (01)
	,@starthour4			char (01)
	,@startmin1			char (01)
	,@startmin2			char (01)
	,@startsec1			char (01)
	,@startsec2			char (01)
	,@endtime			char (06)
	,@endhour1			char (01)
	,@endhour2			char (01)
	,@endmin1			char (01)
	,@endmin2			char (01)
	,@endsec1			char (01)
	,@endsec2			char (01)
	,@sched_flag			char (01)
	,@save_start_sun		char (10)
	,@save_start_mon		char (10)
	,@save_start_tue		char (10)
	,@save_start_wed		char (10)
	,@save_start_thur		char (10)
	,@save_start_fri		char (10)
	,@save_start_sat		char (10)
	,@day_suffix			char (02)
	,@output_flag			char(1)
	,@query_job_name		sysname
	,@startpos			int
	,@charpos			int
      
DECLARE
	 @cu10job_id			uniqueidentifier
	,@cu10job_name			sysname

DECLARE
	 @cu11step_id			int
	,@cu11run_duration		int

DECLARE
	 @cu12step_id			int
	,@cu12step_name			sysname

DECLARE
	 @cu13name			sysname
	,@cu13freq_type			int
	,@cu13freq_interval		int
	,@cu13freq_subday_type		int
	,@cu13freq_subday_interval	int
	,@cu13freq_relative_interval	int
	,@cu13freq_recurrence_factor	int
	,@cu13active_start_time		int
	,@cu13active_end_time		int
	

----------------  initial values  -------------------
Select @output_flag		= 'n'


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Print the headers


   Print  ' '
   Print  '/********************************************************************'
   Select @miscprint = '   REPORT SCHEDULED JOBS '
   Print  @miscprint
   Print  ' '
   Select @miscprint = '-- Generated on ' + convert(varchar(30),getdate()) + '  For Server ' + @@servername
   Print  @miscprint
   Print  ' '
   Select @miscprint = '-- Note:  Averages are calculated for the past 30 days of activity'
   Print  @miscprint
   Print  '********************************************************************/'


--  Cursor for active jobs  -----------------------------------------------------------------
EXECUTE('DECLARE cursor_jobs Insensitive Cursor For ' + 
  'SELECT j.job_id, j.name  
   From msdb.dbo.sysjobs j ' + 
  'Where j.enabled = 1
   Order By j.name For Read Only')


OPEN cursor_jobs

WHILE (10=10)
   Begin
	FETCH Next From cursor_jobs Into @cu10job_id, @cu10job_name

	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_jobs
	      BREAK
           end


--  If there are single quotes in the job name, change them to double single quotes for the query  ----------------
Select @query_job_name = @cu10job_name
Select @startpos = 1
label01:
	select @charpos = charindex('''', @query_job_name, @startpos)
	IF @charpos <> 0
	   begin
	    select @query_job_name = stuff(@query_job_name, @charpos, 1, '''''')
	    select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @query_job_name, @startpos)
	IF @charpos <> 0
	   begin
	    goto label01
 	   end


--  Load the run duration information for this job into a temp table  ----------------
create table #temp_duration(step_id int, run_duration int)

select @cmd = 'insert into #temp_duration(step_id, run_duration) select h.step_id, h.run_duration from msdb.dbo.sysjobhistory  h , msdb.dbo.sysjobs  j  
		where j.name = ''' + @query_job_name + ''' and j.job_id = h.job_id and h.run_date > convert(int, (convert(char(8), getdate()-30, 112)))' 

--print @cmd
exec (@cmd)


--  Convert run duration to seconds (math with time is a pain!)

--  Cursor for run duration info  -----------------------------------------------------------------
EXECUTE('DECLARE cursor_dur Cursor For ' + 
  'SELECT d.step_id, d.run_duration  
   From #temp_duration  d ' + 
  'For Update')


OPEN cursor_dur
	
WHILE (11=11)
   Begin
	FETCH Next From cursor_dur Into @cu11step_id, @cu11run_duration
	
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_dur
	      BREAK
           end

If @cu11run_duration < 0
   begin
	Select @cu11run_duration = 0
   end

Select @starttime  = str(@cu11run_duration, 8)
Select @starthour1  = substring(@starttime, 1, 1)
Select @starthour2  = substring(@starttime, 2, 1) 
Select @starthour3  = substring(@starttime, 3, 1) 
Select @starthour4  = substring(@starttime, 4, 1) 
Select @startmin1   = substring(@starttime, 5, 1) 
Select @startmin2   = substring(@starttime, 6, 1) 
Select @startsec1   = substring(@starttime, 7, 1) 
Select @startsec2   = substring(@starttime, 8, 1)
	
If @starthour1= ' '
   select @starthour1 = '0'
If @starthour2= ' '
   select @starthour2 = '0'
If @starthour3= ' '
   select @starthour3 = '0'
If @starthour4= ' '
   select @starthour4 = '0'
If @startmin1 = ' '
   select @startmin1 = '0'
If @startmin2 = ' '
   select @startmin2 = '0'
If @startsec1 = ' '
   select @startsec1 = '0'
If @startsec2 = ' '
   select @startsec2 = '0'

select @save_tot_seconds = convert(int, @startsec2)
select @save_tot_seconds = @save_tot_seconds + (convert(int, @startsec1) * 10)
select @save_tot_seconds = @save_tot_seconds + (convert(int, @startmin2) * 60)
select @save_tot_seconds = @save_tot_seconds + (convert(int, @startmin1) * 600)
select @save_tot_seconds = @save_tot_seconds + (convert(int, @starthour4) * 3600)
select @save_tot_seconds = @save_tot_seconds + (convert(int, @starthour3) * 36000)
select @save_tot_seconds = @save_tot_seconds + (convert(int, @starthour2) * 360000)
select @save_tot_seconds = @save_tot_seconds + (convert(int, @starthour1) * 3600000)


update #temp_duration set run_duration = @save_tot_seconds where current of cursor_dur

 End  -- run duration loop 
DEALLOCATE cursor_dur




--  Select and format job duration
Select @save_count = (select count(*) from #temp_duration where step_id = 0)

If @save_count > 0
   begin
	Select @save_runduration = (select sum(run_duration)/count(*) from #temp_duration where step_id = 0)
   end
Else
   begin
	Select @save_runduration = 0
   end

If @save_runduration > 3599
   begin
	Select @save_hr = (@save_runduration/3600)
	Select @save_runduration = @save_runduration - (@save_hr * 3600)
   end
Else
   begin 
	Select @save_hr = 0
   end

If @save_runduration > 59
   begin
	Select @save_min = (@save_runduration/60)
	Select @save_runduration = @save_runduration - (@save_min * 60)
   end
Else
   begin 
	Select @save_min = 0
   end

Select @save_sec = @save_runduration 

Select @starthour  = str(@save_hr, 4)
Select @starthour1  = substring(@starthour, 1, 1) 
Select @starthour2  = substring(@starthour, 2, 1) 
Select @starthour3  = substring(@starthour, 3, 1) 
Select @starthour4  = substring(@starthour, 4, 1) 
Select @startmin  = str(@save_min, 2)
Select @startmin1   = substring(@startmin, 1, 1) 
Select @startmin2   = substring(@startmin, 2, 1) 
Select @startsec  = str(@save_sec, 2) 
Select @startsec1   = substring(@startsec, 1, 1) 
Select @startsec2   = substring(@startsec, 2, 1)


   If @starthour3= ' '
      select @starthour3 = '0'
   If @starthour4= ' '
      select @starthour4 = '0'
   If @startmin1 = ' '
      select @startmin1 = '0'
   If @startmin2 = ' '
      select @startmin2 = '0'
   If @startsec1 = ' '
      select @startsec1 = '0'
   If @startsec2 = ' '
      select @startsec2 = '0'

Select @save_dur_text = @starthour1 + @starthour2 + @starthour3 + @starthour4 + ':' + @startmin1 + @startmin2 + ':' + @startsec1 + @startsec2


--  Print the job information  -----------------------------------------------------
Print  ' '
Print  ' '
Select @miscprint = '** Job/Step Name(s)                                     Avg Run Time'
Print  @miscprint
If @save_runduration = 0 and (select count(*) from #temp_duration) > 0
   begin
	Select @miscprint = convert(char(50), @cu10job_name) + '     Not Available'
	Print  @miscprint
   end
Else
   begin
	Select @miscprint = convert(char(50), @cu10job_name) + '     ' + @save_dur_text
	Print  @miscprint
   end

--  Cursor for job steps  ----------------------------------------------------------
select @savecursor = 'DECLARE cursor_steps Insensitive Cursor For ' + 
  'SELECT s.step_id, s.step_name
   From msdb.dbo.sysjobsteps  s, msdb.dbo.sysjobs  j ' + 
  'Where j.name = ''' + @query_job_name + '''
     and j.job_id = s.job_id
   Order By s.step_id For Read Only'


EXECUTE(@savecursor)

OPEN cursor_steps

WHILE (12=12)
   Begin
	FETCH Next From cursor_steps Into @cu12step_id, 
					@cu12step_name

	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_steps
	      BREAK
           end


--  Select and format step duration
Select @save_count = (select count(*) from #temp_duration where step_id = @cu12step_id)
If @save_count > 0
   begin
	Select @save_runduration = (select sum(run_duration)/count(*) from #temp_duration where step_id = @cu12step_id)
   end
Else
   begin
	Select @save_runduration = 0
   end

If @save_runduration > 3599
   begin
	Select @save_hr = (@save_runduration/3600)
	Select @save_runduration = @save_runduration - (@save_hr * 3600)
   end
Else
   begin 
	Select @save_hr = 0
   end

If @save_runduration > 59
   begin
	Select @save_min = (@save_runduration/60)
	Select @save_runduration = @save_runduration - (@save_min * 60)
   end
Else
   begin 
	Select @save_min = 0
   end

Select @save_sec = @save_runduration 

Select @starthour  = str(@save_hr, 4) 
Select @starthour1  = substring(@starthour, 1, 1) 
Select @starthour2  = substring(@starthour, 2, 1) 
Select @starthour3  = substring(@starthour, 3, 1) 
Select @starthour4  = substring(@starthour, 4, 1) 
Select @startmin  = str(@save_min, 2)
Select @startmin1   = substring(@startmin, 1, 1) 
Select @startmin2   = substring(@startmin, 2, 1) 
Select @startsec  = str(@save_sec, 2) 
Select @startsec1   = substring(@startsec, 1, 1) 
Select @startsec2   = substring(@startsec, 2, 1) 

   If @starthour3= ' '
      select @starthour3 = '0'
   If @starthour4= ' '
      select @starthour4 = '0'
   If @startmin1 = ' '
      select @startmin1 = '0'
   If @startmin2 = ' '
      select @startmin2 = '0'
   If @startsec1 = ' '
      select @startsec1 = '0'
If @startsec2 = ' '
      select @startsec2 = '0'


Select @save_dur_text = @starthour1 + @starthour2 + @starthour3 + @starthour4 + ':' + @startmin1 + @startmin2 + ':' + @startsec1 + @startsec2


--  Print the jobstep information
Select @miscprint = '   ' + convert(char(50), @cu12step_name) + '     ' + @save_dur_text
Print  @miscprint


 End  -- sched loop 
DEALLOCATE cursor_steps


Select @sched_flag = 'n'
 
--  Cursor for enabled job schedules  ----------------------------------------------------------
Select @savecursor = 'DECLARE cursor_sched Insensitive Cursor For ' + 
  'SELECT s.name, s.freq_type, s.freq_interval, s.freq_subday_type, s.freq_subday_interval, s.freq_relative_interval, s.freq_recurrence_factor, s.active_start_time, s.active_end_time
   From msdb.dbo.sysschedules s, msdb.dbo.sysjobschedules  sj, msdb.dbo.sysjobs  j ' + 
  'Where s.enabled = 1
     and s.schedule_id = sj.schedule_id
     and j.name = ''' + @query_job_name + '''
     and j.job_id = sj.job_id
   Order By s.schedule_id For Read Only'


EXECUTE(@savecursor)

OPEN cursor_sched

WHILE (13=13)
   Begin
	FETCH Next From cursor_sched Into @cu13name, 
					@cu13freq_type, 
					@cu13freq_interval, 
					@cu13freq_subday_type, 
					@cu13freq_subday_interval, 
					@cu13freq_relative_interval, 
					@cu13freq_recurrence_factor,
					@cu13active_start_time,
					@cu13active_end_time

	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_sched
	      BREAK
           end

--Print ' '
--Print '@cu13freq_type is ' + convert(varchar(20), @cu13freq_type)
--Print '@cu13freq_interval is ' + convert(varchar(20), @cu13freq_interval)
--Print '@cu13freq_subday_type is ' + convert(varchar(20), @cu13freq_subday_type)
--Print '@cu13freq_subday_interval is ' + convert(varchar(20), @cu13freq_subday_interval)
--Print '@cu13freq_relative_interval is ' + convert(varchar(20), @cu13freq_relative_interval)
--Print '@cu13freq_recurrence_factor is ' + convert(varchar(20), @cu13freq_recurrence_factor)
--Print '@cu13active_start_time is ' + convert(varchar(20), @cu13active_start_time)
--Print '@cu13active_end_time is ' + convert(varchar(20), @cu13active_end_time)


--  Set schedule flag  ---------------------------------------------------------
Select @sched_flag = 'y'


--  Process for special schedules  ---------------------------------------------------------
If @cu13freq_type = 64 
   begin
	Print ' '
	Select @miscprint = '   Schedule: ' + @cu13name
	Print  @miscprint
	Select @miscprint = '   Starts automatically when SQL Server Agent Starts'
	Print  @miscprint
	goto label02
   end

If @cu13freq_type = 16 
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_mon = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
	If @cu13freq_interval in (1, 21, 31)
	   begin
		select @day_suffix = 'st'
	   end
	Else If @cu13freq_interval in (2, 22) 
	   begin
		select @day_suffix = 'nd'
	   end
	Else If @cu13freq_interval in (3, 23) 
	   begin
		select @day_suffix = 'rd'
	   end
	Else 
	   begin
		select @day_suffix = 'th'
	   end
	Print ' '
	Select @miscprint = '   Schedule: ' + @cu13name
	Print  @miscprint
	Select @miscprint = '   Once a month on the ' + convert(varchar(5), @cu13freq_interval) + @day_suffix + ' at ' + @save_start_mon
	Print  @miscprint
	goto label02
   end

If @cu13freq_type = 1 
   begin
	Print ' '
	Select @miscprint = '   Schedule: ' + @cu13name
	Print  @miscprint
	Select @miscprint = '   Set for ''one time'' execution'
	Print  @miscprint
	goto label02
   end


--  Set daily job start times  -------------------------------------------------
Select @save_start_sun = '          '
If @cu13freq_type = 4 
 or ((@cu13freq_type = 8) and (@cu13freq_interval in (1,3,5,7,9,11,13,15,17,19,21,23,25,
							27,29,31,33,35,37,39,41,43,45,47,49,
							51,53,55,57,59,61,63,65,67,69,71,73,
							75,77,79,81,83,85,87,89,91,93,95,97,
							99,101,103,105,107,109,111,113,115,117,
							119,121,123,125,127)))
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_sun = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
 
   end


Select @save_start_mon = '          '
If @cu13freq_type = 4 
 or ((@cu13freq_type = 8) and (@cu13freq_interval in (2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,
							38,39,42,43,46,47,50,51,54,55,58,59,62,63,66,67,
							70,71,74,75,78,79,82,83,86,87,90,91,94,95,98,99,
							102,103,106,107,110,111,114,115,118,119,122,123,126,127)))
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_mon = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
 
   end


Select @save_start_tue = '          '
If @cu13freq_type = 4 
 or ((@cu13freq_type = 8) and (@cu13freq_interval in (4,5,6,7,12,13,14,15,20,21,22,23,28,29,30,31,36,37,38,
							39,44,45,46,47,52,53,54,55,60,61,62,63,68,69,70,71,
							76,77,78,79,84,85,86,87,92,93,94,95,100,101,102,103,
							108,109,110,111,116,117,118,119,124,125,126,127)))
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_tue = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
 
   end


Select @save_start_wed = '          '
If @cu13freq_type = 4 
 or ((@cu13freq_type = 8) and (@cu13freq_interval in (8,9,10,11,12,13,14,15,24,25,26,27,28,29,30,31,40,41,42,43,
							44,45,46,47,56,57,58,59,60,61,62,63,72,73,74,75,76,77,78,
							79,88,89,90,91,92,93,94,95,104,105,106,107,108,109,110,111,
							120,121,122,123,124,125,126,127)))
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_wed = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
 
   end


Select @save_start_thur = '          '
If @cu13freq_type = 4 
 or ((@cu13freq_type = 8) and (@cu13freq_interval in (16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,50,
							51,52,53,54,55,56,57,58,59,60,61,62,63,80,81,82,83,84,85,
							86,87,88,89,90,91,92,93,94,95,112,113,114,115,116,117,118,
							119,120,121,122,123,124,125,126,127)))
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_thur = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
 
   end


Select @save_start_fri = '          '
If @cu13freq_type = 4 
 or ((@cu13freq_type = 8) and (@cu13freq_interval in (32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,
							50,51,52,53,54,55,56,57,58,59,60,61,62,63,96,97,98,99,
							100,101,102,103,104,105,106,107,108,109,110,111,112,113,
							114,115,116,117,118,119,120,121,122,123,124,125,126,127)))
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_fri = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
 
   end


Select @save_start_sat = '          '
If @cu13freq_type = 4 
 or ((@cu13freq_type = 8) and (@cu13freq_interval in (64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,
							83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
							101,102,103,104,105,106,107,108,109,110,111,112,113,114,
							115,116,117,118,119,120,121,122,123,124,125,126,127)))
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_sat = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2
 
   end

If @save_start_sun = ' '
   begin
	Select @save_start_sun = 'n/a'
   end
If @save_start_mon = ' '
   begin
	Select @save_start_mon = 'n/a'
   end
If @save_start_tue = ' '
   begin
	Select @save_start_tue = 'n/a'
   end
If @save_start_wed = ' '
   begin
	Select @save_start_wed = 'n/a'
   end
If @save_start_thur = ' '
   begin
	Select @save_start_thur = 'n/a'
   end
If @save_start_fri = ' '
   begin
	Select @save_start_fri = 'n/a'
   end
If @save_start_sat = ' '
   begin
	Select @save_start_sat = 'n/a'
   end

Print ' '
Select @miscprint = '   Schedule: ' + @cu13name
Print  @miscprint
Select @miscprint = '   Sun       Mon       Tue       Wed       Thur      Fri       Sat'
Print  @miscprint
Select @miscprint = '   ' + @save_start_sun + @save_start_mon + @save_start_tue + @save_start_wed + @save_start_thur + @save_start_fri + @save_start_sat
Print  @miscprint


If @cu13freq_subday_type in (4, 8)
   begin
	Select @starttime  = str(@cu13active_start_time, 6) 
	Select @starthour1  = substring(@starttime, 1, 1) 
	Select @starthour2  = substring(@starttime, 2, 1) 
	Select @startmin1   = substring(@starttime, 3, 1) 
	Select @startmin2   = substring(@starttime, 4, 1) 
		If @starthour1= ' '
		   begin
			select @starthour1 = '0'
		   end
		If @starthour2= ' '
		   begin
			select @starthour2 = '0'
		   end
		If @startmin1 = ' '
		   begin
			select @startmin1 = '0'
		   end
		If @startmin2 = ' '
		   begin
			select @startmin2 = '0'
		   end
		Select @save_start_time = @starthour1 + @starthour2 + ':' + @startmin1 + @startmin2

	Select @endtime  = str(@cu13active_end_time, 6) 
	Select @endhour1  = substring(@endtime, 1, 1) 
	Select @endhour2  = substring(@endtime, 2, 1) 
	Select @endmin1   = substring(@endtime, 3, 1) 
	Select @endmin2   = substring(@endtime, 4, 1) 
		If @endhour1= ' '
		   begin
			select @endhour1 = '0'
		   end
		If @endhour2= ' '
		   begin
			select @endhour2 = '0'
		   end
		If @endmin1 = ' '
		   begin
			select @endmin1 = '0'
		   end
		If @endmin2 = ' '
		   begin
			select @endmin2 = '0'
		   end
		Select @save_end_time = @endhour1 + @endhour2 + ':' + @endmin1 + @endmin2

	If @cu13freq_subday_type = 4
	   begin
		Select @miscprint  = '    ###-executed every ' + (convert(varchar(5), @cu13freq_subday_interval)) + ' minutes from ' + @save_start_time + ' to ' + @save_end_time 
		Print  @miscprint
          end
	Else
	   begin
		Select @miscprint  = '    ###-executed every ' + (convert(varchar(5), @cu13freq_subday_interval)) + ' hour(s) from ' + @save_start_time + ' to ' + @save_end_time 
		Print  @miscprint
          end
   end

label02:

 End  -- sched loop 
DEALLOCATE cursor_sched


If @sched_flag = 'n'
   begin
	Print ' '
	Select @miscprint = '   Note: This job is not currently scheduled!'
	Print  @miscprint
   end


Select @output_flag	= 'y' 

--  Finalization  ------------------------------------------------------------------------------

drop table #temp_duration


 End  -- job loop 
DEALLOCATE cursor_jobs

If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORTTempDB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORTTempDB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORTTempDB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_REPORTTempDB (@check_top_offender char(5) = 'n', @kill char(5)='n')

/*********************************************************
 **  Stored Procedure dbasp_REPORTTempDB                 
 **  Written by David Spriggs, Getty Images                
 **  March 9, 2009                                     
 **  
 **  This dbasp is set up to report the current TempDB database space 
 **  allocation. 
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/09/2009	David Spriggs		New report
--	03/10/2009	David Spriggs	        Added the following parameters:
--						@check_top_offender--Returns the Top 5 offenders
--						@kill --enables the kill of the SPID in the Top 5
--	======================================================================================


-----------------  declares  ------------------

declare	     @miscprint		nvarchar(255)
	    ,@volume		varchar(10)
	    ,@tempdbPath	varchar(255)
            ,@dirCmd		nvarchar(4000)
	    ,@fixeddrivefreeMB  int
	    ,@volumefreespace	int
	    ,@freespace		int
	    ,@usedspace		int
	    ,@totalspaceusage	int
	    ,@percentagework	decimal(18,2)

declare	     @spid		int
	    ,@cmd		nvarchar(4000)
/*
declare @check_top_offender char(5)
declare @kill char(5)
set @check_top_offender = 'n'
set @kill = 'n'

*/

/****************************************************************
 *                Initialization
 ***************************************************************/


declare @tempFixedDrives table(drl char(1), mbfree int)

create table #tempfiledir(toutput nvarchar(4000))


/****************************************************************
 *                MainLine
 ***************************************************************/
--Update the Space Usage information first
---DBCC UPDATEUSAGE (TempDB) WITH NO_INFOMSGS 

--Get the TempDB Volume
select 
    top(1)
    @volume  = substring(physical_name,1,1)
from sys.master_files
where db_name(database_id)='tempdb'
and type_desc = 'rows'

--Get the TempDB Path
select
    top(1)
    @tempdbPath = reverse(substring(reverse(physical_name),charindex('\',reverse(physical_name))+1,LEN(physical_name)))
from sys.master_files
where db_name(database_id)='tempdb'
and type_desc = 'rows'


select
     @usedspace =((sum (user_object_reserved_page_count)*8) +(sum (internal_object_reserved_page_count)*8) + (sum (version_store_reserved_page_count)*8)+(sum (mixed_extent_page_count)*8))/1024
    ,@freespace = ((sum (unallocated_extent_page_count)*8))/1024
from sys.dm_db_file_space_usage 

set @totalspaceusage = @usedspace +@freespace

set @percentagework = (convert(numeric(18,2),@usedspace)/convert(numeric(18,2),@totalspaceusage))*100



----------------------  Print the headers  ----------------------

Print  '/*******************************************************************'
Select @miscprint = '   REPORT DISK & DATABASE USAGE FOR SERVER: ' + @@servername
Print  @miscprint
Print  ' '
Select @miscprint = '-- Generated on ' + convert(varchar(30),getdate())
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '

--check and see if is alone or with others

set @dirCmd = 'dir '+@tempdbPath

insert into #tempfiledir
exec xp_cmdshell @dirCmd

delete from #tempfiledir where toutput like '%volume%'
delete from #tempfiledir where toutput like '%directory%'
delete from #tempfiledir where toutput like '%<DIR>%'
delete from #tempfiledir where toutput like '%file%'
delete from #tempfiledir where toutput like '%dir%'
delete from #tempfiledir where toutput is null


--print convert(varchar(10), @fixeddrivefreeMB)

if(select count(*) from #tempfiledir where toutput not like '%temp%') = 0

    begin

	Select @miscprint = 'Percentage used in TempDB = ' + convert(varchar(20),@percentagework )+'%'
	print  @miscprint
	print '  '
	Select @miscprint = 'Used Space for TempDB = '+convert(varchar(10),@usedspace)+' MB'
	print  @miscprint
	print '  '
	Select @miscprint = 'Free Space for TempDB = '+convert(varchar(10),@freespace)+' MB'
	print  @miscprint
	print '  '
	Select @miscprint = 'Total TempDB file size = '+convert(varchar(10),@totalspaceusage) +' MB'
	print  @miscprint
	print '  '
	Select @miscprint ='TempDB resides on '+@tempdbPath
	print  @miscprint
	print '  '
    end
else
    begin

	insert into @tempFixedDrives
	exec xp_fixeddrives

	set @fixeddrivefreeMB = (select mbfree from @tempFixedDrives where drl = @volume)

	Select @miscprint = 'Percentage used in TempDB = ' + convert(varchar(20),@percentagework )+'%'
	print  @miscprint
	print '  '
	Select @miscprint = 'Used Space for TempDB = '+convert(varchar(10),@usedspace)+' MB'
	print  @miscprint
	print '  '
	Select @miscprint = 'Free Space for TempDB = '+convert(varchar(10),@freespace)+' MB'
	print  @miscprint
	print '  '
	Select @miscprint = 'Total TempDB file size = '+convert(varchar(10),@totalspaceusage) +' MB'
	print  @miscprint
	print '  '
	Select @miscprint ='TempDB resides on '+@tempdbPath
	print  @miscprint
	print '  '
	Select @miscprint ='Free Space on disk '+@volume+' = '+convert(varchar(10),@fixeddrivefreeMB)+'MB'
	print  @miscprint
	print '  '
    end

if @check_top_offender = 'y'
    begin
	    print '  '
	    Select @miscprint ='The Top 5 space offenders'
	    print  @miscprint
	    Print  '*******************************************************************/'
	    Print  ' '
	    Print  ' '
	    select
	    TOP (5)
		us.session_id 'SPID'
		,ex.Login_time
		,ex.login_name
                ,ex.host_name
		,sum (us.user_objects_alloc_page_count)*8 + sum (us.internal_objects_alloc_page_count )*8 'Used Space'
	    from sys.dm_db_session_space_usage as us
	    join sys.dm_exec_sessions as ex on us.session_id = ex.session_id
	    group by us.session_id
		    ,user_objects_alloc_page_count,internal_objects_alloc_page_count
		    ,ex.Login_time
		    ,ex.login_name
		    ,ex.host_name
	    order by (us.user_objects_alloc_page_count + us.internal_objects_alloc_page_count)
	    
	  if    @kill = 'y'
	    begin
	    
		set @spid =(select TOP (1) us.session_id 'SPID'from sys.dm_db_session_space_usage as us order by (us.user_objects_alloc_page_count + us.internal_objects_alloc_page_count))
		set @cmd = 'Kill '+convert(varchar(5),@spid)
		exec(@cmd)
		

	    end
	 
    end
---------------------------  Finalization for process  -----------------------

Print  ' '
Print  '/*******************************************************************'
Select @miscprint = '         END OF REPORT - FOR SERVER: ' + @@servername
Print  @miscprint
Print  '*******************************************************************/'

If  (@check_top_offender= 'n' and @kill = 'n')
begin
	Print  ' '
	Select @miscprint = '--------------------------------------------------'
	Print  @miscprint
	Select @miscprint = '--Here are sample execute commands for this sproc:'
	Print  @miscprint
	Select @miscprint = '--------------------------------------------------'
	Print  @miscprint
	Print  ' '
	Select @miscprint = '-- Include the Top 5 offending SPIDS:'
	Print  @miscprint
	Select @miscprint = 'exec dbaadmin.dbo.dbasp_REPORTTempDB @check_top_offender = ''y'''
	Print  @miscprint
	Print  ' '
	Select @miscprint = '--Include the Top 5 offending SPIDS and Kill them:'
	Print  @miscprint
	Select @miscprint = 'exec dbaadmin.dbo.dbasp_REPORTTempDB @check_top_offender = ''y'', @kill=''y'''
	Print  @miscprint
	Print  ' '
   end

drop table #tempfiledir



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORTtopAvg_Time
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORTtopAvg_Time]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORTtopAvg_Time]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_REPORTtopAvg_Time (@out_count int = 20
						,@exception_pct int = 20
						,@exception_recipient sysname = 'tssqldba@gettyimages.com'
						,@seed_date datetime = null)

/*********************************************************
 **  Stored Procedure dbasp_REPORTtopAvg_Time                  
 **  Written by Jim Wilson, Getty Images                
 **  October 05, 2007                                      
 **  
 **  This dbasp is set up to create a report documenting
 **  top Avg Elapsed_Time & CPU processes for the past 4 weeks. 
 **        
 **  Output file is REPORTtopAvgTime.rpt
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/05/2007	Jim Wilson		New report
--	01/25/2008	Jim Wilson		Truncate long email @message to 3900.
--	======================================================================================

/*
declare @out_count int
declare @exception_pct int
declare @exception_recipient sysname
declare @seed_date datetime

select @out_count = 20
select @exception_pct = 20
select @exception_recipient = 'tssqldba@gettyimages.com'
--select @seed_date = getdate()-1
--*/

-----------------  declares  ------------------
Declare 
	 @miscprint			nvarchar(255)
	,@charpos			int
	,@begindate 			datetime
	,@enddate 			datetime
	,@save_date			datetime
	,@save_querytext		nvarchar(100)
	,@save_querytext_new		nvarchar(100)
	,@save_querytext_trim		nvarchar(100)
	,@save_Avg_Elapsed_Time_MS	bigint
	,@save_Avg_Elapsed_Time_MS2	bigint
	,@hold_Avg_Elapsed_Time_MS2	bigint
	,@save_Avg_CPU_Time_MS		bigint
	,@save_Avg_CPU_Time_MS2		bigint
	,@hold_Avg_CPU_Time_MS2		bigint
	,@email_Avg_Elapsed_Time_MS	bigint
	,@email_Prev_Elapsed_Time_MS	bigint
	,@email_Avg_CPU_Time_MS		bigint
	,@email_Prev_CPU_Time_MS	bigint
	,@email_QueryText		nvarchar(100)
	,@exception_d_row_flag		char(1)
	,@exception_c_row_flag		char(1)
	,@prev_found_flag		char(1)
	,@subject			nvarchar(255)
	,@message			nvarchar(4000)
	,@message2			nvarchar(4000)


----------------  initial values  -------------------
Select @message = ''
Select @message2 = ''

If @seed_date is null
   begin
	select @seed_date = getdate()
   end


--  create the temp table
declare @tblv_duration1 table (Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , Execution_Count bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )

declare @tblv_duration2 table (Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , Execution_Count bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )

declare @tblv_duration3 table (Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , Execution_Count bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )

declare @tblv_duration4 table (Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , Execution_Count bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )

declare @tblv_exception_c table (Avg_CPU_Time_MS bigint
			    , Prev_CPU_Time_MS bigint
			    , Avg_Elapsed_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			 , Execution_Count bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    )

declare @tblv_exception_d table (Avg_Elapsed_Time_MS bigint
			    , Prev_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , Execution_Count bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    )

----------------------  Print the headers  ----------------------

Print  '/*******************************************************************'
Select @miscprint = '   SQL REPORT: TOP (' + convert(nvarchar(10), @out_count) + ') AVERAGE ELAPSED TIME & CPU'
Print  @miscprint
Select @miscprint = '   FOR SERVER: ' + @@servername
Print  @miscprint
Print  ' '
Select @miscprint = '-- Generated on ' + convert(varchar(30),getdate())
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/


--  Week one process
Select @save_date = @seed_date-7
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-1
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration1 (Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid, update_flag)
select (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_logical_writes) / sum(execution_count))
    , sum(execution_count)
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration1 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration1 where update_flag = 'n') > 0
   begin
	start_querytext_fix1:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration1 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration1 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration1 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration1 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix1
	   end
   end




--  Week two process
Select @save_date = @seed_date-14
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-8
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration2 (Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid, update_flag)
select (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_logical_writes) / sum(execution_count))
    , sum(execution_count)
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration2 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration2 where update_flag = 'n') > 0
   begin
	start_querytext_fix2:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration2 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration2 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration2 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration2 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix2
	   end
   end




--  Week three process
Select @save_date = @seed_date-21
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-15
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration3 (Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid, update_flag)
select (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_logical_writes) / sum(execution_count))
    , sum(execution_count)
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration3 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration3 where update_flag = 'n') > 0
   begin
	start_querytext_fix3:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration3 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration3 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration3 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration3 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix3
	   end
   end




--  Week four process
Select @save_date = @seed_date-28
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-22
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration4 (Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid, update_flag)
select (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_logical_writes) / sum(execution_count))
    , sum(execution_count)
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration4 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration4 where update_flag = 'n') > 0
   begin
	start_querytext_fix4:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration4 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration4 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration4 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration4 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix4
	   end
   end





/*
where Avg_Elapsed_Time_MS in (select top (@out_count) Avg_Elapsed_Time_MS from @tblv_duration1 order by Avg_Elapsed_Time_MS desc)
or Avg_CPU_Time_MS in (select top (@out_count) Avg_CPU_Time_MS from @tblv_duration1 order by Avg_CPU_Time_MS desc)
*/

--  The next section will check for exceptions
--  Exceptions are rows that are in the top 10 this week and have not been in the list the previous 3 weeks, or...
--  rows that have increased in percentage (input parm) compared with the previous 3 weeks

--  We will process the current weeks table, one row at a time
If (select count(*) from @tblv_duration1) > 0
   begin
	Delete From @tblv_duration1
	where Avg_Elapsed_Time_MS not in (select top (@out_count) Avg_Elapsed_Time_MS from @tblv_duration1 order by Avg_Elapsed_Time_MS desc)
	  and Avg_CPU_Time_MS not in (select top (@out_count) Avg_CPU_Time_MS from @tblv_duration1 order by Avg_CPU_Time_MS desc)

	Update @tblv_duration1 set update_flag = 'n'

	start_exception:

	Select @save_querytext = (select top 1 QueryText from @tblv_duration1 where update_flag = 'n')
	Select @save_Avg_Elapsed_Time_MS = (select top 1 Avg_Elapsed_Time_MS from @tblv_duration1 where QueryText = @save_querytext and update_flag = 'n')
	Select @hold_Avg_Elapsed_Time_MS2 = 0
	Select @save_Avg_CPU_Time_MS = (select top 1 Avg_CPU_Time_MS from @tblv_duration1 where QueryText = @save_querytext and update_flag = 'n')
	Select @hold_Avg_CPU_Time_MS2 = 0
	select @prev_found_flag = 'n'

	If exists (select 1 from @tblv_duration2 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_Avg_Elapsed_Time_MS2 = (select top 1 Avg_Elapsed_Time_MS from @tblv_duration2 where QueryText = @save_querytext)
		If @save_Avg_Elapsed_Time_MS2 > @hold_Avg_Elapsed_Time_MS2
		   begin
			Select @hold_Avg_Elapsed_Time_MS2 = @save_Avg_Elapsed_Time_MS2
		   end

		If @save_Avg_Elapsed_Time_MS > @save_Avg_Elapsed_Time_MS2
		   and (((@save_Avg_Elapsed_Time_MS - @save_Avg_Elapsed_Time_MS2) * 100) / @save_Avg_Elapsed_Time_MS) > @exception_pct
		   begin
			Select @exception_d_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_d_row_flag = 'n'
			goto skip_check1
		   end
	   end

	If exists (select 1 from @tblv_duration3 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_Avg_Elapsed_Time_MS2 = (select top 1 Avg_Elapsed_Time_MS from @tblv_duration3 where QueryText = @save_querytext)
		If @save_Avg_Elapsed_Time_MS2 > @hold_Avg_Elapsed_Time_MS2
		   begin
			Select @hold_Avg_Elapsed_Time_MS2 = @save_Avg_Elapsed_Time_MS2
		   end

		If @save_Avg_Elapsed_Time_MS > @save_Avg_Elapsed_Time_MS2
		   and (((@save_Avg_Elapsed_Time_MS - @save_Avg_Elapsed_Time_MS2) * 100) / @save_Avg_Elapsed_Time_MS) > @exception_pct
		   begin
			Select @exception_d_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_d_row_flag = 'n'
			goto skip_check1
		   end
	   end

	If exists (select 1 from @tblv_duration4 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_Avg_Elapsed_Time_MS2 = (select top 1 Avg_Elapsed_Time_MS from @tblv_duration4 where QueryText = @save_querytext)
		If @save_Avg_Elapsed_Time_MS2 > @hold_Avg_Elapsed_Time_MS2
		   begin
			Select @hold_Avg_Elapsed_Time_MS2 = @save_Avg_Elapsed_Time_MS2
		   end

		If @save_Avg_Elapsed_Time_MS > @save_Avg_Elapsed_Time_MS2
		   and (((@save_Avg_Elapsed_Time_MS - @save_Avg_Elapsed_Time_MS2) * 100) / @save_Avg_Elapsed_Time_MS) > @exception_pct
		   begin
			Select @exception_d_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_d_row_flag = 'n'
			goto skip_check1
		   end
	   end

	skip_check1:


	If exists (select 1 from @tblv_duration2 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_Avg_CPU_Time_MS2 = (select top 1 Avg_CPU_Time_MS from @tblv_duration2 where QueryText = @save_querytext)
		If @save_Avg_CPU_Time_MS2 > @hold_Avg_CPU_Time_MS2
		   begin
			Select @hold_Avg_CPU_Time_MS2 = @save_Avg_CPU_Time_MS2
		   end

		If @save_Avg_CPU_Time_MS > @save_Avg_CPU_Time_MS2
		   and (((@save_Avg_CPU_Time_MS - @save_Avg_CPU_Time_MS2) * 100) / @save_Avg_CPU_Time_MS) > @exception_pct
		   begin
			Select @exception_c_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_c_row_flag = 'n'
			goto skip_check2
		   end
	   end

	If exists (select 1 from @tblv_duration3 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_Avg_CPU_Time_MS2 = (select top 1 Avg_CPU_Time_MS from @tblv_duration3 where QueryText = @save_querytext)
		If @save_Avg_CPU_Time_MS2 > @hold_Avg_CPU_Time_MS2
		   begin
			Select @hold_Avg_CPU_Time_MS2 = @save_Avg_CPU_Time_MS2
		   end

		If @save_Avg_CPU_Time_MS > @save_Avg_CPU_Time_MS2
		   and (((@save_Avg_CPU_Time_MS - @save_Avg_CPU_Time_MS2) * 100) / @save_Avg_CPU_Time_MS) > @exception_pct
		   begin
			Select @exception_c_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_c_row_flag = 'n'
			goto skip_check2
		   end
	   end

	If exists (select 1 from @tblv_duration4 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_Avg_CPU_Time_MS2 = (select top 1 Avg_CPU_Time_MS from @tblv_duration4 where QueryText = @save_querytext)
		If @save_Avg_CPU_Time_MS2 > @hold_Avg_CPU_Time_MS2
		   begin
			Select @hold_Avg_CPU_Time_MS2 = @save_Avg_CPU_Time_MS2
		   end

		If @save_Avg_CPU_Time_MS > @save_Avg_CPU_Time_MS2
		   and (((@save_Avg_CPU_Time_MS - @save_Avg_CPU_Time_MS2) * 100) / @save_Avg_CPU_Time_MS) > @exception_pct
		   begin
			Select @exception_c_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_c_row_flag = 'n'
			goto skip_check2
		   end
	   end

	skip_check2:



	If @prev_found_flag = 'n'
	   begin
		Select @exception_d_row_flag = 'y'
		Select @exception_c_row_flag = 'y'
	   end


	If @exception_d_row_flag = 'y'
	   begin
		insert into @tblv_exception_d (AVG_Elapsed_Time_MS, Prev_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid)
		select AVG_Elapsed_Time_MS, @hold_AVG_Elapsed_Time_MS2, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid
		From @tblv_duration1
		where QueryText = @save_querytext and AVG_Elapsed_Time_MS = @save_AVG_Elapsed_Time_MS
	   end

	If @exception_c_row_flag = 'y'
	   begin
		insert into @tblv_exception_c (AVG_CPU_Time_MS, Prev_CPU_Time_MS, Avg_Elapsed_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid)
		select AVG_CPU_Time_MS, @hold_AVG_CPU_Time_MS2, Avg_Elapsed_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, Execution_Count, QueryText, GroupCount, dbaseid
		From @tblv_duration1
		where QueryText = @save_querytext and AVG_Elapsed_Time_MS = @save_AVG_Elapsed_Time_MS
	   end


	Update @tblv_duration1 set update_flag = 'y' where QueryText = @save_querytext and Avg_Elapsed_Time_MS = @save_Avg_Elapsed_Time_MS
	If (select count(*) from @tblv_duration1 where update_flag = 'n') > 0
	   begin
		goto start_exception
	   end


	If (select count(*) from @tblv_exception_d) > 0
	   begin
		Select @save_date = @seed_date-1
		Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

		Print ''
		Select @miscprint = upper(@@servername) + ' EXCEPTIONS: Top Avg Elapsed Time (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101)
		Print @miscprint
		Print ''

		select Avg_Elapsed_Time_MS
		    , Prev_Elapsed_Time_MS
		    , Avg_CPU_Time_MS
		    , Avg_Logical_Reads
		    , Avg_Logical_Writes
		    , Execution_Count
		    , QueryText 
		from @tblv_exception_d 
		order by Avg_Elapsed_Time_MS desc

		--  Format exception email
		Select @message = upper(@@servername) + ' EXCEPTIONS: Top Avg Elapsed Time & CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101) + char(13)+char(10)
		Select @message = @message + '' + char(13)+char(10)
		Select @message = @message + 'Note: ' + convert(nvarchar(10), @exception_pct) + ' percent increase from previous high Elapsed Time indicates an exception.' + char(13)+char(10)
		Select @message = @message + '' + char(13)+char(10)
		Select @message = @message + 'Avg_Elapsed_Time_MS   Prev_Elapsed_Time_MS  QueryText' + char(13)+char(10)
		Select @message = @message + '--------------------- --------------------- --------------------------------------------------' + char(13)+char(10)
		start_email01:
		Select @email_AVG_Elapsed_Time_MS = (select top 1 AVG_Elapsed_Time_MS from @tblv_exception_d order by AVG_Elapsed_Time_MS desc)
		Select @email_Prev_Elapsed_Time_MS = (select top 1 Prev_Elapsed_Time_MS from @tblv_exception_d where AVG_Elapsed_Time_MS = @email_AVG_Elapsed_Time_MS order by Prev_Elapsed_Time_MS desc)
		Select @email_QueryText = (select top 1 QueryText from @tblv_exception_d where AVG_Elapsed_Time_MS = @email_AVG_Elapsed_Time_MS  and Prev_Elapsed_Time_MS = @email_Prev_Elapsed_Time_MS order by QueryText desc)

		Select @message = @message + convert(char(21), @email_AVG_Elapsed_Time_MS) + ' ' + convert(char(21), @email_Prev_Elapsed_Time_MS) + ' ' + @email_QueryText + char(13)+char(10)

		Delete from @tblv_exception_d where AVG_Elapsed_Time_MS = @email_AVG_Elapsed_Time_MS and Prev_Elapsed_Time_MS = @email_Prev_Elapsed_Time_MS and QueryText = @email_QueryText
		If (select count(*) from @tblv_exception_d) > 0
		   begin
			goto start_email01
		   end
	   end


	If (select count(*) from @tblv_exception_c) > 0
	   begin
		Select @save_date = @seed_date-1
		Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

		Print ''
		Select @miscprint = upper(@@servername) + ' EXCEPTIONS: Top Avg CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101)
		Print @miscprint
		Print ''

		select Avg_CPU_Time_MS
		    , Prev_CPU_Time_MS
		    , Avg_Elapsed_Time_MS
		 , Avg_Logical_Reads
		    , Avg_Logical_Writes
		    , Execution_Count
		    , QueryText 
		from @tblv_exception_c 
		order by Avg_CPU_Time_MS desc

		--  Format exception email
		Select @message2 = upper(@@servername) + ' EXCEPTIONS: Top Avg CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101) + char(13)+char(10)
		Select @message2 = @message2 + '' + char(13)+char(10)
		Select @message2 = @message2 + 'Note: ' + convert(nvarchar(10), @exception_pct) + ' percent increase from previous high CPU indicates an exception.' + char(13)+char(10)
		Select @message2 = @message2 + '' + char(13)+char(10)
		Select @message2 = @message2 + 'Avg_CPU_Time_MS       Prev_CPU_Time_MS      QueryText' + char(13)+char(10)
		Select @message2 = @message2 + '--------------------- --------------------- --------------------------------------------------' + char(13)+char(10)
		start_email02:
		Select @email_AVG_CPU_Time_MS = (select top 1 AVG_CPU_Time_MS from @tblv_exception_c order by AVG_CPU_Time_MS desc)
		Select @email_Prev_CPU_Time_MS = (select top 1 Prev_CPU_Time_MS from @tblv_exception_c where AVG_CPU_Time_MS = @email_AVG_CPU_Time_MS order by Prev_CPU_Time_MS desc)
		Select @email_QueryText = (select top 1 QueryText from @tblv_exception_c where AVG_CPU_Time_MS = @email_AVG_CPU_Time_MS  and Prev_CPU_Time_MS = @email_Prev_CPU_Time_MS order by QueryText desc)

		Select @message2 = @message2 + convert(char(21), @email_AVG_CPU_Time_MS) + ' ' + convert(char(21), @email_Prev_CPU_Time_MS) + ' ' + @email_QueryText + char(13)+char(10)

		Delete from @tblv_exception_c where AVG_CPU_Time_MS = @email_AVG_CPU_Time_MS and Prev_CPU_Time_MS = @email_Prev_CPU_Time_MS and QueryText = @email_QueryText
		If (select count(*) from @tblv_exception_c) > 0
		   begin
			goto start_email02
		   end
	   end


	    If @message <> '' or @message2 <> ''
	       begin
		    Select @subject = 'SQL DBA EXCEPTIONS: [' + upper(@@servername) + '] Top Avg Elapsed Time & CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101)
		    Select @message = left(@message, 3900)
		    Select @message = @message + char(13)+ char(10) + char(13)+ char(10) + @message2
		    Select @message = left(@message, 3900)

		    --print @subject
		    --print @message

		    --  Email TS SQL DBA with this information
		    EXEC dbaadmin.dbo.dbasp_sendmail 
			    --@recipients = 'jim.wilson@gettyimages.com',  
			    @recipients = @exception_recipient,  
			    @subject = @subject,
			    @message = @message

	       end

   end



--  print week 1
Select @save_date = @seed_date-7
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-1
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))
Print ''
Select @miscprint = @@servername + ':  Top Average Elapsed Time & CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, Execution_Count
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration1
Order by Avg_Elapsed_Time_MS desc


--  print week 2
Select @save_date = @seed_date-14
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-8
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))
Print ''
Select @miscprint = @@servername + ':  Top Average Elapsed Time & CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, Execution_Count
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration2
where Avg_Elapsed_Time_MS in (select top (@out_count) Avg_Elapsed_Time_MS from @tblv_duration2 order by Avg_Elapsed_Time_MS desc)
or Avg_CPU_Time_MS in (select top (@out_count) Avg_CPU_Time_MS from @tblv_duration2 order by Avg_CPU_Time_MS desc)
Order by Avg_Elapsed_Time_MS desc


--  print week 3
Select @save_date = @seed_date-21
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-15
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))
Print ''
Select @miscprint = @@servername + ':  Top Average Elapsed Time & CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, Execution_Count
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration3
where Avg_Elapsed_Time_MS in (select top (@out_count) Avg_Elapsed_Time_MS from @tblv_duration3 order by Avg_Elapsed_Time_MS desc)
or Avg_CPU_Time_MS in (select top (@out_count) Avg_CPU_Time_MS from @tblv_duration3 order by Avg_CPU_Time_MS desc)
Order by Avg_Elapsed_Time_MS desc



--  print week 4
Select @save_date = @seed_date-28
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-22
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))
Print ''
Select @miscprint = @@servername + ':  Top Average Elapsed Time & CPU (MS) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, Execution_Count
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration4
where Avg_Elapsed_Time_MS in (select top (@out_count) Avg_Elapsed_Time_MS from @tblv_duration4 order by Avg_Elapsed_Time_MS desc)
or Avg_CPU_Time_MS in (select top (@out_count) Avg_CPU_Time_MS from @tblv_duration4 order by Avg_CPU_Time_MS desc)
Order by Avg_Elapsed_Time_MS desc





---------------------------  Finalization for process  -----------------------
Print  ' '
Print  '/*******************************************************************'
Select @miscprint = '         END OF REPORT - FOR SERVER: ' + @@servername
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORTtopblockers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORTtopblockers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORTtopblockers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_REPORTtopblockers (@seed_date datetime = null)

/*********************************************************
 **  Stored Procedure dbasp_REPORTtopblockers                  
 **  Written by Jim Wilson, Getty Images                
 **  October 02, 2007                                      
 **  
 **  This dbasp is set up to create a report documenting
 **  top blockers for the past 4 weeks. 
 **        
 **  Output file is REPORTtopblockers.rpt
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/02/2007	Jim Wilson		New report
--	10/03/2007	Jim Wilson		Updated for SQL2005.
--	======================================================================================

/*
declare @seed_date datetime

select @seed_date = getdate()-1
--*/


-----------------  declares  ------------------
Declare 
	 @miscprint		    nvarchar(255)
	,@charpos		    int
	,@begindate 		    datetime
	,@enddate 		    datetime
	,@save_date		    datetime
	,@save_inbuff_most	    nvarchar(4000)
	,@save_inbuff_most_trim	    nvarchar(4000)
	,@save_inbuff_part	    nvarchar(100)
	,@save_inbuff_new	    nvarchar(100)


----------------  initial values  -------------------
If @seed_date is null
   begin
	select @seed_date = getdate()
   end


--  create the temp table
declare @tblv_check_contention table (inbuff_part nvarchar(100)
					,inbuff_most nvarchar(4000)
					,update_flag char(1)
					)

declare @tblv_output table (Inputbuffer nvarchar(100)
			    ,Block_Count int
			    ,update_flag char(1)
			    )
  

----------------------  Print the headers  ----------------------

Print  '/*******************************************************************'
Select @miscprint = '   REPORT TOP BLOCKERS FOR SERVER: ' + @@servername
Print  @miscprint
Print  ' '
Select @miscprint = '-- Generated on ' + convert(varchar(30),getdate())
Print  @miscprint
Print  ' '
Select @miscprint = '   NOTE:  You may not be able to search in source code using'
Print  @miscprint
Select @miscprint = '          the strings you find in this report. Carraige returns,'
Print  @miscprint
Select @miscprint = '          line feeds, and tabs have been replaced with spaces.'
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/


--  Week one process
Select @save_date = @seed_date-7
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-1
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_check_contention (inbuff_part, inbuff_most, update_flag)
Select convert(nvarchar(100), inputbuffer), convert(nvarchar(4000), inputbuffer), 'n'
From dbaadmin.dbo.check_contention (nolock) 
Where createdate between @begindate and @enddate
  and headblocker = 'y'
  and inputbuffer not like '%DBCC PROCESS %'
  and inputbuffer not like '%@rundate%'
  and inputbuffer not like '%backup %'
  and inputbuffer not like '%dbaadmin%'
  and inputbuffer not like ''


If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
   begin
	start_inbuff_fix1:
	Select @save_inbuff_most = (select top 1 inbuff_most from @tblv_check_contention where update_flag = 'n')
	select @save_inbuff_most_trim = ltrim(@save_inbuff_most)
	select @charpos = charindex('procedure', @save_inbuff_most_trim)
	IF @charpos <> 0
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, @charpos, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end
	Else	
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, 1, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end

	Update @tblv_check_contention set update_flag = 'y' where inbuff_most = @save_inbuff_most
	If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix1
	   end
   end

--select * from @tblv_check_contention

insert into @tblv_output (Inputbuffer, Block_Count, update_flag)
Select inbuff_part, count(*), 'n'
From @tblv_check_contention
group by inbuff_part
having count(*) >= 10

If (select count(*) from @tblv_output where update_flag = 'n') > 0
   begin
	start_inbuff_fix1b:
	Select @save_inbuff_part = (select top 1 Inputbuffer from @tblv_output where update_flag = 'n')
	Select @save_inbuff_new = replace(@save_inbuff_part, char(10), ' ')-- line feeds
	Select @save_inbuff_new = replace(@save_inbuff_new, char(13), ' ')--carriage returns
	Select @save_inbuff_new = replace(@save_inbuff_new, char(9), ' ')--tabs
	Update @tblv_output set Inputbuffer = @save_inbuff_new where Inputbuffer = @save_inbuff_part

	Update @tblv_output set update_flag = 'y' where Inputbuffer = @save_inbuff_part
	If (select count(*) from @tblv_output where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix1b
	   end
   end

Print ''
Select @miscprint = @@servername + ':  Top Blockers for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Inputbuffer, Block_Count
From @tblv_output
Order by Block_Count desc

delete from @tblv_output
delete from @tblv_check_contention


--  Week two process
Select @save_date = @seed_date-14
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-8
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_check_contention (inbuff_part, inbuff_most, update_flag)
Select convert(nvarchar(100), inputbuffer), convert(nvarchar(4000), inputbuffer), 'n'
From dbaadmin.dbo.check_contention (nolock) 
Where createdate between @begindate and @enddate
  and headblocker = 'y'
  and inputbuffer not like '%DBCC PROCESS %'
  and inputbuffer not like '%@rundate%'
  and inputbuffer not like '%backup %'
  and inputbuffer not like '%dbaadmin%'
  and inputbuffer not like ''


If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
   begin
	start_inbuff_fix2:
	Select @save_inbuff_most = (select top 1 inbuff_most from @tblv_check_contention where update_flag = 'n')
	select @save_inbuff_most_trim = ltrim(@save_inbuff_most)
	select @charpos = charindex('procedure', @save_inbuff_most_trim)
	IF @charpos <> 0
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, @charpos, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end
	Else	
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, 1, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end

	Update @tblv_check_contention set update_flag = 'y' where inbuff_most = @save_inbuff_most
	If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix2
	   end
   end

--select * from @tblv_check_contention

insert into @tblv_output (Inputbuffer, Block_Count, update_flag)
Select inbuff_part, count(*), 'n'
From @tblv_check_contention
group by inbuff_part
having count(*) >= 10

If (select count(*) from @tblv_output where update_flag = 'n') > 0
   begin
	start_inbuff_fix2b:
	Select @save_inbuff_part = (select top 1 Inputbuffer from @tblv_output where update_flag = 'n')
	Select @save_inbuff_new = replace(@save_inbuff_part, char(10), ' ')-- line feeds
	Select @save_inbuff_new = replace(@save_inbuff_new, char(13), ' ')--carriage returns
	Select @save_inbuff_new = replace(@save_inbuff_new, char(9), ' ')--tabs
	Update @tblv_output set Inputbuffer = @save_inbuff_new where Inputbuffer = @save_inbuff_part

	Update @tblv_output set update_flag = 'y' where Inputbuffer = @save_inbuff_part
	If (select count(*) from @tblv_output where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix2b
	   end
   end

Print ''
Print ''
Select @miscprint = @@servername + ':  Top Blockers for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Inputbuffer, Block_Count
From @tblv_output
Order by Block_Count desc

delete from @tblv_output
delete from @tblv_check_contention



--  Week three process
Select @save_date = @seed_date-21
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-15
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_check_contention (inbuff_part, inbuff_most, update_flag)
Select convert(nvarchar(100), inputbuffer), convert(nvarchar(4000), inputbuffer), 'n'
From dbaadmin.dbo.check_contention (nolock) 
Where createdate between @begindate and @enddate
  and headblocker = 'y'
  and inputbuffer not like '%DBCC PROCESS %'
  and inputbuffer not like '%@rundate%'
  and inputbuffer not like '%backup %'
  and inputbuffer not like '%dbaadmin%'
  and inputbuffer not like ''


If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
   begin
	start_inbuff_fix3:
	Select @save_inbuff_most = (select top 1 inbuff_most from @tblv_check_contention where update_flag = 'n')
	select @save_inbuff_most_trim = ltrim(@save_inbuff_most)
	select @charpos = charindex('procedure', @save_inbuff_most_trim)
	IF @charpos <> 0
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, @charpos, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end
	Else	
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, 1, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end

	Update @tblv_check_contention set update_flag = 'y' where inbuff_most = @save_inbuff_most
	If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix3
	   end
   end

--select * from @tblv_check_contention

insert into @tblv_output (Inputbuffer, Block_Count, update_flag)
Select inbuff_part, count(*), 'n'
From @tblv_check_contention
group by inbuff_part
having count(*) >= 10

If (select count(*) from @tblv_output where update_flag = 'n') > 0
   begin
	start_inbuff_fix3b:
	Select @save_inbuff_part = (select top 1 Inputbuffer from @tblv_output where update_flag = 'n')
	Select @save_inbuff_new = replace(@save_inbuff_part, char(10), ' ')-- line feeds
	Select @save_inbuff_new = replace(@save_inbuff_new, char(13), ' ')--carriage returns
	Select @save_inbuff_new = replace(@save_inbuff_new, char(9), ' ')--tabs
	Update @tblv_output set Inputbuffer = @save_inbuff_new where Inputbuffer = @save_inbuff_part

	Update @tblv_output set update_flag = 'y' where Inputbuffer = @save_inbuff_part
	If (select count(*) from @tblv_output where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix3b
	   end
   end

Print ''
Print ''
Select @miscprint = @@servername + ':  Top Blockers for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Inputbuffer, Block_Count
From @tblv_output
Order by Block_Count desc

delete from @tblv_output
delete from @tblv_check_contention


--  Week four process
Select @save_date = @seed_date-28
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-22
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_check_contention (inbuff_part, inbuff_most, update_flag)
Select convert(nvarchar(100), inputbuffer), convert(nvarchar(4000), inputbuffer), 'n'
From dbaadmin.dbo.check_contention (nolock) 
Where createdate between @begindate and @enddate
  and headblocker = 'y'
  and inputbuffer not like '%DBCC PROCESS %'
  and inputbuffer not like '%@rundate%'
  and inputbuffer not like '%backup %'
  and inputbuffer not like '%dbaadmin%'
  and inputbuffer not like ''


If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
   begin
	start_inbuff_fix4:
	Select @save_inbuff_most = (select top 1 inbuff_most from @tblv_check_contention where update_flag = 'n')
	select @save_inbuff_most_trim = ltrim(@save_inbuff_most)
	select @charpos = charindex('procedure', @save_inbuff_most_trim)
	IF @charpos <> 0
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, @charpos, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end
	Else	
	   begin
		select @save_inbuff_new = substring(@save_inbuff_most_trim, 1, 100)
		Update @tblv_check_contention set inbuff_part = @save_inbuff_new where inbuff_most = @save_inbuff_most
	   end

	Update @tblv_check_contention set update_flag = 'y' where inbuff_most = @save_inbuff_most
	If (select count(*) from @tblv_check_contention where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix4
	   end
   end


insert into @tblv_output (Inputbuffer, Block_Count, update_flag)
Select inbuff_part, count(*), 'n'
From @tblv_check_contention
group by inbuff_part
having count(*) >= 10

If (select count(*) from @tblv_output where update_flag = 'n') > 0
   begin
	start_inbuff_fix4b:
	Select @save_inbuff_part = (select top 1 Inputbuffer from @tblv_output where update_flag = 'n')
	Select @save_inbuff_new = replace(@save_inbuff_part, char(10), ' ')-- line feeds
	Select @save_inbuff_new = replace(@save_inbuff_new, char(13), ' ')--carriage returns
	Select @save_inbuff_new = replace(@save_inbuff_new, char(9), ' ')--tabs
	Update @tblv_output set Inputbuffer = @save_inbuff_new where Inputbuffer = @save_inbuff_part

	Update @tblv_output set update_flag = 'y' where Inputbuffer = @save_inbuff_part
	If (select count(*) from @tblv_output where update_flag = 'n') > 0
	   begin
		goto start_inbuff_fix4b
	   end
   end

Print ''
Print ''
Select @miscprint = @@servername + ':  Top Blockers for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select Inputbuffer, Block_Count
From @tblv_output
Order by Block_Count desc

delete from @tblv_output
delete from @tblv_check_contention


---------------------------  Finalization for process  -----------------------
Print  ' '
Print  '/*******************************************************************'
Select @miscprint = '         END OF REPORT - FOR SERVER: ' + @@servername
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORTtopExec_Count
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORTtopExec_Count]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORTtopExec_Count]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_REPORTtopExec_Count (@out_count int = 20
						,@exception_pct int = 20
						,@exception_recipient sysname = 'tssqldba@gettyimages.com'
						,@seed_date datetime = null)

/*********************************************************
 **  Stored Procedure dbasp_REPORTtopExec_Count                  
 **  Written by Jim Wilson, Getty Images                
 **  October 08, 2007                                      
 **  
 **  This dbasp is set up to create a report documenting
 **  top Execution Counts for the past 4 weeks. 
 **        
 **  Output file is REPORTtopExecCount.rpt
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/08/2007	Jim Wilson		New report
--	======================================================================================

/*
declare @out_count int
declare @exception_pct int
declare @exception_recipient sysname
declare @seed_date datetime

select @out_count = 20
select @exception_pct = 20
select @exception_recipient = 'tssqldba@gettyimages.com'
select @seed_date = getdate()
--*/

-----------------  declares  ------------------
Declare 
	 @miscprint		    nvarchar(255)
	,@charpos		    int
	,@begindate 		    datetime
	,@enddate 		    datetime
	,@save_date		    datetime
	,@save_querytext	    nvarchar(100)
	,@save_querytext_new	    nvarchar(100)
	,@save_querytext_trim	    nvarchar(100)
	,@save_AVG_Exec_Count_min   bigint
	,@save_AVG_Exec_Count_min2  bigint
	,@hold_AVG_Exec_Count_min2  bigint
	,@email_AVG_Exec_Count_min  bigint
	,@email_Prev_Exec_Count_min bigint
	,@email_QueryText	    nvarchar(100)
	,@exception_row_flag	    char(1)
	,@prev_found_flag	    char(1)
	,@subject		    nvarchar(255)
	,@message2		    nvarchar(4000)
	

----------------  initial values  -------------------
If @seed_date is null
   begin
	select @seed_date = getdate()
   end

--  create the temp table
declare @tblv_duration1 table (AVG_Exec_Count_min bigint
			    , Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )

declare @tblv_duration2 table (AVG_Exec_Count_min bigint
			    , Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )

declare @tblv_duration3 table (AVG_Exec_Count_min bigint
			    , Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )


declare @tblv_duration4 table (AVG_Exec_Count_min bigint
			    , Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    , update_flag char(1)
			    )

declare @tblv_exception table (AVG_Exec_Count_min bigint
			    ,Prev_Exec_Count_min bigint
			    , Avg_Elapsed_Time_MS bigint
			    , Avg_CPU_Time_MS bigint
			    , Avg_Logical_Reads bigint
			    , Avg_Logical_Writes bigint
			    , QueryText nvarchar(100)
			    , GroupCount int
			    , dbaseid smallint
			    )


----------------------  Print the headers  ----------------------

Print  '/*******************************************************************'
Select @miscprint = '   REPORT TOP (' + convert(nvarchar(10), @out_count) + ') AVERAGE EXECUTION COUNTS'
Print  @miscprint
Select @miscprint = '   FOR SERVER: ' + @@servername
Print  @miscprint
Print  ' '
Select @miscprint = '-- Generated on ' + convert(varchar(30),getdate())
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Week one process
Select @save_date = @seed_date-7
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-1
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration1 (AVG_Exec_Count_min, Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, QueryText, GroupCount, dbaseid, update_flag)
select sum(execution_count) / (sum(intrvl_time_S) / 60)
    , (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_Logical_writes) / sum(execution_count))
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration1 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration1 where update_flag = 'n') > 0
   begin
	start_querytext_fix1:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration1 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration1 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration1 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration1 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix1
	   end
   end





--  Week two process
Select @save_date = @seed_date-14
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-8
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration2 (AVG_Exec_Count_min, Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, QueryText, GroupCount, dbaseid, update_flag)
select sum(execution_count) / (sum(intrvl_time_S) / 60)
    , (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_Logical_writes) / sum(execution_count))
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration2 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration2 where update_flag = 'n') > 0
   begin
	start_querytext_fix2:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration2 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration2 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration2 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration2 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix2
	   end
   end




--  Week three process
Select @save_date = @seed_date-21
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-15
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration3 (AVG_Exec_Count_min, Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, QueryText, GroupCount, dbaseid, update_flag)
select sum(execution_count) / (sum(intrvl_time_S) / 60)
    , (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_Logical_writes) / sum(execution_count))
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration3 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration3 where update_flag = 'n') > 0
   begin
	start_querytext_fix3:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration3 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration3 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration3 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration3 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix3
	   end
   end




--  Week four process
Select @save_date = @seed_date-28
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-22
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

insert into @tblv_duration4 (AVG_Exec_Count_min, Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, QueryText, GroupCount, dbaseid, update_flag)
select sum(execution_count) / (sum(intrvl_time_S) / 60)
    , (sum(delta_elapsed_time) / sum(execution_count))
    , (sum(delta_worker_time) / sum(execution_count))
    , (sum(delta_physical_reads) / sum(execution_count))
    , (sum(delta_Logical_writes) / sum(execution_count))
    , convert(nvarchar(100), querytext)
    , count(*) as 'count'
    , dbid
    , 'n'
From dbo.DMV_QueryStats_log
where rundate between @begindate and @enddate
and querytext is not null
and querytext not like '%wilson%'
and querytext not like '%dbaadmin%'
and querytext not like '%sys.dm%'
and dbid > 4
group by querytext, dbid

delete from @tblv_duration4 where dbaseid is null and groupcount < 10

If (select count(*) from @tblv_duration4 where update_flag = 'n') > 0
   begin
	start_querytext_fix4:
	Select @save_querytext = (select top 1 QueryText from @tblv_duration4 where update_flag = 'n')
	select @save_querytext_trim = ltrim(@save_querytext)

	Select @save_querytext_new = replace(@save_querytext_trim, char(10), ' ')-- line feeds
	Select @save_querytext_new = replace(@save_querytext_new, char(13), ' ')--carriage returns
	Select @save_querytext_new = replace(@save_querytext_new, char(9), ' ')--tabs
	Update @tblv_duration4 set QueryText = @save_querytext_new where QueryText = @save_querytext

	Update @tblv_duration4 set update_flag = 'y' where QueryText = @save_querytext
	If (select count(*) from @tblv_duration4 where update_flag = 'n') > 0
	   begin
		goto start_querytext_fix4
	   end
   end





--  The next section will check for exceptions
--  Exceptions are rows that are in the top 10 this week and have not been in the list the previous 3 weeks, or...
--  rows that have increased in percentage (input parm) compared with the previous 3 weeks

--  We will process the current weeks table, one row at a time
If (select count(*) from @tblv_duration1) > 0
   begin
	Delete From @tblv_duration1
	where AVG_Exec_Count_min not in (select top (@out_count) AVG_Exec_Count_min from @tblv_duration1 order by AVG_Exec_Count_min desc)

	Update @tblv_duration1 set update_flag = 'n'

	start_exception:

	Select @save_querytext = (select top 1 QueryText from @tblv_duration1 where update_flag = 'n')
	Select @save_AVG_Exec_Count_min = (select top 1 AVG_Exec_Count_min from @tblv_duration1 where QueryText = @save_querytext and update_flag = 'n')
	Select @hold_AVG_Exec_Count_min2 = 0
	select @prev_found_flag = 'n'

	If exists (select 1 from @tblv_duration2 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_AVG_Exec_Count_min2 = (select top 1 AVG_Exec_Count_min from @tblv_duration2 where QueryText = @save_querytext)
		If @save_AVG_Exec_Count_min2 > @hold_AVG_Exec_Count_min2
		   begin
			Select @hold_AVG_Exec_Count_min2 = @save_AVG_Exec_Count_min2
		   end
		If @save_AVG_Exec_Count_min > @save_AVG_Exec_Count_min2
		   and (((@save_AVG_Exec_Count_min - @save_AVG_Exec_Count_min2) * 100) / @save_AVG_Exec_Count_min) > @exception_pct
		   begin
			Select @exception_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_row_flag = 'n'
			goto skip_check1
		   end
	   end

	If exists (select 1 AVG_Exec_Count_min from @tblv_duration3 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_AVG_Exec_Count_min2 = (select top 1 AVG_Exec_Count_min from @tblv_duration3 where QueryText = @save_querytext)
		If @save_AVG_Exec_Count_min2 > @hold_AVG_Exec_Count_min2
		   begin
			Select @hold_AVG_Exec_Count_min2 = @save_AVG_Exec_Count_min2
		   end
		If @save_AVG_Exec_Count_min > @save_AVG_Exec_Count_min2
		   and (((@save_AVG_Exec_Count_min - @save_AVG_Exec_Count_min2) * 100) / @save_AVG_Exec_Count_min) > @exception_pct
		   begin
			Select @exception_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_row_flag = 'n'
			goto skip_check1
		   end
	   end

	If exists (select 1 AVG_Exec_Count_min from @tblv_duration4 where QueryText = @save_querytext)
	   begin
		select @prev_found_flag = 'y'
		Select @save_AVG_Exec_Count_min2 = (select top 1 AVG_Exec_Count_min from @tblv_duration4 where QueryText = @save_querytext)
		If @save_AVG_Exec_Count_min2 > @hold_AVG_Exec_Count_min2
		   begin
			Select @hold_AVG_Exec_Count_min2 = @save_AVG_Exec_Count_min2
		   end
		If @save_AVG_Exec_Count_min > @save_AVG_Exec_Count_min2
		   and (((@save_AVG_Exec_Count_min - @save_AVG_Exec_Count_min2) * 100) / @save_AVG_Exec_Count_min) > @exception_pct
		   begin
			Select @exception_row_flag = 'y'
		   end
		Else
		   begin
			Select @exception_row_flag = 'n'
			goto skip_check1
		   end
	   end

	skip_check1:


	If @prev_found_flag = 'n'
	   begin
		Select @exception_row_flag = 'y'
	   end


	If @exception_row_flag = 'y'
	   begin
		insert into @tblv_exception (AVG_Exec_Count_min, Prev_Exec_Count_min, Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, QueryText, GroupCount, dbaseid)
		select AVG_Exec_Count_min, @hold_AVG_Exec_Count_min2, Avg_Elapsed_Time_MS, Avg_CPU_Time_MS, Avg_Logical_Reads, Avg_Logical_Writes, QueryText, GroupCount, dbaseid
		From @tblv_duration1
		where QueryText = @save_querytext and AVG_Exec_Count_min = @save_AVG_Exec_Count_min
	   end


	Update @tblv_duration1 set update_flag = 'y' where QueryText = @save_querytext and AVG_Exec_Count_min = @save_AVG_Exec_Count_min
	If (select count(*) from @tblv_duration1 where update_flag = 'n') > 0
	   begin
		goto start_exception
	   end


	If (select count(*) from @tblv_exception) > 0
	   begin
		Select @save_date = @seed_date-1
		Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

		Print ''
		Select @miscprint = upper(@@servername) + ' EXCEPTIONS: Top Avg Execution Counts (per minute) for week ending on ' + convert(nvarchar(20), @enddate, 101)
		Print @miscprint
		Print ''

		select AVG_Exec_Count_min
		    , Prev_Exec_Count_min
		    , Avg_Elapsed_Time_MS
		    , Avg_CPU_Time_MS
		    , Avg_Logical_Reads
		    , Avg_Logical_Writes
		    , QueryText 
		from @tblv_exception 
		order by AVG_Exec_Count_min desc

		--  Send exception email
		Select @subject = 'SQL DBA EXCEPTIONS: [' + upper(@@servername) + '] Top Avg Execution Counts (per minute) for week ending on ' + convert(nvarchar(20), @enddate, 101)

		Select @message2 = upper(@@servername) + ' EXCEPTIONS: Top Avg Execution Counts (per minute) for week ending on ' + convert(nvarchar(20), @enddate, 101) + char(13)+char(10)
		Select @message2 = @message2 + '' + char(13)+char(10)
		Select @message2 = @message2 + 'Note: ' + convert(nvarchar(10), @exception_pct) + ' percent increase from previous high count indicates an exception.' + char(13)+char(10)
		Select @message2 = @message2 + '' + char(13)+char(10)
		Select @message2 = @message2 + 'AVG_Exec_Count_min   Prev_Exec_Count_min  QueryText' + char(13)+char(10)
		Select @message2 = @message2 + '-------------------- -------------------- --------------------------------------------------' + char(13)+char(10)
		start_email:
		Select @email_AVG_Exec_Count_min = (select top 1 AVG_Exec_Count_min from @tblv_exception order by AVG_Exec_Count_min desc)
		Select @email_Prev_Exec_Count_min = (select top 1 Prev_Exec_Count_min from @tblv_exception where AVG_Exec_Count_min = @email_AVG_Exec_Count_min order by Prev_Exec_Count_min desc)
		Select @email_QueryText = (select top 1 QueryText from @tblv_exception where AVG_Exec_Count_min = @email_AVG_Exec_Count_min  and Prev_Exec_Count_min = @email_Prev_Exec_Count_min order by QueryText desc)

		Select @message2 = @message2 + convert(char(20), @email_AVG_Exec_Count_min) + ' ' + convert(char(20), @email_Prev_Exec_Count_min) + ' ' + @email_QueryText + char(13)+char(10)

		Delete from @tblv_exception where AVG_Exec_Count_min = @email_AVG_Exec_Count_min and Prev_Exec_Count_min = @email_Prev_Exec_Count_min and QueryText = @email_QueryText
		If (select count(*) from @tblv_exception) > 0
		   begin
			goto start_email
		   end

		--print @subject
		--print @message2

		--  Email TS SQL DBA with this information
		EXEC dbaadmin.dbo.dbasp_sendmail 
			--@recipients = 'jim.wilson@gettyimages.com',  
			@recipients = @exception_recipient,  
			@subject = @subject,
			@message = @message2
	   end
   end


--  Print week 1
Select @save_date = @seed_date-7
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-1
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))
Print ''
Select @miscprint = @@servername + ':  Top Avg Execution Counts (per minute) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select AVG_Exec_Count_min
	, Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration1
Order by AVG_Exec_Count_min desc



--  Print week 2
Select @save_date = @seed_date-14
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-8
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Print ''
Select @miscprint = @@servername + ':  Top Avg Execution Counts (per minute) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select AVG_Exec_Count_min
	, Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration2
where AVG_Exec_Count_min in (select top (@out_count) AVG_Exec_Count_min from @tblv_duration2 order by AVG_Exec_Count_min desc)
Order by AVG_Exec_Count_min desc



--  Print week 3
Select @save_date = @seed_date-21
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-15
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Print ''
Select @miscprint = @@servername + ':  Top Avg Execution Counts (per minute) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select AVG_Exec_Count_min
	, Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration3
where AVG_Exec_Count_min in (select top (@out_count) AVG_Exec_Count_min from @tblv_duration3 order by AVG_Exec_Count_min desc)
Order by AVG_Exec_Count_min desc



--  Print week 4
Select @save_date = @seed_date-28
Select @begindate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Select @save_date = @seed_date-22
Select @enddate = convert(varchar(2), DATEPART(mm, @save_date)) + '/' + convert(varchar(2), DATEPART(dd, @save_date)) + '/' + convert(varchar(4), DATEPART(yyyy, @save_date))

Print ''
Select @miscprint = @@servername + ':  Top Avg Execution Counts (per minute) for week ending on ' + convert(nvarchar(20), @enddate, 101)
Print @miscprint
Print ''

Select AVG_Exec_Count_min
	, Avg_Elapsed_Time_MS
	, Avg_CPU_Time_MS
	, Avg_Logical_Reads
	, Avg_Logical_Writes
	, convert(nvarchar(25), db_name(dbaseid)) as 'DBname'
	, QueryText 
From @tblv_duration4
where AVG_Exec_Count_min in (select top (@out_count) AVG_Exec_Count_min from @tblv_duration4 order by AVG_Exec_Count_min desc)
Order by AVG_Exec_Count_min desc





---------------------------  Finalization for process  -----------------------
label99:

Print  ' '
Print  '/*******************************************************************'
Select @miscprint = '         END OF REPORT - FOR SERVER: ' + @@servername
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_REPORTusage
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_REPORTusage]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_REPORTusage]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_REPORTusage

/*********************************************************
 **  Stored Procedure dbasp_REPORTusage                  
 **  Written by Jim Wilson, Getty Images                
 **  April 17, 2000                                      
 **  
 **  This dbasp is set up to create a report documenting
 **  drive and database space usage on a specific SQL server. 
 **        
 **  Output member is REPORTusage.rpt
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	08/21/2002	Jim Wilson		Change @dbnamesave variable to sysname data type
--	08/26/2002	Jim Wilson		Removed servername from order by in cursors.
--	09/30/2002	Jim Wilson		Fix long line (over 255) problem.
--	08/08/2008	Jim Wilson		Converted for SQL 2005.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@Fixedheader01		nvarchar(255)
	,@Fixedheader02		nvarchar(255)
	,@Fixedheader03		nvarchar(255)
	,@G_O			nvarchar(2)
	,@DBNameSave		sysname
	,@FirstFlag		char(01)
	,@WSdatabase_size_MB	char(11)
	,@WSlog_size_MB		char(11)
	,@WSunallocatedspace_MB	char(11)
	,@WSdata_space_used_KB	char(18)
	,@WSindex_size_used_KB	char(18)
	,@WSunused_space_KB	char(18)
	,@WSlog_space_used_pct	char(7)
	,@WSDrive01name		char(10)
	,@WSDrive02name		char(10)
	,@WSDrive03name		char(10)
	,@WSDrive04name		char(10)
	,@WSDrive05name		char(10)
	,@WSDrive06name		char(10)
	,@WSDrive07name		char(10)
	,@WSDrive08name		char(10)
	,@WSDrive01free		char(10)
	,@WSDrive02free		char(10)
	,@WSDrive03free		char(10)
	,@WSDrive04free		char(10)
	,@WSDrive05free		char(10)
	,@WSDrive06free		char(10)
	,@WSDrive07free		char(10)
	,@WSDrive08free		char(10)
     
DECLARE
	 @cu10Servername	sysname
	,@cu10rundate		datetime
	,@cu10Drive01name	char(10)
	,@cu10Drive01free	int
	,@cu10Drive02name	char(10)
	,@cu10Drive02free	int
	,@cu10Drive03name	char(10)
	,@cu10Drive03free	int
	,@cu10Drive04name	char(10)
	,@cu10Drive04free	int
	,@cu10Drive05name	char(10)
	,@cu10Drive05free	int
	,@cu10Drive06name	char(10)
	,@cu10Drive06free	int
	,@cu10Drive07name	char(10)
	,@cu10Drive07free	int
	,@cu10Drive08name	char(10)
	,@cu10Drive08free	int

DECLARE
	 @cu11Servername	    sysname
	,@cu11DatabaseName	    sysname
	,@cu11rundate		    datetime
	,@cu11database_size_MB	    varchar(18)
	,@cu11unallocatedspace_MB   varchar(18)
	,@cu11reserved_space_KB	    varchar(18)
	,@cu11data_space_used_KB    varchar(18)
	,@cu11index_size_used_KB    varchar(18)
	,@cu11unused_space_KB	    varchar(18)
	,@cu11log_size_MB	    varchar(18)
	,@cu11log_space_used_pct    varchar(18)

----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @FirstFlag	= 'Y'
      
/*********************************************************************
 *                Initialization
 ********************************************************************/

--------------------  Cursor cu10  -------------------

EXECUTE('DECLARE cursor_cu10 Insensitive Cursor For ' + 
  'SELECT d.ServerName, d.rundate, d.Drive01name, d.Drive01free, d.Drive02name, d.Drive02free, d.Drive03name, d.Drive03free, d.Drive04name, d.Drive04free, 
	d.Drive05name, d.Drive05free, d.Drive06name, d.Drive06free, d.Drive07name, d.Drive07free, d.Drive08name, d.Drive08free
   From dbaadmin.dbo.fixeddisk_stats_log d ' + 
  'Where  80 > datediff(dd, d.rundate, getdate())
   Order By d.rundate For Read Only')


--------------------  Cursor cu11  -------------------

EXECUTE('DECLARE cursor_cu11 Insensitive Cursor For ' + 
  'SELECT u.Servername, u.DatabaseName, u.rundate, u.database_size_MB, u.[unallocated space_MB], u.reserved_space_KB, u.data_space_used_KB, u.index_size_used_KB, u.unused_space_KB, u.log_size_MB, u.log_space_used_pct
   From dbaadmin.dbo.db_stats_log u ' + 
  'Where  80 > datediff(dd, u.rundate, getdate())
   Order By u.DatabaseName, u.rundate For Read Only')



/****************************************************************
 *                MainLine
 ***************************************************************/

 
----------------------  Print the headers  ----------------------

   Print  '/*******************************************************************'
   Select @miscprint = '   REPORT DISK & DATABASE USAGE FOR SERVER: ' + @@servername
   Print  @miscprint
   Print  ' '
   Select @miscprint = '-- Generated on ' + convert(varchar(30),getdate())
   Print  @miscprint
   Print  '*******************************************************************/'
   Print  ' '


----------------------  Start fixed disk Reporting  ----------------------

OPEN cursor_cu10

WHILE (10=10)
   Begin
	FETCH Next From cursor_cu10 Into @cu10Servername
      ,@cu10rundate
      ,@cu10Drive01name 
      ,@cu10Drive01free 
      ,@cu10Drive02name 
      ,@cu10Drive02free 
      ,@cu10Drive03name 
      ,@cu10Drive03free 
      ,@cu10Drive04name 
      ,@cu10Drive04free 
      ,@cu10Drive05name 
      ,@cu10Drive05free 
      ,@cu10Drive06name 
      ,@cu10Drive06free 
      ,@cu10Drive07name 
      ,@cu10Drive07free 
      ,@cu10Drive08name 
      ,@cu10Drive08free 

	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_cu10
	      BREAK
           end

---------------------------  Format and print output  -----------------------
	IF @FirstFlag = 'Y'
           begin
	      IF @cu10Drive01name is null
		 begin
		   Select @WSDrive01name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive01name = 'Drive ' + @cu10Drive01name  
		   Select @Fixedheader01 = '           Fixed Disk Free Space'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name 
		   Select @Fixedheader03 = '========== =========='
		 end
	      IF @cu10Drive02name is null
		 begin
		   Select @WSDrive02name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive02name = 'Drive ' + @cu10Drive02name  
		   Select @Fixedheader01 = '           Fixed Disk Free Space'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name + ' ' + @WSDrive02name 
		   Select @Fixedheader03 = '========== ========== =========='
		 end
	      IF @cu10Drive03name is null
		 begin
		   Select @WSDrive03name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive03name = 'Drive ' + @cu10Drive03name  
		   Select @Fixedheader01 = '           ---  Fixed Disk Free Space  ----'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name + ' ' + @WSDrive02name + ' ' + @WSDrive03name 
		   Select @Fixedheader03 = '========== ========== ========== =========='
		 end
	      IF @cu10Drive04name is null
		 begin
		   Select @WSDrive04name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive04name = 'Drive ' + @cu10Drive04name  
		   Select @Fixedheader01 = '           ---------  Fixed Disk Free Space  ---------'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name + ' ' + @WSDrive02name + ' ' + @WSDrive03name + ' ' + @WSDrive04name 
		   Select @Fixedheader03 = '========== ========== ========== ========== =========='
		 end
	      IF @cu10Drive05name is null
		 begin
		   Select @WSDrive05name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive05name = 'Drive ' + @cu10Drive05name  
		   Select @Fixedheader01 = '           --------------  Fixed Disk Free Space  ---------------'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name + ' ' + @WSDrive02name + ' ' + @WSDrive03name + ' ' + @WSDrive04name +  ' ' + @WSDrive05name 
		   Select @Fixedheader03 = '========== ========== ========== ========== ========== =========='
		 end
	      IF @cu10Drive06name is null
		 begin
		   Select @WSDrive06name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive06name = 'Drive ' + @cu10Drive06name  
		   Select @Fixedheader01 = '           ---  Fixed Disk Free Space  ----'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name + ' ' + @WSDrive02name + ' ' + @WSDrive03name + ' ' + @WSDrive04name +  ' ' + @WSDrive05name + ' ' + @WSDrive06name 
		   Select @Fixedheader03 = '========== ========== ========== ========== ========== ========== =========='
		 end
	      IF @cu10Drive07name is null
		 begin
		   Select @WSDrive07name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive07name = 'Drive ' + @cu10Drive07name  
		   Select @Fixedheader01 = '           ---------  Fixed Disk Free Space  ---------'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name + ' ' + @WSDrive02name + ' ' + @WSDrive03name + ' ' + @WSDrive04name + ' ' + @WSDrive05name +  ' ' + @WSDrive06name + ' ' + @WSDrive07name
		   Select @Fixedheader03 = '========== ========== ========== ========== ========== ========== ========== =========='
		 end
	      IF @cu10Drive08name is null
		 begin
		   Select @WSDrive08name = ' '  
		 end
	      else
		 begin
		   Select @WSDrive08name = 'Drive ' + @cu10Drive08name  
		   Select @Fixedheader01 = '           --------------  Fixed Disk Free Space  ---------------'
		   Select @Fixedheader02 = 'Date          ' + @WSDrive01name + ' ' + @WSDrive02name + ' ' + @WSDrive03name + ' ' + @WSDrive04name +  ' ' + @WSDrive05name + ' ' + @WSDrive06name +  ' ' + @WSDrive07name + ' ' + @WSDrive08name
		   Select @Fixedheader03 = '========== ========== ========== ========== ========== ========== ========== ========== =========='
		 end

	      Print  @Fixedheader01
	      Print  @Fixedheader02
	      Print  @Fixedheader03
   	      Select @FirstFlag = 'N' 
           end



	IF @cu10Drive01name is null
	   begin
	     Select @WSDrive01free = ' '  
	   end
	Else
	   begin    
	     Select @WSDrive01free = str(@cu10Drive01free, 7) + ' MB'  
	   end

	IF @cu10Drive02name is null
	   begin
	     Select @WSDrive02free = ' '  
	   end
	Else
	   begin
	     Select @WSDrive02free = str(@cu10Drive02free, 7) + ' MB'
	   end

	IF @cu10Drive03name is null
	   begin
	     Select @WSDrive03free = ' '  
	   end
	Else
	   begin
	     Select @WSDrive03free = str(@cu10Drive03free, 7) + ' MB'  
	   end

	IF @cu10Drive04name is null
	   begin
	     Select @WSDrive04free = ' '  
	   end
	Else
	   begin
	     Select @WSDrive04free = str(@cu10Drive04free, 7) + ' MB'  
	   end

	IF @cu10Drive05name is null
	   begin
	     Select @WSDrive05free = ' '  
	   end
	Else
	   begin
	     Select @WSDrive05free = str(@cu10Drive05free, 7) + ' MB'  
	   end

	IF @cu10Drive06name is null
	   begin
	     Select @WSDrive06free = ' '  
	   end
	Else
	   begin
	     Select @WSDrive06free = str(@cu10Drive06free, 7) + ' MB'  
	   end

	IF @cu10Drive07name is null
	   begin
	     Select @WSDrive07free = ' '  
	   end
	Else
	   begin
	     Select @WSDrive07free = str(@cu10Drive07free, 7) + ' MB'  
	   end

	IF @cu10Drive08name is null
	   begin
	     Select @WSDrive08free = ' '  
	   end
	Else
	   begin
	     Select @WSDrive08free = str(@cu10Drive08free, 7) + ' MB'  
	   end

	Select @miscprint  = convert(varchar(10),@cu10rundate,101) + ' ' + @WSDrive01free + ' ' + @WSDrive02free + ' ' + @WSDrive03free + ' ' + @WSDrive04free + ' ' + @WSDrive05free + ' ' + @WSDrive06free + ' ' + @WSDrive07free + ' ' + @WSDrive08free
	Print  @miscprint

 
 End  -- loop 10
DEALLOCATE cursor_cu10

----------------------  Print database reporting headers  ----------------------

   Print  ' '
   Print  ' '
   Select @FirstFlag = 'Y' 

   Select @miscprint = 'Database             ----------  File Size  ------------   ----------------  Usage of Allocated File Space (KB) ----------------'
   Print  @miscprint
   Select @miscprint = 'Date                        Data         Log  Unallocted                Data              Index             Unused    Used Log %'
   Print  @miscprint
   Select @miscprint = '==================== =========== =========== ===========   ================== ================== ================== ============'
   Print  @miscprint


----------------------  Start database Reporting  ----------------------

OPEN cursor_cu11

WHILE (11=11)
   Begin
	FETCH Next From cursor_cu11 Into @cu11Servername
	,@cu11DatabaseName
	,@cu11rundate
	,@cu11database_size_MB
	,@cu11unallocatedspace_MB
	,@cu11reserved_space_KB
	,@cu11data_space_used_KB
	,@cu11index_size_used_KB
	,@cu11unused_space_KB
	,@cu11log_size_MB
	,@cu11log_space_used_pct

	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_cu11
	      BREAK
           end

---------------------------  Format and print output  -----------------------

	IF @FirstFlag = 'Y'
           begin
	      Select @miscprint  = @cu11DatabaseName
	      Print  @miscprint
	      Select @DBNameSave  = @cu11DatabaseName 
   	      Select @FirstFlag = 'N' 
           end

	IF @cu11DatabaseName <> @DBNameSave
	   begin
	      Print  ' '
	      Select @miscprint  = @cu11DatabaseName
	      Print  @miscprint
              Select @DBNameSave  = @cu11DatabaseName 
	   end

	Select @WSdatabase_size_MB = str(@cu11database_size_MB, 8) + ' MB'  
	Select @WSlog_size_MB = str(@cu11log_size_MB, 8) + ' MB'  
	Select @WSunallocatedspace_MB = str(@cu11unallocatedspace_MB, 8) + ' MB'  
	Select @WSdata_space_used_KB = str(@cu11data_space_used_KB, 15, 2) + ' KB'  
	Select @WSindex_size_used_KB = str(@cu11index_size_used_KB, 15, 2) + ' KB'  
	Select @WSunused_space_KB = str(@cu11unused_space_KB, 15, 2) + ' KB'  
	Select @WSlog_space_used_pct = str(@cu11log_space_used_pct, 5, 1) + '%'  


	Select @miscprint  = convert(varchar(10),@cu11rundate,101) + '           ' + @WSdatabase_size_MB + ' ' + @WSlog_size_MB + ' ' + @WSunallocatedspace_MB + '   ' + @WSdata_space_used_KB + ' ' + @WSindex_size_used_KB + ' ' + @WSunused_space_KB + '       ' + @WSlog_space_used_pct
	Print  @miscprint

           
 
 End  -- loop 11

DEALLOCATE cursor_cu11


---------------------------  Finalization for process  -----------------------
Print  ' '
Print  '/*******************************************************************'
Select @miscprint = '         END OF REPORT - FOR SERVER: ' + @@servername
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '



 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Reset_UserDB_Access
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Reset_UserDB_Access]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Reset_UserDB_Access]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_Reset_UserDB_Access @db_name sysname = null

/***************************************************************
 **  Stored Procedure dbasp_Reset_UserDB_Access                  
 **  Written by Jim Wilson, Getty Images                
 **  April 01, 2003                                      
 **  
 **  This sproc is set up to;
 ** 
 **  Reset user database access information after a restore.
 **  Information previously captured into a local dbaadmin table
 **  is used for restore processing to dynamically maintain
 **  database security and access. 
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/01/2003	Jim Wilson		New process.
--	04/15/2005	Jim Wilson		Added some display statements.
--	04/04/2007	Jim Wilson		New cleanup process for table UserDB_Access_Ctrl.
--	05/15/2007	Jim Wilson		Converted for SQL 2005.
--	05/01/2008	Jim Wilson		Changed sp_grantdbaccess to create user.
--	09/22/2008	Jim Wilson		Added conditional to DB grant access.
--	09/26/2008	Jim Wilson		varchar(255) to nvarchar(500).
--	======================================================================================

/**
declare @db_name sysname

Select @db_name = 'Getty_Images_US_Inc__MSCRM'
--**/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@error_count			int
        ,@cmd				nvarchar(500)
        ,@sqlcmd			nvarchar(500)
	,@save_servername		sysname
	,@charpos			int


DECLARE
	 @cu11Loginname			sysname
	,@cu11Username			sysname
	,@cu11DfltDB			sysname

DECLARE
	 @cu12Loginname			sysname
	,@cu12Username			sysname
	,@cu12DBrole			sysname
	,@cu12DfltDB			sysname


----------------  initial values  -------------------
Select @error_count = 0

Select @save_servername		= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
   end


-- VALIDATE DATABASE NAME:
If not exists(select 1 from master.sys.databases where name = @db_name)
   begin
	Select @miscprint = 'DBA WARNING: Database name not found in master.sys.databases' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
end


-- Verify and clean UserDB_Access_Ctrl table
Delete from dbo.UserDB_Access_Ctrl
where loginname not in (select name from master.sys.syslogins)



-- START the Reset Database Access process

--  Get all captured database access records where role is 'public'
--------------------  Cursor for 11DB  -----------------------
EXECUTE('DECLARE cu11_Access Insensitive Cursor For ' + 
  'SELECT u.Loginname, u.Username, u.DfltDB
   From dbaadmin.dbo.UserDB_Access_Ctrl  u ' + 
  'Where u.DBname = ''' + @db_name + '''
     and u.DBrole = ''public''
   Order By u.Loginname For Read Only')


OPEN cu11_Access

WHILE (11=11)
   Begin
	FETCH Next From cu11_Access Into @cu11Loginname, @cu11Username, @cu11DfltDB
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_Access
	      BREAK
           end

	--  Grant DB access for this login
	SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -d' + @db_name + ' -Q"If not exists (select 1 from sys.sysusers where name = ''' + @cu11Loginname + ''') CREATE USER [' + @cu11Loginname + '] FOR LOGIN [' + @cu11Username + ']" -E'
	Print @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd--, no_output

	Select @cmd = 'sp_defaultdb ''' + @cu11Loginname + ''', ''' + @cu11DfltDB + ''''
	Print @cmd
	exec (@cmd)


   End  -- loop 11
   DEALLOCATE cu11_Access


--  Now, get all captured database access records where role is not 'public'
--------------------  Cursor for 11DB  -----------------------
EXECUTE('DECLARE cu12_Access Insensitive Cursor For ' + 
  'SELECT u.Loginname, u.Username, u.DBrole, u.DfltDB
   From dbaadmin.dbo.UserDB_Access_Ctrl  u ' + 
  'Where u.DBname = ''' + @db_name + '''
     and u.DBrole <> ''public''
   Order By u.Loginname For Read Only')


OPEN cu12_Access

WHILE (12=12)
   Begin
	FETCH Next From cu12_Access Into @cu12Loginname, @cu12Username, @cu12DBrole, @cu12DfltDB
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_Access
	      BREAK
           end

	--  Add role members as needed
	SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -d' + @db_name + ' -Q"sp_addrolemember ''' + @cu12DBrole + ''', ''' + @cu12Username + '''" -E'
	Print @sqlcmd
	EXEC master.sys.xp_cmdshell @sqlcmd--, no_output


   End  -- loop 12
   DEALLOCATE cu12_Access


--  Finalization  -------------------------------------------------------------------

label99:



If  @error_count > 0
   begin
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_runarchive
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_runarchive]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_runarchive]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_runarchive  @outpath varchar (255) = null

/*********************************************************
 **  Stored Procedure dbasp_runarchive                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  This procedure runs the archive process that is    
 **  used for disaster recovery.                        
 *********************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	06/07/2002	Jim Wilson		Canged output path to handel cluster instances.
--	06/10/2002	Jim Wilson		Added cmds to create detach and attach scripts.
--	06/12/2002	Jim Wilson		Added output path verification.
--	08/02/2002	Jim Wilson		Added input parm for sysobjectprivledges.
--	08/30/2002	Jim Wilson		Added new script for sysaddoperators.
--	10/01/2002	Jim Wilson		Added new script for sysrestore_byDB.
--	10/10/2002	Jim Wilson		Changed wait to 1 second between commands.
--	04/17/2003	Jim Wilson		Changes for new instance share names.
--	09/16/2003	Jim Wilson		Added new script for syscreateshares.
--	07/20/2005	Jim Wilson		Added new script for SYSchangeobjectownerBYdb.
--	02/21/2006	Jim Wilson		Modified for sql 2005.
--	05/19/2006	Jim Wilson		Fixed servername in output path.
--	08/16/2006	Jim Wilson		enabled syscreateshares
--	08/16/2006	Jim Wilson		enabled dbasp_SYSrestoreBYdb
--	12/07/2006	Jim Wilson		enabled dbasp_SYSsqlcomfig
--	05/01/2007	Jim Wilson		Changed sqlcmd outpt to unicode.
--	03/10/2008	Jim Wilson		Added dbasp_SYSaddsrvrolemembers.
--	05/16/2008	Jim Wilson		Update width for sysjobs output to 2000.
--	08/31/2009	Jim Wilson		Added BASE_archive process.
--	03/12/2010	Jim Wilson		Added weekly baselinefor APPL jobs.
--	======================================================================================


/***
declare @outpath varchar (255)

select @outpath = null
--***/

DECLARE	 
	 @result		int
	,@miscprint		varchar(400)
	,@print_flag		char(1)
	,@sqlcmd		varchar(255)
	,@cmd			varchar(255)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_servername3	sysname
	,@charpos		int
	,@Hold_hh		nvarchar(2)
	

Select @print_flag = 'n'
Select @save_servername = @@servername
Select @save_servername2 = @@servername
Select @save_servername3 = @@servername

select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
	select @save_servername3 = @save_servername3 + ')'
   end	

Select @outpath = '\\' + @save_servername + '\' + @save_servername2 + '_dba_archive'

--  Verify output path existance
create table #fileexists ( 
	doesexist smallint,
	fileindir smallint,
	direxist smallint)

Insert into #fileexists exec master.sys.xp_fileexist @outpath

If exists (select fileindir from #fileexists where fileindir = 1)
   begin
	Select @print_flag = 'y'
   end



If @print_flag = 'n'
   begin
	goto label99
   end

Select @outpath = @outpath + '\'


--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddalerts" -E -o' + @outpath + @save_servername3 + '_SYSaddalerts.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSadddbaliases" -E -o' + @outpath + @save_servername3 + '_SYSadddbaliases.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSadddbrolemembers" -E -o' + @outpath + @save_servername3 + '_SYSadddbrolemembers.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSadddbroles" -E -o' + @outpath + @save_servername3 + '_SYSadddbroles.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddextendedsps" -E -o' + @outpath + @save_servername3 + '_SYSaddextendedsps.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd
	
WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddlinkedservers" -E -o' + @outpath + @save_servername3 + '_SYSaddlinkedservers.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd
	
WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddmasterlogins" -E -o' + @outpath + @save_servername3 + '_SYSaddmasterlogins.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd
	
--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddmasterloginsBYdb" -E -o' + @outpath + @save_servername3 + '_SYSaddmasterloginsBYdb.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd
	
--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddoperators" -E -o' + @outpath + @save_servername3 + '_SYSaddoperators.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddothermastersps" -E -o' + @outpath + @save_servername3 + '_SYSaddothermastersps.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd
	
WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddsrvrolemembers" -E -o' + @outpath + @save_servername3 + '_SYSaddsrvrolemembers.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddsysdbaliases" -E -o' + @outpath + @save_servername3 + '_SYSaddsysdbaliases.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddsysdbroles" -E -o' + @outpath + @save_servername3 + '_SYSaddsysdbroles.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddsysdbrolemembers" -E -o' + @outpath + @save_servername3 + '_SYSaddsysdbrolemembers.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddsysmessages" -E -o' + @outpath + @save_servername3 + '_SYSaddsysmessages.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSattach_userDBs" -E -o' + @outpath + @save_servername3 + '_SYSattach_userDBs.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSchgdbowner" -E -o' + @outpath + @save_servername3 + '_SYSchgdbowner.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSchangeobjectownerBYdb" -E -o' + @outpath + @save_servername3 + '_SYSchangeobjectownerBYdb.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSchguserdefaultdb" -E -o' + @outpath + @save_servername3 + '_SYSchguserdefaultdb.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYScreatedatabases" -E -o' + @outpath + @save_servername3 + '_SYScreatedatabases.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYScreateDBusers" -E -o' + @outpath + @save_servername3 + '_SYScreateDBusers.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_syscreateshares" -E -o' + @outpath + @save_servername3 + '_SYScreateshares.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdbRestore" -E -o' + @outpath + @save_servername3 + '_SYSdbRestore.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdeletedbaliases" -E -o' + @outpath + @save_servername3 + '_SYSdeletedbaliases.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdetach_userDBs" -E -o' + @outpath + @save_servername3 + '_SYSdetach_userDBs.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropdbrolemembers" -E -o' + @outpath + @save_servername3 + '_SYSdropdbrolemembers.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropdbroles" -E -o' + @outpath + @save_servername3 + '_SYSdropdbroles.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropDBusers" -E -o' + @outpath + @save_servername3 + '_SYSdropDBusers.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdroplinkedservers" -E -o' + @outpath + @save_servername3 + '_SYSdroplinkedservers.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropmasterlogins" -E -o' + @outpath + @save_servername3 + '_SYSdropmasterlogins.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropmasterloginsBYdb" -E -o' + @outpath + @save_servername3 + '_SYSdropmasterloginsBYdb.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropsrvrolemembers" -E -o' + @outpath + @save_servername3 + '_SYSdropsrvrolemembers.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropsysdbrolemembers" -E -o' + @outpath + @save_servername3 + '_SYSdropsysdbrolemembers.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSdropsysdbroles" -E -o' + @outpath + @save_servername3 + '_SYSdropsysdbroles.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSgrantsysdbaccess" -E -o' + @outpath + @save_servername3 + '_SYSgrantsysdbaccess.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSgrantmasterlogins" -E -o' + @outpath + @save_servername3 + '_SYSgrantmasterlogins.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSgrantmasterloginsBYdb" -E -o' + @outpath + @save_servername3 + '_SYSgrantmasterloginsBYdb.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSgrantextSPprivileges" -E -o' + @outpath + @save_servername3 + '_SYSgrantextSPprivileges.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSgrantobjectprivileges @outpath = ''' + @outpath + ''' " -E -o' + @outpath + @save_servername3 + '_SYSgrantobjectprivileges.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSrestoreBYdb @outfiles = ''y''" -E'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSsetDBoptions" -E -o' + @outpath + @save_servername3 + '_SYSsetDBoptions.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSsetServerOptions" -E -o' + @outpath + @save_servername3 + '_SYSsetServerOptions.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSsetLinkedServerOptions" -E -o' + @outpath + @save_servername3 + '_SYSsetLinkedServerOptions.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSsetprocoption" -E -o' + @outpath + @save_servername3 + '_SYSsetprocoption.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSsqlconfig" -E -o' + @outpath + @save_servername3 + '_SYSsqlconfig.txt'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSadddbmaintplan_DBs" -E -o' + @outpath + @save_servername3 + '_SYSadddbmaintplan_DBs.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSadddbmaintplan_jobs" -E -o' + @outpath + @save_servername3 + '_SYSadddbmaintplan_jobs.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

--WAITFOR DELAY '000:00:01'
--SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSadddbmaintplans" -E -o' + @outpath + @save_servername3 + '_SYSadddbmaintplans.gsql'
--PRINT   @sqlcmd
--EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w2000 -u -Q"exec dbaadmin.dbo.dbasp_SYSaddjobs" -E -o' + @outpath + @save_servername3 + '_SYSaddjobs.gsql'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd

WAITFOR DELAY '000:00:01'
SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSbase_archive" -E -o' + @outpath + @save_servername3 + '_BASE_archive.txt'
PRINT   @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd


--  Baseline the deployment related APPL jobs every Friday night/Saturday morning
Set @Hold_hh = convert(nvarchar(2), getdate(), 8)

If (select datepart(weekday, getdate())) = 6 and @Hold_hh > 12
or (select datepart(weekday, getdate())) = 7 and @Hold_hh < 6
   begin
	EXEC @result = dbo.dbasp_base_APPL_JobScripting
   end






label99:

DROP TABLE #fileexists


If @print_flag = 'n'
   begin
	select @miscprint = 'DBA WARNING: Unable to write dba_archive file(s) to output path ''' + @outpath + ''''
	raiserror(@miscprint,1,-1) with log
	return 1
   end
Else
   begin
	return 0
   end

 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_script_DBsprocs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_script_DBsprocs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_script_DBsprocs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_script_DBsprocs (@DBname sysname = null)

/*********************************************************
 **  Stored Procedure dbasp_script_DBsprocs                  
 **  Written by Jim Wilson, Getty Images                
 **  September 27, 2002                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Script all sprcos for a specific DB  
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/27/2002	Jim Wilson		New process
--	10/01/2002	Jim Wilson		Change default length tp 500 (from 255)
--	10/08/2002	Jim Wilson		Fixed mutiple line feed problem and
--						changed IF @BasePos < @TextLength to
--						IF @BasePos <= @TextLength
--	02/14/2006	Jim Wilson		Modified for sql2005.
--	06/13/2006	Jim Wilson		Added 'order by lineid' to 'Select @save_lineid = '...
--	09/13/2007	Jim Wilson		Added options ansi_nulls and quoted_identifier
--	05/08/2008	Jim Wilson		Added no-drop code for sproc dbasp_Code_Updates.
--	08/22/2008	Jim Wilson		Fixed no-drop flag.
--	======================================================================================


-----------------  declares  ------------------

/**
Declare @DBname sysname

Select @DBname = 'dbaadmin'
--**/

DECLARE
	 @miscprint		nvarchar(500)
	,@DefinedLength		int
	,@BlankSpaceAdded	int
	,@output_flag		char(1)
	,@G_O			nvarchar(2)
	,@LFCR			int --lengths of line feed carriage return
	,@cmd			nvarchar(2000)
	,@LineId		int
	,@SyscomText		nvarchar(4000)
	,@save_number		smallint
	,@save_colid		smallint
	,@save_lineid		int
	,@save_objid		int
	,@charpos		int	
	,@pos			int
	,@no_drop		char(1)

declare
	 @BasePos		int
	,@CurrentPos		int
	,@TextLength		int 
	,@AddOnLen		int
	,@Line			nvarchar(500)
	,@commentText		nvarchar(500)

declare 
	 @cu11_name		sysname
	,@cu11_id		int
	,@cu11_uname		sysname


----------------  initial values  -------------------

/* NOTE: Length of @SyscomText is 4000 to replace the length of
** text column in syscomments. 
** Lengths on @Line, #CommentText Text column and
** value for @DefinedLength are all 500. These need to all have
** the same values. 
*/
       
Select @G_O             = 'g' + 'o'
Select @DefinedLength   = 500
Select @BlankSpaceAdded = 0 /*Keeps track of blank spaces at end of lines. Note Len function ignores
							 trailing blank spaces*/
Select @output_flag	= 'n'

--  Create tables and table variables
declare @objinfo table	(oname		sysname
			,oid		int
			,uname		sysname
			)

CREATE TABLE #CommentText (LineId	int
			,Text	nvarchar(500)
			)


CREATE TABLE #Syscom (SyscomText	nvarchar(4000)
			,number		smallint
			,colid		smallint
			)

If @DBname is null
   begin
	Select @DBname = 'dbaadmin'
   end


/*********************************************************************
 *                Initialization
 ********************************************************************/

EXEC ('SELECT id, number, colid, status, encrypted, text INTO ##temp_com FROM ' + @DBname + '.sys.syscomments')
--select * from ##temp_com

EXEC ('SELECT id, xtype INTO ##temp_obj FROM ' + @DBname + '.sys.sysobjects')
--select * from ##temp_obj

/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/**************************************************************'
Select @miscprint = 'Generated SQL - script_DBsprocs For Database ' + @dbname
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '**************************************************************/'
Print  ' '


----------------------  Print the headers  ----------------------
Print  '/*********************************************************'
Select @miscprint = 'ADD STORED PROCEDURES FOR DATABASE ' + @DBName
Print  @miscprint
Print  '*********************************************************/'
Print  ' '
Select @miscprint = 'USE ' + @DBname
Print  @miscprint  
Print  @G_O
Print  ' '

--------------------  Capture Sproc names  -------------------

Select @cmd = 'SELECT o.name, o.id, u.name
   From ' + @DBname + '.sys.sysobjects  o, ' + @DBname + '.sys.sysusers  u ' + 
  'Where o.status > -1
     and o.xtype = ''p''
     and o.uid = u.uid'

insert into @objinfo (oname, oid, uname) exec (@cmd)

delete from @objinfo where oname is null or oname = ''
--select * from @objinfo


If (select count(*) from @objinfo) > 0
   begin
	start_objinfo:

	Select @cu11_id = (select top 1 oid from @objinfo order by oname) 
	Select @cu11_name = (select oname from @objinfo where oid = @cu11_id) 
	Select @cu11_uname = (select uname from @objinfo where oid = @cu11_id) 


	-------------  Save the first object id  -------------

	--  Find out how many lines of text are coming back, and return if there are none.
	if (select count(*) from ##temp_com c, ##temp_obj o 
		where o.xtype not in ('S', 'U')
		  and o.id = c.id 
		  and o.id = @cu11_id) = 0 
	   begin
		raiserror(15197,-1,-1,@cu11_name)
		goto label89						
	   end

	if (select count(*) from ##temp_com 
		where id = @cu11_id
		  and encrypted = 0) = 0
	   begin
		raiserror(15471,-1,-1)
		goto label89						
	   end


	--  get the object text.
	delete from #CommentText

	SELECT @LFCR = 2
	SELECT @LineId = 1

	delete from #Syscom
	insert into #Syscom (SyscomText, number, colid)
	SELECT text, number, colid FROM ##temp_com 
				WHERE id = @cu11_id 
				  and encrypted = 0

	If (select count(*) from #Syscom) > 0
	   begin
		start_syscom:

		Select @SyscomText = (select top 1 SyscomText from #Syscom order by number, colid)
		Select @save_number = (select top 1 number from #Syscom where SyscomText = @SyscomText order by number, colid)
		Select @save_colid = (select top 1 colid from #Syscom where SyscomText = @SyscomText order by number, colid)

		SELECT  @BasePos	= 1
		SELECT  @CurrentPos	= 1
		SELECT	@TextLength = LEN(@SyscomText)

		WHILE @CurrentPos  != 0
		   BEGIN
			--Looking for end of line followed by carriage return
			SELECT @CurrentPos =   CHARINDEX(char(13)+char(10), @SyscomText, @BasePos)

			--If carriage return found
			IF @CurrentPos != 0
			   BEGIN
				/*If new value for @Lines length will be > then the
				**set length then insert current contents of @line
				**and proceed.
				*/
				While (isnull(LEN(@Line),0) + @BlankSpaceAdded + @CurrentPos-@BasePos + @LFCR) > @DefinedLength
				   BEGIN
					SELECT @AddOnLen = @DefinedLength-(isnull(LEN(@Line),0) + @BlankSpaceAdded)
					INSERT #CommentText VALUES (@LineId, isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N''))
					SELECT @Line = NULL
					SELECT @LineId = @LineId + 1
					SELECT @BasePos = @BasePos + @AddOnLen
					SELECT @BlankSpaceAdded = 0
				   END
				SELECT @Line	= isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @CurrentPos-@BasePos + @LFCR), N'')
				SELECT @BasePos = @CurrentPos+2
				INSERT #CommentText VALUES( @LineId, @Line )
				SELECT @LineId = @LineId + 1
				SELECT @Line = NULL
			   END
			ELSE
			--else carriage return not found
			   BEGIN
				IF @BasePos <= @TextLength
				   BEGIN
					/*If new value for @Lines length will be > then the
					**defined length
					*/
					While (isnull(LEN(@Line),0) + @BlankSpaceAdded + @TextLength-@BasePos+1 ) > @DefinedLength
					   BEGIN
						SELECT @AddOnLen = @DefinedLength - (isnull(LEN(@Line),0) + @BlankSpaceAdded )
						INSERT #CommentText VALUES (@LineId, isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N''))
						SELECT @Line = NULL
						SELECT @LineId = @LineId + 1
						SELECT @BasePos = @BasePos + @AddOnLen
						SELECT @BlankSpaceAdded = 0
					   END
					SELECT @Line = isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @TextLength-@BasePos+1 ), N'')
					if charindex(' ', @SyscomText, @TextLength+1 ) > 0
					   BEGIN
						SELECT @Line = @Line + ' '
						SELECT @BlankSpaceAdded = 1
					   END
					BREAK
				END
			END
		END

		-- check for more syscom rows to process
		delete from #Syscom where SyscomText = @SyscomText and number = @save_number and colid = @save_colid
		If (select count(*) from #Syscom) > 0
		   begin
			goto start_syscom
		   end

	   end


	IF @Line is NOT NULL
	   begin
		INSERT #CommentText VALUES( @LineId, @Line )
	   end

	print ''
	print ''
	select @miscprint = '------------------------------------------------------------------------------------------------------- '
	print  @miscprint
	select @miscprint = '-- ' + @cu11_name
	print  @miscprint
	select @miscprint = '------------------------------------------------------------------------------------------------------- '
	print  @miscprint
	Select @no_drop = 'n'


	If @cu11_name not like '%dbasp_Code_Updates%'
	   begin
		Select @no_drop = 'n'
		select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_uname + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsProcedure'') = 1)'
		print  @miscprint
		select @miscprint = 'drop procedure [' + @cu11_uname + '].[' + @cu11_name + ']'
		print  @miscprint
		print  'GO'
	   end
	Else
	   begin
		Select @no_drop = 'y'
	   end


	--  set ANSI_NULLS option
	Select @cmd = 'use [' + @DBname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_uname + '].[' + @cu11_name + ']''), N''ExecIsAnsiNullsOn'')'
	EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
	If @save_objid = 1
	   begin
		select @miscprint = 'SET ANSI_NULLS ON'
		print  @miscprint
		print  'GO'
	   end
	Else
	   begin
		select @miscprint = 'SET ANSI_NULLS OFF'
		print  @miscprint
		print  'GO'
	   end


	--  set QUOTED_IDENTIFIER option
    	Select @cmd = 'use [' + @DBname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_uname + '].[' + @cu11_name + ']''), N''ExecIsQuotedIdentOn'')'
	EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
	If @save_objid = 1
	   begin
		select @miscprint = 'SET QUOTED_IDENTIFIER ON'
		print  @miscprint
		print  'GO'
	   end
	Else
	   begin
		select @miscprint = 'SET QUOTED_IDENTIFIER OFF'
		print  @miscprint
		print  'GO'
	   end


	If @no_drop = 'y'
	   begin
		print  ''
		select @miscprint = 'IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[' + @cu11_uname + '].[' + @cu11_name + ']'') AND type in (N''P'', N''PC''))'
		print  @miscprint
		select @miscprint = 'Begin'
		print  @miscprint
		select @miscprint = 'EXEC dbo.sp_executesql @statement = N'''
		print  @miscprint
	   end


	If (select count(*) from #CommentText) > 0
	   begin
		start_comment:

		Select @save_lineid = (select top 1 lineid from #CommentText order by lineid)
		Select @commentText = (select text from #CommentText where lineid = @save_lineid)

		--  Fix CR's with out line feeds
		Select @pos = 1
		Label90:
		Select @charpos = charindex(char(13), @commentText, @pos)
		IF @charpos <> 0
		   begin
			Select @pos = @charpos
			If substring(@commentText, @charpos+1, 1) <> char(10)
			   begin
				select @commentText = stuff(@commentText, @charpos, 1, char(13)+char(10))
				Select @pos = @pos + 1
			   end
		   end

		Select @pos = @pos + 1
		Select @charpos = charindex(char(13), @commentText, @pos)
		IF @charpos <> 0
		   begin
			goto label90
		   end

		--  Fix line feeds with no preceeding CR
		Select @pos = 1
		Label91:
		Select @charpos = charindex(char(10), @commentText, @pos)
		IF @charpos <> 0
		   begin
			Select @pos = @charpos
			If substring(@commentText, @charpos-1, 1) <> char(13)
			   begin
				select @commentText = stuff(@commentText, @charpos, 1, char(13)+char(10))
				Select @pos = @pos + 1
			   end
		   end

		Select @pos = @pos + 1
		Select @charpos = charindex(char(10), @commentText, @pos)
		IF @charpos <> 0
		   begin
			goto label91
		   end

		If @no_drop = 'y'
		   begin
			Select @commentText = replace(@commentText, '''', '''''')
		   end

		select @miscprint = @commentText
		print  @miscprint

		-- check for more comment rows to process
		Delete from #CommentText where lineid = @save_lineid
		If (select count(*) from #CommentText) > 0
		   begin
			goto start_comment
		   end

	   end


	SELECT @Line = NULL
        
	Print  ' '

	If @no_drop = 'y'
	   begin
		print  ''
		select @miscprint = ''''
		print  @miscprint
		select @miscprint = 'End'
		print  @miscprint
	   end

	Print  @G_O 

	Select @output_flag	= 'y'
 

	label89:

	--  Check for more objects to process
	Delete from @objinfo where oid = @cu11_id
	If (select count(*) from @objinfo) > 0
	   begin
		goto start_objinfo
	   end

   end


---------------------------  Finalization  -----------------------
label99:

If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end

DROP TABLE ##temp_com
DROP TABLE ##temp_obj
DROP TABLE #CommentText
DROP TABLE #Syscom

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_script_DDL
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_script_DDL]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_script_DDL]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_script_DDL (@DBname sysname = 'all'
					,@objtype nvarchar(10) = 'all'
					,@suppress_use_stmt char(1) = 'n'
					,@suppress_drop_stmt char(1) = 'n'
					,@drop_only char(1) = 'n')

/*********************************************************
 **  Stored Procedure dbasp_script_DDL                  
 **  Written by Jim Wilson, Getty Images                
 **  October 15, 2007                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Script all objects for a specific DB or all databases.  
 **        
 **  Input parms:  
 **  @DBname = The database name or 'ALL' for all user databases.  
 **  @objtype = The object type you want to script, or 'ALL'. 
 **  @suppress_use_stmt - For no 'USE' statement in the output script.
 **  @suppress_drop_stmt - For no drop statement in the output script
 **  @drop_only - For a drop only output script 
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/27/2002	Jim Wilson		New process
--	10/02/2008	Jim Wilson		Added code for indexed views and drop only input parm.
--	10/23/2008	Jim Wilson		Loop for multiple FK column references.
--	05/13/2009	Jim Wilson		Changed @DefinedLength from 4000 back to 500.
--	05/21/2010	Jim Wilson		Fix for function scripting.
--	======================================================================================

/*
'u' = USER_TABLE
'f' = FOREIGN_KEY_CONSTRAINT
'p' = SQL_STORED_PROCEDURE
'fn' = SQL_SCALAR_FUNCTION
'tf' = SQL_TABLE_VALUED_FUNCTION
'IF' = SQL inline table-valued function
'v' = VIEW (all views)
'vi' = VIEW with index

'it' = INTERNAL_TABLE
'sq' = SERVICE_QUEUE
's' = system table (not created with this script)
'pk' = PRIMARY_KEY_CONSTRAINT (not created seperatly with this script)
'uq' = UNIQUE_CONSTRAINT (not created seperatly with this script)
'd' = DEFAULT_CONSTRAINT (not created seperatly with this script)
*/

-----------------  declares  ------------------

/**
Declare @DBname sysname
Declare @objtype nvarchar(10)
Declare @suppress_use_stmt char(1)
Declare @suppress_drop_stmt char(1)
Declare @drop_only char(1)

Select @DBname = 'dbaadmin'
Select @objtype = 'tf'
Select @suppress_use_stmt = 'n'
Select @suppress_drop_stmt = 'n'
Select @drop_only = 'n'
--**/


DECLARE
	 @miscprint			    nvarchar(500)
	,@query				    nvarchar(4000)
	,@caller_id			    nvarchar(10)
	,@save_dbname			    sysname
	,@save_colname			    sysname
	,@save_type_name		    sysname
	,@save_max_length		    smallint
	,@save_max_length_char		    nvarchar(20)
	,@save_collation_name		    sysname
	,@save_is_nullable		    nvarchar(10)
	,@save_indxname			    sysname
	,@save_type_desc		    nvarchar(60)
	,@save_index_id			    int
	,@save_data_space_name		    sysname
	,@save_PAD_INDEX		    nvarchar(10)
	,@save_STATISTICS_NORECOMPUTE	    nvarchar(10)
	,@save_IGNORE_DUP_KEY		    nvarchar(10)
	,@save_ALLOW_ROW_LOCKS		    nvarchar(10)
	,@save_ALLOW_PAGE_LOCKS		    nvarchar(10)
	,@save_filegroup		    sysname
	,@save_column_id		    int
	,@save_cnstname			    sysname
	,@save_definition		    nvarchar(max)
	,@save_indexkey_property	    char(1)
	,@save_minor_id			    int
	,@save_exprop_name		    sysname
	,@save_exprop_value		    sysname
	,@save_exprop_colname		    sysname
	,@save_seed_value		    sql_variant
	,@save_increment_value		    sql_variant
	,@save_is_system_named		    bit
	,@save_PKobject_id		    int
	,@save_precision		    tinyint
	,@save_scale			    tinyint
	,@save_type_tname		    sysname
	,@save_type_sname		    sysname
	,@save_system_type_id		    tinyint
	,@save_system_type_name		    sysname
	,@save_fgname			    sysname
	,@save_fgsize			   int
	,@save_dfname			    sysname
	,@save_dfsize			    int
	,@save_dfmax_size		    int
	,@save_dfgrowth			    int
	,@save_dfphysical_name		    nvarchar(260)
	,@save_fk_sname			    sysname
	,@save_fk_parent_object_id	    int
	,@save_fk_parent_object_name	    sysname
	,@save_fk_parent_object_sname	    sysname
	,@save_fk_parent_column_id	    int
	,@save_fk_parent_column_name	    sysname
	,@save_fk_referenced_object_id	    int
	,@save_fk_referenced_object_name    sysname
	,@save_fk_referenced_object_sname   sysname
	,@save_fk_referenced_column_id	    int
	,@save_fk_referenced_column_name    sysname
	,@save_fk_parent_names		    sysname
	,@save_fk_referenced_names	    sysname
	,@DefinedLength			    int
	,@BlankSpaceAdded		    int
	,@output_flag			    char(1)
	,@TEXTIMAGE_flag		    char(1)
	,@user_type_flag		    char(1)
	,@save_type			    char(2)
	,@G_O				    nvarchar(2)
	,@LFCR				    int --lengths of line feed carriage return
	,@cmd				    nvarchar(2000)
	,@LineId			    int
	,@SyscomText			    nvarchar(4000)
	,@save_number			    smallint
	,@save_colid			    smallint
	,@save_lineid			    int
	,@save_objid			    int
	,@charpos			    int	
	,@pos				    int
	,@error_count			    int

declare
	 @BasePos		int
	,@CurrentPos		int
	,@TextLength		int 
	,@AddOnLen		int
	,@Line			nvarchar(4000)
	,@commentText		nvarchar(4000)

	
declare 
	 @objid			int
	,@objname		sysname
	,@indid			smallint
	,@groupid		int
	,@indname		sysname
	,@groupname		sysname
	,@status		int
	,@keys			nvarchar(2126)
	,@ignore_dup_key	bit
	,@is_unique		bit
	,@is_hypothetical	bit
	,@is_primary_key	bit
	,@is_unique_key 	bit
	,@auto_created		bit
	,@no_recompute		bit
	,@i			int
	,@thiskey		nvarchar(131) -- 128+3


declare 
	 @cu11_name		sysname
	,@cu11_id		int
	,@cu11_type		char(2)
	,@cu11_schema_name	sysname


----------------  initial values  -------------------

/* NOTE: Length of @SyscomText is 4000 to replace the length of
** text column in syscomments. 
** Lengths on @Line, #CommentText Text column and
** value for @DefinedLength are all 500. These need to all have
** the same values. 
*/
       
Select @error_count	= 0
Select @G_O             = 'g' + 'o'
Select @DefinedLength   = 500
Select @BlankSpaceAdded = 0 /*Keeps track of blank spaces at end of lines. Note Len function ignores
							 trailing blank spaces*/
Select @output_flag	= 'n'

--  Create tables and table variables
declare @objinfo table	(oname		sysname
			,object_id	int
			,schema_name	sysname
			,type		char(2)
			,create_date	datetime
			)

CREATE TABLE #CommentText (LineId	int
			,Text	nvarchar(500)
			)


declare @tbl_Syscom table (SyscomText	nvarchar(4000)
			,number		smallint
			,colid		smallint
			)


declare @temp_com table (id		int
			,number		smallint
			,colid		smallint
			,status		smallint
			,encrypted	bit
			,text		nvarchar(4000)
			   )

declare @tbl_columns table (name		sysname
			,column_id		int
			,type_name		sysname
			,max_length		smallint
			,precision		tinyint
			,scale			tinyint
			,collation_name		sysname null
			,is_nullable		bit
			,is_ansi_padded		bit
			,is_rowguidcol		bit
			,is_identity		bit
			,is_computed		bit
			,is_filestream		bit
			,is_replicated		bit
			,is_non_sql_subscribed	bit
			,is_merge_published	bit
			,is_dts_replicated	bit
			,is_xml_document	bit
			,xml_collection_id	int
			,default_object_id	int
			,rule_object_id		int
			)

declare @tbl_indexes table (name		sysname
			,index_id		int
			,type			tinyint
			,type_desc		nvarchar(60)
			,is_unique		bit
			,data_space_id		int
			,data_space_name	sysname
			,ignore_dup_key		bit
			,is_primary_key		bit
			,is_unique_constraint	bit
			,fill_factor		tinyint
			,is_padded		bit
			,is_disabled		bit
			,is_hypothetical	bit
			,allow_row_locks	bit
			,allow_page_locks	bit
			,auto_created		bit
			,no_recompute		bit
			)

declare @tbl_cnst table (name			sysname
			,object_id		int
			,type			char(2)
			,parent_column_id	int
			,definition		nvarchar(max)
			)

declare @tbl_exprop table (class		tinyint
			,major_id		int
			,minor_id		int
			,colname		sysname
			,name			sysname
			,value			sql_variant
			)

declare @tbl_types table (tname			sysname
			, system_type_id	tinyint
			, sname			sysname
			, principal_id		int null
			, max_length		smallint
			, precision		tinyint
			, scale			tinyint
			, collation_name	sysname null
			, is_nullable		bit
			, is_user_defined	bit
			, is_assembly_type	bit
			, default_object_id	int
			, rule_object_id	int
			)

declare @tbl_filegroups table (fgname		sysname
			,dfname			sysname
			,size			int
			,max_size		int
			,growth			int
			,physical_name		nvarchar(260)
			,is_media_read_only	bit
			,is_read_only		bit
			,is_sparse		bit
			,is_percent_growth	bit
			,is_name_reserved	bit
			)

declare @tbl_forkeys table (fname		sysname
			,sname			sysname
			,parent_object_id	int
			,parent_column_id	int
			,referenced_object_id	int
			,referenced_column_id	int
			,is_disabled		bit
			,is_not_trusted		bit
			,is_system_named	bit
			)

--  Verify input parms
if not exists (select * from master.sys.sysdatabases where name = @dbname)
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @dbname' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

if (select name from master.sys.sysdatabases where name = @dbname) in ('master', 'model', 'msdb', 'tempdb')
   BEGIN
	Select @miscprint = 'DBA WARNING: This process is not allowed for a system database' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

if @objtype not in ('all', 'u', 'f', 'p', 'fn', 'v', 'vi', 'tr', 'tf', 'IF')
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @objtype.  Must be ''all'', ''u'', ''f'', ''p'', ''fn'', ''v'', ''vi'', ''tr'', ''tf'' or ''IF''.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END



If @suppress_drop_stmt = 'y' and @drop_only = 'y'
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parms for @suppress_drop_stmt and @drop_only.  Both parms cannot be ''y''.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END



/*********************************************************************
 *                Initialization
 ********************************************************************/

Select @save_dbname = rtrim(@DBname)

Select @cmd = 'SELECT c.id, c.number, c.colid, c.status, c.encrypted, c.text From ' + @save_dbname + '.sys.syscomments  c'

insert into @temp_com (id, number, colid, status, encrypted, text) exec (@cmd)
--select * from @temp_com


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/**************************************************************'
Select @miscprint = 'Generated SQL - DDL For Database [' + @save_dbname + ']'
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '**************************************************************/'


--------------------  Capture object info  -------------------
Select @cmd = 'SELECT o.name, o.object_id, s.name, o.type, o.create_date
   From ' + @save_dbname + '.sys.objects  o, ' + @save_dbname + '.sys.schemas  s ' + 
  'Where o.is_ms_shipped <> 1
     and o.schema_id = s.schema_id'
--    and o.name = ''test_tbl'''
--     and o.schema_id = s.schema_id and object_id = 2137058649'

insert into @objinfo (oname, object_id, schema_name, type, create_date) exec (@cmd)
delete from @objinfo where oname is null or oname = ''
--select * from @objinfo


If (@objtype = 'all' or @objtype = 'U')
 and (select count(*) from @objinfo where type = 'u') > 0
   begin
	select @caller_id = 's_u' -- single, type 'u'
	select @save_type = 'u'
	Select @output_flag = 'y'

	goto start_header

	s_u:

	If @objtype <> 'all'
	   begin
		goto label99
	   end
   end

If (@objtype = 'all' or @objtype = 'F')
 and (select count(*) from @objinfo where type = 'f') > 0
   begin
	select @caller_id = 's_f' -- single, type 'f'
	select @save_type = 'f'
	Select @output_flag = 'y'

	goto start_header

	s_f:

	If @objtype <> 'all'
	   begin
		goto label99
	   end
   end


If (@objtype = 'all' or @objtype = 'P')
 and (select count(*) from @objinfo where type = 'p') > 0
   begin
	select @caller_id = 's_p' -- single, type 'p'
	select @save_type = 'p'
	Select @output_flag = 'y'

	goto start_header

	s_p:

	If @objtype <> 'all'
	   begin
		goto label99
	   end
   end


If (@objtype = 'all' or @objtype = 'fn' or @objtype = 'tf' or @objtype = 'if')
 and (select count(*) from @objinfo where type in ('fn', 'tf', 'if')) > 0
   begin
	select @caller_id = 's_fn' -- single, type 'fn'
	select @save_type = 'fn'
	Select @output_flag = 'y'

	goto start_header

	s_fn:

	If @objtype <> 'all'
	   begin
		goto label99
	   end
   end


If (@objtype = 'all' or @objtype in ('v', 'vi'))
 and (select count(*) from @objinfo where type = 'v') > 0
   begin
	select @caller_id = 's_v' -- single, type 'v'
	select @save_type = 'v'
	Select @output_flag = 'y'

	goto start_header

	s_v:

	If @objtype <> 'all'
	   begin
		goto label99
	   end
   end


If (@objtype = 'all' or @objtype = 'tr')
 and (select count(*) from @objinfo where type = 'tr') > 0
   begin
	select @caller_id = 's_tr' -- single, type 'v'
	select @save_type = 'tr'
	Select @output_flag = 'y'

	goto start_header

	s_tr:

	If @objtype <> 'all'
	   begin
		goto label99
	   end
   end

goto label99


--  Header Section
start_header:
If @save_type = 'U'
   begin
	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD NON-DEFAULT FILEGROUPS FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '
	
	goto filegroups

	filegroups_return:


	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD USER_TYPES FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '
	
	goto user_types

	user_type_return:


	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD USER_TABLES FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '
	
	goto start01
   end

If @save_type = 'f'
   begin
	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD FORIEGN KEYS FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '

	goto start01
   end


If @save_type = 'p'
   begin
	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD STORED PROCEDURES FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '

	goto start01
   end


If @save_type = 'fn'
   begin
	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD FUNCTIONS FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '

	goto start01
   end


If @save_type = 'V'
   begin
	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD VIEWS FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '

	goto start01
   end


If @save_type = 'TR'
   begin
	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'ADD TRIGGERS FOR DATABASE [' + @save_dbname + ']'
	Print  @miscprint
	Print  '*********************************************************/'
	If @suppress_use_stmt <> 'y'
	   begin
		Print  ' '
		Select @miscprint = 'USE ' + @save_dbname
		Print  @miscprint  
		Print  @G_O
	   end
	Print  ' '

	goto start01
   end

-------------------------------------
--  START: Sub routine for filegroups
-------------------------------------
filegroups:
Select @cmd = 'SELECT fg.name
		    , df.name
		    , df.size
		    , df.max_size
		    , df.growth
		    , df.physical_name
		    , df.is_media_read_only
		    , df.is_read_only
		    , df.is_sparse
		    , df.is_percent_growth
		    , df.is_name_reserved
   From ' + @save_dbname + '.sys.filegroups  fg , ' + @save_dbname + '.sys.database_files  df ' + 
  'Where fg.data_space_id = df.data_space_id
     and fg.type = ''FG''
     and FG.is_default <> 1'

delete from @tbl_filegroups

insert into @tbl_filegroups (fgname
		    ,dfname
		    ,size
		    ,max_size
		    ,growth
		    ,physical_name
		    ,is_media_read_only
		    ,is_read_only
		    ,is_sparse
		    ,is_percent_growth
		    ,is_name_reserved
			) exec (@cmd)

--select * from @tbl_filegroups


--  Add user data types if any exist
If (select count(*) from @tbl_filegroups) > 0
   begin
	start_filegroups:
	Select @save_fgname = (select top 1 fgname from @tbl_filegroups)
	Select @save_dfname = (select dfname from @tbl_filegroups where fgname = @save_fgname)
	Select @save_dfsize = (select size from @tbl_filegroups where fgname = @save_fgname)
	Select @save_dfmax_size = (select max_size from @tbl_filegroups where fgname = @save_fgname)
	Select @save_dfgrowth = (select growth from @tbl_filegroups where fgname = @save_fgname)
	Select @save_dfphysical_name = (select physical_name from @tbl_filegroups where fgname = @save_fgname)

	--  Print header
	select @miscprint = '------------------------------------------------------------------------------------------------------- '
	print  @miscprint
	select @miscprint = '-- ' + @save_fgname
	print  @miscprint
	select @miscprint = '------------------------------------------------------------------------------------------------------- '
	print  @miscprint

	--  Start to format column output
	select @miscprint = 'If not exists (select 1 from sys.filegroups where name = ''' + @save_fgname + ''')'
	Print @miscprint
	select @miscprint = '   begin'
	Print @miscprint
	select @miscprint = '      ALTER DATABASE [' + @save_dbname + ']'
	Print @miscprint
	select @miscprint = '         ADD FILEGROUP ' + @save_fgname
	Print @miscprint
	select @miscprint = '   end'
	Print @miscprint
	Print 'GO'
	Print ''

	select @miscprint = 'If not exists (select 1 from sys.database_files where name = ''' + @save_dfname + ''')'
	Print @miscprint
	select @miscprint = '   begin'
	Print @miscprint
	select @miscprint = '      ALTER DATABASE [' + @save_dbname + ']'
	Print @miscprint
	select @miscprint = '         ADD FILE ('
	Print @miscprint
	select @miscprint = '            NAME = ' + @save_dfname 
	Print @miscprint
	select @miscprint = '           ,FILENAME = ''' + @save_dfphysical_name + ''''
	Print @miscprint
	If @save_dfsize < 128
	   begin
		select @miscprint = '           ,SIZE = 1MB'
		Print @miscprint
	  end
	Else
	   begin
		select @miscprint = '           ,SIZE = ' + convert(nvarchar(12), (@save_dfsize/128)) + 'MB'
		Print @miscprint
	  end

	If @save_dfmax_size < 128
	   begin
		select @miscprint = '           ,MAXSIZE = 1MB'
		Print @miscprint
	   end
	Else
	   begin
		select @miscprint = '           ,MAXSIZE = ' + convert(nvarchar(12), (@save_dfmax_size/128)) + 'MB'
		Print @miscprint
	   end

	If (select is_percent_growth from @tbl_filegroups where fgname = @save_fgname) = 1
	   begin
		select @miscprint = '           ,FILEGROWTH = ' + convert(nvarchar(12), @save_dfgrowth) + '%'
		Print @miscprint
	   end
	Else If @save_dfgrowth < 128
	   begin
		select @miscprint = '           ,FILEGROWTH = 1MB'
		Print @miscprint
	   end
	Else
	   begin
		select @miscprint = '           ,FILEGROWTH = ' + convert(nvarchar(12), (@save_dfgrowth/128)) + 'MB'
		Print @miscprint
	   end

	select @miscprint = '           )'
	Print @miscprint
	select @miscprint = '        TO FILEGROUP ' + @save_fgname
	Print @miscprint
	select @miscprint = '   end'
	Print @miscprint
	Print 'GO'
	Print ''

	--  check for more user types
	Delete from @tbl_filegroups where fgname = @save_fgname
	If (select count(*) from @tbl_filegroups) > 0
	   begin
		goto start_filegroups
	   end
   end
Else
   begin
	Print '--  None Found'
	Print ''
   end

goto filegroups_return
-------------------------------------
--  END: Sub routine for filegroups
-------------------------------------




-------------------------------------
--  START: Sub routine for user types
-------------------------------------
user_types:
Select @cmd = 'SELECT t.name
		    , t.system_type_id
		    , s.name
		    , t.principal_id
		    , t.max_length
		    , t.precision
		    , t.scale
		    , t.collation_name
		    , t.is_nullable
		    , t.is_user_defined
		    , t.is_assembly_type
		    , t.default_object_id
		    , t.rule_object_id
   From ' + @save_dbname + '.sys.types  t , ' + @save_dbname + '.sys.schemas  s ' + 
  'Where t.schema_id = s.schema_id
     and t.is_user_defined = 1'

delete from @tbl_types

insert into @tbl_types (tname
		    , system_type_id
		    , sname
		    , principal_id
		    , max_length
		    , precision
		    , scale
		    , collation_name
		    , is_nullable
		    , is_user_defined
		    , is_assembly_type
		    , default_object_id
		    , rule_object_id
			) exec (@cmd)

--select * from @tbl_types


--  Add user data types if any exist
If (select count(*) from @tbl_types) > 0
   begin
	start_user_types:
	Select @save_type_tname = (select top 1 tname from @tbl_types)
	Select @save_type_sname = (select sname from @tbl_types where tname = @save_type_tname)
	Select @save_system_type_id = (select system_type_id from @tbl_types where tname = @save_type_tname)
	Select @cmd = 'use [' + @save_dbname + '] select @save_system_type_name = (select name from sys.types where system_type_id = ' + convert(nvarchar(10), @save_system_type_id ) + ' and is_user_defined = 0)'
	EXEC sp_executesql @cmd, N'@save_system_type_name sysname output', @save_system_type_name output

	--  Start to format column output
	select @miscprint = 'CREATE TYPE [' + @save_type_sname + '] [' + @save_type_tname + '] FROM ' + @save_system_type_name

	--  add length data to column line output
	If @save_system_type_name in ('nvarchar', 'nchar', 'varchar', 'char', 'binary', 'varbinary')
	   begin
		Select @save_max_length_char = (select convert(nvarchar(10), max_length) from @tbl_types where tname = @save_type_tname)
		select @miscprint = @miscprint + '(' + @save_max_length_char + ')'
	   end

	If @save_system_type_name in ('decimal', 'numeric')
	   begin
		Select @save_precision = (select precision from @tbl_types where tname = @save_type_tname) 
		Select @save_scale = (select scale from @tbl_types where tname = @save_type_tname)
		select @miscprint = @miscprint + '(' + convert(nvarchar(5), @save_precision) + ', ' + convert(nvarchar(5), @save_scale) + ')'
	   end

	If (select is_nullable from @tbl_types where tname = @save_type_tname) = 1
	   begin
		select @miscprint = @miscprint + ' NULL ;'
	   end
	Else
	   begin
		select @miscprint = @miscprint + ' NOT NULL ;'
	   end


	Print @miscprint
	Print 'GO'
	Print ''

	--  check for more user types
	Delete from @tbl_types where tname = @save_type_tname
	If (select count(*) from @tbl_types) > 0
	   begin
		goto start_user_types
	   end
   end
Else
   begin
	Print '--  None Found'
	Print ''
   end

goto user_type_return
-------------------------------------
--  END: Sub routine for user types
-------------------------------------






-------------------------------------------------------------------
--  START: Sub routine for tables, sprocs, functions, views, triggers
-------------------------------------------------------------------
start01:

If (select count(*) from @objinfo where type = @save_type) > 0
   begin
	start_objinfo:

	-------------  Save the top 1 object id  -------------
	If @save_type = 'fn'
	   begin
		Select @cu11_id = (select top 1 object_id from @objinfo where type in ('fn', 'tf', 'if') order by create_date)
	   end
	Else
	   begin
		Select @cu11_id = (select top 1 object_id from @objinfo where type = @save_type order by create_date)
	   end

	Select @cu11_type = (select type from @objinfo where object_id = @cu11_id) 
	Select @cu11_name = (select oname from @objinfo where object_id = @cu11_id) 
	Select @cu11_schema_name = (select schema_name from @objinfo where object_id = @cu11_id) 
	Select @objname = '[' + @cu11_schema_name + '].[' + @cu11_name + ']'
	Select @TEXTIMAGE_flag = 'n'


	If @save_type = 'u' --tables 
	   begin
		--  Now start on the tables
		Select @cmd = 'SELECT c.name
					, c.column_id
					, t.name
					, c.max_length
					, c.precision
					, c.scale
					, c.collation_name
					, c.is_nullable
					, c.is_ansi_padded
					, c.is_rowguidcol
					, c.is_identity
					, c.is_computed
					, c.is_filestream
					, c.is_replicated
					, c.is_non_sql_subscribed
					, c.is_merge_published
					, c.is_dts_replicated
					, c.is_xml_document
					, c.xml_collection_id
					, c.default_object_id
					, c.rule_object_id
		   From ' + @save_dbname + '.sys.columns  c, ' + @save_dbname + '.sys.types  t ' + 
		  'Where c.system_type_id = t.system_type_id
		     and c.user_type_id = t.user_type_id
		     and c.object_id = '+ convert(nvarchar(20), @cu11_id)

		delete from @tbl_columns

		insert into @tbl_columns (name
					, column_id
					, type_name
					, max_length
					, precision
					, scale
					, collation_name
					, is_nullable
					, is_ansi_padded
					, is_rowguidcol
					, is_identity
					, is_computed
					, is_filestream
					, is_replicated
					, is_non_sql_subscribed
					, is_merge_published
					, is_dts_replicated
					, is_xml_document
					, xml_collection_id
					, default_object_id
					, rule_object_id
					) exec (@cmd)

		--select * from @tbl_columns




		Select @cmd = 'SELECT c.name
				    , c.object_id
				    , c.type
				    , c.parent_column_id
				    , c.definition
		   From ' + @save_dbname + '.sys.default_constraints  c ' + 
		  'Where c.type in (''d'', ''c'')
		     and c.parent_object_id = '+ convert(nvarchar(20), @cu11_id)

		delete from @tbl_cnst

		insert into @tbl_cnst (name
				    ,object_id
				    ,type
				    ,parent_column_id
				    ,definition
					) exec (@cmd)

		--select * from @tbl_cnst


		Select @cmd = 'SELECT ep.class
				    , ep.major_id
				    , ep.minor_id
				    , c.name
				    , ep.name
				    , ep.value
		   From ' + @save_dbname + '.sys.extended_properties  ep , ' + @save_dbname + '.sys.columns  c ' + 
		  'Where ep.minor_id = c.column_id
		     and ep.major_id = ' + convert(nvarchar(20), @cu11_id) + '
		     and c.object_id = '+ convert(nvarchar(20), @cu11_id)

		delete from @tbl_exprop

		insert into @tbl_exprop (class
				    ,major_id
				    ,minor_id
				    ,colname
				    ,name
				    ,value
					) exec (@cmd)

		--select * from @tbl_exprop


		If (select count(*) from @tbl_columns) = 0
		   begin
			goto label89
		   end

		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint
		select @miscprint = '-- ' + @cu11_name
		print  @miscprint
		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint

		If @suppress_drop_stmt = 'n'
		   begin
			select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsTable'') = 1)'
			print  @miscprint
			select @miscprint = 'drop table [' + @cu11_schema_name + '].[' + @cu11_name + ']'
			print  @miscprint
			print  'GO'
		   end

		If @drop_only = 'y'
		   begin
			goto label89
		   end

		--  set ANSI_NULLS option
		Select @cmd = 'use [' + @save_dbname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']''), N''IsAnsiNullsOn'')'
		EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
		If @save_objid = 1
		   begin
			select @miscprint = 'SET ANSI_NULLS ON'
			print  @miscprint
			print  'GO'
		   end
		Else
		   begin
			select @miscprint = 'SET ANSI_NULLS OFF'
			print  @miscprint
			print  'GO'
		   end

		--  set QUOTED_IDENTIFIER option
		Select @cmd = 'use [' + @save_dbname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']''), N''IsQuotedIdentOn'')'
		EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
		If @save_objid = 1
		   begin
			select @miscprint = 'SET QUOTED_IDENTIFIER ON'
			print  @miscprint
			print  'GO'
		   end
		Else
		   begin
			select @miscprint = 'SET QUOTED_IDENTIFIER OFF'
			print  @miscprint
			print  'GO'
		   end


		select @miscprint = 'CREATE TABLE [' + @cu11_schema_name + '].[' + @cu11_name + ']('
		print  @miscprint
		

		--  Start the table column process
		start_table_col:

		Select @save_colname = (select top 1 name from @tbl_columns order by column_id)
		Select @save_type_name = (select type_name from @tbl_columns where name = @save_colname)
		Select @save_max_length = (select max_length from @tbl_columns where name = @save_colname)
		Select @save_column_id = (select column_id from @tbl_columns where name = @save_colname)
		If @save_max_length = -1
		   begin
			Select @save_max_length_char = 'max'
		   end
		Else If @save_type_name in ('nvarchar', 'nchar')
		   begin
			Select @save_max_length_char = convert(nvarchar(20), @save_max_length / 2)
		   end
		Else
		   begin
			Select @save_max_length_char = convert(nvarchar(20), @save_max_length)
		   end


		--  Check for large columns
		If @save_type_name in ('text', 'ntext', 'image', 'xml')
		    or (@save_type_name in ('varchar', 'nvarchar', 'varbinary') and @save_max_length_char = 'max')
		   begin
			Select @TEXTIMAGE_flag = 'y'
		   end


		--  Start to format column output
		select @miscprint = '        [' + @save_colname + '] [' + @save_type_name + ']'

		--  add length data to column line output
		If @save_type_name in ('nvarchar', 'nchar', 'varchar', 'char', 'binary', 'varbinary')
		   begin
			select @miscprint = @miscprint + '(' + @save_max_length_char + ')'
		   end

		If @save_type_name in ('decimal', 'numeric')
		   begin
			Select @save_precision = (select precision from @tbl_columns where name = @save_colname) 
			Select @save_scale = (select scale from @tbl_columns where name = @save_colname)
			select @miscprint = @miscprint + '(' + convert(nvarchar(5), @save_precision) + ', ' + convert(nvarchar(5), @save_scale) + ')'
		   end


		--  Check for (and set) identity
		If (select is_identity from @tbl_columns where name = @save_colname) = 1
		   begin
			Select @cmd = 'use [' + @save_dbname + '] select @save_seed_value = (select seed_value from sys.identity_columns where object_id = ' + convert(nvarchar(20), @cu11_id) 
								+ ' and column_id = ' + convert(nvarchar(10), @save_column_id) + ')'
			EXEC sp_executesql @cmd, N'@save_seed_value sql_variant output', @save_seed_value output

			Select @cmd = 'use [' + @save_dbname + '] select @save_increment_value = (select increment_value from sys.identity_columns where object_id = ' + convert(nvarchar(20), @cu11_id) 
								+ ' and column_id = ' + convert(nvarchar(10), @save_column_id) + ')'
			EXEC sp_executesql @cmd, N'@save_increment_value sql_variant output', @save_increment_value output

			If @save_seed_value is not null and  @save_increment_value is not null
			   begin
				Select @miscprint = @miscprint + ' IDENTITY(' + convert(nvarchar(10), @save_seed_value) + ',' + convert(nvarchar(10), @save_increment_value) + ')' 
			   end 
		   end

		--  Set collation
		Select @save_collation_name = (select collation_name from @tbl_columns where name = @save_colname)
		If @save_collation_name is not null
		   begin
			Select @miscprint = @miscprint + ' COLLATE ' + @save_collation_name
		   end

		--  Tack on NULL or NOT NULL
		Select @save_is_nullable = case when ((select is_nullable from @tbl_columns where name = @save_colname) = 1) then 'NULL' else 'NOT NULL' end
		Select @miscprint = @miscprint + ' ' + @save_is_nullable


		--  Add default constraints
		If exists (select 1 from @tbl_cnst where type = 'd' and parent_column_id = @save_column_id)
		   begin
			Select @save_cnstname = (select name from @tbl_cnst where type = 'd' and parent_column_id = @save_column_id)
			Select @save_definition = (select definition from @tbl_cnst where type = 'd' and parent_column_id = @save_column_id)

			Select @miscprint = @miscprint + ' CONSTRAINT [' + rtrim(@save_cnstname) + '] DEFAULT ' + rtrim(@save_definition)
		   end

		If (select count(*) from @tbl_columns) > 1
		   begin
			Select @miscprint = @miscprint + ','
		   end

		--  Print the column line output
		print  @miscprint

		--  check for more columns
		Delete from @tbl_columns where name = @save_colname
		If (select count(*) from @tbl_columns) > 0
		   begin
			goto start_table_col
		   end


		--  Now create the primary key or UNIQUE CONSTRAINT if one exists
		Select @save_PKobject_id = null
		If (select count(*) from @tbl_indexes) > 0
		   begin
			Select @save_indxname = (select top 1 name from @tbl_indexes order by index_id)	
			Select @cmd = 'use [' + @save_dbname + '] Select @save_PKobject_id = (select object_id from sys.objects where name = ''' 
					+ @save_indxname + ''' and type in (''pk'', ''uq'') and parent_object_id = ' + convert(nvarchar(20), @cu11_id) + ')'
			EXEC sp_executesql @cmd, N'@save_PKobject_id int output', @save_PKobject_id output
		   end

		If @save_PKobject_id is not null
		   begin
			Select @save_index_id = (select top 1 index_id from @tbl_indexes where name = @save_indxname)
			Select @save_type_desc = (select top 1 type_desc from @tbl_indexes where name = @save_indxname)
			Select @save_data_space_name = (select top 1 data_space_name from @tbl_indexes where name = @save_indxname)

			--  start building string
			select @miscprint = ' ,'

			--  Check to see if the index is system named
			Select @cmd = 'use [' + @save_dbname + '] Select @save_is_system_named = (select is_system_named from sys.key_constraints where name = ''' + @save_indxname + ''')'
			EXEC sp_executesql @cmd, N'@save_is_system_named bit output', @save_is_system_named output

			If @save_is_system_named <> 1
			   begin
				select @miscprint = @miscprint + 'CONSTRAINT [' + @save_indxname + ']'
			   end

			--  Now check to see if this is a primary key
			If (select is_primary_key from @tbl_indexes where name = @save_indxname) = 1
			   begin
				select @miscprint = @miscprint + ' PRIMARY KEY'
			   end

			--  Now check to see if this is a unique key
			If (select is_unique_constraint from @tbl_indexes where name = @save_indxname) = 1
			   begin
				select @miscprint = @miscprint + ' UNIQUE'
			   end

			select @miscprint = @miscprint + ' ' + @save_type_desc
			print  @miscprint

			select @miscprint = '('
			print  @miscprint

			-- get the index keys
			Select @cmd = 'use [' + @save_dbname + '] Select @keys = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', 1)'
			EXEC sp_executesql @cmd, N'@keys nvarchar(2126) output', @keys output

			Select @cmd = 'use [' + @save_dbname + '] Select @save_indexkey_property = indexkey_property(' + convert(nvarchar(20), @cu11_id) + ', ' + convert(nvarchar(20), @save_index_id) + ', 1, ''isdescending'')'
			EXEC sp_executesql @cmd, N'@save_indexkey_property char(1) output', @save_indexkey_property output

			If @save_indexkey_property = 1
			   begin
				select @miscprint = '        [' + @keys + '] DESC'
				print  @miscprint
			   end
			Else
			   begin
				select @miscprint = '        [' + @keys + '] ASC'
				print  @miscprint
			   end

			Select @i = 2
			Select @cmd = 'use [' + @save_dbname + '] Select @thiskey = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ')'
			EXEC sp_executesql @cmd, N'@thiskey nvarchar(131) output', @thiskey output

			while (@thiskey is not null )
			   begin
				Select @keys = @thiskey

				Select @cmd = 'use [' + @save_dbname + '] Select @save_indexkey_property = indexkey_property(' + convert(nvarchar(20), @cu11_id) + ', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ', ''isdescending'')'
				EXEC sp_executesql @cmd, N'@save_indexkey_property char(1) output', @save_indexkey_property output

				If @save_indexkey_property = 1
				   begin
					select @miscprint = '       ,[' + @keys + '] DESC'
					print  @miscprint
				   end
				Else
				   begin
					select @miscprint = '       ,[' + @keys + '] ASC'
					print  @miscprint
				   end

				Select @i = @i + 1
				Select @cmd = 'use [' + @save_dbname + '] Select @thiskey = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ')'
				EXEC sp_executesql @cmd, N'@thiskey nvarchar(131) output', @thiskey output
			   end

			--  Now set the index options
			Select @save_PAD_INDEX = case when ((select is_padded from @tbl_indexes where name = @save_indxname) = 1) then 'ON' else 'OFF' end 
			Select @save_STATISTICS_NORECOMPUTE = case when ((select no_recompute from @tbl_indexes where name = @save_indxname) = 1) then 'ON' else 'OFF' end 
			Select @save_IGNORE_DUP_KEY = case when ((select ignore_dup_key from @tbl_indexes where name = @save_indxname) = 1) then 'ON' else 'OFF' end 
			Select @save_ALLOW_ROW_LOCKS = case when ((select allow_row_locks from @tbl_indexes where name = @save_indxname) = 1) then 'ON' else 'OFF' end 
			Select @save_ALLOW_PAGE_LOCKS = case when ((select allow_page_locks from @tbl_indexes where name = @save_indxname) = 1) then 'ON' else 'OFF' end 

			select @miscprint = ')WITH (PAD_INDEX = ' + @save_PAD_INDEX + ', STATISTICS_NORECOMPUTE = ' 
							+ @save_STATISTICS_NORECOMPUTE + ', IGNORE_DUP_KEY = ' 
							+ @save_IGNORE_DUP_KEY + ', ALLOW_ROW_LOCKS = ' 
							+ @save_ALLOW_ROW_LOCKS + ', ALLOW_PAGE_LOCKS = ' 
							+ @save_ALLOW_PAGE_LOCKS + ') ON [' + @save_data_space_name + ']'
			print  @miscprint

			--  delete this index from @tbl_indexes
			delete from @tbl_indexes where name = @save_indxname

		  end


		--  now set the filegroups
		Select @cmd = 'use [' + @save_dbname + '] select @save_filegroup = (select d.name 
										    from sys.data_spaces d 
										    where d.data_space_id = (select i.data_space_id 
													    from sys.indexes i
													    where i.object_id = ' + convert(nvarchar(20), @cu11_id) + '
													    and i.index_id < 2)
										    )'
		EXEC sp_executesql @cmd, N'@save_filegroup sysname output', @save_filegroup output

		select @miscprint = ') ON [' + @save_filegroup + ']' 

		If @TEXTIMAGE_flag = 'y'
		   begin
			Select @cmd = 'use [' + @save_dbname + '] select @save_filegroup = (select d.name 
 											    from sys.data_spaces d, sys.tables t 
											    where t.object_id = ' + convert(nvarchar(20), @cu11_id) + '
											      and d.data_space_id = t.lob_data_space_id
											    )'
			EXEC sp_executesql @cmd, N'@save_filegroup sysname output', @save_filegroup output

			select @miscprint = @miscprint + ' TEXTIMAGE_ON [' + @save_filegroup + ']' 
		   end

		print  @miscprint

		print  'GO'

		--  check to see if there are more indexes to process
		If (select count(*) from @tbl_indexes) > 0
		   begin
			start_indexes:
			Select @save_index_id = (select top 1 index_id from @tbl_indexes order by index_id)
			Select @save_indxname = (select top 1 name from @tbl_indexes where index_id = @save_index_id)
			Select @save_type_desc = (select top 1 type_desc from @tbl_indexes where index_id = @save_index_id)
			Select @save_data_space_name = (select top 1 data_space_name from @tbl_indexes where index_id = @save_index_id)

			--  Now check to see if this is a unique index
			If (select is_unique from @tbl_indexes where index_id = @save_index_id) = 1
			   begin
				select @save_type_desc = 'UNIQUE ' + @save_type_desc
			   end

			select @miscprint = 'CREATE ' +  rtrim(@save_type_desc) + ' INDEX [' + rtrim(@save_indxname) + '] ON ' + @objname
			print  @miscprint
			select @miscprint = '('
			print  @miscprint

			-- get the index keys
			Select @cmd = 'use [' + @save_dbname + '] Select @keys = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', 1)'
			EXEC sp_executesql @cmd, N'@keys nvarchar(2126) output', @keys output

			Select @cmd = 'use [' + @save_dbname + '] Select @save_indexkey_property = indexkey_property(' + convert(nvarchar(20), @cu11_id) + ', ' + convert(nvarchar(20), @save_index_id) + ', 1, ''isdescending'')'
			EXEC sp_executesql @cmd, N'@save_indexkey_property char(1) output', @save_indexkey_property output

			If @save_indexkey_property = 1
			   begin
				select @miscprint = '        [' + @keys + '] DESC'
				print  @miscprint
			   end
			Else
			   begin
				select @miscprint = '        [' + @keys + '] ASC'
				print  @miscprint
			   end

			Select @i = 2
			Select @cmd = 'use [' + @save_dbname + '] Select @thiskey = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ')'
			EXEC sp_executesql @cmd, N'@thiskey nvarchar(131) output', @thiskey output

			while (@thiskey is not null )
			   begin
				Select @keys = @thiskey

				Select @cmd = 'use [' + @save_dbname + '] Select @save_indexkey_property = indexkey_property(' + convert(nvarchar(20), @cu11_id) + ', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ', ''isdescending'')'
				EXEC sp_executesql @cmd, N'@save_indexkey_property char(1) output', @save_indexkey_property output

				If @save_indexkey_property = 1
				   begin
					select @miscprint = '       ,[' + @keys + '] DESC'
					print  @miscprint
				   end
				Else
				   begin
					select @miscprint = '       ,[' + @keys + '] ASC'
					print  @miscprint
				   end

				Select @i = @i + 1
				Select @cmd = 'use [' + @save_dbname + '] Select @thiskey = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ')'
				EXEC sp_executesql @cmd, N'@thiskey nvarchar(131) output', @thiskey output
			   end

			--  Now set the index options
			Select @save_PAD_INDEX = case when ((select is_padded from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
			Select @save_STATISTICS_NORECOMPUTE = case when ((select no_recompute from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
			Select @save_IGNORE_DUP_KEY = case when ((select ignore_dup_key from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
			Select @save_ALLOW_ROW_LOCKS = case when ((select allow_row_locks from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
			Select @save_ALLOW_PAGE_LOCKS = case when ((select allow_page_locks from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 


			select @miscprint = ')WITH (PAD_INDEX = ' + @save_PAD_INDEX + ', STATISTICS_NORECOMPUTE = ' 
							+ @save_STATISTICS_NORECOMPUTE + ', IGNORE_DUP_KEY = ' 
							+ @save_IGNORE_DUP_KEY + ', ALLOW_ROW_LOCKS = ' 
							+ @save_ALLOW_ROW_LOCKS + ', ALLOW_PAGE_LOCKS = ' 
							+ @save_ALLOW_PAGE_LOCKS + ') ON [' + @save_data_space_name + ']'
			print  @miscprint
			print  'GO'

			delete from @tbl_indexes where index_id = @save_index_id
			If (select count(*) from @tbl_indexes) > 0
			   begin
				goto start_indexes
			   end
		  end


		--  Now check for extended properties
		If (select count(*) from @tbl_exprop where class = 1) > 0
		   begin
			Print ''
			start_exprop:
			Select @save_minor_id = (select top 1 minor_id from @tbl_exprop where class = 1 order by minor_id)
			Select @save_exprop_name = (select name from @tbl_exprop where class = 1 and minor_id = @save_minor_id)
			Select @save_exprop_value = (select convert(sysname,value) from @tbl_exprop where class = 1 and minor_id = @save_minor_id)
			Select @save_exprop_colname = (select colname from @tbl_exprop where class = 1 and minor_id = @save_minor_id)

			select @miscprint = 'EXEC sys.sp_addextendedproperty @name=N''' + @save_exprop_name + ''', @value=N''' + @save_exprop_value 
						+ ''', @level0type=N''SCHEMA'', @level0name=N''' + @cu11_schema_name 
						+ ''', @level1type=N''TABLE'', @level1name=N''' + @cu11_name 
						+ ''', @level2type=N''COLUMN'', @level2name=N''' + @save_exprop_colname + ''''
			print  @miscprint
			print  'GO'


			Delete from @tbl_exprop where class = 1 and minor_id = @save_minor_id
			If (select count(*) from @tbl_exprop where class = 1) > 0
			   begin
				goto start_exprop
			   end

		   end

		print ''

		--  End type='u' section (tables)
		goto label89

	   end




	-----------------------------------------------------------
	--  start ForeignKeys
	-----------------------------------------------------------
	If @save_type = ('f') --foreignKeys 
	   begin
		--  Here we start the foreign key process
		Select @cmd = 'SELECT f.name
					, s.name
					, f.parent_object_id
					, fc.parent_column_id
					, fc.referenced_object_id
					, fc.referenced_column_id
					, f.is_disabled
					, f.is_not_trusted
					, f.is_system_named
		   From ' + @save_dbname + '.sys.foreign_keys  f, ' 
			  + @save_dbname + '.sys.foreign_key_columns  fc, ' 
			  + @save_dbname + '.sys.schemas s ' +  
		  'Where f.object_id = fc.constraint_object_id
		     and f.schema_id = s.schema_id
		     and f.is_ms_shipped = 0
		     and f.is_disabled = 0
		     and f.object_id = '+ convert(nvarchar(20), @cu11_id)

		delete from @tbl_forkeys

		insert into @tbl_forkeys (fname
					,sname
					,parent_object_id
					,parent_column_id
					,referenced_object_id
					,referenced_column_id
					,is_disabled
					,is_not_trusted
					,is_system_named
					) exec (@cmd)

		--select * from @tbl_forkeys


		If (select count(*) from @tbl_forkeys) = 0
		   begin
			goto label89
		   end

		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint
		select @miscprint = '-- ' + @cu11_name
		print  @miscprint
		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint

		Select @save_fk_sname = (select top 1 sname from @tbl_forkeys where fname = @cu11_name)
		Select @save_fk_parent_object_id = (select top 1 parent_object_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname)
		Select @save_fk_parent_column_id = (select top 1 parent_column_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname and parent_object_id = @save_fk_parent_object_id)
		Select @save_fk_referenced_object_id = (select referenced_object_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname and parent_object_id = @save_fk_parent_object_id and parent_column_id = @save_fk_parent_column_id)
		Select @save_fk_referenced_column_id = (select referenced_column_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname and parent_object_id = @save_fk_parent_object_id and parent_column_id = @save_fk_parent_column_id)

		Select @cmd = 'use [' + @save_dbname + '] select @save_fk_parent_object_name = (select name from sys.objects where object_id = ' + convert(nvarchar(20), @save_fk_parent_object_id) + ')'
		EXEC sp_executesql @cmd, N'@save_fk_parent_object_name sysname output', @save_fk_parent_object_name output

		Select @cmd = 'use [' + @save_dbname + '] select @save_fk_parent_object_sname = (select s.name from sys.schemas s, sys.objects o where s.schema_id = o.schema_id and o.object_id = ' + convert(nvarchar(20), @save_fk_parent_object_id) + ')'
		EXEC sp_executesql @cmd, N'@save_fk_parent_object_sname sysname output', @save_fk_parent_object_sname output

		Select @cmd = 'use [' + @save_dbname + '] select @save_fk_parent_column_name = (select name from sys.columns where object_id = ' + convert(nvarchar(20), @save_fk_parent_object_id) + ' and column_id = ' + convert(nvarchar(20), @save_fk_parent_column_id) + ')'
		EXEC sp_executesql @cmd, N'@save_fk_parent_column_name sysname output', @save_fk_parent_column_name output


		Select @cmd = 'use [' + @save_dbname + '] select @save_fk_referenced_object_name = (select name from sys.objects where object_id = ' + convert(nvarchar(20), @save_fk_referenced_object_id) + ')'
		EXEC sp_executesql @cmd, N'@save_fk_referenced_object_name sysname output', @save_fk_referenced_object_name output

		Select @cmd = 'use [' + @save_dbname + '] select @save_fk_referenced_object_sname = (select s.name from sys.schemas s, sys.objects o where s.schema_id = o.schema_id and o.object_id = ' + convert(nvarchar(20), @save_fk_referenced_object_id) + ')'
		EXEC sp_executesql @cmd, N'@save_fk_referenced_object_sname sysname output', @save_fk_referenced_object_sname output

		Select @cmd = 'use [' + @save_dbname + '] select @save_fk_referenced_column_name = (select name from sys.columns where object_id = ' + convert(nvarchar(20), @save_fk_referenced_object_id) + ' and column_id = ' + convert(nvarchar(20), @save_fk_referenced_column_id) + ')'
		EXEC sp_executesql @cmd, N'@save_fk_referenced_column_name sysname output', @save_fk_referenced_column_name output

		If @suppress_drop_stmt = 'n'
		   begin
			select @miscprint = 'if exists (select * from sys.foreign_keys where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and parent_object_id = OBJECT_ID(N''[' + @save_fk_parent_object_sname + '].[' + @save_fk_parent_object_name + ']''))'
			print  @miscprint
			select @miscprint = 'ALTER TABLE [' + @save_fk_parent_object_sname + '].[' + @save_fk_parent_object_name + '] DROP CONSTRAINT [' + @cu11_name + ']'
			print  @miscprint
			print  'GO'
		   end

		If @drop_only = 'y'
		   begin
			goto label89
		   end


		Select @save_fk_parent_names = '[' + @save_fk_parent_column_name + ']'
		Select @save_fk_referenced_names = '[' + @save_fk_referenced_column_name + ']'
		fk_start01:
		If (select count(*) from @tbl_forkeys where sname = @save_fk_sname and fname = @cu11_name) > 1
		   begin
			Delete from @tbl_forkeys where sname = @save_fk_sname and fname = @cu11_name and parent_object_id = @save_fk_parent_object_id and parent_column_id = @save_fk_parent_column_id and referenced_object_id = @save_fk_referenced_object_id 

			Select @save_fk_parent_object_id = (select top 1 parent_object_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname)
			Select @save_fk_parent_column_id = (select top 1 parent_column_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname and parent_object_id = @save_fk_parent_object_id)
			Select @save_fk_referenced_object_id = (select referenced_object_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname and parent_object_id = @save_fk_parent_object_id and parent_column_id = @save_fk_parent_column_id)
			Select @save_fk_referenced_column_id = (select referenced_column_id from @tbl_forkeys where fname = @cu11_name and sname = @save_fk_sname and parent_object_id = @save_fk_parent_object_id and parent_column_id = @save_fk_parent_column_id)

			Select @cmd = 'use [' + @save_dbname + '] select @save_fk_parent_object_name = (select name from sys.objects where object_id = ' + convert(nvarchar(20), @save_fk_parent_object_id) + ')'
			EXEC sp_executesql @cmd, N'@save_fk_parent_object_name sysname output', @save_fk_parent_object_name output

			Select @cmd = 'use [' + @save_dbname + '] select @save_fk_parent_object_sname = (select s.name from sys.schemas s, sys.objects o where s.schema_id = o.schema_id and o.object_id = ' + convert(nvarchar(20), @save_fk_parent_object_id) + ')'
			EXEC sp_executesql @cmd, N'@save_fk_parent_object_sname sysname output', @save_fk_parent_object_sname output

			Select @cmd = 'use [' + @save_dbname + '] select @save_fk_parent_column_name = (select name from sys.columns where object_id = ' + convert(nvarchar(20), @save_fk_parent_object_id) + ' and column_id = ' + convert(nvarchar(20), @save_fk_parent_column_id) + ')'
			EXEC sp_executesql @cmd, N'@save_fk_parent_column_name sysname output', @save_fk_parent_column_name output

			Select @cmd = 'use [' + @save_dbname + '] select @save_fk_referenced_object_name = (select name from sys.objects where object_id = ' + convert(nvarchar(20), @save_fk_referenced_object_id) + ')'
			EXEC sp_executesql @cmd, N'@save_fk_referenced_object_name sysname output', @save_fk_referenced_object_name output

			Select @cmd = 'use [' + @save_dbname + '] select @save_fk_referenced_object_sname = (select s.name from sys.schemas s, sys.objects o where s.schema_id = o.schema_id and o.object_id = ' + convert(nvarchar(20), @save_fk_referenced_object_id) + ')'
			EXEC sp_executesql @cmd, N'@save_fk_referenced_object_sname sysname output', @save_fk_referenced_object_sname output

			Select @cmd = 'use [' + @save_dbname + '] select @save_fk_referenced_column_name = (select name from sys.columns where object_id = ' + convert(nvarchar(20), @save_fk_referenced_object_id) + ' and column_id = ' + convert(nvarchar(20), @save_fk_referenced_column_id) + ')'
			EXEC sp_executesql @cmd, N'@save_fk_referenced_column_name sysname output', @save_fk_referenced_column_name output

			select @miscprint = @miscprint + ', [' + @save_fk_referenced_column_name + ']'

			Select @save_fk_parent_names = @save_fk_parent_names + ', [' + @save_fk_parent_column_name + ']'
			Select @save_fk_referenced_names = @save_fk_referenced_names + ', [' + @save_fk_referenced_column_name + ']'

			goto fk_start01
		   end


		select @miscprint = 'IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and parent_object_id = OBJECT_ID(N''[' + @save_fk_parent_object_sname + '].[' + @save_fk_parent_object_name + ']''))'
		print  @miscprint

		select @miscprint = 'ALTER TABLE [' + @save_fk_parent_object_sname + '].[' + @save_fk_parent_object_name + ']'

		If (select top 1 is_not_trusted from @tbl_forkeys where fname = @cu11_name) = 0
		   begin
			select @miscprint = @miscprint + ' WITH CHECK'
		   end
		Else
		   begin
			select @miscprint = @miscprint + ' WITH NOCHECK'
		   end

		select @miscprint = @miscprint + ' ADD CONSTRAINT [' + @cu11_name + '] FOREIGN KEY(' + @save_fk_parent_names + ')'
		print  @miscprint
		select @miscprint = 'REFERENCES [' + @save_fk_referenced_object_sname + '].[' + @save_fk_referenced_object_name + '] (' + @save_fk_referenced_names + ')'
		print  @miscprint
		print 'GO'

		If (select is_disabled from @tbl_forkeys where fname = @cu11_name) = 0
		   begin
			select @miscprint = 'ALTER TABLE [' + @save_fk_parent_object_sname + '].[' + @save_fk_parent_object_name + '] CHECK CONSTRAINT [' + @cu11_name + ']'
			print  @miscprint
			print 'GO'
			print ''
		   end
		Else
		   begin
			select @miscprint = 'ALTER TABLE [' + @save_fk_parent_object_sname + '].[' + @save_fk_parent_object_name + '] NOCHECK CONSTRAINT [' + @cu11_name + ']'
			print  @miscprint
			print 'GO'
			print ''
		   end

	   end
	-----------------------------------------------------------
	--  end ForeignKeys
	-----------------------------------------------------------




	-----------------------------------------------------------
	--  start views
	-----------------------------------------------------------
	If @save_type in ('v', 'vi') --views 
	   begin
		--  Find out how many lines of text are coming back, and return if there are none.
		if (select count(*) from @temp_com where id = @cu11_id) = 0 
		   begin
			raiserror(15197,-1,-1,@cu11_name)
			goto label89						
		   end

		if (select count(*) from @temp_com where id = @cu11_id and encrypted = 0) = 0
		   begin
			raiserror(15471,-1,-1)
			goto label89						
		   end

		--  Get index related to this view
		Select @cmd = 'SELECT i.name
				, i.index_id
				, i.type
				, i.type_desc
				, i.is_unique
				, i.data_space_id
				, d.name
				, i.ignore_dup_key
				, i.is_primary_key
				, i.is_unique_constraint
				, i.fill_factor
				, i.is_padded
				, i.is_disabled
				, i.is_hypothetical
				, i.allow_row_locks
				, i.allow_page_locks
				, s.auto_created
				, s.no_recompute
		   From ' + @save_dbname + '.sys.indexes  i, ' + @save_dbname + '.sys.stats  s, ' + @save_dbname + '.sys.data_spaces  d ' + 
		  'Where i.object_id = s.object_id 
		     and i.index_id = s.stats_id
		     and i.data_space_id = d.data_space_id
		     and i.object_id = '+ convert(nvarchar(20), @cu11_id)

		delete from @tbl_indexes

		insert into @tbl_indexes (name
					,index_id
					,type
					,type_desc
					,is_unique
					,data_space_id
					,data_space_name
					,ignore_dup_key
					,is_primary_key
					,is_unique_constraint
					,fill_factor
					,is_padded
					,is_disabled
					,is_hypothetical
					,allow_row_locks
					,allow_page_locks
					,auto_created
					,no_recompute
					) exec (@cmd)

		--select * from @tbl_indexes

		If @objtype = 'vi' and (select count(*) from @tbl_indexes) = 0
		   begin
			goto skip_view
		   end


		--  get the object text.
		delete from #CommentText

		SELECT @LFCR = 2
		SELECT @LineId = 1

		delete from @tbl_Syscom
		insert into @tbl_Syscom (SyscomText, number, colid)
		SELECT text, number, colid FROM @temp_com 
					WHERE id = @cu11_id 
					  and encrypted = 0

		If (select count(*) from @tbl_Syscom) > 0
		   begin
			start_syscom1:

			Select @SyscomText = (select top 1 SyscomText from @tbl_Syscom order by number, colid)
			Select @save_number = (select top 1 number from @tbl_Syscom where SyscomText = @SyscomText order by number, colid)
			Select @save_colid = (select top 1 colid from @tbl_Syscom where SyscomText = @SyscomText order by number, colid)

			SELECT @BasePos = 1
			SELECT @CurrentPos = 1
			SELECT @TextLength = LEN(@SyscomText)

			WHILE @CurrentPos  != 0
			   BEGIN
				--Looking for end of line followed by carriage return
				SELECT @CurrentPos = CHARINDEX(char(13)+char(10), @SyscomText, @BasePos)

				--If carriage return found
				IF @CurrentPos != 0
				   BEGIN
					/*If new value for @Lines length will be > then the
					**set length then insert current contents of @line
					**and proceed.
					*/
					While (isnull(LEN(@Line),0) + @BlankSpaceAdded + @CurrentPos-@BasePos + @LFCR) > @DefinedLength
					   BEGIN
						SELECT @AddOnLen = @DefinedLength-(isnull(LEN(@Line),0) + @BlankSpaceAdded)
						INSERT #CommentText VALUES (@LineId, isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N''))
						SELECT @Line = NULL
						SELECT @LineId = @LineId + 1
						SELECT @BasePos = @BasePos + @AddOnLen
						SELECT @BlankSpaceAdded = 0
					   END
					SELECT @Line = isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @CurrentPos-@BasePos + @LFCR), N'')
					SELECT @BasePos = @CurrentPos+2
					INSERT #CommentText VALUES( @LineId, @Line )
					SELECT @LineId = @LineId + 1
					SELECT @Line = NULL
				   END
				ELSE
				--else carriage return not found
				   BEGIN
					IF @BasePos <= @TextLength
					   BEGIN
						/*If new value for @Lines length will be > then the
						**defined length
						*/
						While (isnull(LEN(@Line),0) + @BlankSpaceAdded + @TextLength-@BasePos+1 ) > @DefinedLength
						   BEGIN
							SELECT @AddOnLen = @DefinedLength - (isnull(LEN(@Line),0) + @BlankSpaceAdded )
							INSERT #CommentText VALUES (@LineId, isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N''))
							SELECT @Line = NULL
							SELECT @LineId = @LineId + 1
							SELECT @BasePos = @BasePos + @AddOnLen
							SELECT @BlankSpaceAdded = 0
						   END
						SELECT @Line = isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @TextLength-@BasePos+1 ), N'')
						if charindex(' ', @SyscomText, @TextLength+1 ) > 0
						   BEGIN
							SELECT @Line = @Line + ' '
							SELECT @BlankSpaceAdded = 1
						   END
						BREAK
					END
				END
			END

			-- check for more syscom rows to process
			delete from @tbl_Syscom where SyscomText = @SyscomText and number = @save_number and colid = @save_colid
			If (select count(*) from @tbl_Syscom) > 0
			   begin
				goto start_syscom1
			   end

		   end


		IF @Line is NOT NULL
		   begin
			INSERT #CommentText VALUES( @LineId, @Line )
		   end

		print ''
		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint
		select @miscprint = '-- ' + @cu11_name
		print  @miscprint
		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint

		If @suppress_drop_stmt = 'n'
		   begin
			select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsView'') = 1)'
			print  @miscprint
			select @miscprint = 'drop view [' + @cu11_schema_name + '].[' + @cu11_name + ']'

			print  @miscprint
			print  'GO'
			print  ' '
		   end

		If @drop_only = 'y'
		   begin
			goto label89
		   end

		--  set ANSI_NULLS option
		Select @cmd = 'use [' + @save_dbname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']''), N''ExecIsAnsiNullsOn'')'
		EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
		If @save_objid = 1
		   begin
			select @miscprint = 'SET ANSI_NULLS ON'
			print  @miscprint
			print  'GO'
		   end
		Else
		   begin
			select @miscprint = 'SET ANSI_NULLS OFF'
			print  @miscprint
			print  'GO'
		   end

		--  set QUOTED_IDENTIFIER option
    		Select @cmd = 'use [' + @save_dbname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']''), N''ExecIsQuotedIdentOn'')'
		EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
		If @save_objid = 1
		   begin
			select @miscprint = 'SET QUOTED_IDENTIFIER ON'
			print  @miscprint
			print  'GO'
		   end
		Else
		   begin
			select @miscprint = 'SET QUOTED_IDENTIFIER OFF'
			print  @miscprint
			print  'GO'
		   end


		If (select count(*) from #CommentText) > 0
		   begin
			start_commenta:

			Select @save_lineid = (select top 1 lineid from #CommentText order by lineid)
			Select @commentText = (select text from #CommentText where lineid = @save_lineid)

			--  Fix CR's with out line feeds
			Select @pos = 1
			Label90a:
			Select @charpos = charindex(char(13), @commentText, @pos)
			IF @charpos <> 0
			   begin
				Select @pos = @charpos
				If substring(@commentText, @charpos+1, 1) <> char(10)
				   begin
					select @commentText = stuff(@commentText, @charpos, 1, char(13)+char(10))
					Select @pos = @pos + 1
				   end
			   end

			Select @pos = @pos + 1
			Select @charpos = charindex(char(13), @commentText, @pos)
			IF @charpos <> 0
			   begin
				goto label90a
			   end

			--  Fix line feeds with no preceeding CR
			Select @pos = 1
			Label91a:
			Select @charpos = charindex(char(10), @commentText, @pos)
			IF @charpos <> 0
			   begin
				Select @pos = @charpos
				If substring(@commentText, @charpos-1, 1) <> char(13)
				   begin
					select @commentText = stuff(@commentText, @charpos, 1, char(13)+char(10))
					Select @pos = @pos + 1
				   end
			   end

			Select @pos = @pos + 1
			Select @charpos = charindex(char(10), @commentText, @pos)
			IF @charpos <> 0
			   begin
				goto label91a
			   end

			select @miscprint = @commentText
			print  @miscprint

			-- check for more comment rows to process
			Delete from #CommentText where lineid = @save_lineid
			If (select count(*) from #CommentText) > 0
			   begin
				goto start_commenta
			   end


			SELECT @Line = NULL
                        
			Print  @G_O 
			Print  ' '


			--  check to see if there are indexes for this view to process
			If (select count(*) from @tbl_indexes) > 0
			   begin
				start_vw_indexes:
				Select @save_index_id = (select top 1 index_id from @tbl_indexes order by index_id)
				Select @save_indxname = (select top 1 name from @tbl_indexes where index_id = @save_index_id)
				Select @save_type_desc = (select top 1 type_desc from @tbl_indexes where index_id = @save_index_id)
				Select @save_data_space_name = (select top 1 data_space_name from @tbl_indexes where index_id = @save_index_id)

				--  Now check to see if this is a unique index
				If (select is_unique from @tbl_indexes where index_id = @save_index_id) = 1
				   begin
					select @save_type_desc = 'UNIQUE ' + @save_type_desc
				   end

				select @miscprint = 'CREATE ' +  rtrim(@save_type_desc) + ' INDEX [' + rtrim(@save_indxname) + '] ON ' + @objname
				print  @miscprint
				select @miscprint = '('
				print  @miscprint

				-- get the index keys
				Select @cmd = 'use [' + @save_dbname + '] Select @keys = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', 1)'
				EXEC sp_executesql @cmd, N'@keys nvarchar(2126) output', @keys output

				Select @cmd = 'use [' + @save_dbname + '] Select @save_indexkey_property = indexkey_property(' + convert(nvarchar(20), @cu11_id) + ', ' + convert(nvarchar(20), @save_index_id) + ', 1, ''isdescending'')'
				EXEC sp_executesql @cmd, N'@save_indexkey_property char(1) output', @save_indexkey_property output

				If @save_indexkey_property = 1
				   begin
					select @miscprint = '        [' + @keys + '] DESC'
					print  @miscprint
				   end
				Else
				   begin
					select @miscprint = '        [' + @keys + '] ASC'
					print  @miscprint
				   end

				Select @i = 2
				Select @cmd = 'use [' + @save_dbname + '] Select @thiskey = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ')'
				EXEC sp_executesql @cmd, N'@thiskey nvarchar(131) output', @thiskey output

				while (@thiskey is not null )
				   begin
					Select @keys = @thiskey

					Select @cmd = 'use [' + @save_dbname + '] Select @save_indexkey_property = indexkey_property(' + convert(nvarchar(20), @cu11_id) + ', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ', ''isdescending'')'
					EXEC sp_executesql @cmd, N'@save_indexkey_property char(1) output', @save_indexkey_property output

					If @save_indexkey_property = 1
					   begin
						select @miscprint = '       ,[' + @keys + '] DESC'
						print  @miscprint
					   end
					Else
					   begin
						select @miscprint = '       ,[' + @keys + '] ASC'
						print  @miscprint
					   end

					Select @i = @i + 1
					Select @cmd = 'use [' + @save_dbname + '] Select @thiskey = index_col(''' + @objname + ''', ' + convert(nvarchar(20), @save_index_id) + ', ' + convert(nvarchar(10), @i) + ')'
					EXEC sp_executesql @cmd, N'@thiskey nvarchar(131) output', @thiskey output
				   end

				--  Now set the index options
				Select @save_PAD_INDEX = case when ((select is_padded from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
				Select @save_STATISTICS_NORECOMPUTE = case when ((select no_recompute from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
				Select @save_IGNORE_DUP_KEY = case when ((select ignore_dup_key from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
				Select @save_ALLOW_ROW_LOCKS = case when ((select allow_row_locks from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 
				Select @save_ALLOW_PAGE_LOCKS = case when ((select allow_page_locks from @tbl_indexes where index_id = @save_index_id) = 1) then 'ON' else 'OFF' end 

				select @miscprint = ')WITH (PAD_INDEX = ' + @save_PAD_INDEX + ', STATISTICS_NORECOMPUTE = ' 
								+ @save_STATISTICS_NORECOMPUTE + ', IGNORE_DUP_KEY = ' 
								+ @save_IGNORE_DUP_KEY + ', ALLOW_ROW_LOCKS = ' 
								+ @save_ALLOW_ROW_LOCKS + ', ALLOW_PAGE_LOCKS = ' 
								+ @save_ALLOW_PAGE_LOCKS + ') ON [' + @save_data_space_name + ']'
				print  @miscprint
				SELECT @Line = NULL
                                
				Print  @G_O 
				Print  ' '

				delete from @tbl_indexes where index_id = @save_index_id
				If (select count(*) from @tbl_indexes) > 0
				   begin
					goto start_vw_indexes
				   end
			  end

		   end


		Print  ' '

		Select @output_flag	= 'y'

		skip_view:

		goto label89

	   end
	-----------------------------------------------------------
	--  end view section
	-----------------------------------------------------------



	-----------------------------------------------------------
	--  start sprocs, function, triggers
	-----------------------------------------------------------
	If @save_type in ('p', 'fn', 'tr') --sprocs, function, triggers 
	   begin
		--  Find out how many lines of text are coming back, and return if there are none.
		if (select count(*) from @temp_com where id = @cu11_id) = 0 
		   begin
			raiserror(15197,-1,-1,@cu11_name)
			goto label89						
		   end

		if (select count(*) from @temp_com where id = @cu11_id and encrypted = 0) = 0
		   begin
			raiserror(15471,-1,-1)
			goto label89						
		   end

		--  get the object text.
		delete from #CommentText

		SELECT @LFCR = 2
		SELECT @LineId = 1

		delete from @tbl_Syscom
		insert into @tbl_Syscom (SyscomText, number, colid)
		SELECT text, number, colid FROM @temp_com 
					WHERE id = @cu11_id 
					  and encrypted = 0

		--select * from @tbl_Syscom

		If (select count(*) from @tbl_Syscom) > 0
		   begin
			start_syscom:

			Select @SyscomText = (select top 1 SyscomText from @tbl_Syscom order by number, colid)
			Select @save_number = (select top 1 number from @tbl_Syscom where SyscomText = @SyscomText order by number, colid)
			Select @save_colid = (select top 1 colid from @tbl_Syscom where SyscomText = @SyscomText order by number, colid)

			SELECT @BasePos = 1
			SELECT @CurrentPos = 1
			SELECT @TextLength = LEN(@SyscomText)

			WHILE @CurrentPos  != 0
			   BEGIN
				--Looking for end of line followed by carriage return
				SELECT @CurrentPos = CHARINDEX(char(13)+char(10), @SyscomText, @BasePos)

				--If carriage return found
				IF @CurrentPos != 0
				   BEGIN
					/*If new value for @Lines length will be > then the
					**set length then insert current contents of @line
					**and proceed.
					*/
					While (isnull(LEN(@Line),0) + @BlankSpaceAdded + @CurrentPos-@BasePos + @LFCR) > @DefinedLength
					   BEGIN
						SELECT @AddOnLen = @DefinedLength-(isnull(LEN(@Line),0) + @BlankSpaceAdded)
						INSERT #CommentText VALUES (@LineId, isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N''))
						SELECT @Line = NULL
						SELECT @LineId = @LineId + 1
						SELECT @BasePos = @BasePos + @AddOnLen
						SELECT @BlankSpaceAdded = 0
					   END
					SELECT @Line = isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @CurrentPos-@BasePos + @LFCR), N'')
					SELECT @BasePos = @CurrentPos+2
					INSERT #CommentText VALUES( @LineId, @Line )
					SELECT @LineId = @LineId + 1
					SELECT @Line = NULL
				   END
				ELSE
				--else carriage return not found
				   BEGIN
					IF @BasePos <= @TextLength
					   BEGIN
						/*If new value for @Lines length will be > then the
						**defined length
						*/
						While (isnull(LEN(@Line),0) + @BlankSpaceAdded + @TextLength-@BasePos+1 ) > @DefinedLength
						   BEGIN
							SELECT @AddOnLen = @DefinedLength - (isnull(LEN(@Line),0) + @BlankSpaceAdded )
							INSERT #CommentText VALUES (@LineId, isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N''))
							SELECT @Line = NULL
							SELECT @LineId = @LineId + 1
							SELECT @BasePos = @BasePos + @AddOnLen
							SELECT @BlankSpaceAdded = 0
						   END
						SELECT @Line = isnull(@Line, N'') + isnull(SUBSTRING(@SyscomText, @BasePos, @TextLength-@BasePos+1 ), N'')
						if charindex(' ', @SyscomText, @TextLength+1 ) > 0
						   BEGIN
							SELECT @Line = @Line + ' '
							SELECT @BlankSpaceAdded = 1
						   END
						BREAK
					END
				END
			END

			-- check for more syscom rows to process
			delete from @tbl_Syscom where SyscomText = @SyscomText and number = @save_number and colid = @save_colid
			If (select count(*) from @tbl_Syscom) > 0
			   begin
				goto start_syscom
			   end

		   end


		IF @Line is NOT NULL
		   begin
			INSERT #CommentText VALUES( @LineId, @Line )
		   end

		print ''
		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint
		select @miscprint = '-- ' + @cu11_name
		print  @miscprint
		select @miscprint = '------------------------------------------------------------------------------------------------------- '
		print  @miscprint

		If @suppress_drop_stmt = 'n'
		   begin
			If @save_type = 'p'
			   begin
				select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsProcedure'') = 1)'
				print  @miscprint
				select @miscprint = 'drop procedure [' + @cu11_schema_name + '].[' + @cu11_name + ']'
				print  @miscprint
				print  'GO'
				print  ''
			   end
			Else If @save_type = 'fn' and @cu11_type = 'if'
			   begin
				select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsInlineFunction'') = 1)'
				print  @miscprint
				select @miscprint = 'drop function [' + @cu11_schema_name + '].[' + @cu11_name + ']'
				print  @miscprint
				print  'GO'
				print  ''
			   end
			Else If @save_type = 'fn' and @cu11_type = 'fn'
			   begin
				select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsScalarFunction'') = 1)'
				print  @miscprint
				select @miscprint = 'drop function [' + @cu11_schema_name + '].[' + @cu11_name + ']'
				print  @miscprint
				print  'GO'
				print  ''
			   end
			Else If @save_type = 'fn' and @cu11_type = 'tf'
			   begin
				select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsTableFunction'') = 1)'
				print  @miscprint
				select @miscprint = 'drop function [' + @cu11_schema_name + '].[' + @cu11_name + ']'
				print  @miscprint
				print  'GO'
				print  ''
			   end
			Else If @save_type = 'tr'
			   begin
				select @miscprint = 'if exists (select * from sys.objects where object_id = object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']'') and OBJECTPROPERTY(object_id, N''IsTrigger'') = 1)'
				print  @miscprint
				select @miscprint = 'drop trigger [' + @cu11_schema_name + '].[' + @cu11_name + ']'
				print  @miscprint
				print  'GO'
				print  ''
			   end
		   end


		If @drop_only = 'y'
		   begin
			goto label89
		   end

		--  set ANSI_NULLS option
		Select @cmd = 'use [' + @save_dbname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']''), N''ExecIsAnsiNullsOn'')'
		EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
		If @save_objid = 1
		   begin
			select @miscprint = 'SET ANSI_NULLS ON'
			print  @miscprint
			print  'GO'
		   end
		Else
		   begin
			select @miscprint = 'SET ANSI_NULLS OFF'
			print  @miscprint
			print  'GO'
		   end

		--  set QUOTED_IDENTIFIER option
    		Select @cmd = 'use [' + @save_dbname + '] select @save_objid = OBJECTPROPERTY(object_id(N''[' + @cu11_schema_name + '].[' + @cu11_name + ']''), N''ExecIsQuotedIdentOn'')'
		EXEC sp_executesql @cmd, N'@save_objid int output', @save_objid output
		If @save_objid = 1
		   begin
			select @miscprint = 'SET QUOTED_IDENTIFIER ON'
			print  @miscprint
			print  'GO'
		   end
		Else
		   begin
			select @miscprint = 'SET QUOTED_IDENTIFIER OFF'
			print  @miscprint
			print  'GO'
		   end




		If (select count(*) from #CommentText) > 0
		   begin
			start_comment:

			Select @save_lineid = (select top 1 lineid from #CommentText order by lineid)
			Select @commentText = (select text from #CommentText where lineid = @save_lineid)

			--  Fix CR's with out line feeds
			Select @pos = 1
			Label90:
			Select @charpos = charindex(char(13), @commentText, @pos)
			IF @charpos <> 0
			   begin
				Select @pos = @charpos
				If substring(@commentText, @charpos+1, 1) <> char(10)
				   begin
					select @commentText = stuff(@commentText, @charpos, 1, char(13)+char(10))
					Select @pos = @pos + 1
				   end
			   end

			Select @pos = @pos + 1
			Select @charpos = charindex(char(13), @commentText, @pos)
			IF @charpos <> 0
			   begin
				goto label90
			   end

			--  Fix line feeds with no preceeding CR
			Select @pos = 1
			Label91:
			Select @charpos = charindex(char(10), @commentText, @pos)
			IF @charpos <> 0
			   begin
				Select @pos = @charpos
				If substring(@commentText, @charpos-1, 1) <> char(13)
				   begin
					select @commentText = stuff(@commentText, @charpos, 1, char(13)+char(10))
					Select @pos = @pos + 1
				   end
			   end

			Select @pos = @pos + 1
			Select @charpos = charindex(char(10), @commentText, @pos)
			IF @charpos <> 0
			   begin
				goto label91
			   end

			select @miscprint = @commentText
			print  @miscprint

			-- check for more comment rows to process
			Delete from #CommentText where lineid = @save_lineid
			If (select count(*) from #CommentText) > 0
			   begin
				goto start_comment
			   end

		   end


		SELECT @Line = NULL
                
		Print  @G_O 
		Print  ' '
		Print  ' '

		Select @output_flag	= 'y'


		goto label89

	   end
	-----------------------------------------------------------
	--  end sprocs, function, triggers section
	-----------------------------------------------------------
         

	label89:

	--  Check for more objects to process
	Delete from @objinfo where object_id = @cu11_id
	If (select count(*) from @objinfo where type = @save_type) > 0
	   begin
		goto start_objinfo
	   end

	--  Return to the caller
	If @caller_id = 's_u'
	   begin
		goto s_u
	   end

	If @caller_id = 's_f'
	   begin
		goto s_f
	   end

	If @caller_id = 's_p'
	   begin
		goto s_p
	   end

	If @caller_id = 's_fn'
	   begin
		goto s_fn
	   end

	If @caller_id = 's_v'
	   begin
		goto s_v
	   end

	If @caller_id = 's_tr'
	   begin
		goto s_tr
	   end

   end
-------------------------------------------------------------------
--  END: Sub routine for tables, sprocs, functions, views, triggers
-------------------------------------------------------------------







---------------------------  Finalization  -----------------------
label99:

DROP TABLE #CommentText


If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end





 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Self_Register
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Self_Register]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Self_Register]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[dbasp_Self_Register]
--
--/*********************************************************
-- **  Stored Procedure dbasp_Self_Register                  
-- **  Written by Jim Wilson, Getty Images                
-- **  March 22, 2007                                      
-- **  
-- **  This procedure registers the local SQL server instance
-- **  to the designated centrl SQL server.
-- **  are found.
-- ***************************************************************/
 as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/22/2007	Jim Wilson		New Process
--	04/16/2007	Jim Wilson		Added sql install date, number and size of user DB's
--	06/19/2007	Jim Wilson		New register process for DEPL related servers.
--	06/21/2007	Jim Wilson		Modify the new register process for all servers now.
--	08/24/2007	Jim Wilson		Added backup processing info.
--	09/18/2007	Jim Wilson		Allow null in new temp table.
--	09/21/2007	Jim Wilson		Update for SQL2005.
--	11/05/2007	Jim Wilson		Added sql and server config info.
--	11/06/2007	Jim Wilson		Get Domain name from srvinfo.
--	11/07/2007	Jim Wilson		Removed psinfo and added msinfo.
--	02/07/2008	Jim Wilson		Added skip for database that are not online.
--	02/12/2008	Jim Wilson		New code for DEPL table update.
--	03/06/2008	Jim Wilson		Added dynamic code for DEPL table update.
--	06/23/2008	Jim Wilson		New code for Compression backup info check in.
--	06/27/2008	Jim Wilson		Fixed bug in getting cluster node names.
--	08/20/2008	Jim Wilson		Major re-write.
--	08/22/2008	Jim Wilson		Skip appl desc for dbaadmin and systeminfo.
--	08/26/2008	Jim Wilson		force reg2.exe for x64.
--	09/16/2008	Jim Wilson		seafresqldba02 to seafresqldba01.
--	09/25/2008	Jim Wilson		New code to check for clr enabled setting.
--	10/07/2008	Jim Wilson		Added FAStT and Multi-Path for SAN flag.
--	10/13/2008	Jim Wilson		Added section for general environment verification (file shares).
--	10/14/2008	Jim Wilson		Skip DB's like "_new" and"_nxt".
--	10/20/2008	Jim Wilson		Fixed code for fulltext DB's.
--	11/10/2008	Jim Wilson		Code to force upper case on server name and sql name.
--	11/14/2008	Jim Wilson		New code to add backup_type to Local_ServerEnviro table.
--	11/21/2008	Jim Wilson		Added auto set for the local policy rights.
--	12/01/2008	Jim Wilson		Fix to grant policy for non-standard cluster group names.
--      12/02/2008	David Spriggs		Added code to update the local dbaadmin DBA_*info tables.
--	12/08/2008	David Spriggs		Added code to capture database compatibility level
--	12/12/2008	Jim Wilson		Revised code to check for baseline date
--	12/29/2008	Jim Wilson		Fully qualified all references to dbaadmin objects.
--	03/11/2009	Jim Wilson		Added DEPLstatus verification to the no_check table.
--	03/18/2009	Jim Wilson		Added section for DiskPerfinfo. Also changed
--						pagefile from available to max size.
--	03/20/2009	Jim Wilson		Only delete DBinfo rowsolder than 60 days (last moddate)
--	03/25/2009	Jim Wilson		Updated code for DiskPerfinfo
--	03/27/2009	Jim Wilson		Set robocopy to work for folders with spaces.  Changed
--						most echo commands to sqlcmd.
--	03/30/2009	Jim Wilson		This sproc will now execute sproc dbasp_self_register_report.
--	04/03/2009	Jim Wilson		Fix issue with null inserts for Litespeed and Redgate info.
--	08/19/2009	Jim Wilson		Fixed code for Redgate and Litespeed version updates.
--	======================================================================================

DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@cmd2				nvarchar(4000)
	,@central_server 		sysname
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_sqlinstance		sysname
	,@save_backup_type	    	sysname
	,@save_ls_version    		sysname
	,@save_rg_version	    	sysname
	,@save_compbackup_rg_flag	char(1)
	,@save_compbackup_ls_flag	char(1)
	,@save_rg_versiontype		sysname
	,@save_rg_license		sysname
	,@save_rg_installdate		datetime
	,@save_ls_versiontype		sysname
	,@save_ls_license		sysname
	,@save_ls_installdate		datetime
	,@charpos			int
	,@isNMinstance			char(1)
	,@outfile_name			sysname
	,@outfile_path			nvarchar(250)
	,@hold_source_path		sysname
	,@save_ENVname	 		sysname


/*********************************************************************
 *                Initialization
 ********************************************************************/

Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
	Select @isNMinstance = 'y'
   end


--  Create temp table
create table #ls_ver 	(
			 name01 sysname
			,value02 sysname null)




Select @central_server = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'CentralServer'
If @central_server is null
   begin
	Select @miscprint = 'DBA WARNING: The central SQL Server is not defined for ' + @@servername + '.  The nightly self check-in failed'
	Print @miscprint
	raiserror(@miscprint,-1,-1)
	goto label99
   end
	

Select @save_ENVname = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'ENVname'
If @save_ENVname is null
   begin
	Select @miscprint = 'DBA WARNING: The envirnment name is not defined for ' + @@servername + '.  The nightly self check-in failed'
	Print @miscprint
	raiserror(@miscprint,-1,-1)
	goto label99
   end

Select @outfile_name = 'CentralTableUpdate_' + @save_servername2 + '.gsql'
Select @outfile_path = '\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\' + @outfile_name



/****************************************************************
 *                MainLine
 ***************************************************************/

--  Capture Backup Type
If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_type' and Env_detail = 'LiteSpeed')
   begin
	Select @save_backup_type = 'LiteSpeed'
   end
Else If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_type' and Env_detail = 'RedGate')
   begin
	Select @save_backup_type = 'RedGate'
   end
Else If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_type' and Env_detail = 'Standard')
   begin
	Select @save_backup_type = 'Standard'
   end
Else 
   begin
	Select @save_backup_type = 'Default'
   end


--  Capture LiteSpeed Version (if installed)
Select @save_ls_version = 'na'
If exists (select * from master.sys.objects where name = 'xp_sqllitespeed_version' and type = 'x')
   begin
	Delete from dbo.Local_ServerEnviro where env_type like 'backup_ls_%'

	insert into #ls_ver exec master.dbo.xp_sqllitespeed_version
	--select * from #ls_ver
	Select @save_ls_version = (select value02 from #ls_ver where name01 = 'Product Version')

	If @save_ls_version is null
	   begin
		Select @save_ls_version = 'unknown'
	   end

	If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_ls_version')
	   begin
		Update dbo.Local_ServerEnviro set env_detail = @save_ls_version where env_type = 'backup_ls_version' 
	   end
	Else
	   begin
		Insert into dbo.Local_ServerEnviro values('backup_ls_version', @save_ls_version)
	   end

	If exists (select 1 from #ls_ver where name01 = 'Professional Edition' and value02 = '1')
	   begin
		select @save_ls_versiontype = 'Professional Edition'
	   end
	Else If exists (select 1 from #ls_ver where name01 = 'Developer Edition' and value02 = '1')
	   begin
		select @save_ls_versiontype = 'Developer Edition'
	   end
	Else If exists (select 1 from #ls_ver where name01 = 'MSDE Edition' and value02 = '1')
	   begin
		select @save_ls_versiontype = 'MSDE Edition'
	   end
	Else
	   begin
		select @save_ls_versiontype = 'Unknown'
	   end

	If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_ls_versiontype')
	   begin
		Update dbo.Local_ServerEnviro set env_detail = @save_ls_versiontype where env_type = 'backup_ls_versiontype' 
	   end
	Else
	   begin
		Insert into dbo.Local_ServerEnviro values('backup_ls_versiontype', @save_ls_versiontype)
	   end


	Select @save_ls_license = 'na'

	Select @save_ls_installdate = (select create_date from master.sys.objects where name = 'xp_sqllitespeed_version' and type = 'x')

	Select @save_compbackup_ls_flag = 'y'
   end


--  Capture RedGate Version (if installed)
Select @save_rg_version = 'na'
If exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
   begin
	Delete from dbo.Local_ServerEnviro where env_type like 'backup_rg_%'

	exec master.dbo.sqbutility 1030, @save_rg_version OUTPUT

	If @save_rg_version is null
	   begin
		Select @save_rg_version = 'Error'
	   end
	Else
	   begin
		exec master.dbo.sqbutility 1021, @save_rg_versiontype OUTPUT, NULL, @save_rg_license OUTPUT;
		Select @save_rg_versiontype = case @save_rg_versiontype
						when '0' THEN 'Trial: Expired'
						when '1' THEN 'Trial'
						when '2' THEN 'Standard'
						when '3' THEN 'Professional'
						when '6' THEN 'Lite'
						else 'unknown'
						end

		Select @save_rg_installdate = (select create_date from master.sys.objects where name = 'sqlbackup' and type = 'x')

		Select @save_compbackup_rg_flag = 'y'
	   end

	If @save_rg_versiontype is null
	   begin
		Select @save_rg_versiontype = 'unknown'
	   end

	If @save_rg_license is null
	   begin
		Select @save_rg_license = 'unknown'
	   end

	Delete from dbo.Local_ServerEnviro where env_type like 'backup_rg_%'

	Insert into dbo.Local_ServerEnviro values('backup_rg_version', @save_rg_version)

	Insert into dbo.Local_ServerEnviro values('backup_rg_versiontype', @save_rg_versiontype)

	Insert into dbo.Local_ServerEnviro values('backup_rg_license', @save_rg_license)

   end


If @save_compbackup_rg_flag = 'y' and @save_backup_type = 'Default'
   begin
	Select @save_backup_type = 'RedGate'

	If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type')
	   begin
		Update dbo.Local_ServerEnviro set env_detail = 'RedGate' where env_type = 'backup_type' 
	   end
	Else
	   begin
		Insert into dbo.Local_ServerEnviro values('backup_type', 'RedGate')
	   end
   end
Else If @save_compbackup_ls_flag = 'y' and @save_backup_type = 'Default'
   begin
	Select @save_backup_type = 'LiteSpeed'

	If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'backup_type')
	   begin
		Update dbo.Local_ServerEnviro set env_detail = 'LiteSpeed' where env_type = 'backup_type' 
	   end
	Else
	   begin
		Insert into dbo.Local_ServerEnviro values('backup_type', 'LiteSpeed')
	   end
   end




--  Create output file
SELECT @cmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"exec dbaadmin.dbo.dbasp_Self_Register_Report" -E -o' + @outfile_path
print @cmd
EXEC master.sys.xp_cmdshell @cmd, no_output





-- Update the local dbaadmin database
SET @cmd2 = 'sqlcmd -S'+@@servername+' -ddbaadmin -E -w265 -i'+@outfile_path+'  -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\DBA_SelfReg_localupdate.log'
Print @cmd2
EXEC master.sys.xp_cmdshell @cmd2, no_output

--  Copy the file to the central server
Select @cmd = 'xcopy /Y /R "' + rtrim(@outfile_path) + '" "\\' + rtrim(@central_server) + '\' + rtrim(@central_server) + '_SQL_Register"'
Print @cmd
EXEC master.sys.xp_cmdshell @cmd, no_output 

If @central_server = 'seafresqldba01'
   begin
	goto file_copy_end
   end

If (select top 1 env_detail from dbo.Local_ServerEnviro where env_type = 'domain') not in ('production', 'stage')
   begin
	Select @cmd = 'xcopy /Y /R "' + rtrim(@outfile_path) + '" "\\seafresqldba01\seafresqldba01_SQL_Register"'
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output 
   end
Else --If (select datepart(dw, getdate())) in (5)  --Thursday
   begin
	Select @hold_source_path = '\\' + upper(@save_servername) + '\' + upper(@save_servername2) + '_dbasql\dba_reports'
	exec dbaadmin.dbo.dbasp_File_Transit @source_name = @outfile_name
		,@source_path = @hold_source_path
		,@target_env = 'AMER'
		,@target_server = 'seafresqldba01'
		,@target_share = 'seafresqldba01_SQL_Register'
   end


file_copy_end:







---------------------------  Finalization  -----------------------
label99:

drop table #ls_ver





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Self_Register_Report
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Self_Register_Report]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Self_Register_Report]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[dbasp_Self_Register_Report]
--
--/*********************************************************
-- **  Stored Procedure dbasp_Self_Register_Report                 
-- **  Written by Jim Wilson, Getty Images                
-- **  March 22, 2007                                      
-- **  
-- **  This procedure registers the local SQL server instance
-- **  to the designated centrl SQL server.
-- ***************************************************************/
 as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/22/2007	Jim Wilson		New Process
--	04/16/2007	Jim Wilson		Added sql install date, number and size of user DB's
--	06/19/2007	Jim Wilson		New register process for DEPL related servers.
--	06/21/2007	Jim Wilson		Modify the new register process for all servers now.
--	08/24/2007	Jim Wilson		Added backup processing info.
--	09/18/2007	Jim Wilson		Allow null in new temp table.
--	09/21/2007	Jim Wilson		Update for SQL2005.
--	11/05/2007	Jim Wilson		Added sql and server config info.
--	11/06/2007	Jim Wilson		Get Domain name from srvinfo.
--	11/07/2007	Jim Wilson		Removed psinfo and added msinfo.
--	02/07/2008	Jim Wilson		Added skip for database that are not online.
--	02/12/2008	Jim Wilson		New code for DEPL table update.
--	03/06/2008	Jim Wilson		Added dynamic code for DEPL table update.
--	06/23/2008	Jim Wilson		New code for Compression backup info check in.
--	06/27/2008	Jim Wilson		Fixed bug in getting cluster node names.
--	08/20/2008	Jim Wilson		Major re-write.
--	08/22/2008	Jim Wilson		Skip appl desc for dbaadmin and systeminfo.
--	08/26/2008	Jim Wilson		force reg2.exe for x64.
--	09/16/2008	Jim Wilson		seafresqldba02 to seafresqldba01.
--	09/25/2008	Jim Wilson		New code to check for clr enabled setting.
--	10/07/2008	Jim Wilson		Added FAStT and Multi-Path for SAN flag.
--	10/13/2008	Jim Wilson		Added section for general environment verification (file shares).
--	10/14/2008	Jim Wilson		Skip DB's like "_new" and"_nxt".
--	10/20/2008	Jim Wilson		Fixed code for fulltext DB's.
--	11/10/2008	Jim Wilson		Code to force upper case on server name and sql name.
--	11/14/2008	Jim Wilson		New code to add backup_type to Local_ServerEnviro table.
--	11/21/2008	Jim Wilson		Added auto set for the local policy rights.
--	12/01/2008	Jim Wilson		Fix to grant policy for non-standard cluster group names.
--      12/02/2008	David Spriggs		Added code to update the local dbaadmin DBA_*info tables.
--	12/08/2008	David Spriggs		Added code to capture database compatibility level
--	12/12/2008	Jim Wilson		Revised code to check for baseline date
--	12/29/2008	Jim Wilson		Fully qualified all references to dbaadmin objects.
--	03/11/2009	Jim Wilson		Added DEPLstatus verification to the no_check table.
--	03/18/2009	Jim Wilson		Added section for DiskPerfinfo. Also changed
--						pagefile from available to max size.
--	03/20/2009	Jim Wilson		Only delete DBinfo rowsolder than 60 days (last moddate)
--	03/25/2009	Jim Wilson		Updated code for DiskPerfinfo
--	03/27/2009	Jim Wilson		Set robocopy to work for folders with spaces.  Changed
--						most echo commands to sqlcmd.
--	03/30/2009	Jim Wilson		Changed output to print only.
--	05/13/2009	Jim Wilson		Fixed substrings for cluster info.
--	05/18/2009	David Spriggs		Keep Baselined databases from checking in.
--	05/20/2009	Jim Wilson		Added status and createdate to dba_dbinfo update.
--	06/25/2009	Jim Wilson		Added MOMdate update for dba_serverinfo (regread).
--	07/07/2009	Jim Wilson		Added rmtshare cmd if showacls result is blank.
--	07/21/2009	Jim Wilson		Added update top (1) to dba_serverinfo update.
--	08/13/2009	Jim Wilson		Added -4 to ping command.
--	08/17/2009	Jim Wilson		Added nslookup to IP capture process and new diskinfo section.
--	10/09/2009	Jim Wilson		Replaced code for DB systeming with DEPLinfo.
--	10/19/2009	Jim Wilson		Added raiserror with nowait after go's.
--	10/20/2009	Jim Wilson		Set Redgate log file retention if installed.
--	10/23/2009	Jim Wilson		Add insert to temp table for sqbutility exec's to suppress "return".
--	10/26/2009	Jim Wilson		Add conditional for CLR check - make sure the DB is not in no_check.
--	11/09/2009	Jim Wilson		Added code for cluster node check (2 instances on one node)
--	03/12/2010	Jim Wilson		New code for active = 'm'.
--	03/15/2010	Jim Wilson		Output code will now be non-DBname specific.
--	03/17/2010	Jim Wilson		Added dbaperf and DEPLinfo version columns and more pagefile info.
--	03/26/2010	Jim Wilson		Added chkcpu32 processing for cpu info capture.
--	05/05/2010	Jim Wilson		SQL2008 starts here.  Updated capture for sql install date.
--	05/05/2010	Jim Wilson		Revised OSuptime code.
--	======================================================================================

DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@cmd2				nvarchar(4000)
	,@central_server 		sysname
	,@save_cmptlvl 			nvarchar(10)
	,@save_dbaadmin_build		sysname
	,@save_dbaperf_build		sysname
	,@save_DEPLinfo_build		sysname
	,@save_version			nvarchar(500)
	,@save_SQL_install_date		datetime
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_ServerType		sysname
	,@save_sqlinstance		sysname
	,@save_SQLSvcAcct		sysname
	,@save_SQLAgentAcct		sysname
	,@save_SQLStartupParms		sysname
	,@hold_SQLStartupParms		sysname
	,@save_install_folder		sysname
	,@save_SQLScanforStartupSprocs	char(1)
	,@save_baseline_srvname		sysname
	,@save_backup_type	    	sysname
	,@save_ls_version    		sysname
	,@save_rg_version	    	sysname
	,@save_domain_name		sysname
	,@save_port			nvarchar(10)
	,@save_SQLrecycle_date		sysname
	,@save_awe_enabled		char(1)
	,@save_clr_enabled		char(1)
	,@save_MAXdop_value		nvarchar(5)
	,@save_SQLmax_memory		nvarchar(20)
	,@save_tempdb_filecount		nvarchar(5)
	,@save_iscluster		char(1)
	,@save_is64bit			char(1)
	,@save_compbackup_rg_flag	char(1)
	,@save_compbackup_ls_flag	char(1)
	,@save_rg_versiontype		sysname
	,@save_rg_license		sysname
	,@save_rg_installdate		datetime
	,@save_ls_versiontype		sysname
	,@save_ls_license		sysname
	,@save_ls_installdate		datetime
	,@save_FullTextCat		char(1)
	,@save_Assemblies		char(1)
	,@save_Mirroring		char(1)
	,@save_Repl_Flag		char(1)
	,@save_LogShipping		char(1)
	,@save_LinkedServers		char(1)
	,@save_ReportingSvcs		char(1)
	,@save_LocalPasswords		char(1)
	,@save_SAN_flag			char(1)
	,@save_depl_flag		char(1)
	,@save_ip			sysname
	,@save_id			int
	,@save_CPUtype			sysname
	,@save_Memory			sysname
	,@save_OSname			sysname
	,@save_OSver			sysname
	,@save_OSuptime			sysname
	,@save_boot_3gb			char(1)
	,@save_boot_pae			char(1)
	,@save_boot_userva		char(1)
	,@save_Pagefile_maxsize		sysname
	,@save_Pagefile_avail		sysname
	,@save_Pagefile_inuse		sysname
	,@save_TimeZone			sysname
	,@save_SystemModel		sysname
	,@save_system_man		sysname
	,@save_system_mod		sysname
	,@charpos			int
	,@charpos2			int
	,@Filesize_logonly		dec(15,2)
	,@Filesize_dataonly		dec(15,2)
	,@Datasize			dec(15,2)
	,@Logsize			dec(15,2)
	,@bytesperpage			dec(15,2)
	,@pagesperMB			dec(15,2)
	,@DEPLinfo_flag			char(1)
	,@depl_flag			char(1)
	,@save_RSTRfolder		sysname
	,@save_companionDB_name		sysname
	,@isNMinstance			char(1)
	,@error_count			int
	,@outfile_name			sysname
	,@outfile_path			nvarchar(250)
	,@hold_source_path		sysname
	,@save_sqlnetname		sysname
	,@save_server_active		char(1)

DECLARE
	 @save_DBstatus			sysname
	,@save_ENVname	 		sysname
	,@save_ENVnum			sysname
	,@save_DBCreateDate		datetime
	,@save_count			int
	,@save_count2			int
	,@save_seq_id			int
	,@save_Appl_desc		sysname
	,@save_BaselineDate		sysname
	,@save_build			sysname
	,@save_RecovModel		sysname
	,@save_db_FullTextCat		char(1)
	,@save_db_Assemblies		char(1)
	,@save_db_Mirroring		char(1)
	,@save_db_Repl_Flag		char(1)
	,@save_db_LogShipping		char(1)
	,@save_db_ReportingSvcs		char(1)
	,@save_db_StartupSprocs		char(1)
	,@save_row_count		bigint
	,@hold_DB_name			sysname
	,@hold_Appl_desc		sysname
	,@hold_dbid			int

DECLARE
	 @save_filepath			nvarchar(500)
	,@save_sharename		sysname
	,@save_bytes_sec		sysname
	,@save_master_path		nvarchar(500)
	,@save_tempdb_path		nvarchar(500)
	,@save_mdf_path			nvarchar(500)
	,@save_ldf_path			nvarchar(500)
	,@save_master_push		bigint
	,@save_master_pull		bigint
	,@save_tempdb_push		bigint
	,@save_tempdb_pull		bigint
	,@save_mdf_push			bigint
	,@save_mdf_pull			bigint
	,@save_ldf_push			bigint
	,@save_ldf_pull			bigint
	,@outpath			varchar(255)

DECLARE
	 @save_OracleClient		sysname
	,@save_TNSnamesPath		sysname
	,@save_CPUphysical		sysname
	,@save_CPUphysical_num		smallint
	,@save_CPUcore			sysname
	,@save_CPUcore_num		smallint
	,@save_CPUlogical		sysname
	,@save_OSinstallDate		sysname
	,@save_Pagefile_path		sysname
	,@save_Pagefile_path2		sysname
	,@save_IEver			sysname
	,@save_MDACver			sysname
	,@save_AntiVirus_type		sysname
	,@save_AntiVirus_Excludes	sysname
	,@save_MOMdate			sysname

DECLARE
	 @save_cluster_name		sysname
	,@save_cluster_IP		sysname
	,@save_cluster_ver		sysname
	,@save_clusterSvcAcct		sysname
	,@save_Quorumgroup		sysname
	,@save_Quorumgroup_node		sysname
	,@save_Quorumgroup_status	sysname
	,@save_DTCgroup			sysname
	,@save_DTCgroup_node		sysname
	,@save_DTCgroup_status		sysname
	,@save_VirtSrv01		sysname
	,@save_VirtSrv01_node		sysname
	,@save_VirtSrv01_status		sysname
	,@save_VirtSrv02		sysname
	,@save_VirtSrv02_node		sysname
	,@save_VirtSrv02_status		sysname
	,@save_VirtSrv03		sysname
	,@save_VirtSrv03_node		sysname
	,@save_VirtSrv03_status		sysname
	,@save_VirtSrv04		sysname
	,@save_VirtSrv04_node		sysname
	,@save_VirtSrv04_status		sysname
	,@save_VirtSrv05		sysname
	,@save_VirtSrv05_node		sysname
	,@save_VirtSrv05_status		sysname
	,@save_clustNode01		sysname
	,@save_clustNode01_IP		sysname
	,@save_clustNode01_status	sysname
	,@save_clustNode02		sysname
	,@save_clustNode02_IP		sysname
	,@save_clustNode02_status	sysname
	,@save_clustNode03		sysname
	,@save_clustNode03_IP		sysname
	,@save_clustNode03_status	sysname
	,@save_clustNode04		sysname
	,@save_clustNode04_IP		sysname
	,@save_clustNode04_status	sysname
	,@save_clustNode05		sysname
	,@save_clustNode05_IP		sysname
	,@save_clustNode05_status	sysname

DECLARE
	 @fileexist_path		sysname
	,@save_Administrators		sysname
	,@save_nodename			sysname
	,@save_checkname		sysname
	,@save_OSuptime_date 		sysname
	,@save_OSuptime_day 		nvarchar(10)
	,@save_OSuptime_month 		nvarchar(5)
	,@save_OSuptime_year 		nvarchar(5)
	,@save_OSuptime_time 		sysname
	,@save_OSuptime_time_hour 	sysname
	,@save_OSuptime_time_minute 	sysname
	,@save_OSuptime_time_second 	sysname
	,@save_OSuptime_meridiem 	sysname
	,@save_OSuptime_seeddate 	datetime

DECLARE
	 @in_key			sysname
	,@in_path			sysname
	,@in_value			sysname
	,@result_value			nvarchar(500)


DECLARE
	 @cu11DBName			sysname
	,@cu11DBId			smallint

DECLARE
	 @cu12FILEsize			dec(15,0)
	,@cu12FILEgroupid		smallint


DECLARE 
	 @hr				int
	,@fso				int
	,@save_drivename		char(1)
	,@odrive			int
	,@save_driveSize_char		varchar(20)
	,@save_driveSize		bigint
	,@save_drivefree		bigint
	,@save_drivefree_pct		int
	,@MB				bigint
	,@p2 				nvarchar(4000)
	,@p4 				int
	,@p5 				int



/*********************************************************************
 *                Initialization
 ********************************************************************/
Select @save_is64bit = 'n'
Select @save_compbackup_rg_flag = 'n'
Select @save_compbackup_ls_flag = 'n'
Select @save_FullTextCat = 'n'
Select @save_Assemblies = 'n'
Select @save_Mirroring = 'n'
Select @save_Repl_Flag = 'n'
Select @save_LogShipping = 'n'
Select @save_ReportingSvcs = 'n'
Select @save_SAN_flag = 'n'
Select @save_depl_flag = 'n'
Select @save_domain_name = ' '
Select @save_SQLScanforStartupSprocs = 'n'
Select @isNMinstance = 'n'
Select @error_count = 0
Select @save_ServerType = 'SQL Server'
SET @MB = 1048576

Select @save_version = @@version

Select @save_version = replace(@save_version, '  ', ' ')


If @save_version like '%x64%'
   begin
	Select @save_is64bit = 'y'
   end

select @bytesperpage = low
	from master.dbo.spt_values
	where number = 1
		and type = 'E'
select @pagesperMB = 1048576 / @bytesperpage


Select @save_sqlinstance = 'mssqlserver'
Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
	Select @isNMinstance = 'y'
   end


Select @DEPLinfo_flag = 'n'
If (SELECT DATABASEPROPERTYEX ('DEPLinfo','status')) = 'ONLINE'
   begin
	Select @DEPLinfo_flag = 'y'
   end


--  Create temp table
create table #clust_tb01 (text01	nvarchar(400))

create table #config 	(
			 name01 sysname
			,min02 sysname null
			,max03 sysname null
			,config04 sysname null
			,run05 sysname null
			)

CREATE TABLE #temp_tbl1	(tb11_id [int] IDENTITY(1,1) NOT NULL
			,text01	nvarchar(400)
			)

CREATE TABLE #temp_tbl2	(tbl2_id [int] IDENTITY(1,1) NOT NULL
			,text01	nvarchar(400)
			)

Create table #regresults (results nvarchar(1500) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

create table #copystats (copydata nvarchar(500))

create table #drives (drive char(1) PRIMARY KEY,
			FreeSpace int NULL,
			TotalSize int NULL,
			)

CREATE TABLE #SqbOutput	(text01	nvarchar(400))



Select @central_server = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'CentralServer'
If @central_server is null
   begin
	Select @miscprint = 'DBA WARNING: The central SQL Server is not defined for ' + @@servername + '.  The nightly self check-in failed'
	Print @miscprint
	raiserror(@miscprint,-1,-1)
	goto label99
   end
	

Select @save_ENVname = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'ENVname'
If @save_ENVname is null
   begin
	Select @miscprint = 'DBA WARNING: The envirnment name is not defined for ' + @@servername + '.  The nightly self check-in failed'
	Print @miscprint
	raiserror(@miscprint,-1,-1)
	goto label99
   end





--  Create headers

Select @miscprint = '--  DBA Central Table Update Script from server: ''' + @@servername + ''''
Print  @miscprint

Select @miscprint = '--  Created: '  + convert(varchar(30),getdate(),9)
Print  @miscprint

Select @miscprint = ' '
Print  @miscprint



/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------------------------------------------------------------------------------
-- General Environment verification
----------------------------------------------------------------------------------------------

--  check file shares

--  Check to see if the 'dba_archive' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_dba_archive'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'dbasql' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_dbasql'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'backup' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_backup'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end


--  Check to see if the 'dba_mail' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername + '_dba_mail'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'builds' folder exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername + '_builds'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'mdf' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_mdf'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'ldf' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_ldf'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'SQLjob_logs' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_SQLjob_logs'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end

--  Check to see if the 'log' share exists
Delete from #fileexists
Select @fileexist_path = '\\' + @save_servername + '\' + @save_servername2 + '_log'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
--select * from #fileexists

If (select fileindir from #fileexists) = 1
   begin
	Select @cmd = 'showacls ' + @fileexist_path

	delete from #regresults
	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults

	If (select count(*) from #regresults) = 0
	   begin
		Select @cmd = 'rmtshare ' + @fileexist_path + ' /users'

		delete from #regresults
		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults
	   end

	If exists (select 1 from #regresults where results like '%Administrators%')
	   begin
		Select @save_Administrators = (select top 1 results from #regresults where results like '%Administrators%')
		If @save_Administrators not like '%Full Control%'
		   begin
			Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators full control.  ' + @fileexist_path 
			Print @miscprint
			raiserror(@miscprint,-1,-1) with log
		   end
	   end
	Else 
	   begin
		Select @miscprint = '--DBA WARNING: Standard share is missing local adminitrators.  ' + @fileexist_path 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end
   end
Else
   begin
	Select @miscprint = '--DBA WARNING: Standard share could not be found.  ' + @fileexist_path 
	Print @miscprint
	raiserror(@miscprint,-1,-1) with log
   end



--  Check to see if dbasp_dba_setpolicygrants has run for this server

If (SERVERPROPERTY('IsClustered')) = 0
   begin
	Select @save_checkname = 'check_localpolicy_' + @save_servername
	If not exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = @save_checkname)
	   begin
		exec dbaadmin.dbo.dbasp_dba_setpolicygrants
		insert into dbaadmin.dbo.Local_ServerEnviro values (@save_checkname, @save_servername) 
	   end
   end
Else
   begin
	delete from #clust_tb01
	select @cmd = 'cluster group /status'
	--print @cmd
	insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
	delete from #clust_tb01 where text01 is null
	delete from #clust_tb01 where text01 = char(13)
	delete from #clust_tb01 where text01 = char(10)
	delete from #clust_tb01 where text01 = char(13)+char(10)
	delete from #clust_tb01 where text01 = char(10)+char(13)
	delete from #clust_tb01 where text01 not like '%' + @save_servername + '%'
	--select * from #clust_tb01

	If (select count(*) from #clust_tb01) = 0
	   begin
		--  At this point we don't have a standard named group.  Find the cluster group for this server name.
		delete from #clust_tb01
		select @cmd = 'cluster res /status'
		--print @cmd
		insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
		delete from #clust_tb01 where text01 is null
		delete from #clust_tb01 where text01 = char(13)
		delete from #clust_tb01 where text01 = char(10)
		delete from #clust_tb01 where text01 = char(13)+char(10)
		delete from #clust_tb01 where text01 = char(10)+char(13)
		delete from #clust_tb01 where text01 not like 'SQL Network Name%'
		delete from #clust_tb01 where text01 not like '%' + @save_servername + '%'
		--select * from #clust_tb01

		If (select count(*) from #clust_tb01) > 0
		   begin
			Select @save_sqlnetname = (select top 1 text01 from #clust_tb01)
			Select @charpos = charindex(')', @save_sqlnetname)
			IF @charpos <> 0
			   begin
				Select @save_sqlnetname = substring(@save_sqlnetname, @charpos+1, 100)
				Select @save_sqlnetname = ltrim(@save_sqlnetname)

				Select @charpos = charindex(' ', @save_sqlnetname)
				IF @charpos <> 0
				   begin
					Select @save_sqlnetname = substring(@save_sqlnetname, 1, @charpos-1)
					Select @save_sqlnetname = rtrim(@save_sqlnetname)
				   end

				delete from #clust_tb01
				select @cmd = 'cluster group /status'
				--print @cmd
				insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
				delete from #clust_tb01 where text01 is null
				delete from #clust_tb01 where text01 = char(13)
				delete from #clust_tb01 where text01 = char(10)
				delete from #clust_tb01 where text01 = char(13)+char(10)
				delete from #clust_tb01 where text01 = char(10)+char(13)
				delete from #clust_tb01 where text01 not like '%' + @save_sqlnetname + '%'
				--select * from #clust_tb01

			   end
			Else
			   begin
				goto skip_policy
			   end
		   end
		Else
		   begin
			goto skip_policy
		   end
	   end
	Else
	   begin
		Select @save_sqlnetname = @save_servername 
	   end


	If (select count(*) from #clust_tb01) > 0
	   begin
		Select @save_nodename = (select top 1 text01 from #clust_tb01 where text01 like '%' + @save_sqlnetname + '%')
		Select @charpos = charindex('  ', @save_nodename)
		IF @charpos <> 0
		   begin
			Select @save_nodename = substring(@save_nodename, @charpos+2, 200)
			Select @save_nodename = ltrim(@save_nodename)
		   end

		Select @charpos = charindex(' ', @save_nodename)
		IF @charpos <> 0
		   begin
			Select @save_nodename = substring(@save_nodename, 1, @charpos-1)
			Select @save_nodename = rtrim(@save_nodename)
		   end

		Select @save_checkname = 'check_localpolicy_' + @save_nodename

		If not exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = @save_checkname)
		   begin
			exec dbaadmin.dbo.dbasp_dba_setpolicygrants
			insert into dbaadmin.dbo.Local_ServerEnviro values (@save_checkname, @save_servername) 
		   end
	   end
	Else
	   begin
		Select @miscprint = '--DBA WARNING: Unable to determine cluster node name for dbasp_dba_setpolicygrants process.' 
		Print @miscprint
		raiserror(@miscprint,-1,-1) with log
	   end

   end

skip_policy:





----------------------------------------------------------------------------------------------
--  Start the Capture Process
----------------------------------------------------------------------------------------------

--  Create the MSINFO output file
select @cmd = 'msinfo32 /categories +IEsummary /report c:\msinfo_' + @save_servername2 + '.txt'
exec master.sys.xp_cmdshell @cmd, no_output


--  Capture the SQL version
Start_check:
Select @charpos = charindex(char(10), @save_version)
IF @charpos <> 0
   begin
	select @save_version = stuff(@save_version, @charpos, 1, '')
	goto start_check
   end


--  Capture the SQL install date
Select @save_SQL_install_date = (select createdate from master.sys.syslogins where name = 'NT AUTHORITY\SYSTEM')


--  Capture Last SQL recycle date
Select @save_SQLrecycle_date = (select convert(sysname, create_date, 120) from master.sys.databases where name = 'tempdb')


--  Capture the service accounts (Note:  We have to strip off the last byte from config_value because it's not printable)
If @isNMinstance = 'n'
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\MSSQLServer'
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end
Else
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\MSSQL$' + @save_sqlinstance
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end

Select @save_SQLSvcAcct = @result_value

Select @charpos = charindex('\', @save_SQLSvcAcct)
IF @charpos <> 0
   begin
	Select @save_SQLSvcAcct = rtrim(substring(@save_SQLSvcAcct, @charpos+1, 100))
	goto get_SQLSvcAcct_end
   end

Select @charpos = charindex('@', @save_SQLSvcAcct)
IF @charpos <> 0
   begin
	Select @save_SQLSvcAcct = rtrim(substring(@save_SQLSvcAcct, 1, @charpos-1))
	goto get_SQLSvcAcct_end
   end

get_SQLSvcAcct_end:

If @save_SQLSvcAcct is null or @save_SQLSvcAcct = ''
   begin
	Select @save_SQLSvcAcct = 'unknown'
   end


If @isNMinstance = 'n'
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\SQLServerAgent'
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end
Else
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\SQLAgent$' + @save_sqlinstance
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end

Select @save_SQLAgentAcct = @result_value

Select @charpos = charindex('\', @save_SQLAgentAcct)
IF @charpos <> 0
   begin
	Select @save_SQLAgentAcct = rtrim(substring(@save_SQLAgentAcct, @charpos+1, 100))
	goto get_SQLAgentAcct_end
   end

Select @charpos = charindex('@', @save_SQLAgentAcct)
IF @charpos <> 0
   begin
	Select @save_SQLAgentAcct = rtrim(substring(@save_SQLAgentAcct, 1, @charpos-1))
	goto get_SQLAgentAcct_end
   end

get_SQLAgentAcct_end:

If @save_SQLAgentAcct is null or @save_SQLAgentAcct = ''
   begin
	Select @save_SQLAgentAcct = 'unknown'
   end



--  Capture the SQL Startup Parameters
Select @save_SQLStartupParms = ''

--  Get the instalation directory folder name
select @in_key = 'HKEY_LOCAL_MACHINE'
select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'
select @in_value = @save_sqlinstance
exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output

If @result_value is null or @result_value = ''
   begin
	goto startup_parm_end
   end

--  Now get the startup parms
select @save_install_folder = @result_value
select @in_key = 'HKEY_LOCAL_MACHINE'
select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\' + @save_install_folder + '\MSSQLServer\Parameters'

If @@version like '%x64%'
   begin
	Select @cmd = 'reg2 query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /s'
   end
Else
   begin
	Select @cmd = 'reg query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /s'
   end
--print @cmd

insert into #regresults exec master.sys.xp_cmdshell @cmd
delete from #regresults where results is null
--select * from #regresults



If exists (select 1 from #regresults where results like '%but is for a machine type%')
   begin
	Select @cmd = 'reg2 query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /s'
	--print @cmd

	insert into #regresults exec master.sys.xp_cmdshell @cmd
	--select * from #regresults
	delete from #regresults where results is null
	delete from #regresults where results like '%but is for a machine type%'
   end

delete from #regresults where results not like '%REG_SZ%'
delete from #regresults where results like '%ERROR:%'

startup_parm_start:
If (select count(*) from #regresults) > 1
   begin
	select @hold_SQLStartupParms = (select top 1 results from #regresults)
	Select @charpos = charindex('REG_SZ', @hold_SQLStartupParms)
	IF @charpos <> 0
	   begin
		Select @hold_SQLStartupParms = rtrim(substring(@hold_SQLStartupParms, @charpos+6, 100))
	   end

	Delete from #regresults where results like '%' + @hold_SQLStartupParms + '%'
	Select @save_SQLStartupParms = @save_SQLStartupParms + ltrim(@hold_SQLStartupParms) + ';'
	goto startup_parm_start
   end
Else If (select count(*) from #regresults) > 0
   begin
	select @hold_SQLStartupParms = (select top 1 results from #regresults)
	Select @charpos = charindex('REG_SZ', @hold_SQLStartupParms)
	IF @charpos <> 0
	   begin
		Select @hold_SQLStartupParms = rtrim(substring(@hold_SQLStartupParms, @charpos+7, 100))
	   end

	Delete from #regresults where results like '%' + @hold_SQLStartupParms + '%'
	Select @save_SQLStartupParms = @save_SQLStartupParms + ltrim(@hold_SQLStartupParms)
   end

startup_parm_end:




--  Check to see if SQL is set up to scan for startup sprocs
If (select convert(int, value_in_use) from master.sys.configurations where name like '%scan for startup procs%') = 1
   begin
	Select @save_SQLScanforStartupSprocs = 'n'
   end


--  Get domain name
Select @save_domain_name = (select top 1 env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'domain')
If @save_domain_name is null
   begin
	Select @save_domain_name = 'Unknown'
   end


--  Check for clustering
If (SERVERPROPERTY('IsClustered')) = 0
   begin
	Select @save_iscluster = 'n'
   end
Else
   begin
	Select @save_iscluster = 'y'
   end


--  Capture the dbaadmin version
Select @save_dbaadmin_build = (select top 1 vchLabel from dbaadmin.dbo.build where vchName = 'dbaadmin' order by iBuildID desc)

If @save_dbaadmin_build is null or @save_dbaadmin_build = ''
   begin
	Select @save_dbaadmin_build = 'none'
   end


--  Capture the dbaperf version
If exists (select 1 from master.sys.databases where name = 'dbaperf')
   begin
	Select @save_dbaperf_build = (select top 1 vchLabel from dbaperf.dbo.build where vchName = 'dbaperf' order by iBuildID desc)

	If @save_dbaperf_build is null or @save_dbaperf_build = ''
	   begin
		Select @save_dbaperf_build = 'none'
	   end
   end
Else
   begin
	Select @save_dbaperf_build = 'n/a'
   end



--  Capture the DEPLinfo version
If exists (select 1 from master.sys.databases where name = 'DEPLinfo')
   begin
	Select @save_DEPLinfo_build = (select top 1 vchLabel from DEPLinfo.dbo.build where vchName = 'DEPLinfo' order by iBuildID desc)

	If @save_DEPLinfo_build is null or @save_DEPLinfo_build = ''
	   begin
		Select @save_DEPLinfo_build = 'none'
	   end
   end
Else
   begin
	Select @save_DEPLinfo_build = 'n/a'
   end



--  Capture Backup Type
If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_type' and Env_detail = 'LiteSpeed')
   begin
	Select @save_backup_type = 'LiteSpeed'
   end
Else If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_type' and Env_detail = 'RedGate')
   begin
	Select @save_backup_type = 'RedGate'
   end
Else If exists (select 1 from dbaadmin.dbo.Local_ServerEnviro where env_type = 'backup_type' and Env_detail = 'Standard')
   begin
	Select @save_backup_type = 'Standard'
   end
Else 
   begin
	Select @save_backup_type = 'Default'
   end



--  Capture LiteSpeed Version (if installed)
Select @save_ls_version = 'na'
If exists (select * from master.sys.objects where name = 'xp_sqllitespeed_version' and type = 'x')
   begin
	Select @save_ls_version = (select env_detail from dbo.Local_ServerEnviro where env_type = 'backup_ls_version')
	Select @save_ls_versiontype = (select env_detail from dbo.Local_ServerEnviro where env_type = 'backup_ls_versiontype')
	Select @save_ls_license = 'na'

	Select @save_ls_installdate = (select create_date from master.sys.objects where name = 'xp_sqllitespeed_version' and type = 'x')

	Select @save_compbackup_ls_flag = 'y'
   end


--  Capture RedGate Version (if installed)
Select @save_rg_version = 'na'
If exists (select 1 from master.sys.objects where name = 'sqlbackup' and type = 'x')
   begin
	Select @save_rg_version = (select env_detail from dbo.Local_ServerEnviro where env_type = 'backup_rg_version')
	Select @save_rg_versiontype = (select env_detail from dbo.Local_ServerEnviro where env_type = 'backup_rg_versiontype')
	Select @save_rg_license = (select env_detail from dbo.Local_ServerEnviro where env_type = 'backup_rg_license')

	Select @save_rg_installdate = (select create_date from master.sys.objects where name = 'sqlbackup' and type = 'x')

	Select @save_compbackup_rg_flag = 'y'


	--  set retention for Redgate log files
	insert into #SqbOutput exec master.dbo.sqbutility @Parameter1=1008,@Parameter2=@p2 output
	--select @p2

	If @p2 like '%LogDelete=0%'
	   begin
		insert into #SqbOutput exec master.dbo.sqbutility @Parameter1=1041,@Parameter2=N'LogDelete',@Parameter3=1,@Parameter4=@p4 output
		insert into #SqbOutput exec master.dbo.sqbutility @Parameter1=1041,@Parameter2=N'LogDeleteHours',@Parameter3=168,@Parameter4=@p5 output
	   end
   end





--  Capture SQL AWE setting
--  Capture SQL Max DOP setting
--  Capture SQL memory Limit
--  CLR Enabled
delete from #config
insert into #config exec master.sys.sp_configure

If (select run05 from #config where name01 = 'awe enabled') = 1
   begin
	Select @save_awe_enabled = 'y'
   end
Else
   begin
	Select @save_awe_enabled = 'n'
   end

Select @save_MAXdop_value = (select run05 from #config where name01 = 'max degree of parallelism')
If @save_MAXdop_value is null
   begin
	Select @save_MAXdop_value = 'Unknown'
   end

Select @save_SQLmax_memory = (select run05 from #config where name01 like '%max server memory%')
If @save_SQLmax_memory is null
   begin
	Select @save_SQLmax_memory = 'Unknown'
   end

If (select run05 from #config where name01 = 'clr enabled') = 1
   begin
	Select @save_clr_enabled = 'y'
   end
Else
   begin
	Select @save_clr_enabled = 'n'
   end



--  Capture TempDB files (number of)
Select @save_tempdb_filecount = (select convert(nvarchar(5), count(*)) from tempdb.sys.sysfiles where groupid <> 0)


--  check for linked servers
Select @save_LinkedServers = 'n'
If exists (select 1 from master.sys.servers where name <> @@servername)
   begin
	Select @save_LinkedServers = 'y'
   end


--  check for local passwords
Select @save_LocalPasswords = 'n'
If exists (select 1 from dbaadmin.dbo.local_control where subject like 'pw_%')
   begin
	Select @save_LocalPasswords = 'n'
   end


--
--  START DB CAPTURE PROCESS
--

--  Capture ENV related info
--  Set ENVnum value
If @save_envname in ('production', 'stage', 'staging', 'alpha', 'beta', 'prodsupport')
   begin
	Select @save_envnum = rtrim(@save_envname)
	goto envnum_end
   end

--  First check the instance name
Select @charpos = charindex('01', @save_sqlinstance)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '01'
	goto envnum_end
   end

Select @charpos = charindex('02', @save_sqlinstance)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '02'
	goto envnum_end
   end
	
Select @charpos = charindex('03', @save_sqlinstance)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '03'
	goto envnum_end
   end
	
Select @charpos = charindex('04', @save_sqlinstance)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '04'
	goto envnum_end
   end


--  Now check the server name
Select @charpos = charindex('01', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '01'
	goto envnum_end
   end
	
Select @charpos = charindex('02', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '02'
	goto envnum_end
   end
	
Select @charpos = charindex('03', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '03'
	goto envnum_end
   end
	
Select @charpos = charindex('04', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '04'
	goto envnum_end
   end
	
Select @charpos = charindex('1', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '01'
	goto envnum_end
   end
	
Select @charpos = charindex('2', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '02'
	goto envnum_end
   end
	
Select @charpos = charindex('3', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '03'
	goto envnum_end
   end
	
Select @charpos = charindex('4', @save_servername)
IF @charpos <> 0
   begin
	Select @save_envnum = rtrim(@save_envname) + '04'
	goto envnum_end
   end

--  Default to '01' if the naming convention is not found in the instance or the servername
Select @save_envnum = rtrim(@save_envname) + '01'

envnum_end:



-- Create script to delete all rows on the central server dbaadmin.dbo.DBA_DBInfo related to this SQL server
Select @miscprint = ' '
Print  @miscprint

Select @miscprint = '--  Start DBA_DBInfo Updates'
Print  @miscprint

Select @miscprint = 'delete from dbo.DBA_DBInfo where SQLName = ''' + @@servername + ''' and moddate < getdate()-60'
Print  @miscprint

Select @miscprint = 'go'
Print  @miscprint

Select @miscprint = ' '
Print  @miscprint

raiserror('', -1,-1) with nowait


--------------------  Cursor 11  -----------------------
EXECUTE('DECLARE cursor_11DBNames Insensitive Cursor For ' + 
  'SELECT d.name, d.database_id
   From master.sys.databases   d ' + 
  'Where d.database_id > 4
   Order By d.name For Read Only')

OPEN cursor_11DBNames

WHILE (11=11)
   Begin
	FETCH Next From cursor_11DBNames Into @cu11DBName, @cu11DBId
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11DBNames
	      BREAK
           end

	--  skip DB's "_new" and "_nxt"
	If @cu11DBName like '%_new' or @cu11DBName like '%_nxt'
	   begin
		goto loop11_end
	   end

        -- skip baseline databases
	if @cu11DBName in (SELECT detail01 from dbaadmin.dbo.no_check where NoCheck_Type = 'baseline')
           begin
                goto loop11_end
           end


	Select @miscprint = '--  ' + @cu11DBName
	Print  @miscprint

	Select @save_DBstatus = convert(sysname, (SELECT DATABASEPROPERTYEX (@cu11DBName,'status')))

	Select @save_DBCreateDate = (select create_date from master.sys.databases where name = @cu11DBName)

	Select @depl_flag = 'n'
	Select @save_RSTRfolder = ''
	Select @save_baseline_srvname = ''
	Select @save_Appl_desc = ''
	Select @save_db_FullTextCat = 'n'
	Select @save_db_Mirroring = 'n'
	Select @save_db_Assemblies = 'n'
	Select @save_db_Repl_Flag = 'n'
	Select @save_db_LogShipping = 'n'
	Select @save_db_ReportingSvcs = 'n'
	Select @save_db_StartupSprocs = 'n'
	Select @Filesize_dataonly = 0
	Select @Filesize_logonly = 0

	If @cu11DBName in ('dbaadmin', 'dbaperf', 'dbacentral', 'DEPLinfo', 'DEPLcontrol', 'systeminfo')
	   begin
		goto end_ApplCrossRef
	   end


	--  Determine Appl_desc and baseline folder info
	Select @save_count = (Select count(*) from dbaadmin.dbo.db_ApplCrossRef where db_name = @cu11DBName)

	If @save_count = 1
	   begin
		Select @save_RSTRfolder = (Select top 1 RSTRfolder from dbaadmin.dbo.db_ApplCrossRef where db_name = @cu11DBName)
		Select @save_Appl_desc = (Select top 1 Appl_desc from dbaadmin.dbo.db_ApplCrossRef where db_name = @cu11DBName)
		Select @save_baseline_srvname = (Select top 1 Baseline_srvname from dbaadmin.dbo.db_ApplCrossRef where db_name = @cu11DBName)
	   end
	Else If @save_count > 1
	   begin
		Select @save_seq_id = 0

		Start_ApplCrossRef01:

		Select @save_seq_id = (Select top 1 seq_id from dbaadmin.dbo.db_ApplCrossRef where db_name = @cu11DBName and seq_id > @save_seq_id order by seq_id)
		Select @save_companionDB_name = (Select companionDB_name from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)

		If exists (select 1 from master.sys.databases where name = @save_companionDB_name)
		   begin
			Select @save_RSTRfolder = (Select top 1 RSTRfolder from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
			Select @save_Appl_desc = (Select top 1 Appl_desc from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
			Select @save_baseline_srvname = (Select top 1 Baseline_srvname from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
			goto end_ApplCrossRef
		   end

		If exists (Select 1 from dbaadmin.dbo.db_ApplCrossRef where db_name = @cu11DBName and seq_id > @save_seq_id)
		   begin
			goto Start_ApplCrossRef01
		   end
	   end
	Else If @save_count = 0
	   begin
		--  Check for partial DB_names in the db_ApplCrossRef table
		Select @save_seq_id = 0

		Start_ApplCrossRef02:

		Select @save_seq_id = (Select top 1 seq_id from dbaadmin.dbo.db_ApplCrossRef where db_name like '%*' and seq_id > @save_seq_id order by seq_id)
		Select @hold_DB_name = (Select db_name from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
		Select @save_companionDB_name = (Select companionDB_name from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
	    
		Select @hold_DB_name = replace(@hold_DB_name, '*', '%')

		If @cu11DBName like @hold_DB_name
		   begin
			If @save_companionDB_name = ''
			   begin
				Select @save_RSTRfolder = (Select top 1 RSTRfolder from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
				Select @save_Appl_desc = (Select top 1 Appl_desc from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
				Select @save_baseline_srvname = (Select top 1 Baseline_srvname from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
				goto end_ApplCrossRef
			   end
			Else If exists (select 1 from master.sys.databases where name = @save_companionDB_name)
			   begin
				Select @save_RSTRfolder = (Select top 1 RSTRfolder from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
				Select @save_Appl_desc = (Select top 1 Appl_desc from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
				Select @save_baseline_srvname = (Select top 1 Baseline_srvname from dbaadmin.dbo.db_ApplCrossRef where seq_id = @save_seq_id)
				goto end_ApplCrossRef
			   end
		   end

		If exists (Select 1 from dbaadmin.dbo.db_ApplCrossRef where db_name like '%*' and seq_id > @save_seq_id)
		   begin
			goto Start_ApplCrossRef02
		   end


		--  No db_name match or partial db_name match.  Check to see if this instance is used for a single Appl_desc.  If so, use that.
		Select @hold_dbid = 4
		Select @save_count2 = 0
		Select @hold_Appl_desc = ''

		Start_ApplCrossRef03:

		Select @hold_DB_name = (select top 1 name from  master.sys.databases Where database_id > @hold_dbid)

		Select @hold_dbid = (select database_id from  master.sys.databases Where name = @hold_DB_name)

		Select @save_count = (Select count(*) from dbaadmin.dbo.db_ApplCrossRef where db_name = @hold_DB_name)
	    
		If @save_count = 1
		   begin
			If (Select top 1 Appl_desc from dbaadmin.dbo.db_ApplCrossRef where db_name = @hold_DB_name) <> @hold_Appl_desc
			   begin
				Select @save_count2 = @save_count2 + 1
				Select @hold_Appl_desc = (Select top 1 Appl_desc from dbaadmin.dbo.db_ApplCrossRef where db_name = @hold_DB_name)
			   end
		   end

		If @save_count2 > 1
		   begin
			Select @hold_Appl_desc = ''
			goto end_ApplCrossRef
		   end

		If exists (select 1 from  master.sys.databases Where database_id > @hold_dbid)
		   begin
			goto Start_ApplCrossRef03
		   end

		If @save_count2 = 1
		   begin
			Select @save_Appl_desc = @hold_Appl_desc
			Select @save_baseline_srvname = (Select top 1 Baseline_srvname from dbaadmin.dbo.db_ApplCrossRef where Appl_desc = @hold_Appl_desc)
		   end

	   end

	end_ApplCrossRef:


	If @save_baseline_srvname is null or @save_baseline_srvname = ''
	   begin
		Select @save_baseline_srvname = @central_server
	   end

	If @save_domain_name in ('production', 'stage') or @save_envname = 'Production'
	   begin
		Select @save_baseline_srvname = (select top 1 env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'CentralServer')
	   end

	--  If the database is not online, skip the info capture
	if @save_DBstatus <> 'ONLINE'
	   begin
		goto skip_11
	   end


	--  Check the build table if it exists
	Select @save_build = ''
	Select @save_BaselineDate = ''
    
	Select @cmd = 'select @save_count = (select count(*) from [' + @cu11DBName + '].sys.objects o, [' + @cu11DBName + '].sys.columns c where o.object_id = c.object_id and o.name = ''build'' and o.type = ''U'' and o.schema_id = 1 and c.name = ''vchName'')'
	EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

	If @save_count is not null and @save_count = 1
	   begin
		Select @cmd = 'select @save_build = (select top 1 vchLabel from [' + @cu11DBName + '].dbo.build where vchName = ''' + @cu11DBName + ''' and vchLabel not like ''%Backup, Detach%'' order by ibuildid desc)'
		EXEC sp_executesql @cmd, N'@save_build sysname output', @save_build output

		Select @cmd = 'select @save_BaselineDate = (select top 1 dtBuildDate from [' + @cu11DBName + '].dbo.build where vchLabel = ''Baseline Backup'' or vchLabel = ''Backup, Detach & Move'' order by ibuildid desc)'
		EXEC sp_executesql @cmd, N'@save_BaselineDate sysname output', @save_BaselineDate output
	   end

	If @save_build is null
	   begin
		Select @save_build = ''
	   end

	If @save_BaselineDate is null
	   begin
		Select @save_BaselineDate = ''
	   end


	--  Check to see if this DB is part of the DEPL process
	If exists (select 1 from dbo.db_sequence where db_name = @cu11DBName)
	   and not exists(select 1 from dbo.No_Check where NoCheck_type = 'DEPL_RD_Skip' and (detail01 = @cu11DBName or detail01 = 'all'))
	   begin
		Select @depl_flag = 'y'
		Select @save_depl_flag = 'y'
	   end


	-- check for active full text catalogs
    	Select @cmd = 'select @save_count = (select count(*) from master.sys.dm_fts_active_catalogs df, master.sys.databases d where df.database_id = d.database_id and d.name = ''' + @cu11DBName + ''')'
	EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

	If @save_count is not null and @save_count > 0
	   begin
		Select @save_db_FullTextCat = 'y'
		Select @save_FullTextCat = 'y'
	   end



	-- check for assemblies
	If not exists (select 1 from dbo.no_check where NoCheck_type = 'backup' and detail01 = @cu11DBName)
	   begin
		Select @cmd = 'select @save_count = (select count(*) from [' + @cu11DBName + '].sys.assemblies)'
		EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

		If @save_count is not null and @save_count > 0
		   begin
			Select @save_db_Assemblies = 'y'
			Select @save_Assemblies = 'y'
		   end
	   end


	--  check for mirroring
    	Select @cmd = 'select @save_count = (select count(*) from [' + @cu11DBName + '].sys.database_mirroring where mirroring_state is not null)'
	EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

	If @save_count is not null and @save_count > 0
	   begin
		Select @save_db_Mirroring = 'y'
		Select @save_Mirroring = 'y'
	   end


	-- check for replication
    	Select @cmd = 'select @save_count = (select count(*) from master.sys.databases where name = ''' + @cu11DBName + ''' and (is_published = 1 or is_subscribed = 1 or is_distributor = 1))'
	EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

	If @save_count is not null and @save_count > 0
	   begin
		Select @save_db_Repl_Flag = 'y'
		Select @save_Repl_Flag = 'y'
	   end


	--  check for log shipping
    	Select @cmd = 'select @save_count = (select count(*) from msdb.dbo.log_shipping_primary_databases where primary_database = ''' + @cu11DBName + ''')'
	EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

	If @save_count is not null and @save_count > 0
	   begin
		Select @save_db_LogShipping = 'y'
		Select @save_LogShipping = 'y'
	   end


	--  check for Report Services
    	Select @cmd = 'select @save_count = (select count(*) from [' + @cu11DBName + '].sys.sysusers Where issqlrole = 1 and name = ''RSExecRole'')'
	EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

	If @save_count is not null and @save_count > 0
	   begin
		Select @save_db_ReportingSvcs = 'y'
		Select @save_ReportingSvcs = 'y'
	   end


	--  check for startup sprocs
    	Select @cmd = 'select @save_count = (select count(*) from [' + @cu11DBName + '].sys.sysobjects where xtype = ''p'' and OBJECTPROPERTY(id, ''ExecIsStartup'') = 1)'
	EXEC sp_executesql @cmd, N'@save_count int output', @save_count output

	If @save_count is not null and @save_count > 0
	   begin
		Select @save_db_StartupSprocs = 'y'
	   end



	--  Get the file sizes
	--------------------  Cursor 12  -----------------------
	select @Logsize = 0
	select @Datasize = 0
	
	EXECUTE('DECLARE cursor_12FILEsize Insensitive Cursor For ' + 
	  'SELECT (convert(dec(15),a.size)), a.groupid 
	   From [' + @cu11DBName + '].sys.sysfiles a ')
	
	OPEN cursor_12FILEsize
	
	WHILE (12=12)
	   Begin
		FETCH Next From cursor_12FILEsize Into @cu12FILEsize, @cu12FILEgroupid 
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cursor_12FILEsize
		      BREAK
	           end
	
		If @cu12FILEgroupid = 0
		   begin
		     select @Logsize = @cu12FILEsize + @Logsize
		   end	
		Else
		   begin
		     select @Datasize = @cu12FILEsize + @Datasize
		   end	
	
	End  -- loop 12
	DEALLOCATE cursor_12FILEsize


	Select @Filesize_logonly = @Filesize_logonly + (@Logsize / @pagesperMB)
	Select @Filesize_dataonly = @Filesize_dataonly + (@Datasize / @pagesperMB)


	--  Get the row count for this DB
    	Select @cmd = 'select @save_row_count = (select sum(rowcnt) from [' + @cu11DBName + '].sys.sysindexes where indid in (0,1))'
	EXEC sp_executesql @cmd, N'@save_row_count bigint output', @save_row_count output

	If @save_row_count is null
	   begin
		Select @save_row_count = 0
	   end


	--  Get the recovery model for this DB
	Select @save_RecovModel = convert(sysname, DATABASEPROPERTYEX(@cu11DBName, 'recovery'))
	If @save_RecovModel is null
	   begin
		Select @save_RecovModel = 'Unknown'
	   end

	-- Get database compatibility level for this DB
	Select @save_cmptlvl = convert(nvarchar(10), compatibility_level) from master.sys.databases where name = @cu11DBName
	if @save_cmptlvl is null
	    begin
		Select @save_cmptlvl = 'Unknown'
	    end

	skip_11:


	-- Create script to insert this row on the central server dbo.DBA_DBInfo related for this SQL server
	Select @miscprint = 'if not exists (select 1 from dbo.DBA_DBInfo where SQLName = ''' + upper(@@servername) + ''' and DBname = ''' + rtrim(@cu11DBName) + ''')'
	Print  @miscprint

	Select @miscprint = '   begin'
	Print  @miscprint

	Select @miscprint = '      INSERT INTO dbo.DBA_DBInfo (SQLName, DBName, status, CreateDate) VALUES (''' + upper(@@servername) + ''', ''' + rtrim(@cu11DBName) + ''', ''' + @save_DBstatus + ''', ''' + convert(nvarchar(30), @save_DBCreateDate, 121) + ''')'
	Print  @miscprint

	Select @miscprint = '   end'
	Print  @miscprint

	Select @miscprint = 'go'
	Print  @miscprint

	Select @miscprint = ' '
	Print  @miscprint

	raiserror('', -1,-1) with nowait

	Select @miscprint = 'Update dbo.DBA_DBInfo set ENVname = ''' + @save_ENVname + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,ENVnum = ''' + @save_ENVnum + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,status = ''' + @save_DBstatus + ''''
	Print  @miscprint

	Select @miscprint = '                    ,CreateDate = ''' + convert(nvarchar(30), @save_DBCreateDate, 121) + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,Appl_desc = ''' + @save_Appl_desc + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,BaselineFolder = ''' + @save_RSTRfolder + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,BaselineServername = ''' + upper(@save_baseline_srvname) + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,BaselineDate = ''' + @save_BaselineDate + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,build = ''' + @save_build + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,data_size_MB = ''' + convert(nvarchar(20), @Filesize_dataonly) + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,log_size_MB = ''' + convert(nvarchar(20), @Filesize_logonly) + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,row_count = ' + convert(nvarchar(20), @save_row_count) + ''
	Print  @miscprint

	Select @miscprint = '                                  ,RecovModel = ''' + @save_RecovModel + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,FullTextCat = ''' + @save_db_FullTextCat + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,Assemblies = ''' + @save_db_Assemblies + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,Mirroring = ''' + @save_db_Mirroring + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,Repl_Flag = ''' + @save_db_Repl_Flag + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,LogShipping = ''' + @save_db_LogShipping + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,ReportingSvcs = ''' + @save_db_ReportingSvcs + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,StartupSprocs = ''' + @save_db_StartupSprocs + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,DBCompat = ''' + @save_cmptlvl + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,DEPLstatus = ''' + @depl_flag + ''''
	Print  @miscprint

	Select @miscprint = '                                  ,modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
	Print  @miscprint


	Select @miscprint = 'where SQLName = ''' + upper(@@servername) + ''' and DBName = ''' + rtrim(@cu11DBName) + ''''
	Print  @miscprint

	Select @miscprint = 'go'
	Print  @miscprint

	Select @miscprint = ' '
	Print  @miscprint

	raiserror('', -1,-1) with nowait


loop11_end:


End  -- loop 11
DEALLOCATE cursor_11DBNames




--  Verify DEPLstatus setting
If @save_depl_flag = 'y' and exists (select 1 from dbo.No_Check where NoCheck_type = 'DEPL_RD_Skip' and detail01 = 'all')
   begin
	Select @save_depl_flag = 'n'
   end


--  Check for the Oracle Client
delete from #temp_tbl1
Select @cmd = 'tnsping infoaccess'
insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl1 where text01 is null or text01 = ''
Delete from #temp_tbl1 where text01 not like '%:\%'
--select * from #temp_tbl1

Select @save_OracleClient = 'na'
Select @save_TNSnamesPath = 'na'
	
If (select count(*) from #temp_tbl1) > 0
   begin
	Select @save_TNSnamesPath = (select top 1 text01 from #temp_tbl1)
	select @charpos = 0

	startTNSnamesPath:
	select @charpos2 = charindex('\', @save_TNSnamesPath, @charpos)

	If @charpos2 > 0
	   begin
		Select @charpos = @charpos2+1
		goto startTNSnamesPath
	   end

	If @charpos > 0
	   begin
		Select @save_TNSnamesPath = substring(@save_TNSnamesPath, 1, @charpos-2)
	   end

	Select @save_OracleClient = 'unknown'


	If @save_TNSnamesPath like '%.%'
	   begin
		Select @save_OracleClient = @save_TNSnamesPath
		startOracleClient:
		select @charpos = charindex('.', @save_OracleClient)
		select @charpos2 = charindex('\', @save_OracleClient)
	
		If @charpos2 < @charpos
		   begin
			Select @save_OracleClient = substring(@save_OracleClient, @charpos2+1, 200)
			goto startOracleClient
		   end
	
		select @charpos2 = charindex('\', @save_OracleClient)
	
		If @charpos2 > 0
		   begin
			Select @save_OracleClient = substring(@save_OracleClient, 1, @charpos2-1)
		   end
	   end
   end


--  Capture SAN flag
delete from #temp_tbl1
Select @cmd = 'wmic diskdrive list brief'
insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl1 where text01 is null or text01 = ''
--select * from #temp_tbl1

If exists (select 1 from #temp_tbl1 where text01 like '%Powerpath%' or text01 like '%RDAC%' or text01 like '%HSV110%' or text01 like '%FAStT%' or text01 like '%Multi-Path%')
   begin
	Select @save_SAN_flag = 'y'
   end 


--  Capture SQL port
Select @save_port = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'SQL Port')
If @save_port is null or @save_port = ''
   begin
	Select @save_port = 'Error'
   end



--  Capture IP
delete from #temp_tbl1
Select @cmd = 'nslookup ' + @save_servername
insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl1 where text01 is null or text01 = ''
--select * from #temp_tbl1
	
If (select count(*) from #temp_tbl1) > 0
   begin
	Select @save_id = (select top 1 tb11_id from #temp_tbl1 where text01 like '%Name:%')

	Select @save_ip = (select top 1 text01 from #temp_tbl1 where text01 like '%Address:%' and tb11_id > @save_id order by tb11_id)
	Select @save_ip = ltrim(substring(@save_ip, 9, 20))
	Select @save_ip = rtrim(@save_ip)

	Select @charpos = charindex(':', @save_ip)
	IF @charpos <> 0
	   begin
		select @save_ip = substring(@save_ip, 1, @charpos-1)
	   end
   end
Else
   begin
	Select @save_ip = 'Error'
   end


-- If nslookup didn't work, try ping
If @save_ip is null or @save_ip = '' or @save_ip = 'Error'
   begin
	delete from #temp_tbl1
	Select @cmd = 'ping ' + @save_servername + ' -4'
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''
	Delete from #temp_tbl1 where text01 not like '%Reply from%'
	--select * from #temp_tbl1
        	
	If (select count(*) from #temp_tbl1) > 0
	   begin
		Select @save_ip = (select top 1 text01 from #temp_tbl1 where text01 like '%Reply from%')
		Select @save_ip = ltrim(substring(@save_ip, 11, 20))
		Select @charpos = charindex(':', @save_ip)
		IF @charpos <> 0
		   begin
			select @save_ip = substring(@save_ip, 1, @charpos-1)
		   end
	   end
	Else
	   begin
		Select @save_ip = 'Error'
	   end
   end


--  Capture CPU info
delete from #temp_tbl1
Select @cmd = 'echo. | 276610_276610.exe'
insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl1 where text01 is null or text01 = ''
Delete from #temp_tbl1 where text01 not like '%System wide availability%'
--select * from #temp_tbl1


If exists (select 1 from #temp_tbl1 where text01 like '%Assertion failed:%')
   begin
	goto start_htdump
   end

If (select count(*) from #temp_tbl1) = 0
   begin
	Select @save_CPUphysical = 'Unknown'
	Select @save_CPUcore = 'Unknown'
	Select @save_CPUlogical = 'Unknown'
	goto start_htdump
   end

	
--  get physical info
Select @save_CPUphysical = (select top 1 text01 from #temp_tbl1)
select @charpos = charindex(':', @save_CPUphysical)

If @charpos > 0
   begin
	Select @save_CPUphysical = substring(@save_CPUphysical, @charpos+1, 200)
	Select @save_CPUphysical = ltrim(rtrim(@save_CPUphysical))
	Select @save_CPUphysical = replace(@save_CPUphysical, 'processors', '')
	Select @save_CPUcore = @save_CPUphysical
   end

select @charpos = charindex(',', @save_CPUphysical)
If @charpos > 0
   begin
	Select @save_CPUphysical = substring(@save_CPUphysical, 1, @charpos-1)
	Select @save_CPUphysical = ltrim(rtrim(@save_CPUphysical))
   end


--  get core info
select @charpos = charindex(',', @save_CPUcore)

If @charpos > 0
   begin
	Select @save_CPUcore = substring(@save_CPUcore, @charpos+1, 200)
	Select @save_CPUcore = ltrim(rtrim(@save_CPUcore))
	Select @save_CPUlogical = @save_CPUcore
   end

select @charpos = charindex(',', @save_CPUcore)
If @charpos > 0
   begin
	Select @save_CPUcore = substring(@save_CPUcore, 1, @charpos-1)
	Select @save_CPUcore = ltrim(rtrim(@save_CPUcore))
   end


--  get logical info
select @charpos = charindex(',', @save_CPUlogical)

If @charpos > 0
   begin
	Select @save_CPUlogical = substring(@save_CPUlogical, @charpos+1, 200)
	Select @save_CPUlogical = ltrim(rtrim(@save_CPUlogical))
   end

goto start_chkcpu



start_htdump:

delete from #temp_tbl1
Select @cmd = 'htdump.exe'
insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl1 where text01 is null or text01 = ''
Delete from #temp_tbl1 where text01 not like '%System has %'


If (select count(*) from #temp_tbl1) = 0
   begin
	Select @save_CPUphysical = 'Unknown'
	Select @save_CPUcore = 'Unknown'
	Select @save_CPUlogical = 'Unknown'
	goto start_chkcpu
   end

--  get physical info
Select @save_CPUlogical = (select top 1 text01 from #temp_tbl1)
select @charpos = charindex('System has ', @save_CPUlogical)

If @charpos > 0
   begin
	Select @save_CPUlogical = substring(@save_CPUlogical, @charpos+11, 200)
	Select @save_CPUlogical = ltrim(rtrim(@save_CPUlogical))
	Select @save_CPUphysical = @save_CPUlogical
   end

select @charpos = charindex('processor', @save_CPUlogical)
If @charpos > 0
   begin
	Select @save_CPUlogical = substring(@save_CPUlogical, 1, @charpos-1)
	Select @save_CPUlogical = ltrim(rtrim(@save_CPUlogical))
   end


--  get physical info
select @charpos = charindex('exposed by ', @save_CPUphysical)

If @charpos > 0
   begin
	Select @save_CPUphysical = substring(@save_CPUphysical, @charpos+11, 200)
	Select @save_CPUphysical = ltrim(rtrim(@save_CPUphysical))
   end

select @charpos = charindex('processor', @save_CPUphysical)
If @charpos > 0
   begin
	Select @save_CPUphysical = substring(@save_CPUphysical, 1, @charpos-1)
	Select @save_CPUphysical = ltrim(rtrim(@save_CPUphysical))
   end



start_chkcpu:
--  One last try with chkcpu32.exe
If @save_CPUphysical is null or @save_CPUphysical = '' or @save_CPUphysical = 'Unknown'
   or @save_CPUcore is null or @save_CPUcore = '' or @save_CPUcore = 'Unknown'
   or @save_CPUlogical is null or @save_CPUlogical = '' or @save_CPUlogical = 'Unknown'
   begin
	delete from #temp_tbl1
	Select @cmd = 'chkcpu32.exe'
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''

	If (select count(*) from #temp_tbl1 where text01 like '%System CPU count%') = 0
	   begin
		If @save_CPUphysical is null or @save_CPUphysical = ''
		   begin
			Select @save_CPUphysical = 'Unknown'
		   end
		If @save_CPUcore is null or @save_CPUcore = ''
		   begin
			Select @save_CPUcore = 'Unknown'
		   end
		If @save_CPUlogical is null or @save_CPUlogical = ''
		   begin
			Select @save_CPUlogical = 'Unknown'
		   end
		goto skip_cpu
	   end
	   
	Select @save_CPUphysical = (select top 1 text01 from #temp_tbl1 where text01 like '%System CPU count%')
	Select @charpos = charindex(':', @save_CPUphysical)

	If @charpos > 0
	   begin
		Select @save_CPUphysical = substring(@save_CPUphysical, @charpos+1, 200)
		Select @save_CPUphysical = ltrim(rtrim(@save_CPUphysical))
		
		Select @charpos = charindex('Physical', @save_CPUphysical)

		If @charpos > 0
		   begin
			Select @save_CPUphysical = left(@save_CPUphysical, @charpos-1)
			Select @save_CPUphysical = ltrim(rtrim(@save_CPUphysical))
			Select @save_CPUphysical_num = convert(smallint, @save_CPUphysical)
			Select @save_CPUphysical = @save_CPUphysical + ' physical'
		   end
	   end
	   


	Select @save_CPUcore = (select top 1 text01 from #temp_tbl1 where text01 like '%System CPU count%')
	Select @charpos = charindex(',', @save_CPUcore)

	If @charpos > 0
	   begin
		Select @save_CPUcore = substring(@save_CPUcore, @charpos+1, 200)
		Select @save_CPUcore = ltrim(rtrim(@save_CPUcore))
		
		Select @charpos = charindex('Core', @save_CPUcore)

		If @charpos > 0
		   begin
			Select @save_CPUcore = left(@save_CPUcore, @charpos-1)
			Select @save_CPUcore = ltrim(rtrim(@save_CPUcore))
			Select @save_CPUcore_num = convert(smallint, @save_CPUcore)
			Select @save_CPUcore_num = @save_CPUphysical_num * @save_CPUcore_num
			Select @save_CPUcore = convert(nvarchar(10), @save_CPUcore_num) + ' core(s)'
		   end
	   end

 
 	Select @save_CPUlogical = (select top 1 text01 from #temp_tbl1 where text01 like '%System CPU count%')
	Select @charpos = charindex('per CPU', @save_CPUlogical)

	If @charpos > 0
	   begin
		Select @save_CPUlogical = substring(@save_CPUlogical, @charpos+8, 200)
		Select @save_CPUlogical = ltrim(rtrim(@save_CPUlogical))
		
		Select @charpos = charindex('Thread', @save_CPUlogical)

		If @charpos > 0
		   begin
			Select @save_CPUlogical = left(@save_CPUlogical, @charpos-1)
			Select @save_CPUlogical = ltrim(rtrim(@save_CPUlogical))
			Select @save_CPUlogical = @save_CPUlogical + ' logical'
		   end
	   end
   end


skip_cpu:




--  Capture CPU Type
--  Capture OS Name
--  Capture OS Version
--  Capture OS Install Date
--  Capture OS Uptime
--  Capture Memory
--  Capture PageFile size
--  Capture PageFile path
--  Capture Machine Definition
delete from #temp_tbl2
select @cmd = 'systeminfo'
--print @cmd
insert #temp_tbl2(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl2 where text01 is null or text01 = ''
--select * from #temp_tbl2

If (select count(*) from #temp_tbl2) = 0
   begin
	Select @save_CPUtype = ''
	Select @save_OSname = ''
	Select @save_OSver = ''
	Select @save_OSinstallDate = ''
	Select @save_OSuptime = ''
	Select @save_Memory = ''
	Select @save_Pagefile_maxsize = ''
	Select @save_Pagefile_avail = ''
	Select @save_Pagefile_inuse = ''	
	Select @save_Pagefile_path = ''
	Select @save_TimeZone = ''
	Select @save_SystemModel = ''
	goto skip_systeminfo
   end

Select @save_CPUtype = (select top 1 text01 from #temp_tbl2 where text01 like '%stepping%')
Select @charpos = charindex(': ', @save_CPUtype)
IF @charpos <> 0
   begin
	Select @save_CPUtype = ltrim(substring(@save_CPUtype, @charpos+1, 132))
   end

Select @save_OSname = (select top 1 text01 from #temp_tbl2 where text01 like 'OS Name:%')
Select @charpos = charindex(':', @save_OSname)
IF @charpos <> 0
   begin
	Select @save_OSname = ltrim(substring(@save_OSname, @charpos+1, 132))
	If @save_OSname like '%x64%'
	   begin
		Select @save_is64bit = 'y'
	   end
   end

Select @save_OSver = (select top 1 text01 from #temp_tbl2 where text01 like 'OS Version:%')
Select @charpos = charindex(':', @save_OSver)
IF @charpos <> 0
   begin
	Select @save_OSver = ltrim(substring(@save_OSver, @charpos+1, 132))
   end

Select @save_OSinstallDate = (select top 1 text01 from #temp_tbl2 where text01 like 'Original Install Date:%')
Select @charpos = charindex(':', @save_OSinstallDate)
IF @charpos <> 0
   begin
	Select @save_OSinstallDate = ltrim(substring(@save_OSinstallDate, @charpos+1, 132))
   end


If exists (select 1 from #temp_tbl2 where text01 like 'System Up Time:%')
   begin
	Select @save_OSuptime = (select top 1 text01 from #temp_tbl2 where text01 like 'System Up Time:%')
	Select @charpos = charindex(':', @save_OSuptime)
	IF @charpos <> 0
	   begin
		Select @save_OSuptime = ltrim(substring(@save_OSuptime, @charpos+1, 132))
	   end

	select @save_OSuptime_seeddate = getdate()

	Select @charpos = charindex('Days', @save_OSuptime)
	IF @charpos <> 0
	   begin
		select @save_OSuptime_day = ltrim(rtrim(left(@save_OSuptime, @charpos-1)))
		select @save_OSuptime = ltrim(right(@save_OSuptime, len(@save_OSuptime)-@charpos-4))
	   end
   
	Select @charpos = charindex('Hours', @save_OSuptime)
	IF @charpos <> 0
	   begin
		select @save_OSuptime_time_hour = ltrim(rtrim(left(@save_OSuptime, @charpos-1)))
		select @save_OSuptime = ltrim(right(@save_OSuptime, len(@save_OSuptime)-@charpos-5))
	   end
   
	Select @charpos = charindex('Minutes', @save_OSuptime)
	IF @charpos <> 0
	   begin
		select @save_OSuptime_time_minute = ltrim(rtrim(left(@save_OSuptime, @charpos-1)))
		select @save_OSuptime = ltrim(right(@save_OSuptime, len(@save_OSuptime)-@charpos-7))
	   end  
   
	Select @charpos = charindex('Seconds', @save_OSuptime)
	IF @charpos <> 0
	   begin
		select @save_OSuptime_time_second = ltrim(rtrim(left(@save_OSuptime, @charpos-1)))
	   end  
  
	Select @save_OSuptime_seeddate = dateadd (dd, - convert(int, @save_OSuptime_day), @save_OSuptime_seeddate)  
	Select @save_OSuptime_seeddate = dateadd (hh, - convert(int, @save_OSuptime_time_hour), @save_OSuptime_seeddate)  
	Select @save_OSuptime_seeddate = dateadd (mi, - convert(int, @save_OSuptime_time_minute), @save_OSuptime_seeddate)  
	Select @save_OSuptime_seeddate = dateadd (ss, - convert(int, @save_OSuptime_time_second), @save_OSuptime_seeddate)  
	
	Select @save_OSuptime = convert(sysname, @save_OSuptime_seeddate, 120)

   end
Else
   begin
	Select @save_OSuptime = (select top 1 text01 from #temp_tbl2 where text01 like 'System Boot Time:%')
	Select @charpos = charindex(':', @save_OSuptime)
	IF @charpos <> 0
	   begin
		Select @save_OSuptime = ltrim(substring(@save_OSuptime, @charpos+1, 132))
	   end

	Select @charpos = charindex(',', @save_OSuptime)
	IF @charpos <> 0
	   begin
		select @save_OSuptime_date = ltrim(left(@save_OSuptime, @charpos-1))
		select @save_OSuptime_time = ltrim(right(@save_OSuptime, len(@save_OSuptime)-@charpos))
		print @save_OSuptime_date
		print @save_OSuptime_time
	
		Select @charpos = charindex(' ', @save_OSuptime_time)
		IF @charpos <> 0
		   begin
			select @save_OSuptime_meridiem = ltrim(right(@save_OSuptime_time, len(@save_OSuptime_time)-@charpos))
			select @save_OSuptime_time = ltrim(left(@save_OSuptime_time, @charpos-1))
			print @save_OSuptime_meridiem
			print @save_OSuptime_time
		   end
	   
		Select @charpos = charindex('/', @save_OSuptime_date)
		IF @charpos <> 0
		   begin
			select @save_OSuptime_month = ltrim(left(@save_OSuptime_date, @charpos-1))
			select @save_OSuptime_day = ltrim(right(@save_OSuptime_date, len(@save_OSuptime_date)-@charpos))
			Select @save_OSuptime_month = ltrim(rtrim(@save_OSuptime_month))
			If len(@save_OSuptime_month) < 2
			   begin
				Select @save_OSuptime_month = '0' + @save_OSuptime_month
			   end
		   end
	
		Select @charpos = charindex('/', @save_OSuptime_day)
		IF @charpos <> 0
		   begin
			select @save_OSuptime_year = ltrim(right(@save_OSuptime_day, len(@save_OSuptime_day)-@charpos))
			select @save_OSuptime_day = ltrim(left(@save_OSuptime_day, @charpos-1))
			print @save_OSuptime_year
			print @save_OSuptime_day
		   end
	   
		If @save_OSuptime_meridiem = 'PM'
		   begin
			Select @charpos = charindex(':', @save_OSuptime_time)
			IF @charpos <> 0
			   begin
				select @save_OSuptime_time_hour = ltrim(left(@save_OSuptime_time, @charpos-1))
				select @save_OSuptime_time_minute = ltrim(right(@save_OSuptime_time, len(@save_OSuptime_time)-@charpos))
			   end
		   
			Select @save_OSuptime_time_hour = @save_OSuptime_time_hour + 12
			Select @save_OSuptime_time = ltrim(rtrim(@save_OSuptime_time_hour)) + ':' + ltrim(rtrim(@save_OSuptime_time_minute))
		   end

		Select @save_OSuptime = @save_OSuptime_year + '-' + @save_OSuptime_month + '-' + @save_OSuptime_day + ' ' + @save_OSuptime_time

	   end

   end


Select @save_Memory = (select top 1 text01 from #temp_tbl2 where text01 like 'Total Physical Memory:%')
Select @charpos = charindex(':', @save_Memory)
IF @charpos <> 0
   begin
	Select @save_Memory = ltrim(substring(@save_Memory, @charpos+1, 132))
   end


Select @save_Pagefile_maxsize = (select top 1 text01 from #temp_tbl2 where text01 like 'Page File: Max Size:%')
Select @charpos = charindex('Max', @save_Pagefile_maxsize)
IF @charpos <> 0
   begin
	Select @save_Pagefile_maxsize = ltrim(substring(@save_Pagefile_maxsize, @charpos+9, 132))
   end


Select @save_Pagefile_avail = (select top 1 text01 from #temp_tbl2 where text01 like 'Page File: Available:%')
Select @charpos = charindex('Available', @save_Pagefile_avail)
IF @charpos <> 0
   begin
	Select @save_Pagefile_avail = ltrim(substring(@save_Pagefile_avail, @charpos+10, 132))
   end

   
Select @save_Pagefile_inuse = (select top 1 text01 from #temp_tbl2 where text01 like 'Page File: In Use:%')
Select @charpos = charindex('In', @save_Pagefile_inuse)
IF @charpos <> 0
   begin
	Select @save_Pagefile_inuse = ltrim(substring(@save_Pagefile_inuse, @charpos+7, 132))
   end


Select @save_Pagefile_path = ''
Select @save_Pagefile_path2 = (select top 1 text01 from #temp_tbl2 where text01 like 'Page File Location%')
Select @save_id = (select top 1 tbl2_id from #temp_tbl2 where text01 like 'Page File Location%')
Select @charpos = charindex(':', @save_Pagefile_path2)
pagefilepath_loop:
IF @charpos <> 0
   begin
	Select @save_Pagefile_path = @save_Pagefile_path + ltrim(substring(@save_Pagefile_path2, @charpos+1, 132)) + ';'
   end
   
--  Check for more pagefile paths
Select @save_id = @save_id + 1
Select @save_Pagefile_path2 = (select top 1 text01 from #temp_tbl2 where tbl2_id =  @save_id)
If @save_Pagefile_path2 not like 'Domain%' and @save_Pagefile_path2 like '%:\%'
   begin
	goto pagefilepath_loop
   end
   

Select @save_TimeZone = (select top 1 text01 from #temp_tbl2 where text01 like 'Time Zone:%')
Select @charpos = charindex('Zone', @save_TimeZone)
IF @charpos <> 0
   begin
	Select @save_TimeZone = ltrim(substring(@save_TimeZone, @charpos+5, 132))
   end


Select @save_system_man = (select top 1 text01 from #temp_tbl2 where text01 like 'System Manufacturer%')
Select @save_system_man = replace(@save_system_man, char(9), ' ')
Select @charpos = charindex('System Manufacturer', @save_system_man)
IF @charpos <> 0
   begin
	Select @save_system_man = rtrim(ltrim(substring(@save_system_man, @charpos+20, 132)))
   end

Select @save_system_mod = (select top 1 text01 from #temp_tbl2 where text01 like 'System Model%')
Select @save_system_mod = replace(@save_system_mod, char(9), ' ')
Select @charpos = charindex('System Model', @save_system_mod)
IF @charpos <> 0
   begin
	Select @save_system_mod = ltrim(substring(@save_system_mod, @charpos+13, 132))
   end

If @save_system_man is not null and @save_system_mod is not null
   begin
    	Select @save_SystemModel = rtrim(@save_system_man) + ' ' + rtrim(@save_system_mod)
   end
Else
   begin
    	Select @save_SystemModel = 'Unknown'
   end

skip_systeminfo:




--  Capture CPU Type
--  Capture OS Name
--  Capture OS Version
--  Capture Memory
--  Capture PageFile size
--  Capture PageFile path
--  Capture Machine Definition
--  Capture IE version
delete from #temp_tbl2
select @cmd = 'type c:\msinfo_' + @save_servername2 + '.txt'
--print @cmd
insert #temp_tbl2(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl2 where text01 is null or text01 = ''
--select * from #temp_tbl2

If (select count(*) from #temp_tbl2) = 0
   begin
	Select @save_IEver = 'Error'
	goto skip_msinfo
   end

If @save_CPUtype is null or @save_CPUtype = ''
   begin
	Select @save_CPUtype = (select top 1 text01 from #temp_tbl2 where text01 like 'Processor%')
	Select @save_CPUtype = replace(@save_CPUtype, char(9), ' ')
	Select @charpos = charindex('Processor', @save_CPUtype)
	IF @charpos <> 0
	   begin
		Select @save_CPUtype = rtrim(ltrim(substring(@save_CPUtype, @charpos+10, 132)))
	   end
   end

If @save_OSname is null or @save_OSname = ''
   begin
	Select @save_OSname = (select top 1 text01 from #temp_tbl2 where text01 like 'OS Name%')
	Select @save_OSname = replace(@save_OSname, char(9), ' ')
	Select @charpos = charindex('OS Name', @save_OSname)
	IF @charpos <> 0
	   begin
		Select @save_OSname = rtrim(ltrim(substring(@save_OSname, @charpos+8, 132)))
		If @save_OSname like '%x64%'
		   begin
			Select @save_is64bit = 'y'
		   end
	   end
   end

If @save_OSver is null or @save_OSver = ''
   begin
	Select @save_OSver = (select top 1 text01 from #temp_tbl2 where text01 like 'Version%' and text01 like '%Build%')
	Select @save_OSver = replace(@save_OSver, char(9), ' ')
	Select @charpos = charindex('Version', @save_OSver)
	IF @charpos <> 0
	   begin
		Select @save_OSver = rtrim(ltrim(substring(@save_OSver, @charpos+8, 132)))
	   end
   end

If @save_Memory is null or @save_Memory = ''
   begin
	Select @save_Memory = (select top 1 text01 from #temp_tbl2 where text01 like 'Total Physical Memory%')
	Select @save_Memory = replace(@save_Memory, char(9), ' ')
	Select @charpos = charindex('Total Physical Memory', @save_Memory)
	IF @charpos <> 0
	   begin
		Select @save_Memory = rtrim(ltrim(substring(@save_Memory, @charpos+22, 132)))
	   end
   end

If @save_Pagefile_inuse is null or @save_Pagefile_inuse = ''
   begin
	Select @save_Pagefile_inuse = (select top 1 text01 from #temp_tbl2 where text01 like 'Page File Space%')
	Select @save_Pagefile_inuse = replace(@save_Pagefile_inuse, char(9), ' ')
	Select @charpos = charindex('Page File Space', @save_Pagefile_inuse)
	IF @charpos <> 0
	   begin
		Select @save_Pagefile_inuse = rtrim(ltrim(substring(@save_Pagefile_inuse, @charpos+16, 132)))
	   end
   end

If @save_Pagefile_path is null or @save_Pagefile_path = ''
   begin
	Select @save_Pagefile_path = (select top 1 text01 from #temp_tbl2 where text01 like 'Page File%' and text01 like '%:\%')
	Select @save_Pagefile_path = replace(@save_Pagefile_path, char(9), ' ')
	Select @charpos = charindex('Page File', @save_Pagefile_path)
	IF @charpos <> 0
	   begin
		Select @save_Pagefile_path = rtrim(ltrim(substring(@save_Pagefile_path, @charpos+10, 132)))
	   end
   end
   
If @save_TimeZone is null or @save_TimeZone = ''
   begin
	Select @save_TimeZone = (select top 1 text01 from #temp_tbl2 where text01 like 'Time Zone%')
	Select @save_TimeZone = replace(@save_TimeZone, char(9), ' ')
	Select @charpos = charindex('Time Zone', @save_TimeZone)
	IF @charpos <> 0
	   begin
		Select @save_TimeZone = rtrim(ltrim(substring(@save_TimeZone, @charpos+10, 132)))
	   end
   end


If @save_SystemModel is null or @save_SystemModel = ''
   begin
	Select @save_system_man = (select top 1 text01 from #temp_tbl2 where text01 like 'System Manufacturer%')
	Select @save_system_man = replace(@save_system_man, char(9), ' ')
	Select @charpos = charindex('System Manufacturer', @save_system_man)
	IF @charpos <> 0
	   begin
		Select @save_system_man = rtrim(ltrim(substring(@save_system_man, @charpos+20, 132)))
	   end

	Select @save_system_mod = (select top 1 text01 from #temp_tbl2 where text01 like 'System Model%')
	Select @save_system_mod = replace(@save_system_mod, char(9), ' ')
	Select @charpos = charindex('System Model', @save_system_mod)
	IF @charpos <> 0
	   begin
		Select @save_system_mod = ltrim(substring(@save_system_mod, @charpos+13, 132))
	   end

	If @save_system_man is not null and @save_system_mod is not null
	   begin
    		Select @save_SystemModel = rtrim(@save_system_man) + ' ' + rtrim(@save_system_mod)
	   end
	Else
	   begin
    		Select @save_SystemModel = 'Unknown'
	   end
   end

Select @save_IEver = (select top 1 text01 from #temp_tbl2 where text01 like 'Version%' and text01 not like '%Build%')
Select @save_IEver = replace(@save_IEver, char(9), ' ')
Select @charpos = charindex('Version', @save_IEver)
IF @charpos <> 0
   begin
	Select @save_IEver = rtrim(ltrim(substring(@save_IEver, @charpos+8, 132)))
   end


skip_msinfo:






--  Capture Boot 3gb
--  Capture Boot pae
--  Capture Boot userva
delete from #temp_tbl2
Select @cmd = 'Type c:\boot.ini'
insert #temp_tbl2(text01) exec master.sys.xp_cmdshell @cmd
Delete from #temp_tbl2 where text01 is null or text01 = ''

Select @save_boot_3gb = 'n'
Select @save_boot_pae = 'n'
Select @save_boot_userva = 'n'

If (select count(*) from #temp_tbl2) = 0
   begin
	goto skip_boot
   end


If exists(select 1 from #temp_tbl2 where text01 like '%/3gb%')
   begin
	Select @save_boot_3gb = 'y'
   end

If exists(select 1 from #temp_tbl2 where text01 like '%/pae%')
   begin
	Select @save_boot_pae = 'y'
   end

If exists(select 1 from #temp_tbl2 where text01 like '%/userva%')
   begin
	Select @save_boot_userva = 'y'
   end

skip_boot:



--  Capture MDAC version
select @in_key = 'HKEY_LOCAL_MACHINE'
select @in_path = 'SOFTWARE\Microsoft\DataAccess'
select @in_value = 'Version'
exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output

If @result_value is not null and @result_value <> ''
   begin
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'SOFTWARE\Microsoft\DataAccess'
	select @in_value = 'FullInstallVer'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
   end

If @result_value is not null and @result_value <> ''
   begin
	Select @save_MDACver = @result_value
   end


--  Capture AntiVirus Info
select @save_install_folder = @result_value
select @in_key = 'HKEY_LOCAL_MACHINE'
select @in_path = 'SOFTWARE\McAfee\VSCore\On Access Scanner\McShield\Configuration\Default'

If @@version like '%x64%'
   begin
	Select @cmd = 'reg2 query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /s'
   end
Else
   begin
	Select @cmd = 'reg query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /s'
   end

--print @cmd

insert into #regresults exec master.sys.xp_cmdshell @cmd
delete from #regresults where results is null
--select * from #regresults

If exists (select 1 from #regresults where results like '%but is for a machine type%')
   begin
	Select @cmd = 'reg2 query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /s'
	--print @cmd

	insert into #regresults exec master.sys.xp_cmdshell @cmd
	delete from #regresults where results is null
	--select * from #regresults
   end

delete from #regresults where results not like '%ExcludedItem%'

Select @save_AntiVirus_type = 'na'
Select @save_AntiVirus_Excludes = ''

If (select count(*) from #regresults) > 1
   begin
	Select @save_AntiVirus_type = 'McAfee'
	Select @save_AntiVirus_Excludes = 'n'

	If not exists (select 1 from #regresults where results like '%mssql%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%mssql.1%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%mssql.2%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%mssql.3%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%MDF%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%NDF%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%LDF%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%MDFnxt%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%NDFnxt%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%BAK%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%DIF%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%TRN%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%BKP%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%DFL%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%TNL%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%SQB%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%SQD%')
	   begin
		goto anti_virus_end
	   end
	If not exists (select 1 from #regresults where results like '%SQT%')
	   begin
		goto anti_virus_end
	   end

	Select @save_AntiVirus_Excludes = 'y'

   end

anti_virus_end:



--  Capture MOM Verify date
Set @save_MOMdate = null

select @in_key = 'HKEY_LOCAL_MACHINE'
select @in_path = 'Software\Microsoft\Microsoft SQL Server'
Select @cmd = 'reg query "\\' + @save_servername + '\' + @in_key + '\' + @in_path + '" /s'
--print @cmd

delete from #regresults
insert into #regresults exec master.sys.xp_cmdshell @cmd
--select * from #regresults
delete from #regresults where results is null
delete from #regresults where results not like '%LastMonitoringDate%'
--select * from #regresults

If exists (select 1 from #regresults where results like '%LastMonitoringDate%')
   begin
	Select @save_MOMdate = (select top 1 results from #regresults where results like '%LastMonitoringDate%')
	Select @charpos = charindex('REG_SZ', @save_MOMdate)
	IF @charpos <> 0
	   begin
		Select @save_MOMdate = substring(@save_MOMdate, @charpos+7, 30)
		Select @save_MOMdate = replace(@save_MOMdate, char(9), '')
		Select @save_MOMdate = rtrim(ltrim(@save_MOMdate))
	   end
   end



--  Check for CLR Enabled
If @save_Assemblies = 'y' and @save_clr_enabled = 'n'
   begin
	select @miscprint = '--DBA WARNING: ''CLR Enabled'' setting in sp_configure is not enabled.  Assemblies were found in this SQL instance.'
	raiserror(@miscprint,-1,-1) with log
   end


--  Set active status
If exists (select 1 from dbo.Local_ServerEnviro where env_type = 'check_sqlstatus' and env_detail like 'maint%')
   begin
	Select @save_server_active = 'm'
   end
Else 
   begin
	Select @save_server_active = 'y'
   end




-- Create script to insert this row on the central server dbo.DBA_ServerInfo related for this SQL server
Select @miscprint = ' '
Print  @miscprint

Select @miscprint = '--  Start DBA_ServerInfo Updates'
Print  @miscprint

Select @miscprint = 'if not exists (select 1 from dbo.DBA_ServerInfo where ServerName = ''' + upper(@save_servername) + ''' and SQLName = ''' + upper(@@servername) + ''')'
Print  @miscprint

Select @miscprint = '   begin'
Print  @miscprint

Select @miscprint = '      INSERT INTO dbo.DBA_ServerInfo (ServerName, SQLName, Active, Filescan, SQLmail, modDate) VALUES (''' + upper(@save_servername) + ''', ''' + upper(@@servername) + ''', ''' + @save_server_active + ''', ''Y'', ''Y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
Print  @miscprint

Select @miscprint = '   end'
Print  @miscprint

Select @miscprint = 'go'
Print  @miscprint

Select @miscprint = ' '
Print  @miscprint

raiserror('', -1,-1) with nowait

Select @miscprint = 'Update top (1) dbo.DBA_ServerInfo set SQLEnv = ''' + @save_ENVname + ''''
Print  @miscprint

Select @miscprint = '                                      ,active = ''' + @save_server_active + ''''
Print  @miscprint

Select @miscprint = '                                      ,modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLver = ''' + @save_version + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLinstallDate = ''' + convert(nvarchar(30), @save_SQL_install_date, 121) + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLrecycleDate = ''' + @save_SQLrecycle_date + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLSvcAcct = ''' + @save_SQLSvcAcct + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLAgentAcct = ''' + @save_SQLAgentAcct + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLStartupParms = ''' + @save_SQLStartupParms + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLScanforStartupSprocs = ''' + @save_SQLScanforStartupSprocs + ''''
Print  @miscprint

Select @miscprint = '                                      ,dbaadmin_Version = ''' + @save_dbaadmin_build + ''''
Print  @miscprint

Select @miscprint = '                                      ,dbaperf_Version = ''' + @save_dbaperf_build + ''''
Print  @miscprint

Select @miscprint = '                                      ,DEPLinfo_Version = ''' + @save_DEPLinfo_build + ''''
Print  @miscprint

Select @miscprint = '                                      ,backup_type = ''' + @save_backup_type + ''''
Print  @miscprint

Select @miscprint = '                                      ,LiteSpeed = ''' + @save_compbackup_ls_flag + ''''
Print  @miscprint

Select @miscprint = '                                      ,RedGate = ''' + @save_compbackup_rg_flag + ''''
Print  @miscprint

Select @miscprint = '                                      ,awe_enabled = ''' + @save_awe_enabled + ''''
Print  @miscprint

Select @miscprint = '                                      ,MAXdop_value = ''' + @save_MAXdop_value + ''''
Print  @miscprint

Select @miscprint = '                                      ,Memory = ''' + @save_Memory + ''''
Print  @miscprint

Select @miscprint = '                                      ,SQLmax_memory = ''' + @save_SQLmax_memory + ''''
Print  @miscprint

Select @miscprint = '                                      ,tempdb_filecount = ''' + @save_tempdb_filecount + ''''
Print  @miscprint

Select @miscprint = '                                      ,FullTextCat = ''' + @save_FullTextCat + ''''
Print  @miscprint

Select @miscprint = '                                      ,Assemblies = ''' + @save_Assemblies + ''''
Print  @miscprint

Select @miscprint = '                                      ,Mirroring = ''' + @save_Mirroring + ''''
Print  @miscprint

Select @miscprint = '                                      ,Repl_Flag = ''' + @save_Repl_Flag + ''''
Print  @miscprint

Select @miscprint = '                                      ,LogShipping = ''' + @save_LogShipping + ''''
Print  @miscprint

Select @miscprint = '                                      ,LinkedServers = ''' + @save_LinkedServers + ''''
Print  @miscprint

Select @miscprint = '                                      ,ReportingSvcs = ''' + @save_ReportingSvcs + ''''
Print  @miscprint

Select @miscprint = '                                      ,LocalPasswords = ''' + @save_LocalPasswords + ''''
Print  @miscprint

Select @miscprint = '                                      ,DEPLstatus = ''' + @save_depl_flag + ''''
Print  @miscprint

Select @miscprint = '                                      ,OracleClient = ''' + @save_OracleClient + ''''
Print  @miscprint

Select @miscprint = '                                      ,TNSnamesPath = ''' + @save_TNSnamesPath + ''''
Print  @miscprint

Select @miscprint = '                                      ,DomainName = ''' + @save_domain_name + ''''
Print  @miscprint

Select @miscprint = '              ,iscluster = ''' + @save_iscluster + ''''
Print  @miscprint

Select @miscprint = '                                      ,SAN = ''' + @save_SAN_flag + ''''
Print  @miscprint

Select @miscprint = '                                      ,Port = ''' + @save_port + ''''
Print  @miscprint

Select @miscprint = '                                      ,IPnum = ''' + @save_ip + ''''
Print  @miscprint

Select @miscprint = '                                      ,ServerType = ''' + @save_ServerType + ''''
Print  @miscprint

Select @miscprint = '                                      ,CPUphysical = ''' + @save_CPUphysical + ''''
Print  @miscprint

Select @miscprint = '                                      ,CPUcore = ''' + @save_CPUcore + ''''
Print  @miscprint

Select @miscprint = '                                      ,CPUlogical = ''' + @save_CPUlogical + ''''
Print  @miscprint

Select @miscprint = '                                      ,CPUtype = ''' + @save_CPUtype + ''''
Print  @miscprint

Select @miscprint = '                                      ,OSname = ''' + @save_OSname + ''''
Print  @miscprint

Select @miscprint = '                                      ,OSver = ''' + @save_OSver + ''''
Print  @miscprint

Select @miscprint = '                                      ,OSinstallDate = ''' + @save_OSinstallDate + ''''
Print  @miscprint

Select @miscprint = '                                      ,OSuptime = ''' + @save_OSuptime + ''''
Print  @miscprint

Select @miscprint = '                                      ,MDACver = ''' + @save_MDACver + ''''
Print  @miscprint

Select @miscprint = '                                      ,IEver = ''' + @save_IEver + ''''
Print  @miscprint

Select @miscprint = '                                      ,AntiVirus_type = ''' + @save_AntiVirus_type + ''''
Print  @miscprint

Select @miscprint = '                                      ,AntiVirus_Excludes = ''' + @save_AntiVirus_Excludes + ''''
Print  @miscprint

Select @miscprint = '                                      ,boot_3gb = ''' + @save_boot_3gb + ''''
Print  @miscprint

Select @miscprint = '                                      ,boot_pae = ''' + @save_boot_pae + ''''
Print  @miscprint

Select @miscprint = '                                      ,boot_userva = ''' + @save_boot_userva + ''''
Print  @miscprint

Select @miscprint = '                                      ,Pagefile_maxsize = ''' + @save_Pagefile_maxsize + ''''
Print  @miscprint

Select @miscprint = '                                      ,Pagefile_available = ''' + @save_Pagefile_avail + ''''
Print  @miscprint

Select @miscprint = '                                      ,Pagefile_inuse = ''' + @save_Pagefile_inuse + ''''
Print  @miscprint

Select @miscprint = '                                      ,Pagefile_path = ''' + @save_Pagefile_path + ''''
Print  @miscprint

Select @miscprint = '                                      ,TimeZone = ''' + @save_TimeZone + ''''
Print  @miscprint

Select @miscprint = '                                      ,SystemModel = ''' + @save_SystemModel + ''''
Print  @miscprint

Select @miscprint = '                                      ,MOMverifyDate = ''' + @save_MOMdate + ''''
Print  @miscprint

Select @miscprint = 'where '
Print  @miscprint

Select @miscprint = 'ServerName = ''' + upper(@save_servername) + ''' and SQLName = ''' + upper(@@servername) + ''''
Print  @miscprint

Select @miscprint = 'go'
Print  @miscprint

Select @miscprint = ' '
Print  @miscprint

raiserror('', -1,-1) with nowait






--  Capture Disk Info and create insert/update script
delete from #drives

Set @save_MOMdate = null
INSERT #drives(drive,FreeSpace) EXEC master.sys.xp_fixeddrives

If (select count(*) from #drives) > 0
   begin

	Select @miscprint = ' '
	Print  @miscprint

	Select @miscprint = '--  Start DBA_DiskInfo Updates'
	Print  @miscprint

	Select @miscprint = 'Update dbo.DBA_DiskInfo set active = ''n'' where SQLName = ''' + upper(@@servername) + ''''
	Print  @miscprint

	Select @miscprint = 'go'
	Print  @miscprint

	Select @miscprint = ' '
	Print  @miscprint

	raiserror('', -1,-1) with nowait

	EXEC @hr=sp_OACreate 'Scripting.FileSystemObject', @fso OUT
	IF @hr <> 0 EXEC sp_OAGetErrorInfo @fso

	start_drives01:

	Select @save_drivename = (select top 1 drive from #drives order by drive)
	Select @save_drivefree = (select top 1 FreeSpace from #drives where drive = @save_drivename)
	Select @save_driveSize = null

	EXEC @hr = sp_OAMethod @fso,'GetDrive', @odrive OUT, @save_drivename
	IF @hr <> 0 EXEC sp_OAGetErrorInfo @fso

	EXEC @hr = sp_OAGetProperty @odrive,'TotalSize', @save_driveSize_char OUT
	IF @hr <> 0 EXEC sp_OAGetErrorInfo @odrive

	If @save_driveSize_char is not null
	   begin
		Select @save_driveSize = convert(bigint, @save_driveSize_char)

		SET @save_driveSize = @save_driveSize/@MB

		Select @save_drivefree_pct = CAST((@save_drivefree/(@save_driveSize*1.0))*100.0 as int)

		Select @miscprint = 'if not exists (select 1 from dbo.DBA_DiskInfo where SQLName = ''' + upper(@@servername) + ''' and DriveName = ''' + rtrim(@save_drivename) + ''')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      INSERT INTO dbo.DBA_DiskInfo (SQLName, Active, DriveName, modDate) VALUES (''' + upper(@@servername) + ''', ''Y'', ''' + rtrim(@save_drivename) + ''', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait

		Select @miscprint = 'Update top (1) dbo.DBA_DiskInfo set active = ''y'''
		Print  @miscprint

		Select @miscprint = '                                      ,DriveSize = ' + convert(varchar(20), @save_drivesize)
		Print  @miscprint

		Select @miscprint = '                                      ,DriveFree = ' + convert(varchar(20), @save_drivefree)
		Print  @miscprint

		Select @miscprint = '                                      ,DriveFree_pct = ' + convert(varchar(20), @save_drivefree_pct)
		Print  @miscprint

		Select @miscprint = '                                      ,modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print  @miscprint

		Select @miscprint = 'where '
		Print  @miscprint

		Select @miscprint = 'SQLName = ''' + upper(@@servername) + ''' and DriveName = ''' + rtrim(@save_drivename) + ''''
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait

	   end


	delete from #drives where drive = @save_drivename
	If (select count(*) from #drives) > 0
	   begin
		goto start_drives01
	   end

	Select @miscprint = ' '
	Print  @miscprint

   end





--  Capture Cluster info
If @save_iscluster = 'y'
   begin
	Select @save_cluster_name = ''
	Select @save_cluster_IP = ''
	Select @save_cluster_ver = ''
	Select @save_clusterSvcAcct = ''
	Select @save_Quorumgroup = ''
	Select @save_Quorumgroup_node = ''
	Select @save_Quorumgroup_status = ''
	Select @save_DTCgroup = ''
	Select @save_DTCgroup_node = ''
	Select @save_DTCgroup_status = ''
	Select @save_VirtSrv01 = ''
	Select @save_VirtSrv01_node = ''
	Select @save_VirtSrv01_status = ''
	Select @save_VirtSrv02 = ''
	Select @save_VirtSrv02_node = ''
	Select @save_VirtSrv02_status = ''
	Select @save_VirtSrv03 = ''
	Select @save_VirtSrv03_node = ''
	Select @save_VirtSrv03_status = ''
	Select @save_VirtSrv04 = ''
	Select @save_VirtSrv04_node = ''
	Select @save_VirtSrv04_status = ''
	Select @save_VirtSrv05 = ''
	Select @save_VirtSrv05_node = ''
	Select @save_VirtSrv05_status = ''
	Select @save_clustNode01 = ''
	Select @save_clustNode01_IP = ''
	Select @save_clustNode01_status = ''
	Select @save_clustNode02 = ''
	Select @save_clustNode02_IP = ''
	Select @save_clustNode02_status = ''
	Select @save_clustNode03 = ''
	Select @save_clustNode03_IP = ''
	Select @save_clustNode03_status = ''
	Select @save_clustNode04 = ''
	Select @save_clustNode04_IP = ''
	Select @save_clustNode04_status = ''
	Select @save_clustNode05 = ''
	Select @save_clustNode05_IP = ''
	Select @save_clustNode05_status = ''


	--  Get the cluster name and related info
	delete from #clust_tb01
	select @cmd = 'cluster /ver'
	--print @cmd
	insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
	delete from #clust_tb01 where text01 is null
	delete from #clust_tb01 where text01 like '%Cluster Vendor%'
	delete from #clust_tb01 where text01 = char(13)
	delete from #clust_tb01 where text01 = char(10)
	delete from #clust_tb01 where text01 = char(13)+char(10)
	delete from #clust_tb01 where text01 = char(10)+char(13)
	delete from #clust_tb01 where text01 = ''
	--select * from #clust_tb01

	If (select count(*) from #clust_tb01) = 0
	   begin
		goto skip_cluster
	   end

	Select @save_cluster_name = (select top 1 text01 from #clust_tb01 where text01 like 'Cluster Name%')
	Select @save_cluster_name = replace(@save_cluster_name, char(13), '')
	If @save_cluster_name is not null and @save_cluster_name <> ''
	   begin
		Select @charpos = charindex(':', @save_cluster_name)
		IF @charpos <> 0
		   begin
			Select @save_cluster_name = ltrim(substring(@save_cluster_name, @charpos+1, 132))
		   end
	   end

	Select @save_cluster_ver = (select top 1 text01 from #clust_tb01 where text01 like 'Cluster Version%')
	Select @save_cluster_ver = replace(@save_cluster_ver, char(13), '')
	If @save_cluster_ver is not null and @save_cluster_ver <> ''
	   begin
		Select @charpos = charindex(':', @save_cluster_ver)
		IF @charpos <> 0
		   begin
			Select @save_cluster_ver = ltrim(substring(@save_cluster_ver, @charpos+1, 132))
		   end
	   end

	--  Capture the IP
	delete from #temp_tbl1
	Select @cmd = 'ping ' + @save_cluster_name
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''
	Delete from #temp_tbl1 where text01 not like '%Reply from%'
	--select * from #temp_tbl1
        	
	If (select count(*) from #temp_tbl1) > 0
	   begin
		Select @save_cluster_IP = (select top 1 text01 from #temp_tbl1 where text01 like '%Reply from%')
		Select @save_cluster_IP = ltrim(substring(@save_cluster_IP, 11, 20))
		Select @charpos = charindex(':', @save_cluster_IP)
		IF @charpos <> 0
		   begin
			select @save_cluster_IP = substring(@save_cluster_IP, 1, @charpos-1)
		   end
	   end
	Else
	   begin
		Select @save_cluster_IP = 'Error'
	   end

	--  Capture the service account for the cluster service
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'System\CurrentControlSet\Services\ClusSvc'
	select @in_value = 'ObjectName'
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output

	Select @save_clusterSvcAcct = @result_value




	--  Get the cluster group related info
	delete from #clust_tb01
	select @cmd = 'cluster res /status'
	--print @cmd
	insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
	delete from #clust_tb01 where text01 is null
	delete from #clust_tb01 where text01 = char(13)
	delete from #clust_tb01 where text01 = char(10)
	delete from #clust_tb01 where text01 = char(13)+char(10)
	delete from #clust_tb01 where text01 = char(10)+char(13)
	delete from #clust_tb01 where text01 = ''
	--select * from #clust_tb01


	If (select count(*) from #clust_tb01) = 0
	   begin
		goto start_node
	   end


	--  First we get the Quorum group info
	If exists(select 1 from #clust_tb01 where text01 like '%Disk Q%')
	   begin
		Select @save_Quorumgroup = (select top 1 text01 from #clust_tb01 where text01 like '%Disk Q%')
	   end
	Else If exists(select 1 from #clust_tb01 where text01 like '%DiskQ%')
	   begin
		Select @save_Quorumgroup = (select top 1 text01 from #clust_tb01 where text01 like '%DiskQ%')
	   end
	Else If exists(select 1 from #clust_tb01 where text01 like '%Q:%')
	   begin
		Select @save_Quorumgroup = (select top 1 text01 from #clust_tb01 where text01 like '%Q:%')
	   end
	Else If exists(select 1 from #clust_tb01 where text01 like '%Qu%')
	   begin
		Select @save_Quorumgroup = (select top 1 text01 from #clust_tb01 where text01 like '%Qu%')
	   end

	If @save_Quorumgroup is not null
	   begin
		Select @save_Quorumgroup = replace(@save_Quorumgroup, char(13), '')
		Select @charpos = charindex('  ', @save_Quorumgroup)
		IF @charpos <> 0
		   begin
			Select @save_Quorumgroup = ltrim(substring(@save_Quorumgroup, @charpos+1, 132))
			Select @save_Quorumgroup_node = @save_Quorumgroup
			Select @charpos = charindex('  ', @save_Quorumgroup)
			IF @charpos <> 0
			   begin
				Select @save_Quorumgroup = ltrim(substring(@save_Quorumgroup, 1, @charpos-1))
			   end
		   end
	   end

	If @save_Quorumgroup_node is not null
	   begin
		Select @save_Quorumgroup_node = ltrim(@save_Quorumgroup_node)
		Select @charpos = charindex('  ', @save_Quorumgroup_node)
		IF @charpos <> 0
		   begin
			Select @save_Quorumgroup_node = ltrim(substring(@save_Quorumgroup_node, @charpos+1, 132))
			Select @save_Quorumgroup_status = @save_Quorumgroup_node
			Select @charpos = charindex(' ', @save_Quorumgroup_node)
			IF @charpos <> 0
			   begin
				Select @save_Quorumgroup_node = ltrim(substring(@save_Quorumgroup_node, 1, @charpos-1))
			   end
		   end
	   end

	If @save_Quorumgroup_status is not null
	   begin
		Select @save_Quorumgroup_status = ltrim(@save_Quorumgroup_status)
		Select @charpos = charindex(' ', @save_Quorumgroup_status)
		IF @charpos <> 0
		   begin
			Select @save_Quorumgroup_status = ltrim(substring(@save_Quorumgroup_status, @charpos+1, 132))
		   end
	   end


	--  Next we get the MSDTC group info
	If exists(select 1 from #clust_tb01 where text01 like '%MSDTC%')
	   begin
		Select @save_DTCgroup = (select top 1 text01 from #clust_tb01 where text01 like '%MSDTC%')
	   end
	Else If exists(select 1 from #clust_tb01 where text01 like '%DTC%')
	   begin
		Select @save_DTCgroup = (select top 1 text01 from #clust_tb01 where text01 like '%DTC%')
	   end


	If @save_DTCgroup is not null
	   begin
		Select @save_DTCgroup = replace(@save_DTCgroup, char(13), '')
		Select @charpos = charindex('  ', @save_DTCgroup)
		IF @charpos <> 0
		   begin
			Select @save_DTCgroup = ltrim(substring(@save_DTCgroup, @charpos+1, 132))
			Select @save_DTCgroup_node = @save_DTCgroup
			Select @charpos = charindex('  ', @save_DTCgroup)
			IF @charpos <> 0
			   begin
				Select @save_DTCgroup = ltrim(substring(@save_DTCgroup, 1, @charpos-1))
			   end
		   end
	   end


	If @save_DTCgroup_node is not null
	   begin
		Select @save_DTCgroup_node = ltrim(@save_DTCgroup_node)
		Select @charpos = charindex('  ', @save_DTCgroup_node)
		IF @charpos <> 0
		   begin
			Select @save_DTCgroup_node = ltrim(substring(@save_DTCgroup_node, @charpos+1, 132))
			Select @save_DTCgroup_status = @save_DTCgroup_node
			Select @charpos = charindex(' ', @save_DTCgroup_node)
			IF @charpos <> 0
			   begin
				Select @save_DTCgroup_node = ltrim(substring(@save_DTCgroup_node, 1, @charpos-1))
			   end
		   end
	   end

	If @save_DTCgroup_status is not null
	   begin
		Select @save_DTCgroup_status = ltrim(@save_DTCgroup_status)
		Select @charpos = charindex(' ', @save_DTCgroup_status)
		IF @charpos <> 0
		   begin
			Select @save_DTCgroup_status = ltrim(substring(@save_DTCgroup_status, @charpos+1, 132))
		   end
	   end


	--  Get the other cluster group related info 
	delete from #clust_tb01
	select @cmd = 'cluster group /status'
	--print @cmd
	insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
	delete from #clust_tb01 where text01 is null
	delete from #clust_tb01 where text01 = char(13)
	delete from #clust_tb01 where text01 = char(10)
	delete from #clust_tb01 where text01 = char(13)+char(10)
	delete from #clust_tb01 where text01 = char(10)+char(13)
	delete from #clust_tb01 where text01 = ''
	delete from #clust_tb01 where text01 like '%Listing status%'
	delete from #clust_tb01 where text01 like '%-------------%'
	delete from #clust_tb01 where text01 like '%Group%' and text01 like '%Node%' and text01 like '%Status%'
	delete from #clust_tb01 where text01 like '%' + @save_DTCgroup + '%'
	delete from #clust_tb01 where text01 like '%' + @save_Quorumgroup + '%'
	--select * from #clust_tb01

	--  Start 01
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto start_node
	   end

	Select @save_VirtSrv01 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_VirtSrv01 is not null
	   begin
		Select @save_VirtSrv01 = replace(@save_VirtSrv01, char(13), '')
		Select @save_VirtSrv01 = replace(@save_VirtSrv01, char(9), '')
		Select @charpos = charindex('  ', @save_VirtSrv01)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv01_node = ltrim(substring(@save_VirtSrv01, @charpos+1, 200))
			Select @save_VirtSrv01 = rtrim(substring(@save_VirtSrv01, 1, @charpos-1))
		   end
	   end

	If @save_VirtSrv01_node is not null
	   begin
		Select @save_VirtSrv01_node = ltrim(@save_VirtSrv01_node)
		Select @charpos = charindex(' ', @save_VirtSrv01_node)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv01_status = ltrim(substring(@save_VirtSrv01_node, @charpos+1, 200))
			Select @save_VirtSrv01_node = rtrim(substring(@save_VirtSrv01_node, 1, @charpos-1))
		   end
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_VirtSrv01 + '%'


	--  Start 02
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto start_node
	   end

	Select @save_VirtSrv02 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_VirtSrv02 is not null
	   begin
		Select @save_VirtSrv02 = replace(@save_VirtSrv02, char(13), '')
		Select @save_VirtSrv02 = replace(@save_VirtSrv02, char(9), '')
		Select @charpos = charindex('  ', @save_VirtSrv02)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv02_node = ltrim(substring(@save_VirtSrv02, @charpos+1, 200))
			Select @save_VirtSrv02 = rtrim(substring(@save_VirtSrv02, 1, @charpos-1))
		   end
	   end

	If @save_VirtSrv02_node is not null
	   begin
		Select @save_VirtSrv02_node = ltrim(@save_VirtSrv02_node)
		Select @charpos = charindex(' ', @save_VirtSrv02_node)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv02_status = ltrim(substring(@save_VirtSrv02_node, @charpos+1, 200))
			Select @save_VirtSrv02_node = rtrim(substring(@save_VirtSrv02_node, 1, @charpos-1))
		   end
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_VirtSrv02 + '%'

	--  Start 03
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto start_node
	   end

	Select @save_VirtSrv03 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_VirtSrv03 is not null
	   begin
		Select @save_VirtSrv03 = replace(@save_VirtSrv03, char(13), '')
		Select @save_VirtSrv03 = replace(@save_VirtSrv03, char(9), '')
		Select @charpos = charindex('  ', @save_VirtSrv03)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv03_node = ltrim(substring(@save_VirtSrv03, @charpos+1, 200))
			Select @save_VirtSrv03 = rtrim(substring(@save_VirtSrv03, 1, @charpos-1))
		   end
	   end

	If @save_VirtSrv03_node is not null
	   begin
		Select @save_VirtSrv03_node = ltrim(@save_VirtSrv03_node)
		Select @charpos = charindex(' ', @save_VirtSrv03_node)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv03_status = ltrim(substring(@save_VirtSrv03_node, @charpos+1, 200))
			Select @save_VirtSrv03_node = rtrim(substring(@save_VirtSrv03_node, 1, @charpos-1))
		   end
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_VirtSrv03 + '%'

	--  Start 04
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto start_node
	   end

	Select @save_VirtSrv04 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_VirtSrv04 is not null
	   begin
		Select @save_VirtSrv04 = replace(@save_VirtSrv04, char(13), '')
		Select @save_VirtSrv04 = replace(@save_VirtSrv04, char(9), '')
		Select @charpos = charindex('  ', @save_VirtSrv04)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv04_node = ltrim(substring(@save_VirtSrv04, @charpos+1, 200))
			Select @save_VirtSrv04 = rtrim(substring(@save_VirtSrv04, 1, @charpos-1))
		   end
	   end

	If @save_VirtSrv04_node is not null
	   begin
		Select @save_VirtSrv04_node = ltrim(@save_VirtSrv04_node)
		Select @charpos = charindex(' ', @save_VirtSrv04_node)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv04_status = ltrim(substring(@save_VirtSrv04_node, @charpos+1, 200))
			Select @save_VirtSrv04_node = rtrim(substring(@save_VirtSrv04_node, 1, @charpos-1))
		   end
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_VirtSrv04 + '%'

	--  Start 05
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto start_node
	   end

	Select @save_VirtSrv05 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_VirtSrv05 is not null
	   begin
		Select @save_VirtSrv05 = replace(@save_VirtSrv05, char(13), '')
		Select @save_VirtSrv05 = replace(@save_VirtSrv05, char(9), '')
		Select @charpos = charindex('  ', @save_VirtSrv05)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv05_node = ltrim(substring(@save_VirtSrv05, @charpos+1, 200))
			Select @save_VirtSrv05 = rtrim(substring(@save_VirtSrv05, 1, @charpos-1))
		   end
	   end

	If @save_VirtSrv05_node is not null
	   begin
		Select @save_VirtSrv05_node = ltrim(@save_VirtSrv05_node)
		Select @charpos = charindex(' ', @save_VirtSrv05_node)
		IF @charpos <> 0
		   begin
			Select @save_VirtSrv05_status = ltrim(substring(@save_VirtSrv05_node, @charpos+1, 200))
			Select @save_VirtSrv05_node = rtrim(substring(@save_VirtSrv05_node, 1, @charpos-1))
		   end
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_VirtSrv05 + '%'



	start_node:

	--  Get the NODE related info here...
	delete from #clust_tb01
	select @cmd = 'cluster node /status'
	--print @cmd
	insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
	delete from #clust_tb01 where text01 is null
	delete from #clust_tb01 where text01 = char(13)
	delete from #clust_tb01 where text01 = char(10)
	delete from #clust_tb01 where text01 = char(13)+char(10)
	delete from #clust_tb01 where text01 = char(10)+char(13)
	delete from #clust_tb01 where text01 = ''
	delete from #clust_tb01 where text01 like '%Listing status%'
	delete from #clust_tb01 where text01 like '%-------------%'
	delete from #clust_tb01 where text01 like '%Node%' and text01 like '%Node ID%' and text01 like '%Status%'
	--select * from #clust_tb01

	--  Start 01
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto end_node
	   end

	Select @save_clustNode01 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_clustNode01 is not null
	   begin
		Select @save_clustNode01 = replace(@save_clustNode01, char(13), '')
		Select @save_clustNode01 = replace(@save_clustNode01, char(9), '')
		Select @charpos = charindex('  ', @save_clustNode01)
		IF @charpos <> 0
		   begin
			Select @save_clustNode01_status = ltrim(substring(@save_clustNode01, @charpos+1, 200))
			Select @save_clustNode01 = rtrim(substring(@save_clustNode01, 1, @charpos-1))
		   end
	   end

	If @save_clustNode01_status is not null
	   begin
		Select @save_clustNode01_status = ltrim(@save_clustNode01_status)
		Select @charpos = charindex(' ', @save_clustNode01_status)
		IF @charpos <> 0
		   begin
			Select @save_clustNode01_status = ltrim(substring(@save_clustNode01_status, @charpos+1, 200))
		   end
	   end

	--  Capture the IP
	delete from #temp_tbl1
	Select @cmd = 'ping ' + @save_clustNode01
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''
	Delete from #temp_tbl1 where text01 not like '%Reply from%'
	--select * from #temp_tbl1
        	
	If (select count(*) from #temp_tbl1) > 0
	   begin
		Select @save_clustNode01_IP = (select top 1 text01 from #temp_tbl1 where text01 like '%Reply from%')
		Select @save_clustNode01_IP = ltrim(substring(@save_clustNode01_IP, 11, 20))
		Select @charpos = charindex(':', @save_clustNode01_IP)
		IF @charpos <> 0
		   begin
			select @save_clustNode01_IP = substring(@save_clustNode01_IP, 1, @charpos-1)
		   end
	   end
	Else
	   begin
		Select @save_clustNode01_IP = 'Error'
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_clustNode01 + '%'


	--  Start 02
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto end_node
	   end

	Select @save_clustNode02 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_clustNode02 is not null
	   begin
		Select @save_clustNode02 = replace(@save_clustNode02, char(13), '')
		Select @save_clustNode02 = replace(@save_clustNode02, char(9), '')
		Select @charpos = charindex('  ', @save_clustNode02)
		IF @charpos <> 0
		   begin
			Select @save_clustNode02_status = ltrim(substring(@save_clustNode02, @charpos+1, 200))
			Select @save_clustNode02 = rtrim(substring(@save_clustNode02, 1, @charpos-1))
		   end
	   end

	If @save_clustNode02_status is not null
	   begin
		Select @save_clustNode02_status = ltrim(@save_clustNode02_status)
		Select @charpos = charindex(' ', @save_clustNode02_status)
		IF @charpos <> 0
		   begin
			Select @save_clustNode02_status = ltrim(substring(@save_clustNode02_status, @charpos+1, 200))
		   end
	   end

	--  Capture the IP
	delete from #temp_tbl1
	Select @cmd = 'ping ' + @save_clustNode02
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''
	Delete from #temp_tbl1 where text01 not like '%Reply from%'
	--select * from #temp_tbl1
        	
	If (select count(*) from #temp_tbl1) > 0
	   begin
		Select @save_clustNode02_IP = (select top 1 text01 from #temp_tbl1 where text01 like '%Reply from%')
		Select @save_clustNode02_IP = ltrim(substring(@save_clustNode02_IP, 11, 20))
		Select @charpos = charindex(':', @save_clustNode02_IP)
		IF @charpos <> 0
		   begin
			select @save_clustNode02_IP = substring(@save_clustNode02_IP, 1, @charpos-1)
		   end
	   end
	Else
	   begin
		Select @save_clustNode02_IP = 'Error'
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_clustNode02 + '%'


	--  Start 03
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto end_node
	   end

	Select @save_clustNode03 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_clustNode03 is not null
	   begin
		Select @save_clustNode03 = replace(@save_clustNode03, char(13), '')
		Select @save_clustNode03 = replace(@save_clustNode03, char(9), '')
		Select @charpos = charindex('  ', @save_clustNode03)
		IF @charpos <> 0
		   begin
			Select @save_clustNode03_status = ltrim(substring(@save_clustNode03, @charpos+1, 200))
			Select @save_clustNode03 = rtrim(substring(@save_clustNode03, 1, @charpos-1))
		   end
	   end

	If @save_clustNode03_status is not null
	   begin
		Select @save_clustNode03_status = ltrim(@save_clustNode03_status)
		Select @charpos = charindex(' ', @save_clustNode03_status)
		IF @charpos <> 0
		   begin
			Select @save_clustNode03_status = ltrim(substring(@save_clustNode03_status, @charpos+1, 200))
		   end
	   end

	--  Capture the IP
	delete from #temp_tbl1
	Select @cmd = 'ping ' + @save_clustNode03
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''
	Delete from #temp_tbl1 where text01 not like '%Reply from%'
	--select * from #temp_tbl1
        	
	If (select count(*) from #temp_tbl1) > 0
	   begin
		Select @save_clustNode03_IP = (select top 1 text01 from #temp_tbl1 where text01 like '%Reply from%')
		Select @save_clustNode03_IP = ltrim(substring(@save_clustNode03_IP, 11, 20))
		Select @charpos = charindex(':', @save_clustNode03_IP)
		IF @charpos <> 0
		   begin
			select @save_clustNode03_IP = substring(@save_clustNode03_IP, 1, @charpos-1)
		   end
	   end
	Else
	   begin
		Select @save_clustNode03_IP = 'Error'
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_clustNode03 + '%'


	--  Start 04
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto end_node
	   end

	Select @save_clustNode04 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_clustNode04 is not null
	   begin
		Select @save_clustNode04 = replace(@save_clustNode04, char(13), '')
		Select @save_clustNode04 = replace(@save_clustNode04, char(9), '')
		Select @charpos = charindex('  ', @save_clustNode04)
		IF @charpos <> 0
		   begin
			Select @save_clustNode04_status = ltrim(substring(@save_clustNode04, @charpos+1, 200))
			Select @save_clustNode04 = rtrim(substring(@save_clustNode04, 1, @charpos-1))
		   end
	   end

	If @save_clustNode04_status is not null
	   begin
		Select @save_clustNode04_status = ltrim(@save_clustNode04_status)
		Select @charpos = charindex(' ', @save_clustNode04_status)
		IF @charpos <> 0
		   begin
			Select @save_clustNode04_status = ltrim(substring(@save_clustNode04_status, @charpos+1, 200))
		   end
	   end

	--  Capture the IP
	delete from #temp_tbl1
	Select @cmd = 'ping ' + @save_clustNode04
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''
	Delete from #temp_tbl1 where text01 not like '%Reply from%'
	--select * from #temp_tbl1
        	
	If (select count(*) from #temp_tbl1) > 0
	   begin
		Select @save_clustNode04_IP = (select top 1 text01 from #temp_tbl1 where text01 like '%Reply from%')
		Select @save_clustNode04_IP = ltrim(substring(@save_clustNode04_IP, 11, 20))
		Select @charpos = charindex(':', @save_clustNode04_IP)
		IF @charpos <> 0
		   begin
			select @save_clustNode04_IP = substring(@save_clustNode04_IP, 1, @charpos-1)
		   end
	   end
	Else
	   begin
		Select @save_clustNode04_IP = 'Error'
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_clustNode04 + '%'


	--  Start 05
	If (select count(*) from #clust_tb01) = 0
	   begin
		goto end_node
	   end

	Select @save_clustNode05 = (select top 1 text01 from #clust_tb01 order by text01)

	If @save_clustNode05 is not null
	   begin
		Select @save_clustNode05 = replace(@save_clustNode05, char(13), '')
		Select @save_clustNode05 = replace(@save_clustNode05, char(9), '')
		Select @charpos = charindex('  ', @save_clustNode05)
		IF @charpos <> 0
		   begin
			Select @save_clustNode05_status = ltrim(substring(@save_clustNode05, @charpos+1, 200))
			Select @save_clustNode05 = rtrim(substring(@save_clustNode05, 1, @charpos-1))
		   end
	   end

	If @save_clustNode05_status is not null
	   begin
		Select @save_clustNode05_status = ltrim(@save_clustNode05_status)
		Select @charpos = charindex(' ', @save_clustNode05_status)
		IF @charpos <> 0
		   begin
			Select @save_clustNode05_status = ltrim(substring(@save_clustNode05_status, @charpos+1, 200))
		   end
	   end

	--  Capture the IP
	delete from #temp_tbl1
	Select @cmd = 'ping ' + @save_clustNode05
	insert #temp_tbl1(text01) exec master.sys.xp_cmdshell @cmd
	Delete from #temp_tbl1 where text01 is null or text01 = ''
	Delete from #temp_tbl1 where text01 not like '%Reply from%'
	--select * from #temp_tbl1
        	
	If (select count(*) from #temp_tbl1) > 0
	   begin
		Select @save_clustNode05_IP = (select top 1 text01 from #temp_tbl1 where text01 like '%Reply from%')
		Select @save_clustNode05_IP = ltrim(substring(@save_clustNode05_IP, 11, 20))
		Select @charpos = charindex(':', @save_clustNode05_IP)
		IF @charpos <> 0
		   begin
			select @save_clustNode05_IP = substring(@save_clustNode05_IP, 1, @charpos-1)
		   end
	   end
	Else
	   begin
		Select @save_clustNode05_IP = 'Error'
	   end

	--  delete references to this group
	delete from #clust_tb01 where text01 like @save_clustNode05 + '%'


	end_node: 


	-- Create script to insert this row on the central server dbo.DBA_ClusterInfo related for this SQL server
	Select @miscprint = ' '
	Print  @miscprint

	Select @miscprint = '--  Start DBA_ClusterInfo Updates'
	Print  @miscprint

	Select @miscprint = 'if not exists (select 1 from dbo.DBA_ClusterInfo where SQLName = ''' + upper(@@servername) + ''')'
	Print  @miscprint

	Select @miscprint = '   begin'
	Print  @miscprint

	Select @miscprint = '      INSERT INTO dbo.DBA_ClusterInfo (SQLName, modDate) VALUES (''' + upper(@@servername) + ''', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
	Print  @miscprint

	Select @miscprint = '   end'
	Print  @miscprint

	Select @miscprint = 'go'
	Print  @miscprint

	Select @miscprint = ' '
	Print  @miscprint

	raiserror('', -1,-1) with nowait

	Select @miscprint = 'Update dbo.DBA_ClusterInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,ClusterName = ''' + @save_cluster_name + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,ClusterIP = ''' + @save_cluster_IP + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,ClusterVer = ''' + @save_cluster_ver + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,ClusterSvcAcct = ''' + @save_clusterSvcAcct + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,Quorumgroup = ''' + @save_Quorumgroup + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,Quorumgroup_node = ''' + @save_Quorumgroup_node + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,Quorumgroup_status = ''' + @save_Quorumgroup_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,DTCgroup = ''' + @save_DTCgroup + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,DTCgroup_node = ''' + @save_DTCgroup_node + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,DTCgroup_status = ''' + @save_DTCgroup_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv01 = ''' + @save_VirtSrv01 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv01_node = ''' + @save_VirtSrv01_node + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv01_status = ''' + @save_VirtSrv01_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv02 = ''' + @save_VirtSrv02 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv02_node = ''' + @save_VirtSrv02_node + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv02_status = ''' + @save_VirtSrv02_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv03 = ''' + @save_VirtSrv03 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv03_node = ''' + @save_VirtSrv03_node + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv03_status = ''' + @save_VirtSrv03_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv04 = ''' + @save_VirtSrv04 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv04_node = ''' + @save_VirtSrv04_node + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv04_status = ''' + @save_VirtSrv04_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv05 = ''' + @save_VirtSrv05 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv05_node = ''' + @save_VirtSrv05_node + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VirtSrv05_status = ''' + @save_VirtSrv05_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode01 = ''' + @save_clustNode01 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode01_IP = ''' + @save_clustNode01_IP + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode01_status = ''' + @save_clustNode01_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode02 = ''' + @save_clustNode02 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode02_IP = ''' + @save_clustNode02_IP + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode02_status = ''' + @save_clustNode02_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode03 = ''' + @save_clustNode03 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode03_IP = ''' + @save_clustNode03_IP + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode03_status = ''' + @save_clustNode03_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode04 = ''' + @save_clustNode04 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode04_IP = ''' + @save_clustNode04_IP + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode04_status = ''' + @save_clustNode04_status + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode05 = ''' + @save_clustNode05 + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode05_IP = ''' + @save_clustNode05_IP + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,clustNode05_status = ''' + @save_clustNode05_status + ''''
	Print  @miscprint

	Select @miscprint = 'where SQLName = ''' + upper(@@servername) + ''''
	Print  @miscprint

	Select @miscprint = 'go'
	Print  @miscprint

	Select @miscprint = ' '
	Print  @miscprint

	raiserror('', -1,-1) with nowait






	-- Now check to see if we have more than once SQL instance running on this cluster node
	delete from #clust_tb01
	select @cmd = 'cluster res /status'
	--print @cmd
	insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
	delete from #clust_tb01 where text01 is null
	delete from #clust_tb01 where text01 = char(13)
	delete from #clust_tb01 where text01 = char(10)
	delete from #clust_tb01 where text01 = char(13)+char(10)
	delete from #clust_tb01 where text01 = char(10)+char(13)
	delete from #clust_tb01 where text01 not like 'SQL Network Name%'
	delete from #clust_tb01 where text01 not like '%' + @save_servername + '%'
	--select * from #clust_tb01

	If (select count(*) from #clust_tb01) > 0
	   begin
		Select @save_nodename = (select top 1 text01 from #clust_tb01)
		Select @save_nodename = replace(@save_nodename, @save_servername, '')
		Select @charpos = charindex(')', @save_nodename)
		IF @charpos <> 0
		   begin
			Select @save_nodename = substring(@save_nodename, @charpos+1, 100)
			Select @save_nodename = ltrim(@save_nodename)

			Select @charpos = charindex(' ', @save_nodename)
			IF @charpos <> 0
			   begin
				Select @save_nodename = substring(@save_nodename, 1, @charpos-1)
				Select @save_nodename = rtrim(@save_nodename)
			   end
		   end
		Else
		   begin
			Select @miscprint = 'No node name found for cluster health check.'
			Print '--DBA Error: ' + @miscprint
			raiserror(67016, 16, -1, @miscprint)

			goto skip_clustercheck
		   end
	   end


	If @save_nodename is null or @save_nodename = ''
	   begin
		Select @miscprint = 'No node name found for cluster health check.'
		Print '--DBA Error: ' + @miscprint
		raiserror(67016, 16, -1, @miscprint)

		goto skip_clustercheck
	   end



	delete from #clust_tb01
	select @cmd = 'cluster res /status'
	--print @cmd
	insert #clust_tb01 exec master.sys.xp_cmdshell @cmd
	delete from #clust_tb01 where text01 is null
	delete from #clust_tb01 where text01 = char(13)
	delete from #clust_tb01 where text01 = char(10)
	delete from #clust_tb01 where text01 = char(13)+char(10)
	delete from #clust_tb01 where text01 = char(10)+char(13)
	delete from #clust_tb01 where text01 not like 'SQL Server Agent%'
	--select * from #clust_tb01

	If (select count(*) from #clust_tb01 where text01 like '%' + @save_nodename + '%') > 1
	   begin
		Select @miscprint = 'Two or more SQL instances are active on this cluster node. ' + @save_nodename
		Print '--DBA Error: ' + @miscprint
		raiserror(67016, 16, -1, @miscprint)
	
		goto skip_clustercheck
	   end


	skip_clustercheck:


   end

skip_cluster:





--  Now we insert or update the central compression_backupinfo table if needed
If @save_compbackup_rg_flag = 'y'
   begin
	Select @miscprint = ' '
	Print  @miscprint

	Select @miscprint = '--  Start Compress_BackupInfo Updates for RedGate'
	Print  @miscprint

	If @save_iscluster = 'n'
	   begin
		Select @miscprint = 'if not exists (select 1 from dbo.Compress_BackupInfo where servername = ''' + upper(@save_servername) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      INSERT INTO dbo.Compress_BackupInfo (servername, SQLname, CompType, modDate) VALUES (''' + upper(@save_servername) + ''', ''' + upper(@@servername) + ''', ''RedGate'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		raiserror('', -1,-1) with nowait

		SELECT @cmd = 'sqlcmd -S' + @@servername + ' -w265 -u -Q"print ''' + @miscprint + '''" -E >>' + @outfile_path
		EXEC master.sys.xp_cmdshell @cmd, no_output

		Select @miscprint = ' '
		Print  @miscprint

		Select @miscprint = 'Update dbo.Compress_BackupInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,Version = ''' + @save_rg_version + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,VersionType = ''' + @save_rg_versiontype + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,License = ''' + @save_rg_license + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,InstallDate = ''' + convert(nvarchar(30), @save_rg_installdate, 121) + ''''
		Print  @miscprint

		Select @miscprint = 'where servername = ''' + upper(@save_servername) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'''
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait


		goto LS_start
	   end


	If @save_iscluster = 'y' and @save_clustNode01 is not null and @save_clustNode01 <> ''
	   begin
    		If @save_is64bit = 'n'
		   begin
			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end
		Else
		   begin
    			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Wow6432Node\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end


		If @@version like '%x64%'
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode01 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		Else
		   begin
			Select @cmd = 'reg query "\\' + @save_clustNode01 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		--print @cmd

		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults

		If exists (select 1 from #regresults where results like '%but is for a machine type%')
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode01 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
			--print @cmd

			insert into #regresults exec master.sys.xp_cmdshell @cmd
			delete from #regresults where results is null
			--select * from #regresults
		   end

		delete from #regresults where results like '%' + @in_path + '%'
		delete from #regresults where results not like '%' + @in_value + '%'


		select @save_rg_license = (select top 1 results from #regresults)
		--print @save_rg_license

		If @save_rg_license is not null and @save_rg_license <> ''
		   begin
			Select @charpos = charindex('REG_SZ', @save_rg_license)
			IF @charpos <> 0
			   begin
				Select @save_rg_license = substring(@save_rg_license, @charpos+6, 100)
			   end
			select @save_rg_license = rtrim(ltrim(@save_rg_license))
		   end
		Else
		   begin
			select @save_rg_license = 'Not Found'
		   end

		Select @miscprint = 'if not exists (select 1 from dbo.Compress_BackupInfo where servername = ''' + upper(@save_clustNode01) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      INSERT INTO dbo.Compress_BackupInfo (servername, SQLname, CompType, modDate) VALUES (''' + upper(@save_clustNode01) + ''', ''' + upper(@@servername) + ''', ''RedGate'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait

		Select @miscprint = 'Update dbo.Compress_BackupInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,Version = ''' + @save_rg_version + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,VersionType = ''' + @save_rg_versiontype + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,License = ''' + @save_rg_license + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,InstallDate = ''' + convert(nvarchar(30), @save_rg_installdate, 121) + ''''
		Print  @miscprint

		Select @miscprint = 'where servername = ''' + upper(@save_clustNode01) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'''
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait
	   end


	If @save_iscluster = 'y' and @save_clustNode02 is not null and @save_clustNode02 <> ''
	   begin
    		If @save_is64bit = 'n'
		   begin
			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end
		Else
		   begin
    			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Wow6432Node\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end


		If @@version like '%x64%'
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode02 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		Else
		   begin
			Select @cmd = 'reg query "\\' + @save_clustNode02 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		--print @cmd

		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults

		If exists (select 1 from #regresults where results like '%but is for a machine type%')
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode02 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
			--print @cmd

			insert into #regresults exec master.sys.xp_cmdshell @cmd
			delete from #regresults where results is null
			--select * from #regresults
		   end

		delete from #regresults where results like '%' + @in_path + '%'
		delete from #regresults where results not like '%' + @in_value + '%'

		select @save_rg_license = (select top 1 results from #regresults)
		--print @save_rg_license

		If @save_rg_license is not null and @save_rg_license <> ''
		   begin
			Select @charpos = charindex('REG_SZ', @save_rg_license)
			IF @charpos <> 0
			   begin
				Select @save_rg_license = substring(@save_rg_license, @charpos+6, 100)
			   end
			select @save_rg_license = rtrim(ltrim(@save_rg_license))
		   end
		Else
		   begin
			select @save_rg_license = 'Not Found'
		   end

		Select @miscprint = 'if not exists (select 1 from dbo.Compress_BackupInfo where servername = ''' + upper(@save_clustNode02) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      INSERT INTO dbo.Compress_BackupInfo (servername, SQLname, CompType, modDate) VALUES (''' + upper(@save_clustNode02) + ''', ''' + upper(@@servername) + ''', ''RedGate'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait

		Select @miscprint = 'Update dbo.Compress_BackupInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,Version = ''' + @save_rg_version + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,VersionType = ''' + @save_rg_versiontype + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,License = ''' + @save_rg_license + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,InstallDate = ''' + convert(nvarchar(30), @save_rg_installdate, 121) + ''''
		Print  @miscprint

		Select @miscprint = 'where servername = ''' + upper(@save_clustNode02) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'''
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait
	   end


	If @save_iscluster = 'y' and @save_clustNode03 is not null and @save_clustNode03 <> ''
	   begin
    		If @save_is64bit = 'n'
		   begin
			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end
		Else
		   begin
    			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Wow6432Node\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end


		If @@version like '%x64%'
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode03 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		Else
		   begin
			Select @cmd = 'reg query "\\' + @save_clustNode03 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		--print @cmd

		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults

		If exists (select 1 from #regresults where results like '%but is for a machine type%')
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode03 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
			--print @cmd

			insert into #regresults exec master.sys.xp_cmdshell @cmd
			delete from #regresults where results is null
			--select * from #regresults
		   end

		delete from #regresults where results like '%' + @in_path + '%'
		delete from #regresults where results not like '%' + @in_value + '%'

		select @save_rg_license = (select top 1 results from #regresults)
		--print @save_rg_license

		If @save_rg_license is not null and @save_rg_license <> ''
		   begin
			Select @charpos = charindex('REG_SZ', @save_rg_license)
			IF @charpos <> 0
			   begin
				Select @save_rg_license = substring(@save_rg_license, @charpos+6, 100)
			   end
			select @save_rg_license = rtrim(ltrim(@save_rg_license))
		   end
		Else
		   begin
			select @save_rg_license = 'Not Found'
		   end

		Select @miscprint = 'if not exists (select 1 from dbo.Compress_BackupInfo where servername = ''' + upper(@save_clustNode03) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      INSERT INTO dbo.Compress_BackupInfo (servername, SQLname, CompType, modDate) VALUES (''' + upper(@save_clustNode03) + ''', ''' + upper(@@servername) + ''', ''RedGate'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait

		Select @miscprint = 'Update dbo.Compress_BackupInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,Version = ''' + @save_rg_version + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,VersionType = ''' + @save_rg_versiontype + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,License = ''' + @save_rg_license + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,InstallDate = ''' + convert(nvarchar(30), @save_rg_installdate, 121) + ''''
		Print  @miscprint

		Select @miscprint = 'where servername = ''' + upper(@save_clustNode03) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'''
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait
	   end


	If @save_iscluster = 'y' and @save_clustNode04 is not null and @save_clustNode04 <> ''
	   begin
    		If @save_is64bit = 'n'
		   begin
			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end
		Else
		   begin
    			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Wow6432Node\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end


		If @@version like '%x64%'
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode04 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		Else
		   begin
			Select @cmd = 'reg query "\\' + @save_clustNode04 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		--print @cmd

		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults

		If exists (select 1 from #regresults where results like '%but is for a machine type%')
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode04 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
			--print @cmd

			insert into #regresults exec master.sys.xp_cmdshell @cmd
			delete from #regresults where results is null
			--select * from #regresults
		   end

		delete from #regresults where results like '%' + @in_path + '%'
		delete from #regresults where results not like '%' + @in_value + '%'

		select @save_rg_license = (select top 1 results from #regresults)
		--print @save_rg_license

		If @save_rg_license is not null and @save_rg_license <> ''
		   begin
			Select @charpos = charindex('REG_SZ', @save_rg_license)
			IF @charpos <> 0
			   begin
				Select @save_rg_license = substring(@save_rg_license, @charpos+6, 100)
			   end
			select @save_rg_license = rtrim(ltrim(@save_rg_license))
		   end
		Else
		   begin
			select @save_rg_license = 'Not Found'
		   end

		Select @miscprint = 'if not exists (select 1 from dbo.Compress_BackupInfo where servername = ''' + upper(@save_clustNode04) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      INSERT INTO dbo.Compress_BackupInfo (servername, SQLname, CompType, modDate) VALUES (''' + upper(@save_clustNode04) + ''', ''' + upper(@@servername) + ''', ''RedGate'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait

		Select @miscprint = 'Update dbo.Compress_BackupInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,Version = ''' + @save_rg_version + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,VersionType = ''' + @save_rg_versiontype + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,License = ''' + @save_rg_license + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,InstallDate = ''' + convert(nvarchar(30), @save_rg_installdate, 121) + ''''
		Print  @miscprint

		Select @miscprint = 'where servername = ''' + upper(@save_clustNode04) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'''
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait	
	   end


	If @save_iscluster = 'y' and @save_clustNode05 is not null and @save_clustNode05 <> ''
	   begin
    		If @save_is64bit = 'n'
		   begin
			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end
		Else
		   begin
    			select @in_key = 'HKEY_LOCAL_MACHINE'
			select @in_path = 'SOFTWARE\Wow6432Node\Red Gate\Licensing\SQL Backup'
			select @in_value = 'Serial number'
		   end


		If @@version like '%x64%'
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode05 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		Else
		   begin
			Select @cmd = 'reg query "\\' + @save_clustNode05 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
		   end
		--print @cmd

		insert into #regresults exec master.sys.xp_cmdshell @cmd
		delete from #regresults where results is null
		--select * from #regresults

		If exists (select 1 from #regresults where results like '%but is for a machine type%')
		   begin
			Select @cmd = 'reg2 query "\\' + @save_clustNode05 + '\' + @in_key + '\' + @in_path + '" /v "' + @in_value + '"'
			--print @cmd

			insert into #regresults exec master.sys.xp_cmdshell @cmd
			delete from #regresults where results is null
			--select * from #regresults
		   end

		delete from #regresults where results like '%' + @in_path + '%'
		delete from #regresults where results not like '%' + @in_value + '%'

		select @save_rg_license = (select top 1 results from #regresults)
		--print @save_rg_license

		If @save_rg_license is not null and @save_rg_license <> ''
		   begin
			Select @charpos = charindex('REG_SZ', @save_rg_license)
			IF @charpos <> 0
			   begin
				Select @save_rg_license = substring(@save_rg_license, @charpos+6, 100)
			   end
			select @save_rg_license = rtrim(ltrim(@save_rg_license))
		   end
		Else
		   begin
			select @save_rg_license = 'Not Found'
		   end

		Select @miscprint = 'if not exists (select 1 from dbo.Compress_BackupInfo where servername = ''' + upper(@save_clustNode05) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      INSERT INTO dbo.Compress_BackupInfo (servername, SQLname, CompType, modDate) VALUES (''' + upper(@save_clustNode05) + ''', ''' + upper(@@servername) + ''', ''RedGate'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait

		Select @miscprint = 'Update dbo.Compress_BackupInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,Version = ''' + @save_rg_version + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,VersionType = ''' + @save_rg_versiontype + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,License = ''' + @save_rg_license + ''''
		Print  @miscprint

		Select @miscprint = '                                      ,InstallDate = ''' + convert(nvarchar(30), @save_rg_installdate, 121) + ''''
		Print  @miscprint

		Select @miscprint = 'where servername = ''' + upper(@save_clustNode05) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''RedGate'''
		Print  @miscprint

		Select @miscprint = 'go'
		Print  @miscprint

		Select @miscprint = ' '
		Print  @miscprint

		raiserror('', -1,-1) with nowait
	   end

   end

LS_start:
If @save_compbackup_ls_flag = 'y'
   begin
	Select @miscprint = ' '
	Print  @miscprint

	Select @miscprint = '--  Start Compress_BackupInfo Updates for LiteSpeed'
	Print  @miscprint

	Select @miscprint = 'if not exists (select 1 from dbo.Compress_BackupInfo where servername = ''' + upper(@save_servername) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''LiteSpeed'')'
	Print  @miscprint

	Select @miscprint = '   begin'
	Print  @miscprint

	Select @miscprint = '      INSERT INTO dbo.Compress_BackupInfo (servername, SQLname, CompType, modDate) VALUES (''' + upper(@save_servername) + ''', ''' + upper(@@servername) + ''', ''LiteSpeed'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
	Print  @miscprint

	Select @miscprint = '   end'
	Print  @miscprint

	Select @miscprint = 'go'
	Print  @miscprint

	Select @miscprint = ' '
	Print  @miscprint

	raiserror('', -1,-1) with nowait

	Select @miscprint = 'Update dbo.Compress_BackupInfo set modDate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,Version = ''' + @save_ls_version + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,VersionType = ''' + @save_ls_versiontype + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,License = ''' + @save_ls_license + ''''
	Print  @miscprint

	Select @miscprint = '                                      ,InstallDate = ''' + convert(nvarchar(30), @save_ls_installdate, 121) + ''''
	Print  @miscprint

	Select @miscprint = 'where servername = ''' + upper(@save_servername) + ''' and SQLname = ''' + upper(@@servername) + ''' and CompType = ''LiteSpeed'''
	Print  @miscprint

	Select @miscprint = 'go'
	Print  @miscprint

	Select @miscprint = ' '
	Print  @miscprint

	raiserror('', -1,-1) with nowait

   end





--  Disk performance capture section

Select @cmd = 'del c:\DBA_DiskCheck_DoNotDelete.txt2 /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

--  Check disk speed for master path
select @save_filepath = (select top 1 filename from master.sys.sysfiles order by fileid)
select @save_filepath = reverse(@save_filepath)
Select @charpos = charindex('\', @save_filepath)
IF @charpos <> 0
   begin
	select @save_filepath = substring(@save_filepath, @charpos, 500)
   end

If left(@save_filepath, 1) = '\'
   begin
	select @save_filepath = reverse(@save_filepath)
	Select @save_filepath = left(@save_filepath, len(@save_filepath)-1)
   end
Else
   begin
	select @save_filepath = reverse(@save_filepath)
   end

Select @save_master_path = @save_filepath

Select @cmd = 'robocopy c:\ "' + @save_filepath + '" DBA_DiskCheck_DoNotDelete.txt /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_master_push = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_master_push = 0
   end


Select @cmd = 'ren "' + @save_filepath + '\DBA_DiskCheck_DoNotDelete.txt" DBA_DiskCheck_DoNotDelete.txt2'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'robocopy "' + @save_filepath + '" c:\ DBA_DiskCheck_DoNotDelete.txt2 /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_master_pull = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_master_pull = 0
   end


Select @cmd = 'del "' + @save_filepath + '\DBA_DiskCheck_DoNotDelete.txt2" /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'del c:\DBA_DiskCheck_DoNotDelete.txt2 /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output



--  Check disk speed for tempdb path
select @save_filepath = (select top 1 filename from tempdb.sys.sysfiles order by fileid)
select @save_filepath = reverse(@save_filepath)
Select @charpos = charindex('\', @save_filepath)
IF @charpos <> 0
   begin
	select @save_filepath = substring(@save_filepath, @charpos, 500)
   end	

If left(@save_filepath, 1) = '\'
   begin
	select @save_filepath = reverse(@save_filepath)
	Select @save_filepath = left(@save_filepath, len(@save_filepath)-1)
   end
Else
   begin
	select @save_filepath = reverse(@save_filepath)
   end

Select @save_tempdb_path = @save_filepath

Select @cmd = 'robocopy c:\ "' + @save_filepath + '" DBA_DiskCheck_DoNotDelete.txt /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_tempdb_push = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_tempdb_push = 0
   end


Select @cmd = 'ren "' + @save_filepath + '\DBA_DiskCheck_DoNotDelete.txt" DBA_DiskCheck_DoNotDelete.txt2'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'robocopy "' + @save_filepath + '" c:\ DBA_DiskCheck_DoNotDelete.txt2 /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_tempdb_pull = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_tempdb_pull = 0
   end


Select @cmd = 'del "' + @save_filepath + '\DBA_DiskCheck_DoNotDelete.txt2" /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'del c:\DBA_DiskCheck_DoNotDelete.txt2 /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output



--  Check disk speed for MDF path
Select @save_sharename = @save_servername2 + '_mdf'
exec dbo.dbasp_get_share_path @save_sharename, @outpath output

Select @save_mdf_path = @outpath

Select @cmd = 'robocopy c:\ "' + @save_mdf_path + '" DBA_DiskCheck_DoNotDelete.txt /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_mdf_push = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_mdf_push = 0
   end


Select @cmd = 'ren "' + @save_mdf_path + '\DBA_DiskCheck_DoNotDelete.txt" DBA_DiskCheck_DoNotDelete.txt2'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'robocopy "' + @save_mdf_path + '" c:\ DBA_DiskCheck_DoNotDelete.txt2 /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_mdf_pull = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_mdf_pull = 0
   end


Select @cmd = 'del "' + @save_mdf_path + '\DBA_DiskCheck_DoNotDelete.txt2" /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'del c:\DBA_DiskCheck_DoNotDelete.txt2 /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output




--  Check disk speed for LDF path
Select @save_sharename = @save_servername2 + '_ldf'
exec dbo.dbasp_get_share_path @save_sharename, @outpath output

Select @save_ldf_path = @outpath

Select @cmd = 'robocopy c:\ "' + @save_ldf_path + '" DBA_DiskCheck_DoNotDelete.txt /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_ldf_push = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_ldf_push = 0
   end


Select @cmd = 'ren "' + @save_ldf_path + '\DBA_DiskCheck_DoNotDelete.txt" DBA_DiskCheck_DoNotDelete.txt2'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'robocopy "' + @save_ldf_path + '" c:\ DBA_DiskCheck_DoNotDelete.txt2 /NP /Z /R:3'
--Print @cmd

Waitfor delay '00:00:03'
delete from #copystats
Insert into #copystats exec master.sys.xp_cmdshell @cmd
delete from #copystats where copydata is null
delete from #copystats where copydata not like '%Bytes/sec%'
--select * from #copystats

If (select count(*) from #copystats) > 0
   begin
	Select @save_bytes_sec = (select top 1 copydata from #copystats)
	Select @charpos = charindex('Bytes/sec', @save_bytes_sec)
	IF @charpos <> 0
	   begin
		select @save_bytes_sec = substring(@save_bytes_sec, @charpos-21, 20)
		Select @save_bytes_sec = rtrim(ltrim(@save_bytes_sec))
		Select @save_ldf_pull = convert(bigint, @save_bytes_sec)
	   end	
   end
Else
   begin
	Select @save_ldf_pull = 0
   end


Select @cmd = 'del "' + @save_ldf_path + '\DBA_DiskCheck_DoNotDelete.txt2" /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output

Select @cmd = 'del c:\DBA_DiskCheck_DoNotDelete.txt2 /Q'
--Print @cmd
exec master.sys.xp_cmdshell @cmd, no_output



--  Insert data
If @save_master_path is null
   begin
	Select @save_master_path = 'unknown'
   end

If @save_tempdb_path is null
   begin
	Select @save_tempdb_path = 'unknown'
   end

If @save_mdf_path is null
   begin
	Select @save_mdf_path = 'unknown'
   end

If @save_ldf_path is null
   begin
	Select @save_ldf_path = 'unknown'
   end


Select @miscprint = ' '
Print  @miscprint

Select @miscprint = '--  Start DBA_DiskPerfinfo Insert'
Print  @miscprint

Select @miscprint = 'Delete from dbo.DBA_DiskPerfinfo where CreateDate < getdate()-60'
Print  @miscprint


Select @miscprint = 'go'
Print  @miscprint

Select @miscprint = ' '
Print  @miscprint

raiserror('', -1,-1) with nowait

Select @miscprint = 'INSERT INTO dbo.DBA_DiskPerfinfo values(''' + @@servername + ''''
Print  @miscprint

Select @miscprint = '                                                ,''' + @save_master_path + ''''
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_master_push)
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_master_pull)
Print  @miscprint

Select @miscprint = '                                                ,''' + @save_mdf_path + ''''
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_mdf_push)
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_mdf_pull)
Print  @miscprint

Select @miscprint = '                                                ,''' + @save_ldf_path + ''''
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_ldf_push)
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_ldf_pull)
Print  @miscprint

Select @miscprint = '                                                ,''' + @save_tempdb_path + ''''
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_tempdb_push)
Print  @miscprint

Select @miscprint = '                                                ,' + convert(nvarchar(30), @save_tempdb_pull)
Print  @miscprint

Select @miscprint = '                                                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
Print  @miscprint

Select @miscprint = '                                                )'
Print  @miscprint

Select @miscprint = 'go'
Print  @miscprint

Select @miscprint = ' '
Print  @miscprint

raiserror('', -1,-1) with nowait




---------------------------  Finalization  -----------------------
label99:

drop table #clust_tb01
drop table #config
drop TABLE #temp_tbl1
drop TABLE #temp_tbl2
drop table #regresults
drop table #fileexists
drop table #copystats
drop table #drives
drop TABLE #SqbOutput




 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Self_Register_web
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Self_Register_web]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Self_Register_web]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[dbasp_Self_Register_web]
--
--/*********************************************************
-- **  Stored Procedure dbasp_Self_Register_web                  
-- **  Written by Jim Wilson, Getty Images                
-- **  April 6, 2009                                      
-- **  
-- **  This procedure registers the local web servers
-- **  to the designated centrl SQL server.
-- ***************************************************************/
 as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	04/06/2009	Jim Wilson		New process
--	06/19/2009	Jim Wilson		Added code for IEver and MDACver.
--	07/10/2009	Jim Wilson		Fixed pagefile_path section.
--	07/15/2009	Jim Wilson		Fixed boot ini for server 2008 (there is none)
--						New section for HOTfix(s)
--	07/17/2009	Jim Wilson		Added new REGinfo section.
--	======================================================================================



-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd 				nvarchar(4000)
	,@filename_wild			nvarchar(50)
	,@filename_ext			nvarchar(50)
	,@save_sr_id			int
	,@save_sr_id2			int
	,@save_sr_id_DFG		int
	,@save_sr_id_mac		int
	,@save_sr_id_mac2		int
	,@save_sr_id_Adapter_Type	int
	,@save_sr_id_Product_Type	int
	,@save_sr_id_driver		int
	,@save_sr_id_disks		int	
	,@hold_servername		sysname
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_filename			sysname
	,@save_alt_filename		sysname
	,@charpos			int
	,@charpos2			int

DECLARE
	 @save_EnvName			sysname
	,@save_OSname			sysname
	,@save_OSver			sysname
	,@save_OSinstallDate		sysname
	,@save_OSuptime		sysname
	,@save_MemoryPhysical_Total	sysname
	,@save_MemoryPhysical_Avail	sysname
	,@save_MemoryVirtual_Total	sysname
	,@save_MemoryVirtual_Avail	sysname
	,@save_Domain			sysname
	,@save_Logon_Server		sysname
	,@save_SAN_flag			char(1)
	,@save_CPUnumber		sysname
	,@save_CPUtype			sysname
	,@save_BiosVer			sysname
	,@save_SMBiosVer		sysname
	,@save_MDACver			sysname
	,@save_IEver			sysname
	,@save_Boot_Loader		sysname
	,@save_Boot_Loader_temp		sysname
	,@save_Boot_OppSystems		sysname
	,@save_Boot_OppSystems_temp	sysname
	,@save_Pagefile_Maxsize		sysname
	,@save_Pagefile_Avail		sysname
	,@save_Pagefile_InUse		sysname
	,@save_Pagefile_path		sysname
	,@save_Pagefile_path_temp	sysname
	,@save_Path			nvarchar(2000)
	,@save_SystemManufacture	sysname
	,@save_SystemModel		sysname
	,@save_SystemType		sysname

Declare
	 @save_MACaddress		sysname
	,@save_order			int
	,@save_DefaultIPGateway		sysname
	,@save_Adapter_Type		sysname
	,@save_Product_Type		sysname
	,@save_Adapter_driver		sysname
	,@save_Adapter_name		sysname
	,@save_DNS			sysname
	,@save_IP			sysname
	,@save_IPsub			sysname
	,@save_WinsPri			sysname
	,@save_WinsSec			sysname
	,@save_Drive			nvarchar(5)
	,@save_Drive_temp		sysname
	,@save_Description		sysname
	,@save_Compressed		nvarchar(10)
	,@save_File_System		nvarchar(10)
	,@save_DriveSize		sysname
	,@save_DriveFreeSpace		sysname
	,@save_Driveinfo		sysname
	,@save_HOTfix_temp		sysname
	,@save_HOTfix			sysname
	,@save_REG01_temp		nvarchar(500)
	,@save_REG02_temp		nvarchar(500)
	,@save_KEYpath01		nvarchar(500)
	,@save_KEYpath02		nvarchar(500)
	,@save_KEYname			sysname
	,@save_KEYtype			sysname
	,@save_KEYdata			sysname



----------------  initial values  -------------------
select @filename_ext 	= 'txt'

Select @save_servername	= @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @hold_servername = @save_servername



create table #DirectoryTempTable (cmdoutput nvarchar(255) null)

create table #SystemReport	(sr_id int IDENTITY(1,1) NOT NULL
				,cmdoutput nvarchar(255) null)


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Check for files in the WEB_Register folder for this server
Delete from #DirectoryTempTable
Select @cmd = 'dir \\' + @hold_servername + '\' + @hold_servername + '_WEB_Register\SystemReport_*.' + @filename_ext + ' /B'
print @cmd
Insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null or cmdoutput = ''
--select * from #DirectoryTempTable

-- Check to see if there are files to process
If (select count(*) from #DirectoryTempTable) > 0
   begin
	start_files:

	Select @save_filename = (select top 1 cmdoutput from #DirectoryTempTable order by cmdoutput)
	Select @save_filename =  rtrim(@save_filename)

	--  Load SystemReport file into the main_temp table
	select @cmd = 'type \\' + @hold_servername + '\' + @hold_servername + '_WEB_Register\' + @save_filename
	--print @cmd

	Delete from #SystemReport
	insert into #SystemReport exec master.sys.xp_cmdshell @cmd
	delete from #SystemReport where cmdoutput is null
	delete from #SystemReport where cmdoutput = ''
	--select * from #SystemReport

	If (select count(*) from #SystemReport) > 0
	   begin
		--  WEB_Serverinfo section

		--  First, make sure we have a row in the WEB_Serverinfo table for this server
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Host Name%' order by sr_id)
		Select @save_servername = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'System Name%' order by sr_id)
		Select @save_servername2 = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		If @save_servername is not null
		   begin
			Select @save_servername = substring(@save_servername, 11, 200)
			Select @save_servername = ltrim(rtrim(@save_servername))
		   end
		Else If @save_servername2 is not null
		   begin
			Select @save_servername2 = substring(@save_servername2, 13, 200)
			Select @save_servername2 = replace(@save_servername2, '\', '')
			Select @save_servername = ltrim(rtrim(@save_servername2))
		   end

		If @save_servername is null or @save_servername = ''
		   begin
			Print '--  DBA Error:  Unknown server name for WEB_Serverinfo process.'
			goto skip_SystemReport
		   end

		Print ''
		Print ''
		Print '--  Start WEB_ServerInfo Updates for server ' + upper(@save_servername)
		Print 'if not exists (select 1 from dbaadmin.dbo.WEB_ServerInfo where ServerName = ''' + upper(@save_servername) + ''')'
		Print '   begin'
		Print '      INSERT INTO dbaadmin.dbo.WEB_ServerInfo (ServerName, ServerType, Active, modDate) VALUES (''' + upper(@save_servername) + ''', ''WebServer'', ''Y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print '   end'
		Print ''
		Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_ServerInfo where ServerName = ''' + upper(@save_servername) + ''')'
		Select @cmd = @cmd + '   begin'
		Select @cmd = @cmd + '      INSERT INTO dbaadmin.dbo.WEB_ServerInfo (ServerName, ServerType, Active, modDate) VALUES (''' + upper(@save_servername) + ''', ''WebServer'', ''Y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Select @cmd = @cmd + '   end'
		exec (@cmd)


		--  Get the Environment name
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Environment:%' order by sr_id)
		Select @save_EnvName = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_EnvName)
		IF @charpos <> 0
		   begin
			Select @save_EnvName = ltrim(substring(@save_EnvName, @charpos+1, 132))
		   end

		IF @save_EnvName is null or @save_EnvName = ''
		   begin
			Select @save_EnvName = 'Unknown'
		   end

		Print '--  Update Environment name for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set EnvName = ''' + @save_EnvName + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set EnvName = ''' + @save_EnvName + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)




		--  Get the OS info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'OS Name:%' order by sr_id)
		Select @save_OSname = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_OSname)
		IF @charpos <> 0
		   begin
			Select @save_OSname = ltrim(substring(@save_OSname, @charpos+1, 132))
		   end

		IF @save_OSname is null or @save_OSname = ''
		   begin
			Select @save_OSname = 'Unknown'
		   end


		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'OS Version:%' order by sr_id)
		Select @save_OSver = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_OSver)
		IF @charpos <> 0
		   begin
			Select @save_OSver = ltrim(substring(@save_OSver, @charpos+1, 132))
		   end

		IF @save_OSver is null or @save_OSver = ''
		   begin
			Select @save_OSver = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Original Install Date:%' order by sr_id)
		Select @save_OSinstallDate = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_OSinstallDate)
		IF @charpos <> 0
		   begin
			Select @save_OSinstallDate = ltrim(substring(@save_OSinstallDate, @charpos+1, 132))
		   end

		IF @save_OSinstallDate is null or @save_OSinstallDate = ''
		   begin
			Select @save_OSinstallDate = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'System Up Time:%' order by sr_id)
		Select @save_OSuptime = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_OSuptime)
		IF @charpos <> 0
		   begin
			Select @save_OSuptime = ltrim(substring(@save_OSuptime, @charpos+1, 132))
		   end

		IF @save_OSuptime is null or @save_OSuptime = ''
		   begin
			Select @save_OSuptime = 'Unknown'
		   end

		Print '--  Update OSinfo for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set OSname = ''' + @save_OSname + ''', OSver = ''' + @save_OSver + ''', OSinstallDate = ''' + @save_OSinstallDate + ''', OSuptime = ''' + @save_OSuptime + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set OSname = ''' + @save_OSname + ''', OSver = ''' + @save_OSver + ''', OSinstallDate = ''' + @save_OSinstallDate + ''', OSuptime = ''' + @save_OSuptime + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)


		--  Get the Memory info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Total Physical Memory:%' order by sr_id)
		Select @save_MemoryPhysical_Total = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_MemoryPhysical_Total)
		IF @charpos <> 0
		   begin
			Select @save_MemoryPhysical_Total = ltrim(substring(@save_MemoryPhysical_Total, @charpos+1, 132))
		   end

		IF @save_MemoryPhysical_Total is null or @save_MemoryPhysical_Total = ''
		   begin
			Select @save_MemoryPhysical_Total = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Available Physical Memory:%' order by sr_id)
		Select @save_MemoryPhysical_Avail = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_MemoryPhysical_Avail)
		IF @charpos <> 0
		   begin
			Select @save_MemoryPhysical_Avail = ltrim(substring(@save_MemoryPhysical_Avail, @charpos+1, 132))
		   end

		IF @save_MemoryPhysical_Avail is null or @save_MemoryPhysical_Avail = ''
		   begin
			Select @save_MemoryPhysical_Avail = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Total Virtual Memory%' order by sr_id)
		Select @save_MemoryVirtual_Total = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		IF @save_MemoryVirtual_Total is null or @save_MemoryVirtual_Total = ''
		   begin
			Select @save_MemoryVirtual_Total = 'Unknown'
		   end
		Else
		   begin
			Select @save_MemoryVirtual_Total = replace(@save_MemoryVirtual_Total, char(9), '')
			Select @save_MemoryVirtual_Total = replace(@save_MemoryVirtual_Total, 'Total Virtual Memory', '')
			Select @save_MemoryVirtual_Total = ltrim(rtrim(@save_MemoryVirtual_Total))
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Available Virtual Memory%' order by sr_id)
		Select @save_MemoryVirtual_Avail = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		IF @save_MemoryVirtual_Avail is null or @save_MemoryVirtual_Avail = ''
		   begin
			Select @save_MemoryVirtual_Avail = 'Unknown'
		   end
		Else
		   begin
			Select @save_MemoryVirtual_Avail = replace(@save_MemoryVirtual_Avail, char(9), '')
			Select @save_MemoryVirtual_Avail = replace(@save_MemoryVirtual_Avail, 'Available Virtual Memory', '')
			Select @save_MemoryVirtual_Avail = ltrim(rtrim(@save_MemoryVirtual_Avail))
		   end


		Print '--  Update Memory for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set MemoryPhysical_Total = ''' + @save_MemoryPhysical_Total + ''', MemoryPhysical_Avail = ''' + @save_MemoryPhysical_Avail + ''', MemoryVirtual_Total = ''' + @save_MemoryVirtual_Total + ''', MemoryVirtual_Avail = ''' + @save_MemoryVirtual_Avail + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set MemoryPhysical_Total = ''' + @save_MemoryPhysical_Total + ''', MemoryPhysical_Avail = ''' + @save_MemoryPhysical_Avail + ''', MemoryVirtual_Total = ''' + @save_MemoryVirtual_Total + ''', MemoryVirtual_Avail = ''' + @save_MemoryVirtual_Avail + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)



		--  Get domain and logon server info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Domain:%' order by sr_id)
		Select @save_Domain = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_Domain)
		IF @charpos <> 0
		   begin
			Select @save_Domain = ltrim(substring(@save_Domain, @charpos+1, 132))
		   end

		IF @save_Domain is null or @save_Domain = ''
		   begin
			Select @save_Domain = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Logon Server:%' order by sr_id)
		Select @save_Logon_Server = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_Logon_Server)
		IF @charpos <> 0
		   begin
			Select @save_Logon_Server = ltrim(substring(@save_Logon_Server, @charpos+1, 132))
		 end

		IF @save_Logon_Server is null or @save_Logon_Server = ''
		   begin
			Select @save_Logon_Server = 'Unknown'
		   end

		Print '--  Update Domain info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set Domain = ''' + @save_Domain + ''', Logon_Server = ''' + @save_Logon_Server + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set Domain = ''' + @save_Domain + ''', Logon_Server = ''' + @save_Logon_Server + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)



		--  Place holder for ipconfig info
		Select @save_SAN_flag = 'n'
		If exists (select 1 from #SystemReport where cmdoutput like 'Model=%' and (cmdoutput like '%Powerpath%' 
											or cmdoutput like '%RDAC%' 
											or cmdoutput like '%HSV110%' 
											or cmdoutput like '%FAStT%' 
											or cmdoutput like '%Multi-Path%'))
		   begin
			Select @save_SAN_flag = 'y'
		   end

		Print '--  Update SAN info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set SAN = ''' + @save_SAN_flag + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set SAN = ''' + @save_SAN_flag + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)


		--  Get CPU and Bios info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Processor(s):%' order by sr_id)
		Select @save_CPUnumber = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_CPUnumber)
		IF @charpos <> 0
		   begin
			Select @save_CPUnumber = ltrim(substring(@save_CPUnumber, @charpos+1, 132))
		   end

		Select @charpos = charindex(' ', @save_CPUnumber)
		IF @charpos <> 0
		   begin
			Select @save_CPUnumber = left(@save_CPUnumber, @charpos-1)
		   end

		IF @save_CPUnumber is null or @save_CPUnumber = ''
		   begin
			Select @save_CPUnumber = 'Unknown'
		   end

		Select @save_sr_id = @save_sr_id + 1
		Select @save_CPUtype = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		If @save_CPUtype like 'BIOS Version:%'
		   begin
			Select @save_CPUtype = 'Unknown'
		   end
		Else
		   begin
			Select @charpos = charindex(':', @save_CPUtype)
			IF @charpos <> 0
			   begin
				Select @save_CPUtype = ltrim(substring(@save_CPUtype, @charpos+1, 132))
			   end

			IF @save_CPUtype is null or @save_CPUtype = ''
			   begin
				Select @save_CPUtype = 'Unknown'
			   end
		   end


		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'BIOS Version:%' order by sr_id)
		Select @save_BiosVer = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_BiosVer)
		IF @charpos <> 0
		   begin
			Select @save_BiosVer = ltrim(substring(@save_BiosVer, @charpos+1, 132))
		   end

		IF @save_BiosVer is null or @save_BiosVer = ''
		   begin
			Select @save_BiosVer = 'Unknown'
		   end


		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'SMBIOS Version%' order by sr_id)
		Select @save_SMBiosVer = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex('SMBIOS Version', @save_SMBiosVer)
		IF @charpos <> 0
		   begin
			Select @save_SMBiosVer = replace(@save_SMBiosVer, char(9), '')
			Select @save_SMBiosVer = ltrim(substring(@save_SMBiosVer, 15, 132))
		   end

		IF @save_SMBiosVer is null or @save_SMBiosVer = ''
		   begin
			Select @save_SMBiosVer = 'Unknown'
		   end


		Print '--  Update CPU/Bios info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set CPUnumber = ''' + @save_CPUnumber + ''', CPUtype = ''' + @save_CPUtype + ''', BiosVer = ''' + @save_BiosVer + ''', SMBiosVer = ''' + @save_SMBiosVer + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set CPUnumber = ''' + @save_CPUnumber + ''', CPUtype = ''' + @save_CPUtype + ''', BiosVer = ''' + @save_BiosVer + ''', SMBiosVer = ''' + @save_SMBiosVer + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)



		--  Get MDAC version info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '%MDACVer.Version.%' order by sr_id)
		Select @save_MDACver = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex('MDACVer.Version.', @save_MDACver)
		IF @charpos <> 0
		   begin
			Select @save_MDACver = substring(@save_MDACver, @charpos+16, 20)
			Select @save_MDACver = replace(@save_MDACver, char(9), '')
			Select @save_MDACver = rtrim(@save_MDACver)
		   end

		IF @save_MDACver is null or @save_MDACver = ''
		   begin
			Select @save_MDACver = 'Unknown'
		   end

		Print '--  Update MDAC version info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set MDACver = ''' + @save_MDACver + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set MDACver = ''' + @save_MDACver + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)


		--  Get IE version info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '%microsoft\internet explorer%' order by sr_id)
		Select @save_IEver = (select cmdoutput from #SystemReport where sr_id = @save_sr_id+1)

		Select @charpos = charindex('REG_SZ', @save_IEver)
		IF @charpos <> 0
		   begin
			Select @save_IEver = substring(@save_IEver, @charpos+7, 50)
			Select @save_IEver = replace(@save_IEver, char(9), '')
			Select @save_IEver = ltrim(rtrim(@save_IEver))
		   end

		IF @save_IEver is null or @save_IEver = ''
		   begin
			Select @save_IEver = 'Unknown'
		   end

		Print '--  Update IE version info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set IEver = ''' + @save_IEver + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set IEver = ''' + @save_IEver + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)


		--  Get BOOT ini info
		Select @save_Boot_Loader = ''
		Select @save_Boot_OppSystems = ''

		If @save_OSname like '%2008%'
		   begin
			Select @save_Boot_Loader = 'na'
			Select @save_Boot_OppSystems = 'na'
			goto skip_bootini01
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '%boot loader%' order by sr_id)
		Select @save_sr_id = @save_sr_id + 1

		Select @save_sr_id2 = (select top 1 sr_id from #SystemReport where cmdoutput like '%operating systems%' order by sr_id)

		Select @save_Boot_Loader = ''

		If @save_sr_id2 > @save_sr_id
		   begin
			start_Boot_Loader:
			Select @save_Boot_Loader_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
			Select @save_Boot_Loader_temp = ltrim(rtrim(@save_Boot_Loader_temp))

			Select @save_Boot_Loader = @save_Boot_Loader + @save_Boot_Loader_temp

			Select @save_sr_id = @save_sr_id + 1
			If @save_sr_id2 > @save_sr_id
			   begin
				Select @save_Boot_Loader = @save_Boot_Loader + ' '
				goto start_Boot_Loader
			   end
		   end

		IF @save_Boot_Loader is null or @save_Boot_Loader = ''
		   begin
			Select @save_Boot_Loader = 'Unknown'
		   end


		Select @save_sr_id2 = @save_sr_id2 + 1
		If exists(select 1 from #SystemReport where sr_id = @save_sr_id2)
		   begin
			Select @save_Boot_OppSystems = ''

			start_Boot_OppSystems:
			Select @save_Boot_OppSystems_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id2)
			Select @save_Boot_OppSystems_temp = ltrim(rtrim(@save_Boot_OppSystems_temp))
			Select @save_Boot_OppSystems = @save_Boot_OppSystems + @save_Boot_OppSystems_temp

			Select @save_sr_id2 = @save_sr_id2 + 1
			If exists(select 1 from #SystemReport where sr_id = @save_sr_id2)
			   begin
				Select @save_Boot_OppSystems = @save_Boot_OppSystems + ' '

				goto start_Boot_OppSystems
			   end
		   end

		IF @save_Boot_OppSystems is null
		   begin
			Select @save_Boot_OppSystems = 'Unknown'
		   end

		skip_bootini01:

		Print '--  Update Boot ini info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set Boot_Loader = ''' + @save_Boot_Loader + ''', Boot_OppSystems = ''' + @save_Boot_OppSystems + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set Boot_Loader = ''' + @save_Boot_Loader + ''', Boot_OppSystems = ''' + @save_Boot_OppSystems + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)


		--  Get Pagefile info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Page File:%' and cmdoutput like '%Max Size:%' order by sr_id)
		Select @save_Pagefile_Maxsize = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex('Max Size:', @save_Pagefile_Maxsize)
		IF @charpos <> 0
		   begin
			Select @save_Pagefile_Maxsize = ltrim(substring(@save_Pagefile_Maxsize, @charpos+10, 132))
		   end

		IF @save_Pagefile_Maxsize is null or @save_Pagefile_Maxsize = ''
		   begin
			Select @save_Pagefile_Maxsize = 'Unknown'
		   end


		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Page File:%' and cmdoutput like '%Available:%' order by sr_id)
		Select @save_Pagefile_Avail = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex('Available:', @save_Pagefile_Avail)
		IF @charpos <> 0
		   begin
			Select @save_Pagefile_Avail = ltrim(substring(@save_Pagefile_Avail, @charpos+11, 132))
		   end

		IF @save_Pagefile_Avail is null or @save_Pagefile_Avail = ''
		   begin
			Select @save_Pagefile_Avail = 'Unknown'
		   end


		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Page File:%' and cmdoutput like '%In Use:%' order by sr_id)
		Select @save_Pagefile_InUse = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex('In Use:', @save_Pagefile_InUse)
		IF @charpos <> 0
		   begin
			Select @save_Pagefile_InUse = ltrim(substring(@save_Pagefile_InUse, @charpos+8, 132))
		   end

		IF @save_Pagefile_InUse is null or @save_Pagefile_InUse = ''
		   begin
			Select @save_Pagefile_InUse = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Page File Location(s):%' and cmdoutput not like '%N/A%' order by sr_id)
		Select @save_Pagefile_path = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_Pagefile_path)
		IF @charpos <> 0
		   begin
			Select @save_Pagefile_path = ltrim(substring(@save_Pagefile_path, @charpos+1, 132))

			check_for_more_pagefiles:
			Select @save_sr_id = @save_sr_id + 1
			Select @save_Pagefile_path_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
			If @save_Pagefile_path_temp not like 'Domain:%' and @save_Pagefile_path_temp like '%:\%'
			   begin
				Select @save_Pagefile_path = @save_Pagefile_path + ', ' + ltrim(rtrim(@save_Pagefile_path_temp))
				goto check_for_more_pagefiles
			   end
			goto Pagefile_path_end
		   end


		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'Page File%' and cmdoutput like '%:\%' order by sr_id)
		Select @save_Pagefile_path = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)


		Select @charpos = charindex('Page File', @save_Pagefile_path)
		IF @charpos <> 0
		   begin
			Select @save_Pagefile_path = substring(@save_Pagefile_path, @charpos+10, 132)
			Select @save_Pagefile_path = replace(@save_Pagefile_path, char(9), '')
			Select @save_Pagefile_path = ltrim(@save_Pagefile_path)
			Select @save_Pagefile_path = rtrim(@save_Pagefile_path)

			check_for_more_pagefiles02:
			Select @save_sr_id = @save_sr_id + 1
			Select @save_Pagefile_path_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
			If @save_Pagefile_path_temp not like 'Domain:%' and @save_Pagefile_path_temp like '%:\%'
			   begin
				Select @save_Pagefile_path = @save_Pagefile_path + ', ' + ltrim(rtrim(@save_Pagefile_path_temp))
				goto check_for_more_pagefiles02
			   end
			goto Pagefile_path_end
		   end


		IF @save_Pagefile_path is null or @save_Pagefile_path = ''
		   begin
			Select @save_Pagefile_path = 'Unknown'
		   end

		Pagefile_path_end:


		Print '--  Update Page file info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set Pagefile_Maxsize = ''' + @save_Pagefile_Maxsize + ''', Pagefile_Avail = ''' + @save_Pagefile_Avail + ''', Pagefile_InUse = ''' + @save_Pagefile_InUse + ''', Pagefile_path = ''' + @save_Pagefile_path + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set Pagefile_Maxsize = ''' + @save_Pagefile_Maxsize + ''', Pagefile_Avail = ''' + @save_Pagefile_Avail + ''', Pagefile_InUse = ''' + @save_Pagefile_InUse + ''', Pagefile_path = ''' + @save_Pagefile_path + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)



		--  Get Path info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '% Path %' and cmdoutput like '%REG_%' order by sr_id)
		Select @save_Path = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex('REG_', @save_Path)
		IF @charpos <> 0
		   begin
			Select @save_Path = ltrim(substring(@save_Path, @charpos+1, 2000))
			Select @charpos = charindex(' ', @save_Path)
			IF @charpos <> 0
			   begin
				Select @save_Path = ltrim(substring(@save_Path, @charpos+1, 2000))
				Select @save_Path = replace(@save_Path, char(9), '')
				Select @save_Path = ltrim(rtrim(@save_Path))
			   end
		   end

		IF @save_Path is null or @save_Path = ''
		   begin
			Select @save_Path = 'Unknown'
		   end


		Print '--  Update Path for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set Path = ''' + @save_Path + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set Path = ''' + @save_Path + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)



		--  Get Hardware info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'System Manufacturer:%' order by sr_id)
		Select @save_SystemManufacture = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_SystemManufacture)
		IF @charpos <> 0
		   begin
			Select @save_SystemManufacture = ltrim(substring(@save_SystemManufacture, @charpos+1, 132))
		   end

		IF @save_SystemManufacture is null or @save_SystemManufacture = ''
		   begin
			Select @save_SystemManufacture = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'System Model:%' order by sr_id)
		Select @save_SystemModel = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_SystemModel)
		IF @charpos <> 0
		   begin
			Select @save_SystemModel = ltrim(substring(@save_SystemModel, @charpos+1, 132))
		   end

		IF @save_SystemModel is null or @save_SystemModel = ''
		   begin
			Select @save_SystemModel = 'Unknown'
		   end

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'System Type:%' order by sr_id)
		Select @save_SystemType = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex(':', @save_SystemType)
		IF @charpos <> 0
		   begin
			Select @save_SystemType = ltrim(substring(@save_SystemType, @charpos+1, 132))
		   end

		IF @save_SystemType is null or @save_SystemType = ''
		   begin
			Select @save_SystemType = 'Unknown'
		   end


		Print '--  Update Path and Hardware info for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_ServerInfo set SystemManufacture = ''' + @save_SystemManufacture + ''', SystemModel = ''' + @save_SystemModel + ''', SystemType = ''' + @save_SystemType + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print 'Where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_ServerInfo set SystemManufacture = ''' + @save_SystemManufacture + ''', SystemModel = ''' + @save_SystemModel + ''', SystemType = ''' + @save_SystemType + ''', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)



		--  Process the IPconfig info
		Print '--  Set all rows in the IPconfig table for this server to active = ''n'''
		Print 'Update dbaadmin.dbo.WEB_IPconfig set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_IPconfig set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)

		Select @save_sr_id = 1 

		start_IPconfig01:

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'DNSHostName%' 
										and cmdoutput like '%' + @save_servername + '%' 
										and sr_id > @save_sr_id order by sr_id)


		If @save_sr_id is null or @save_sr_id = 0
		   begin
			goto end_IPconfig
		   end


		--  get the MACaddress and Adapter info for this entry
		Select @save_sr_id_mac = (select top 1 sr_id from #SystemReport where cmdoutput like 'MACAddress%' and sr_id > @save_sr_id order by sr_id)
		Select @save_MACaddress = (select cmdoutput from #SystemReport where sr_id = @save_sr_id_mac)

		Select @charpos = charindex('=', @save_MACaddress)
		IF @charpos <> 0
		   begin
			Select @save_MACaddress = substring(@save_MACaddress, @charpos+1, 132)
			Select @save_MACaddress = ltrim(rtrim(@save_MACaddress))
		   end

		IF @save_MACaddress is null or @save_MACaddress = ''
		   begin
			goto skip_IPconfig
		   end


		Select @save_sr_id_mac2 = (select top 1 sr_id from #SystemReport where cmdoutput like 'MAC Address%' and cmdoutput like '%' + @save_MACaddress + '%' and sr_id > @save_sr_id order by sr_id)
		Select @save_sr_id_Adapter_Type = (select top 1 sr_id from #SystemReport where cmdoutput like 'Adapter Type%' and sr_id < @save_sr_id_mac2 order by sr_id desc)
		Select @save_Adapter_Type = (select cmdoutput from #SystemReport where sr_id = @save_sr_id_Adapter_Type)

		Select @charpos = charindex('Adapter Type', @save_Adapter_Type)
		IF @charpos <> 0
		   begin
			Select @save_Adapter_Type = substring(@save_Adapter_Type, @charpos+13, 132)
			Select @save_Adapter_Type = ltrim(rtrim(@save_Adapter_Type))
		   end

		IF @save_Adapter_Type is null or @save_Adapter_Type = ''
		   begin
			Select @save_Adapter_Type = 'Not Available'
		   end


		Select @save_sr_id_Product_Type = (select top 1 sr_id from #SystemReport where cmdoutput like 'Product Type%' and sr_id > @save_sr_id_Adapter_Type order by sr_id)
		Select @save_Product_Type = (select cmdoutput from #SystemReport where sr_id = @save_sr_id_Product_Type)

		Select @charpos = charindex('Product Type', @save_Product_Type)
		IF @charpos <> 0
		   begin
			Select @save_Product_Type = substring(@save_Product_Type, @charpos+13, 132)
			Select @save_Product_Type = ltrim(rtrim(@save_Product_Type))
		   end


		IF @save_Product_Type is null or @save_Product_Type = ''
		   begin
			Select @save_Product_Type = 'Not Available'
		   end

		If @save_Adapter_Type <> 'Not Available' and @save_Product_Type <> 'Not Available'
		   begin
			Select @save_Adapter_name = @save_Product_Type + ' ' + @save_Adapter_Type
			Select @save_Adapter_name = replace(@save_Adapter_name, char(9), ' ')
		   end
		Else
		   begin
			Select @save_Adapter_name = 'Not Available'
		   end


		Select @save_sr_id_driver = (select top 1 sr_id from #SystemReport where cmdoutput like 'Driver%' and sr_id > @save_sr_id_Product_Type order by sr_id)
		Select @save_Adapter_driver = (select cmdoutput from #SystemReport where sr_id = @save_sr_id_driver)

		Select @charpos = charindex('Driver', @save_Adapter_driver)
		IF @charpos <> 0
		   begin
			Select @save_Adapter_driver = substring(@save_Adapter_driver, @charpos+7, 132)
			Select @save_Adapter_driver = ltrim(rtrim(@save_Adapter_driver))
		   end

		IF @save_Adapter_driver is null or @save_Adapter_driver = ''
		   begin
			Select @save_Adapter_driver = 'Not Available'
		   end

		

		-- Get the default Gateway info
		Select @save_sr_id_DFG = @save_sr_id - 1
		Select @save_order = 1
		Select @save_DefaultIPGateway = (select cmdoutput from #SystemReport where sr_id = @save_sr_id_DFG)
		
		Select @charpos = charindex('"', @save_DefaultIPGateway)
		start_dfg01:
		Select @charpos2 = charindex('"', @save_DefaultIPGateway, @charpos+1)
		IF @charpos <> 0 and @charpos2 <> 0
		   begin
			Select @save_DefaultIPGateway = substring(@save_DefaultIPGateway, @charpos+1, @charpos2-@charpos-1)
			Select @save_DefaultIPGateway = ltrim(rtrim(@save_DefaultIPGateway))

			Print '--  Insert/Update IPconfig DFG info for server ' + upper(@save_servername)
			Print 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Print '                        where ServerName = ''' + upper(@save_servername) + ''''
			Print '                          and MACaddress = ''' + @save_MACaddress + ''''
			Print '                          and IPtype = ''DFLT_Gateway'''
			Print '                          and IPaddress = ''' + @save_DefaultIPGateway + ''''
			Print '                          )'
			Print '   begin'
			Print '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Print '         values (''' + upper(@save_servername) + ''''
			Print '                ,''' + @save_Adapter_name + ''''
			Print '                ,''' + @save_Adapter_driver + ''''
			Print '                ,''' + @save_MACaddress + ''''
			Print '                ,''DFLT_Gateway'''
			Print '                ,''' + @save_DefaultIPGateway + ''''
			Print '                ,' + convert(nvarchar(10), @save_order)
			Print '                ,''y'''
			Print '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                )'
			Print '   end '
			Print 'Else'
			Print '   begin'
			Print '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Print '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Print '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Print '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                                          ,active = ''y'''
			Print '         where ServerName = ''' + upper(@save_servername) + ''''
			Print '           and MACaddress = ''' + @save_MACaddress + ''''
			Print '           and IPtype = ''DFLT_Gateway'''
			Print '           and IPaddress = ''' + @save_DefaultIPGateway + ''''
			Print '   end'
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Select @cmd = @cmd + '                        where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                          and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                          and IPtype = ''DFLT_Gateway'''
			Select @cmd = @cmd + '                          and IPaddress = ''' + @save_DefaultIPGateway + ''''
			Select @cmd = @cmd + '                          )'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Select @cmd = @cmd + '         values (''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                ,''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                ,''DFLT_Gateway'''
			Select @cmd = @cmd + '                ,''' + @save_DefaultIPGateway + ''''
			Select @cmd = @cmd + '                ,' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                ,''y'''
			Select @cmd = @cmd + '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                )'
			Select @cmd = @cmd + '   end '
			Select @cmd = @cmd + 'Else'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                                          ,active = ''y'''
			Select @cmd = @cmd + '         where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '           and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '           and IPtype = ''DFLT_Gateway'''
			Select @cmd = @cmd + '           and IPaddress = ''' + @save_DefaultIPGateway + ''''
			Select @cmd = @cmd + '   end'
			exec (@cmd)

			Select @save_DefaultIPGateway = (select cmdoutput from #SystemReport where sr_id = @save_sr_id_DFG)
			Select @charpos = charindex('"', @save_DefaultIPGateway, @charpos2+1)
			IF @charpos <> 0
			   begin
				Select @save_order = @save_order + 1
				goto start_dfg01
			   end
		   end
		Else
		   begin
			goto skip_DFG
		   end


		skip_DFG:



		-- Get the DNS info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'DNSServerSearchOrder%' and sr_id > @save_sr_id order by sr_id)
		Select @save_order = 1
		Select @save_DNS = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
		
		Select @charpos = charindex('"', @save_DNS)
		start_dns01:
		Select @charpos2 = charindex('"', @save_DNS, @charpos+1)
		IF @charpos <> 0 and @charpos2 <> 0
		   begin
			Select @save_DNS = substring(@save_DNS, @charpos+1, @charpos2-@charpos-1)
			Select @save_DNS = ltrim(rtrim(@save_DNS))

			Print '--  Insert/Update IPconfig DNS info for server ' + upper(@save_servername)
			Print 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Print '                        where ServerName = ''' + upper(@save_servername) + ''''
			Print '                          and MACaddress = ''' + @save_MACaddress + ''''
			Print '                          and IPtype = ''DNS'''
			Print '                          and IPaddress = ''' + @save_DNS + ''''
			Print '                          )'
			Print '   begin'
			Print '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Print '         values (''' + upper(@save_servername) + ''''
			Print '                ,''' + @save_Adapter_name + ''''
			Print '                ,''' + @save_Adapter_driver + ''''
			Print '                ,''' + @save_MACaddress + ''''
			Print '                ,''DNS'''
			Print '                ,''' + @save_DNS + ''''
			Print '                ,' + convert(nvarchar(10), @save_order)
			Print '                ,''y'''
			Print '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                )'
			Print '   end '
			Print 'Else'
			Print '   begin'
			Print '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Print '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Print '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Print '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                                          ,active = ''y'''
			Print '         where ServerName = ''' + upper(@save_servername) + ''''
			Print '           and MACaddress = ''' + @save_MACaddress + ''''
			Print '           and IPtype = ''DNS'''
			Print '           and IPaddress = ''' + @save_DNS + ''''
			Print '   end'
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Select @cmd = @cmd + '                        where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                          and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                          and IPtype = ''DNS'''
			Select @cmd = @cmd + '                          and IPaddress = ''' + @save_DNS + ''''
			Select @cmd = @cmd + '                          )'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Select @cmd = @cmd + '         values (''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                ,''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                ,''DNS'''
			Select @cmd = @cmd + '                ,''' + @save_DNS + ''''
			Select @cmd = @cmd + '                ,' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                ,''y'''
			Select @cmd = @cmd + '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                )'
			Select @cmd = @cmd + '   end '
			Select @cmd = @cmd + 'Else'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                                          ,active = ''y'''
			Select @cmd = @cmd + '         where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '           and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '           and IPtype = ''DNS'''
			Select @cmd = @cmd + '           and IPaddress = ''' + @save_DNS + ''''
			Select @cmd = @cmd + '   end'
			exec (@cmd)


			Select @save_DNS = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
			Select @charpos = charindex('"', @save_DNS, @charpos2+1)
			IF @charpos <> 0
			   begin
				Select @save_order = @save_order + 1
				goto start_dns01
			   end
		   end
		Else
		   begin
			goto skip_DNS
		   end


		skip_DNS:



		-- Get the IP info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'IPAddress%' and sr_id > @save_sr_id order by sr_id)
		Select @save_order = 1
		Select @save_IP = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
		
		Select @charpos = charindex('"', @save_IP)
		start_ip01:
		Select @charpos2 = charindex('"', @save_IP, @charpos+1)
		IF @charpos <> 0 and @charpos2 <> 0
		   begin
			Select @save_IP = substring(@save_IP, @charpos+1, @charpos2-@charpos-1)
			Select @save_IP = ltrim(rtrim(@save_IP))

			Print '--  Insert/Update IPconfig DNS info for server ' + upper(@save_servername)
			Print 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Print '                        where ServerName = ''' + upper(@save_servername) + ''''
			Print '                          and MACaddress = ''' + @save_MACaddress + ''''
			Print '                          and IPtype = ''IP'''
			Print '                          and IPaddress = ''' + @save_IP + ''''
			Print '                          )'
			Print '   begin'
			Print '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Print '         values (''' + upper(@save_servername) + ''''
			Print '                ,''' + @save_Adapter_name + ''''
			Print '                ,''' + @save_Adapter_driver + ''''
			Print '                ,''' + @save_MACaddress + ''''
			Print '                ,''IP'''
			Print '                ,''' + @save_IP + ''''
			Print '                ,' + convert(nvarchar(10), @save_order)
			Print '                ,''y'''
			Print '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                )'
			Print '   end '
			Print 'Else'
			Print '   begin'
			Print '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Print '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Print '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Print '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                                          ,active = ''y'''
			Print '         where ServerName = ''' + upper(@save_servername) + ''''
			Print '           and MACaddress = ''' + @save_MACaddress + ''''
			Print '           and IPtype = ''IP'''
			Print '           and IPaddress = ''' + @save_IP + ''''
			Print '   end'
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Select @cmd = @cmd + '                        where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                          and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                          and IPtype = ''IP'''
			Select @cmd = @cmd + '                          and IPaddress = ''' + @save_IP + ''''
			Select @cmd = @cmd + '                          )'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Select @cmd = @cmd + '         values (''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                ,''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                ,''IP'''
			Select @cmd = @cmd + '                ,''' + @save_IP + ''''
			Select @cmd = @cmd + '                ,' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                ,''y'''
			Select @cmd = @cmd + '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                )'
			Select @cmd = @cmd + '   end '
			Select @cmd = @cmd + 'Else'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                                          ,active = ''y'''
			Select @cmd = @cmd + '         where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '           and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '           and IPtype = ''IP'''
			Select @cmd = @cmd + '           and IPaddress = ''' + @save_IP + ''''
			Select @cmd = @cmd + '   end'
			exec (@cmd)


			Select @save_IP = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
			Select @charpos = charindex('"', @save_IP, @charpos2+1)
			IF @charpos <> 0
			   begin
				Select @save_order = @save_order + 1
				goto start_ip01
			   end
		   end
		Else
		   begin
			goto skip_IP
		   end


		skip_IP:




		-- Get the Subnet info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'IPSubnet%' and sr_id > @save_sr_id order by sr_id)
		Select @save_order = 1
		Select @save_IPsub = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
		
		Select @charpos = charindex('"', @save_IPsub)
		Select @charpos2 = charindex('"', @save_IPsub, @charpos+1)
		IF @charpos <> 0 and @charpos2 <> 0
		   begin
			Select @save_IPsub = substring(@save_IPsub, @charpos+1, @charpos2-@charpos-1)
			Select @save_IPsub = ltrim(rtrim(@save_IPsub))

			Print '--  Insert/Update IPconfig DNS info for server ' + upper(@save_servername)
			Print 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Print '                        where ServerName = ''' + upper(@save_servername) + ''''
			Print '                          and MACaddress = ''' + @save_MACaddress + ''''
			Print '                          and IPtype = ''Subnet'''
			Print '                          and IPaddress = ''' + @save_IPsub + ''''
			Print '                          )'
			Print '   begin'
			Print '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Print '         values (''' + upper(@save_servername) + ''''
			Print '                ,''' + @save_Adapter_name + ''''
			Print '                ,''' + @save_Adapter_driver + ''''
			Print '                ,''' + @save_MACaddress + ''''
			Print '                ,''Subnet'''
			Print '                ,''' + @save_IPsub + ''''
			Print '                ,' + convert(nvarchar(10), @save_order)
			Print '                ,''y'''
			Print '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                )'
			Print '   end '
			Print 'Else'
			Print '   begin'
			Print '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Print '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Print '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Print '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                                          ,active = ''y'''
			Print '         where ServerName = ''' + upper(@save_servername) + ''''
			Print '           and MACaddress = ''' + @save_MACaddress + ''''
			Print '           and IPtype = ''Subnet'''
			Print '           and IPaddress = ''' + @save_IPsub + ''''
			Print '   end'
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Select @cmd = @cmd + '                        where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                          and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                          and IPtype = ''Subnet'''
			Select @cmd = @cmd + '                          and IPaddress = ''' + @save_IPsub + ''''
			Select @cmd = @cmd + '                          )'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Select @cmd = @cmd + '         values (''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                ,''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                ,''Subnet'''
			Select @cmd = @cmd + '                ,''' + @save_IPsub + ''''
			Select @cmd = @cmd + '                ,' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                ,''y'''
			Select @cmd = @cmd + '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                )'
			Select @cmd = @cmd + '   end '
			Select @cmd = @cmd + 'Else'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                                          ,active = ''y'''
			Select @cmd = @cmd + '         where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '           and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '           and IPtype = ''Subnet'''
			Select @cmd = @cmd + '           and IPaddress = ''' + @save_IPsub + ''''
			Select @cmd = @cmd + '   end'
			exec (@cmd)
		   end



		-- Get the WINS Primary info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'WINSPrimaryServer%' and sr_id > @save_sr_id order by sr_id)
		Select @save_order = 1
		Select @save_WinsPri = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
		
		Select @charpos = charindex('=', @save_WinsPri)
		IF @charpos <> 0
		   begin
			Select @save_WinsPri = substring(@save_WinsPri, @charpos+1, 132)
			Select @save_WinsPri = ltrim(rtrim(@save_WinsPri))

			Print '--  Insert/Update IPconfig DNS info for server ' + upper(@save_servername)
			Print 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Print '                        where ServerName = ''' + upper(@save_servername) + ''''
			Print '                          and MACaddress = ''' + @save_MACaddress + ''''
			Print '                          and IPtype = ''WinsPrimary'''
			Print '                          and IPaddress = ''' + @save_WinsPri + ''''
			Print '                          )'
			Print '   begin'
			Print '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Print '         values (''' + upper(@save_servername) + ''''
			Print '                ,''' + @save_Adapter_name + ''''
			Print '                ,''' + @save_Adapter_driver + ''''
			Print '                ,''' + @save_MACaddress + ''''
			Print '                ,''WinsPrimary'''
			Print '                ,''' + @save_WinsPri + ''''
			Print '                ,' + convert(nvarchar(10), @save_order)
			Print '                ,''y'''
			Print '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                )'
			Print '   end '
			Print 'Else'
			Print '   begin'
			Print '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Print '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Print '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Print '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                                          ,active = ''y'''
			Print '         where ServerName = ''' + upper(@save_servername) + ''''
			Print '           and MACaddress = ''' + @save_MACaddress + ''''
			Print '           and IPtype = ''WinsPrimary'''
			Print '           and IPaddress = ''' + @save_WinsPri + ''''
			Print '   end'
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Select @cmd = @cmd + '                        where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                          and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                          and IPtype = ''WinsPrimary'''
			Select @cmd = @cmd + '                          and IPaddress = ''' + @save_WinsPri + ''''
			Select @cmd = @cmd + '                          )'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Select @cmd = @cmd + '         values (''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                ,''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                ,''WinsPrimary'''
			Select @cmd = @cmd + '                ,''' + @save_WinsPri + ''''
			Select @cmd = @cmd + '                ,' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                ,''y'''
			Select @cmd = @cmd + '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                )'
			Select @cmd = @cmd + '   end '
			Select @cmd = @cmd + 'Else'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                                          ,active = ''y'''
			Select @cmd = @cmd + '         where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '           and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '           and IPtype = ''WinsPrimary'''
			Select @cmd = @cmd + '           and IPaddress = ''' + @save_WinsPri + ''''
			Select @cmd = @cmd + '   end'
			exec (@cmd)
		   end



		-- Get the WINS Secondary info
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'WINSSecondaryServer%' and sr_id > @save_sr_id order by sr_id)
		Select @save_order = 1
		Select @save_WinsSec = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
		
		Select @charpos = charindex('=', @save_WinsSec)
		IF @charpos <> 0
		   begin
			Select @save_WinsSec = substring(@save_WinsSec, @charpos+1, 132)
			Select @save_WinsSec = ltrim(rtrim(@save_WinsSec))

			Print '--  Insert/Update IPconfig DNS info for server ' + upper(@save_servername)
			Print 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Print '                        where ServerName = ''' + upper(@save_servername) + ''''
			Print '                          and MACaddress = ''' + @save_MACaddress + ''''
			Print '                          and IPtype = ''WinsSecondary'''
			Print '                          and IPaddress = ''' + @save_WinsSec + ''''
			Print '                          )'
			Print '   begin'
			Print '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Print '         values (''' + upper(@save_servername) + ''''
			Print '                ,''' + @save_Adapter_name + ''''
			Print '                ,''' + @save_Adapter_driver + ''''
			Print '                ,''' + @save_MACaddress + ''''
			Print '                ,''WinsSecondary'''
			Print '                ,''' + @save_WinsSec + ''''
			Print '                ,' + convert(nvarchar(10), @save_order)
			Print '                ,''y'''
			Print '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                )'
			Print '   end '
			Print 'Else'
			Print '   begin'
			Print '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Print '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Print '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Print '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print '                                          ,active = ''y'''
			Print '         where ServerName = ''' + upper(@save_servername) + ''''
			Print '           and MACaddress = ''' + @save_MACaddress + ''''
			Print '           and IPtype = ''WinsSecondary'''
			Print '           and IPaddress = ''' + @save_WinsSec + ''''
			Print '   end'
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_IPconfig'
			Select @cmd = @cmd + '                        where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                          and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                          and IPtype = ''WinsSecondary'''
			Select @cmd = @cmd + '                          and IPaddress = ''' + @save_WinsSec + ''''
			Select @cmd = @cmd + '                          )'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Insert into dbaadmin.dbo.WEB_IPconfig (ServerName, Adapter_name, Adapter_driver, MACaddress, IPtype, IPaddress, IPorder, active, modDate)'
			Select @cmd = @cmd + '         values (''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                ,''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                ,''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '                ,''WinsSecondary'''
			Select @cmd = @cmd + '                ,''' + @save_WinsSec + ''''
			Select @cmd = @cmd + '                ,' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                ,''y'''
			Select @cmd = @cmd + '                ,''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                )'
			Select @cmd = @cmd + '   end '
			Select @cmd = @cmd + 'Else'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      Update dbaadmin.dbo.WEB_IPconfig set Adapter_name = ''' + @save_Adapter_name + ''''
			Select @cmd = @cmd + '                                          ,Adapter_driver = ''' + @save_Adapter_driver + ''''
			Select @cmd = @cmd + '                                          ,IPorder = ' + convert(nvarchar(10), @save_order)
			Select @cmd = @cmd + '                                          ,moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + '                                          ,active = ''y'''
			Select @cmd = @cmd + '         where ServerName = ''' + upper(@save_servername) + ''''
			Select @cmd = @cmd + '           and MACaddress = ''' + @save_MACaddress + ''''
			Select @cmd = @cmd + '           and IPtype = ''WinsSecondary'''
			Select @cmd = @cmd + '           and IPaddress = ''' + @save_WinsSec + ''''
			Select @cmd = @cmd + '   end'
			exec (@cmd)
		   end



		skip_IPconfig:

		Select @save_sr_id = @save_sr_id + 1
		If exists (select 1 from #SystemReport where cmdoutput like 'DNSHostName%' and cmdoutput like '%' + @save_servername + '%' and sr_id > @save_sr_id)
		   begin
			goto start_IPconfig01
		   end

		end_IPconfig:


		-- Get the Drive info
		Print ''
		Print '--  Reset all WEB_DriveInfo rows to active = ''n'' for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_DriveInfo set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_DriveInfo set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '%Storage%' order by sr_id)
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '%Drives%' and sr_id > @save_sr_id order by sr_id)
		Select @save_sr_id_disks = (select top 1 sr_id from #SystemReport where cmdoutput like '%Disks%' and sr_id > @save_sr_id order by sr_id)

		start_drive:
		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '%Drive%' and sr_id > @save_sr_id order by sr_id)
		Select @save_Drive_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		Select @charpos = charindex('Drive', @save_Drive_temp)
		IF @charpos <> 0
		   begin
			Select @save_Drive_temp = substring(@save_Drive_temp, @charpos+6, 132)
			Select @save_Drive_temp = replace(@save_Drive_temp, char(9), '')
			Select @save_Drive = ltrim(rtrim(@save_Drive_temp))

			Print ''
			Print '--  Start WEB_DriveInfo Updates for server ' + upper(@save_servername)
			Print 'if not exists (select 1 from dbaadmin.dbo.WEB_DriveInfo where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''')'
			Print '   begin'
			Print '      INSERT INTO dbaadmin.dbo.WEB_DriveInfo (ServerName, Drive_name, active, modDate) VALUES (''' + upper(@save_servername) + ''', ''' + @save_Drive + ''', ''y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
			Print '   end'
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_DriveInfo where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''')'
			Select @cmd = @cmd + '   begin'
			Select @cmd = @cmd + '      INSERT INTO dbaadmin.dbo.WEB_DriveInfo (ServerName, Drive_name, active, modDate) VALUES (''' + upper(@save_servername) + ''', ''' + @save_Drive + ''', ''y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
			Select @cmd = @cmd + '   end'
			exec (@cmd)

		   end
		Else
		   begin
			goto end_drive
		   end

		start_driveinfo:
		Select @save_sr_id = @save_sr_id + 1
		Select @save_Driveinfo = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
		Select @save_Driveinfo = replace(@save_Driveinfo, char(9), ' ')
		Select @save_Driveinfo = ltrim(rtrim(@save_Driveinfo))

		If @save_sr_id > @save_sr_id_disks-1
		   begin
			goto end_drive
		   end

		If len(@save_Driveinfo) = 0
		   begin
			goto start_drive
		   end

		If @save_Driveinfo like 'Drive%'
		   begin
			Select @save_sr_id = @save_sr_id-1
			goto start_drive
		   end

		Select @charpos = charindex('Description', @save_Driveinfo)
		IF @charpos <> 0
		   begin
			Select @save_Description = substring(@save_Driveinfo, @charpos+12, 132)
			Select @save_Description = replace(@save_Description, char(9), '')
			Select @save_Description = ltrim(rtrim(@save_Description))

			Print '--  Update Drive Description for server ' + upper(@save_servername)
			Print 'Update dbaadmin.dbo.WEB_DriveInfo set Description = ''' + @save_Description + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print 'Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			Print ''
			Select @cmd = 'Update dbaadmin.dbo.WEB_DriveInfo set Description = ''' + @save_Description + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			exec (@cmd)

			goto start_driveinfo
		   end



		Select @charpos = charindex('Compressed', @save_Driveinfo)
		IF @charpos <> 0
		   begin
			Select @save_Compressed = substring(@save_Driveinfo, @charpos+11, 132)
			Select @save_Compressed = replace(@save_Compressed, char(9), '')
			Select @save_Compressed = ltrim(rtrim(@save_Compressed))

			Print '--  Update Drive Compressed value for server ' + upper(@save_servername)
			Print 'Update dbaadmin.dbo.WEB_DriveInfo set Compressed = ''' + @save_Compressed + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print 'Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			Print ''
			Select @cmd = 'Update dbaadmin.dbo.WEB_DriveInfo set Compressed = ''' + @save_Compressed + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			exec (@cmd)

			goto start_driveinfo
		   end
		
		Select @charpos = charindex('File System', @save_Driveinfo)
		IF @charpos <> 0
		   begin
			Select @save_File_System = substring(@save_Driveinfo, @charpos+12, 132)
			Select @save_File_System = replace(@save_File_System, char(9), '')
			Select @save_File_System = ltrim(rtrim(@save_File_System))

			Print '--  Update Drive File System for server ' + upper(@save_servername)
			Print 'Update dbaadmin.dbo.WEB_DriveInfo set File_System = ''' + @save_File_System + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print 'Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			Print ''
			Select @cmd = 'Update dbaadmin.dbo.WEB_DriveInfo set File_System = ''' + @save_File_System + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			exec (@cmd)

			goto start_driveinfo
		   end

		Select @charpos = charindex('Size', @save_Driveinfo)
		IF @charpos <> 0
		   begin
			Select @save_DriveSize = substring(@save_Driveinfo, @charpos+5, 132)
			Select @save_DriveSize = replace(@save_DriveSize, char(9), '')
			Select @save_DriveSize = ltrim(rtrim(@save_DriveSize))

			Print '--  Update Drive Size info for server ' + upper(@save_servername)
			Print 'Update dbaadmin.dbo.WEB_DriveInfo set Drive_Size = ''' + @save_DriveSize + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print 'Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			Print ''
			Select @cmd = 'Update dbaadmin.dbo.WEB_DriveInfo set Drive_Size = ''' + @save_DriveSize + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			exec (@cmd)

			goto start_driveinfo
		   end

		Select @charpos = charindex('Free Space', @save_Driveinfo)
		IF @charpos <> 0
		   begin
			Select @save_DriveFreeSpace = substring(@save_Driveinfo, @charpos+11, 132)
			Select @save_DriveFreeSpace = replace(@save_DriveFreeSpace, char(9), '')
			Select @save_DriveFreeSpace = ltrim(rtrim(@save_DriveFreeSpace))

			Print '--  Update Drive Free Space for server ' + upper(@save_servername)
			Print 'Update dbaadmin.dbo.WEB_DriveInfo set Drive_Freespace = ''' + @save_DriveFreeSpace + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Print 'Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			Print ''
			Select @cmd = 'Update dbaadmin.dbo.WEB_DriveInfo set Drive_Freespace = ''' + @save_DriveFreeSpace + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
			Select @cmd = @cmd + ' Where ServerName = ''' + upper(@save_servername) + ''' and Drive_name = ''' + @save_Drive + ''''
			exec (@cmd)

			goto start_driveinfo

		   end



		--  See if there is more info for this drive
		goto start_driveinfo



		goto start_drive

		end_drive:




		-- Get the hotfix info
		Print ''
		Print '--  Reset all WEB_HOTfix rows to active = ''n'' for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_HOTfix set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_HOTfix set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like '%Hotfix(s)%' order by sr_id)

		start_HOTfix:
		Select @save_sr_id = @save_sr_id + 1
		Select @save_HOTfix_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		If @save_HOTfix_temp like '%Network Card%' or @save_HOTfix_temp is null or @save_HOTfix_temp = ''
		   begin
			goto end_HOTfix
		   end

		If left(@save_HOTfix_temp, 1) <> ' '
		   begin
			goto end_HOTfix
		   end

		If @save_HOTfix_temp like '% File %'
		   begin
			goto start_HOTfix
		   end

		Select @charpos = charindex(':', @save_HOTfix_temp)
		IF @charpos <> 0
		   begin
			Select @save_HOTfix_temp = substring(@save_HOTfix_temp, @charpos+1, 132)
			Select @save_HOTfix_temp = replace(@save_HOTfix_temp, char(9), '')
			Select @save_HOTfix = ltrim(rtrim(@save_HOTfix_temp))

			Print ''
			Print '--  Start WEB_HOTfix Updates for server ' + upper(@save_servername)
			Print 'If not exists (select 1 from dbaadmin.dbo.WEB_HOTfix where ServerName = ''' + upper(@save_servername) + ''' and HOTfix_name = ''' + @save_HOTfix + ''')'
			Print '   begin'
			Print '      INSERT INTO dbaadmin.dbo.WEB_HOTfix (ServerName, HOTfix_name, active, modDate) VALUES (''' + upper(@save_servername) + ''', ''' + @save_HOTfix + ''', ''y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
			Print '   end '
			Print 'Else '
			Print '   begin '
			Print '      update dbaadmin.dbo.WEB_HOTfix set active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''' where ServerName = ''' + upper(@save_servername) + ''' and HOTfix_name = ''' + @save_HOTfix + ''''
			Print '   end '
			Print ''
			Select @cmd = 'if not exists (select 1 from dbaadmin.dbo.WEB_HOTfix where ServerName = ''' + upper(@save_servername) + ''' and HOTfix_name = ''' + @save_HOTfix + ''')'
			Select @cmd = @cmd + '   begin '
			Select @cmd = @cmd + '      INSERT INTO dbaadmin.dbo.WEB_HOTfix (ServerName, HOTfix_name, active, modDate) VALUES (''' + upper(@save_servername) + ''', ''' + @save_HOTfix + ''', ''y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
			Select @cmd = @cmd + '   end '
			Select @cmd = @cmd + 'Else '
			Select @cmd = @cmd + '   begin '
			Select @cmd = @cmd + '      update dbaadmin.dbo.WEB_HOTfix set active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''' where ServerName = ''' + upper(@save_servername) + ''' and HOTfix_name = ''' + @save_HOTfix + ''''
			Select @cmd = @cmd + '   end '
			exec (@cmd)

		   end
		Else
		   begin
			goto end_HOTfix
		   end


		--  Check to see if there are more hotfix rows to process
		goto start_HOTfix


		end_HOTfix:




		-- Get the REG info
		Print ''
		Print '--  Reset all WEB_REGinfo rows to active = ''n'' for server ' + upper(@save_servername)
		Print 'Update dbaadmin.dbo.WEB_REGinfo set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		Print ''
		Select @cmd = 'Update dbaadmin.dbo.WEB_REGinfo set active = ''n'' where ServerName = ''' + upper(@save_servername) + ''''
		exec (@cmd)

		Select @save_sr_id = (select top 1 sr_id from #SystemReport where cmdoutput like 'HKEY_LOCAL_MACHINE\software\GettyImages%' order by sr_id)

		start_REG:
		Select @save_REG01_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)
		Select @save_sr_id = @save_sr_id + 1
		Select @save_REG02_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

		If @save_REG02_temp is null or @save_REG02_temp = ''
		   begin
			goto skip_reg
		   end

		--  Parse the REG path
		Select @save_KEYpath01 = 'HKEY_LOCAL_MACHINE\software\GettyImages'
		Select @save_KEYpath02 = substring(@save_REG01_temp, 41, 250)


		start_REGkeys:

		--  get the key name
		Select @save_REG02_temp = ltrim(@save_REG02_temp)
		Select @charpos = charindex(' ', @save_REG02_temp)
		IF @charpos <> 0
		   begin
			Select @save_KEYname = substring(@save_REG02_temp, 1, @charpos)
			Select @save_KEYname = rtrim(ltrim(@save_KEYname))
			Select @save_REG02_temp = substring(@save_REG02_temp, @charpos+1, 250)
			Select @save_REG02_temp = rtrim(ltrim(@save_REG02_temp))
		   end
		Else
		   begin
			goto skip_reg
		   end


		--  get the key type
		Select @save_REG02_temp = ltrim(@save_REG02_temp)
		Select @charpos = charindex(' ', @save_REG02_temp)
		IF @charpos <> 0
		   begin
			Select @save_KEYtype = substring(@save_REG02_temp, 1, @charpos)
			Select @save_KEYtype = rtrim(ltrim(@save_KEYtype))
			Select @save_REG02_temp = substring(@save_REG02_temp, @charpos+1, 250)
			Select @save_REG02_temp = rtrim(ltrim(@save_REG02_temp))
		   end
		Else
		   begin
			goto skip_reg
		   end


		--  get the key data
		Select @save_REG02_temp = ltrim(@save_REG02_temp)
		Select @save_KEYdata = substring(@save_REG02_temp, 1, 250)
		Select @save_KEYdata = rtrim(ltrim(@save_KEYdata))

		If @save_KEYdata is null
		   begin
			select @save_KEYdata = ''
		   end


		Print ''
		Print '--  Start WEB_REGinfo Updates for server ' + upper(@save_servername)
		Print 'If not exists (select 1 from dbaadmin.dbo.WEB_REGinfo where ServerName = ''' + upper(@save_servername) + ''' and KEYpath02 = ''' + @save_KEYpath02 + ''' and KEYname = ''' + @save_KEYname + ''')'
		Print '   begin'
		Print '      INSERT INTO dbaadmin.dbo.WEB_REGinfo (ServerName, KEYpath01, KEYpath02, KEYname, KEYtype, KEYdata, active, modDate)'
		Print '             VALUES (''' + upper(@save_servername) + ''', ''' + @save_KEYpath01 + ''', ''' + @save_KEYpath02 + ''', ''' + @save_KEYname + ''', ''' + @save_KEYtype + ''', ''' + @save_KEYdata + ''', ''y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Print '   end '
		Print 'Else '
		Print '   begin '
		Print '      update dbaadmin.dbo.WEB_REGinfo set KEYtype = ''' + @save_KEYtype + ''', KEYdata = ''' + @save_KEYdata + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Print '                                     where ServerName = ''' + upper(@save_servername) + ''' and KEYpath02 = ''' + @save_KEYpath02 + ''' and KEYname = ''' + @save_KEYname + ''''
		Print '   end '
		Print ''
		Select @cmd = 'If not exists (select 1 from dbaadmin.dbo.WEB_REGinfo where ServerName = ''' + upper(@save_servername) + ''' and KEYpath02 = ''' + @save_KEYpath02 + ''' and KEYname = ''' + @save_KEYname + ''')'
		Select @cmd = @cmd + '   begin'
		Select @cmd = @cmd + '      INSERT INTO dbaadmin.dbo.WEB_REGinfo (ServerName, KEYpath01, KEYpath02, KEYname, KEYtype, KEYdata, active, modDate)'
		Select @cmd = @cmd + '             VALUES (''' + upper(@save_servername) + ''', ''' + @save_KEYpath01 + ''', ''' + @save_KEYpath02 + ''', ''' + @save_KEYname + ''', ''' + @save_KEYtype + ''', ''' + @save_KEYdata + ''', ''y'', ''' + convert(nvarchar(30), getdate(), 121) + ''')'
		Select @cmd = @cmd + '   end '
		Select @cmd = @cmd + 'Else '
		Select @cmd = @cmd + '   begin '
		Select @cmd = @cmd + '      update dbaadmin.dbo.WEB_REGinfo set KEYtype = ''' + @save_KEYtype + ''', KEYdata = ''' + @save_KEYdata + ''', active = ''y'', moddate = ''' + convert(nvarchar(30), getdate(), 121) + ''''
		Select @cmd = @cmd + '                                     where ServerName = ''' + upper(@save_servername) + ''' and KEYpath02 = ''' + @save_KEYpath02 + ''' and KEYname = ''' + @save_KEYname + ''''
		Select @cmd = @cmd + '   end '
		Select @cmd = @cmd + ''
		exec (@cmd)


		If exists (select 1 from #SystemReport where sr_id > @save_sr_id)
		   begin
			Select @save_sr_id = @save_sr_id + 1
			Select @save_REG02_temp = (select cmdoutput from #SystemReport where sr_id = @save_sr_id)

			If @save_REG02_temp is not null and @save_REG02_temp <> ''
			   begin
				goto start_REGkeys
			   end
		   end




		skip_reg:

		If exists (select 1 from #SystemReport where sr_id > @save_sr_id and cmdoutput like 'HKEY_LOCAL_MACHINE\software\GettyImages%')
		   begin
			Select @save_sr_id = (select top 1 sr_id from #SystemReport where sr_id > @save_sr_id and cmdoutput like 'HKEY_LOCAL_MACHINE\software\GettyImages%' order by sr_id)
			goto start_REG
		   end


		end_reg:
	


--select * from dbaadmin.dbo.WEB_ServerInfo 

--delete from dbaadmin.dbo.WEB_ServerInfo 


	   end






	skip_SystemReport:


	--  Rename the file so it wont be processed again
	Select @save_alt_filename = replace(@save_filename, '.txt', '.old')	

	Select @cmd = 'del "\\' + @hold_servername + '\' + @hold_servername + '_WEB_Register\' + @save_alt_filename + '"'
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output

	Select @cmd = 'ren "\\' + @hold_servername + '\' + @hold_servername + '_WEB_Register\' + @save_filename + '" "' + @save_alt_filename + '"'
	Print @cmd
	EXEC master.sys.xp_cmdshell @cmd, no_output


	--  Check to see if there are more files to process
	delete from #DirectoryTempTable where cmdoutput like '%' + @save_filename + '%'
	If (select count(*) from #DirectoryTempTable) > 0
	   begin
		goto start_files
	   end

   end



----------------  End  -------------------

label99:

drop table #DirectoryTempTable
drop table #SystemReport




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_sendmail
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_sendmail]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_sendmail]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_sendmail (@recipients nvarchar(500) = null
				,@copy_recipients nvarchar(500) = null
				,@blind_copy_recipients nvarchar(500) = null
				,@stage_recipients nvarchar(500) = null
				,@stage_copy_recipients nvarchar(500) = null
				,@stage_blind_copy_recipients nvarchar(500) = null
				,@test_recipients nvarchar(500) = null
				,@test_copy_recipients nvarchar(500) = null
				,@test_blind_copy_recipients nvarchar(500) = null
				,@subject nvarchar(255) = null
				,@attachments nvarchar(4000) = null
				,@message nvarchar(4000) = null
				,@outpath nvarchar(255) = null)

/*********************************************************
 **  Stored Procedure dbasp_sendmail                  
 **  Written by Jim Wilson, Getty Images                
 **  July 1, 2002                                      
 **  
 **  This dbasp is set up to create a parameter file
 **  that is used in the DBA SQL Mail process.  The output
 **  file has an extension of 'sml', and is written to the
 **  dba_mail folder of the local server.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	07/01/2002	Jim Wilson		New sproc
--	09/24/2002	Jim Wilson		Modified dbasql share example
--	11/06/2002	Jim Wilson		Changed osql -w to 4000
--	02/17/2003	Jim Wilson		Added logic to drop temp table command
--	04/16/2003	Jim Wilson		Attachments can now be up to 4000 bytes
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	04/28/2003	Jim Wilson		Global temp table (##) name now unique
--	05/06/2003	Jim Wilson		Added wait for 2 seconds
--	04/05/2004	Jim Wilson		New uniqueidentifier for global temp table name
--						and file output names (to avoid duplicates).
--	05/04/2006	Jim Wilson		Updated for SQL 2005
--	07/13/2006	Jim Wilson/Michael Nguyen - Code to handel single quotes in the @message
--	10/09/2007	Jim Wilson		Change temp table from nvarchar(max) to 4000.
--	05/15/2009	Jim Wilson		Added support for test and stage recipients.
--	======================================================================================


/***
Declare @recipients nvarchar(500)
Declare @copy_recipients nvarchar(500)
Declare @blind_copy_recipients nvarchar(500)
Declare @stage_recipients nvarchar(500)
Declare @stage_copy_recipients nvarchar(500)
Declare @stage_blind_copy_recipients nvarchar(500)
Declare @test_recipients nvarchar(500)
Declare @test_copy_recipients nvarchar(500)
Declare @test_blind_copy_recipients nvarchar(500)
Declare @subject nvarchar(255)
Declare @attachments nvarchar(4000)
Declare @message nvarchar(max)
Declare @outpath nvarchar(255)

Select @recipients 			= 'jim.wilson@gettyimages.com' 
Select @copy_recipients 		= 'jim.wilson@gettyimages.com'
Select @blind_copy_recipients		= 'jim.wilson@gettyimages.com'
Select @stage_recipients 		= 'jim.wilson@gettyimages.com' 
Select @stage_copy_recipients 		= 'jim.wilson@gettyimages.com'
Select @stage_blind_copy_recipients	= 'jim.wilson@gettyimages.com'
Select @test_recipients 		= 'jim.wilson@gettyimages.com' 
Select @test_copy_recipients 		= 'jim.wilson@gettyimages.com'
Select @test_blind_copy_recipients	= 'jim.wilson@gettyimages.com'
Select @subject 			= 'test subject'
--Select @attachments 			= '\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test01.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test02.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test03.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test04.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test05.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test06.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test07.txt;\\seafresqldbq01\seafresqldbq0






























1_dbasql\dba_mail\jim_test08.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test09.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test10.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test11.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test12.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test13.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test14.txt;\\seafresqldbq01\seafresqldbq01_dbasql\dba_mail\jim_test15.txt'
Select @message				= 'test message'
Select @outpath 			= null
--***/


DECLARE
	 @miscprint		nvarchar(500)
	,@outfullpath		nvarchar(500)
	,@Hold_hhmissmmm	nvarchar(12)
	,@error_count		int
	,@outDateStmp 		char(9)
	,@cmd			nvarchar(max)
	,@uniqueID		nvarchar(100)
	,@Q			char(1)


DECLARE	 
	 @result		int
	,@print_flag		char(1)
	,@sqlcmd		nvarchar(4000)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_servername3	sysname
	,@save_envname		sysname
	,@charpos		int	


----------------  initial values  -------------------
Select @error_count = 0

Waitfor delay '00:00:02'
Set @Hold_hhmissmmm = convert(nvarchar(12), getdate(), 14)
Set @outDateStmp = substring(@Hold_hhmissmmm, 1, 2) + substring(@Hold_hhmissmmm, 4, 2) + substring(@Hold_hhmissmmm, 7, 2) + substring(@Hold_hhmissmmm, 10, 3) 

Set @uniqueID = rtrim(convert(nvarchar(100), newid()))
Select @uniqueID = REPLACE(@uniqueID,'-','x')
Select @Q = ''''


--  Set output path value
Select @print_flag = 'n'

Select @save_servername		= @@servername
Select @save_servername2 	= @@servername
Select @save_servername3 	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
	Select @save_servername3 = @save_servername3 + ')'
   end

 
If @outpath is null
   begin
	Select @outpath = '\\' + @save_servername + '\' + @save_servername + '_dba_mail'
   end

--  Verify output path existance
create table #fileexists ( 
	doesexist smallint,
	fileindir smallint,
	direxist smallint)

Insert into #fileexists exec master.sys.xp_fileexist @outpath

If exists (select fileindir from #fileexists where fileindir = 1)
   begin
	Select @print_flag = 'y'
   end

DROP TABLE #fileexists 

If @print_flag = 'n'
   begin
	select @miscprint = 'DBA WARNING: Unable to write SQL mail parameter file to output path ''' + @outpath + ''''
	raiserror(@miscprint,1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end


-- Check and reset @recipients if needed
Select @save_envname = (select env_detail from dbo.Local_ServerEnviro where env_type = 'ENVname') 

If @save_envname is null or @save_envname like '%prod%'
   begin
	goto skip_reset01
   end

If @save_envname like '%stag%'
   begin
	If @stage_recipients <> '' and @stage_recipients is not null
	   begin
		Select @recipients = @stage_recipients
	   end

	If @stage_copy_recipients <> '' and @stage_copy_recipients is not null
	   begin
		Select @copy_recipients = @stage_copy_recipients
	   end

	If @stage_blind_copy_recipients <> '' and @stage_blind_copy_recipients is not null
	   begin
		Select @blind_copy_recipients = @stage_blind_copy_recipients
	   end
   end
Else
   begin
	If @test_recipients <> '' and @test_recipients is not null
	   begin
		Select @recipients = @test_recipients
	   end

	If @test_copy_recipients <> '' and @test_copy_recipients is not null
	   begin
		Select @copy_recipients = @test_copy_recipients
	   end

	If @test_blind_copy_recipients <> '' and @test_blind_copy_recipients is not null
	   begin
		Select @blind_copy_recipients = @test_blind_copy_recipients
	   end
   end


skip_reset01:

If @recipients is null or @subject is null
begin
	raiserror('DBA WARNING: Invalid parameters passed to dbasp_sendmail',-1,-1)
	Select @error_count = @error_count + 1
	goto label99
   end
Else
   begin

	--  Set the ouput file name
	Set @Hold_hhmissmmm = convert(nvarchar(12), getdate(), 14)
	Select @outfullpath = @outpath + '\' + @save_servername3 + '_' + convert(char(8), getdate(), 112) + substring(@Hold_hhmissmmm, 1, 2) + substring(@Hold_hhmissmmm, 4, 2) + substring(@Hold_hhmissmmm, 7, 2) + substring(@Hold_hhmissmmm, 10, 3) + '_' + @uniqueID + '.sml' 

	--------------------  Create the temp table for output  -----------------------
	select @cmd = 'CREATE TABLE ##output_' + @uniqueID + ' ([commands] [nvarchar] (4000) NULL)'
	--print @cmd
	exec (@cmd)
			

	select @cmd = 'Insert into ##output_' + @uniqueID + ' (commands) values (''@recipients = ''''' + rtrim(@recipients) + ''''''')'
	--print @cmd
	exec (@cmd)

	select @cmd = 'Insert into ##output_' + @uniqueID + ' (commands) values (''@subject = ''''' + rtrim(@subject) + ''''''')'
	--print @cmd
	exec (@cmd)


	If @copy_recipients is not null
	   begin
		select @cmd = 'Insert into ##output_' + @uniqueID + ' (commands) values (''@copy_recipients = ''''' + rtrim(@copy_recipients) + ''''''')'
		--print @cmd
		exec (@cmd)
	   end


	If @blind_copy_recipients is not null
	   begin
		select @cmd = 'Insert into ##output_' + @uniqueID + ' (commands) values (''@blind_copy_recipients = ''''' + rtrim(@blind_copy_recipients) + ''''''')'
		--print @cmd
		exec (@cmd)
	   end


	If @attachments is not null
	   begin
		select @cmd = 'Insert into ##output_' + @uniqueID + ' (commands) values (''@attachments = ''''' + rtrim(@attachments) + ''''''')'
		--print @cmd
		exec (@cmd)
	   end


	If @message is not null
	   begin
		select @cmd = 'Insert into ##output_' + @uniqueID + ' (commands) values (''@message = ''''' + replace(rtrim(@message), @Q, @Q+@Q+@Q+@Q) + ''''''')'
		--print @cmd
		exec (@cmd)
	   end


	SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w4000 -h-1 -Q"set nocount on select * from ##output_' + @uniqueID + '" -E -o' + @outfullpath
	--print @sqlcmd
	EXEC @result = master.sys.xp_cmdshell @sqlcmd, no_output


	select @cmd = 'drop table ##output_' + @uniqueID
	--print @cmd
	exec (@cmd)

   end




--  Finalization  -------------------------------------------------------------------

label99:


If  @error_count > 0
   begin
	RETURN (1)
   end
Else
   begin
	RETURN (0)
   end
		
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_set_maintplans
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_set_maintplans]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_set_maintplans]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_set_maintplans

/***************************************************************
 **  Stored Procedure dbasp_set_maintplans                  
 **  Written by Jim Wilson, Getty Images                
 **  August 05, 2004                                      
 **  
 **  This sproc is set up to;
 ** 
 **  Create and/or reset the standard maintenance plans used
 **  for SQL DBA daily and weekly maintenance processing.
 **  In normal SQL DBA maintenance processing, maintenance plans
 **  are only used as a means to obtain a list of databases to process. 
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/05/2004	Jim Wilson		New process.
--	08/17/2004	Jim Wilson		Added check to the backup_nocheck table.
--	02/15/2006	Jim Wilson		Modified for sql2005.  This process uses the legacy tables in msdb.
--	02/11/2008	Jim Wilson		Added skip for DB's not online.
--	04/30/2008	Jim Wilson		Added fix for dbaadmin and systeminfo owner and recovery option.
--	12/15/2008	David Spriggs		Added code for new No_Check table.
--	10/09/2009	Jim Wilson		Updated code for DB systeminfo to DEPLinfo.
--	05/20/2010	Steve Ledridge		Complete Rewrite.
--						* Added Calls to dbasp_LogEvent which replaced all print statements
--						* Added Section to Force Recovery Plan based on Logic and No_Check
--							NEW No_Check Type : ForcedRecoveryModel
--							formated as follows:
--								[NoCheck_type]	= ForcedRecoveryModel
--								[detail01]	= Database Name
--								[detail02]	= 'NO' (Do Not Change), 'YES' (Force to Simple), 'VALUE' (USE detail03 Value)
--								[detail03]	= NULL,'SIMPLE' (same as Using 'YES' in detail02),'FULL','BULK-LOGED'
--						* Added population of tranlog plan
--						* Re-wrote both Sections for Adding Pland and Plan Members
--							to use a Single SET-Based Insert of missing records.
--						* Changed Plan Member Logic to start by flushing all members out of
--							the standard plans before re-inserting them to make sure they
--							dont exist in plans that they shouldnt belong to. This assumes
--							that the no_check table represents databases that should not
--							be backed up at all rather than left as they are. If we want
--							to force mebers into groups that are not selected by the logic
--							we will need to change the way the 'BACKUP' NoCheck_Type is used.
--
--	======================================================================================

-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@PlanID 		uniqueidentifier
	,@PlanID_full		uniqueidentifier
	,@PlanID_simple		uniqueidentifier
	,@PlanID_tranlog	uniqueidentifier
	,@cmd			nvarchar(1000)
	,@ForcedRecoveryScript	varchar(max)

DECLARE
	 @cu10DBName		sysname
	,@cu10DBId		smallint
	,@cu10DBStatus		int

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint
	,@cu11DBStatus		int

--------------------------------------------------
-- DECLARE ALL cE VARIABLES AT HEAD OF PROCCESS --
--------------------------------------------------
DECLARE	@cEModule		sysname
	,@cECategory		sysname
	,@cEEvent		sysname
	,@cEGUID		uniqueidentifier
	,@cEMessage		nvarchar(max)
	,@cE_ThrottleType	VarChar(50)
	,@cE_ThrottleNumber	INT
	,@cE_ThrottleGrouping	VarChar(255)
	,@cE_ForwardTo		VarChar(2048)
	,@cE_RedirectTo		VarChar(2048)
	,@cEStat_Rows		BigInt
	,@cEStat_Duration	FLOAT
	,@cERE_ForceScreen	BIT
	,@cERE_Severity		INT
	,@cERE_State		INT
	,@cERE_With		VarChar(2048)
	,@cEMail_Subject	VarChar(2048)
	,@cEMail_To		VarChar(2048)
	,@cEMail_CC		VarChar(2048)
	,@cEMail_BCC		VarChar(2048)
	,@cEMail_Urgent		BIT
	,@cEFile_Name		VarChar(2048)
	,@cEFile_Path		VarChar(2048)
	,@cEFile_OverWrite	BIT
	,@cEPage_Subject	VarChar(2048)
	,@cEPage_To		VarChar(2048)
	,@cEMethod_Screen	BIT
	,@cEMethod_TableLocal	BIT
	,@cEMethod_TableCentral	BIT
	,@cEMethod_RaiseError	BIT
	,@cEMethod_EMail	BIT
	,@cEMethod_File		BIT
	,@cEMethod_Twitter	BIT
	,@cEMethod_DBAPager	BIT
		

----------------  initial values  -------------------

--  Create table variables
declare @DBnames table	(name		sysname
			,dbid		smallint
			,status		int
			)

--------------------------------------------------
--           SET GLOBAL cE VARIABLES            --
--------------------------------------------------
SELECT	@cEModule		= object_name(@@Procid)	
	,@cEGUID		= NEWID()

--  Main Processing  -------------------------------------------------------------------


--  Fix owner and options for databases
--------------------------------------------------
--            SET EVENT cE VARIABLES            --
--------------------------------------------------
SELECT	@cECategory		= 'ForceDBRecoverModel'
	,@cEEvent		= 'CHECK'
	,@cEMessage		= 'Checking if Changes Are Needed'
	
--------------------------------------------------
--            CALL LOG EVENT SPROC              --
--------------------------------------------------
exec dbaadmin.dbo.[dbasp_LogEvent]
			 @cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
--------------------------------------------------
--                    DONE                      --
--------------------------------------------------

SELECT		@ForcedRecoveryScript = @ForcedRecoveryScript 
		+ 'ALTER DATABASE ' + QUOTENAME([DBName]) 
		+ ' SET RECOVERY ' + REPLACE([ForcedRecovery],'-','_') 
		+ CHAR(13) + CHAR(10)
		+ CASE [Is_OperationsDB]
			WHEN 1 THEN 'ALTER AUTHORIZATION ON DATABASE::' 
					+ QUOTENAME([DBName]) + ' TO sa'
					+ CHAR(13) + CHAR(10)
			ELSE ''
			END
FROM		(
		SELECT		[DBName]
				, [CurRecovery]
				, CASE	WHEN [NoCkeck_Setting] = 'VALUE'
					THEN [NoCkeck_Value]
					
					WHEN [NoCkeck_Setting] = 'YES'
					THEN N'SIMPLE'
					
					WHEN [NoCkeck_Setting] = 'NO'
					THEN [CurRecovery]
					
					WHEN [Is_SystemDB] = 1
					THEN N'SIMPLE'
					
					WHEN [Is_OperationsDB] = 1
					THEN N'SIMPLE'
					
					WHEN [ENVname] != 'production'
					THEN N'SIMPLE'
						
					ELSE [CurRecovery]
					END AS [ForcedRecovery]
				,[Is_SystemDB]
				,[Is_OperationsDB]
				,[NoCkeck_Setting]
				,[NoCkeck_Value]
				,[ENVname]					
		FROM		(		
				SELECT		name AS [DBName]
						, CAST(Databasepropertyex(name,'Recovery') AS sysname) AS [CurRecovery]		
						, CASE  WHEN [T1].[database_id] < 5	THEN 1 
							WHEN [T1].[name] = 'aspnetdb'	THEN 1
							WHEN [T1].[name] like 'aspstate%' THEN 1
							ELSE 0 
							END AS [Is_SystemDB]
						, CASE	[T1].[name]
							WHEN	'dbaadmin'		THEN 1
							WHEN	'dbacentral'		THEN 1
							WHEN	'dbaperf'		THEN 1
							WHEN	'dbaperf_reports'	THEN 1
							WHEN	'deplcontrol'		THEN 1
							WHEN	'deplinfo'		THEN 1
							WHEN	'deploymaster'		THEN 1
							WHEN	'gears'			THEN 1
							WHEN	'operations'		THEN 1
							WHEN	'runbook'		THEN 1
							WHEN	'runbook05'		THEN 1
							WHEN	'sprocket'		THEN 1
							WHEN	'SQLdmRepository'	THEN 1
							WHEN	'MetricsOps'		THEN 1
							WHEN	'AutoTracking'		THEN 1
							ELSE	0
							END AS [Is_OperationsDB]
						, [T2].[detail02] AS [NoCkeck_Setting]
						, [T2].[detail03] AS [NoCkeck_Value]
						, [T3].[env_detail] AS [ENVname]
				FROM		[master].[sys].[databases] [T1]
				LEFT JOIN	[dbo].[No_Check] [T2]
					ON	[T1].[name] = [T2].[detail01]
					AND	[T2].[NoCheck_type] = 'ForcedRecoveryModel'
				LEFT JOIN	[dbaadmin].[dbo].[Local_ServerEnviro] [T3]
					ON	[env_type] = 'ENVname'
				) [Data]
		) [Data]
WHERE		[CurRecovery] != [ForcedRecovery]		

IF @@ROWCOUNT > 0 
BEGIN
	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cEEvent		= 'START'
		,@cEMessage		= REPLACE(@ForcedRecoveryScript,CHAR(13)+CHAR(10), '; ')
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------


		--------------------------------------------------
		--                     DO IT                    --
		--------------------------------------------------
		BEGIN TRY
			--------------------------------------------------
			--            SET EVENT cE VARIABLES            --
			--------------------------------------------------
			-- VALUES USED UNLESS CATCH BLOCK CALLED
			SELECT	@cEEvent		= 'DONE'
				,@cEMessage		= 'Changes Were Applied'
				,@cEMethod_RaiseError	= 0	
		
			EXEC		(@ForcedRecoveryScript)
		END TRY
		BEGIN CATCH
			--------------------------------------------------
			--            SET EVENT cE VARIABLES            --
			--------------------------------------------------
			-- VALUES ONLY USED FOR ERROR
			SELECT	@cEEvent		= 'FAIL'
				,@cEMessage		= 'Changes Were NOT Applied: ' 
							+ REPLACE(@ForcedRecoveryScript,CHAR(13)+CHAR(10), '; ')
				,@cERE_Severity		= 10
				,@cERE_State		= 1
				,@cERE_With		= 'WITH NOWAIT,LOG'
				,@cEMethod_RaiseError	= 1
		END CATCH
		--------------------------------------------------
		--                    DONE                      --
		--------------------------------------------------		

	
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
				,@cERE_Severity
				,@cERE_State
				,@cERE_With
				,@cEMethod_RaiseError
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------
END	
ELSE
BEGIN
	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cEEvent		= 'DONE'
		,@cEMessage		= 'No Changes Were Needed'
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------
END


--------------------------------------------------
--            SET EVENT cE VARIABLES            --
--------------------------------------------------
SELECT	@cECategory		= 'FixMainenancePlans'
	,@cEEvent		= 'CHECK'
	,@cEMessage		= 'Checking if Standard Plans Exists'
	
--------------------------------------------------
--            CALL LOG EVENT SPROC              --
--------------------------------------------------
exec dbaadmin.dbo.[dbasp_LogEvent]
			 @cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
--------------------------------------------------
--                    DONE                      --
--------------------------------------------------

SELECT		@cEMessage = REPLACE(dbo.Concatenate([SplitValue]+',')+'|',',|','')
FROM		dbo.dbaudf_split('Mplan_sys_all,Mplan_user_all,Mplan_user_defrag,Mplan_user_full,Mplan_user_simple,Mplan_user_tranlog',',')
WHERE		[SplitValue] NOT IN (select [plan_name] from msdb.dbo.sysdbmaintplans)

IF		@cEMessage != '|'
BEGIN
	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cECategory		= 'FixMainenancePlans'
		,@cEEvent		= 'START'
		,@cEMessage		= @cEMessage + ' Plans Need to be Created.'
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------



	--------------------------------------------------
	--                     DO IT                    --
	--------------------------------------------------
	BEGIN TRY
		--------------------------------------------------
		--            SET EVENT cE VARIABLES            --
		--------------------------------------------------
		-- VALUES USED UNLESS CATCH BLOCK CALLED
		SELECT	@cEEvent		= 'DONE'
			,@cEMessage		= 'Changes Were Applied'
			,@cEMethod_RaiseError	= 0	
	
		insert into	msdb.dbo.sysdbmaintplans (plan_id,plan_name,date_created,owner,max_history_rows,remote_history_server,max_remote_history_rows,user_defined_1,user_defined_2,user_defined_3,user_defined_4)
		SELECT		plan_id,plan_name,date_created,owner,max_history_rows,remote_history_server,max_remote_history_rows,user_defined_1,user_defined_2,user_defined_3,user_defined_4
		FROM		(
				SELECT	NEWID(),N'Mplan_sys_all',getdate(),N'sa',1000,N'',0,NULL,NULL,NULL,NULL
				UNION ALL
				SELECT	NEWID(),N'Mplan_user_all',getdate(),N'sa',1000,N'',0,NULL,NULL,NULL,NULL
				UNION ALL
				SELECT	NEWID(),N'Mplan_user_defrag',getdate(),N'sa',1000,N'',0,NULL,NULL,NULL,NULL
				UNION ALL
				SELECT	NEWID(),N'Mplan_user_full',getdate(),N'sa',1000,N'',0,NULL,NULL,NULL,NULL
				UNION ALL
				SELECT	NEWID(),N'Mplan_user_simple',getdate(),N'sa',1000,N'',0,NULL,NULL,NULL,NULL
				UNION ALL
				SELECT	NEWID(),N'Mplan_user_tranlog',getdate(),N'sa',1000,N'',0,NULL,NULL,NULL,NULL
				) Plans(plan_id,plan_name,date_created,owner,max_history_rows,remote_history_server,max_remote_history_rows,user_defined_1,user_defined_2,user_defined_3,user_defined_4)
		WHERE		[plan_name] NOT IN (select [plan_name] from msdb.dbo.sysdbmaintplans)
	END TRY
	BEGIN CATCH
		--------------------------------------------------
		--            SET EVENT cE VARIABLES            --
		--------------------------------------------------
		-- VALUES ONLY USED FOR ERROR
		SELECT	@cEEvent		= 'FAIL'
			,@cEMessage		= 'Changes Were NOT Applied: ' 
						+ REPLACE(dbo.Concatenate([SplitValue]+',')+' Plans Failed to Create.',', Plans Failed to Create.',' Plans Failed to Create.')
			,@cERE_Severity		= 10
			,@cERE_State		= 1
			,@cERE_With		= 'WITH NOWAIT,LOG'
			,@cEMethod_RaiseError	= 1
		FROM	dbo.dbaudf_split('Mplan_sys_all,Mplan_user_all,Mplan_user_defrag,Mplan_user_full,Mplan_user_simple,Mplan_user_tranlog',',')
		WHERE	[SplitValue] NOT IN (select [plan_name] from msdb.dbo.sysdbmaintplans)

	END CATCH

	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------	
END
ELSE
BEGIN
	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cECategory		= 'FixMainenancePlans'
		,@cEEvent		= 'DONE'
		,@cEMessage		= 'No Plans Need to be Created.'
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------
END		

--  Set standard maint plan members

--------------------------------------------------
--            SET EVENT cE VARIABLES            --
--------------------------------------------------
SELECT	@cECategory		= 'FixMainenancePlanMembers'
	,@cEEvent		= 'START'
	,@cEMessage		= 'Reset all Members for the Standard Plans except ''Mplan_user_defrag''.'
	
--------------------------------------------------
--            CALL LOG EVENT SPROC              --
--------------------------------------------------
exec dbaadmin.dbo.[dbasp_LogEvent]
			 @cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
--------------------------------------------------
--                    DONE                      --
--------------------------------------------------

	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cEEvent		= 'START'
		,@cEMessage		= 'Remove all Members for the Standard Plans except ''Mplan_user_defrag''.'
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------

	DELETE		msdb.dbo.sysdbmaintplan_databases
	WHERE		plan_id IN (SELECT plan_id FROM msdb.dbo.sysdbmaintplans WHERE plan_name IN ('Mplan_sys_all','Mplan_user_all','Mplan_user_full','Mplan_user_simple','Mplan_user_tranlog'))

	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cEEvent		= 'DONE'
		,@cEMessage		= 'Remove all Members for the Standard Plans except ''Mplan_user_defrag''.'
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------


	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cEEvent		= 'START'
		,@cEMessage		= 'Add all Members for the Standard Plans except ''Mplan_user_defrag''.'
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------
		
	insert into	msdb.dbo.sysdbmaintplan_databases (plan_id, database_name)
	SELECT		PlanDB.*
	FROM		(
			SELECT	plan_id,N'All System Databases' 
			FROM	msdb.dbo.sysdbmaintplans 
			WHERE	plan_name = N'Mplan_sys_all'

			UNION ALL		
			SELECT	T2.plan_id, T1.name
			From	master.sys.sysdatabases T1
			JOIN	msdb.dbo.sysdbmaintplans T2
			  ON	T2.plan_name = N'Mplan_user_all'
			WHERE	T1.DBID > 4	
			  AND	T1.name NOT IN (SELECT detail01 FROM dbo.No_Check where  NoCheck_type='BACKUP')

			UNION ALL		
			SELECT	T2.plan_id, T1.name
			From	master.sys.sysdatabases T1
			JOIN	msdb.dbo.sysdbmaintplans T2
			  ON	T2.plan_name = N'Mplan_user_simple'
			WHERE	T1.DBID > 4	
			  AND	T1.name NOT IN (SELECT detail01 FROM dbo.No_Check where  NoCheck_type='BACKUP')
			  AND	databaseproperty(T1.name, 'IsTrunclog') = 1

			UNION ALL		
			SELECT	T2.plan_id, T1.name
			From	master.sys.sysdatabases T1
			JOIN	msdb.dbo.sysdbmaintplans T2
			  ON	T2.plan_name = N'Mplan_user_full'
			WHERE	T1.DBID > 4	
			  AND	T1.name NOT IN (SELECT detail01 FROM dbo.No_Check where  NoCheck_type='BACKUP')
			  AND	databaseproperty(T1.name, 'IsTrunclog') != 1

			UNION ALL		
			SELECT	T2.plan_id, T1.name
			From	master.sys.sysdatabases T1
			JOIN	msdb.dbo.sysdbmaintplans T2
			  ON	T2.plan_name = N'Mplan_user_tranlog'
			WHERE	T1.DBID > 4	
			  AND	T1.name NOT IN (SELECT detail01 FROM dbo.No_Check where  NoCheck_type='BACKUP')
			  AND	databaseproperty(T1.name, 'IsTrunclog') != 1
			) PlanDB(plan_id,database_name)
	LEFT JOIN	msdb.dbo.sysdbmaintplan_databases MPD
		ON	PlanDB.plan_id = MPD.plan_id
		AND	PlanDB.database_name = MPD.database_name
	WHERE		MPD.plan_id IS NULL	

	--------------------------------------------------
	--            SET EVENT cE VARIABLES            --
	--------------------------------------------------
	SELECT	@cEEvent		= 'DONE'
		,@cEMessage		= 'Add all Members for the Standard Plans except ''Mplan_user_defrag''.'
		
	--------------------------------------------------
	--            CALL LOG EVENT SPROC              --
	--------------------------------------------------
	exec dbaadmin.dbo.[dbasp_LogEvent]
				 @cEModule
				,@cECategory
				,@cEEvent
				,@cEGUID
				,@cEMessage
	--------------------------------------------------
	--                    DONE                      --
	--------------------------------------------------
--------------------------------------------------
--            SET EVENT cE VARIABLES            --
--------------------------------------------------
SELECT	@cEEvent		= 'DONE'
	,@cEMessage		= 'All Standard Plan Members, except ''Mplan_user_defrag'', Have Been Reset.'
	
--------------------------------------------------
--            CALL LOG EVENT SPROC              --
--------------------------------------------------
exec dbaadmin.dbo.[dbasp_LogEvent]
			 @cEModule
			,@cECategory
			,@cEEvent
			,@cEGUID
			,@cEMessage
--------------------------------------------------
--                    DONE                      --
--------------------------------------------------	
---------------------------  Finalization  -----------------------


 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SetStatusForRestore
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SetStatusForRestore]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SetStatusForRestore]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].dbasp_SetStatusForRestore (@dbname sysname = null
						,@dropDB char(1) = 'n'
						)

/*********************************************************
 **  Stored Procedure dbasp_SetStatusForRestore                  
 **  Written by Jim Wilson, Getty Images                
 **  March 23, 2004                                      
 **  
 **  This procedure is used to set the database status prior to
 **  the DB restore.
 **
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	03/23/2004	Jim Wilson		New process 
--	01/21/2005	Jim Wilson		Set save_status for DB status 
--	03/15/2006	Jim Wilson		Updated for SQL 2005. 
--	10/30/2006	Jim Wilson		Added check/fix for schema ownership. 
--	01/08/2007	Jim Wilson		Added DB drop for DB's that are not online. 
--	02/08/2008	Jim Wilson		Added disable for service broker. 
--	07/15/2008	Jim Wilson		Added @dropDB input parm and section to drop the database. 
--	07/21/2008	Jim Wilson		Added code to drop assemblies. 
--	03/31/2008	Jim Wilson		Added code to drop dropassembly_modules. 
--	04/02/2008	Jim Wilson		New code to remove type dependencies. 
--	09/30/2009	David Spriggs		Removed(commented out) the set single user and replace with
--						kill spid loop.
--	======================================================================================
/**
declare @dbname sysname
declare @dropDB char(1)

select @dbname = 'PumpAudio_Live'
select @dropDB = 'y'
--**/


DECLARE  
	 @miscprint		nvarchar(2000)
	,@hold_oldstatus	int
	,@cmd			nvarchar(2000)
	,@query_text		varchar(500)
	,@error_count		int
	,@return_name 		sysname
	,@return_type		sysname
	,@return_object_id	int
	,@save_object_name	sysname
	,@save_object_type	nvarchar(20)
	,@save_schema_name	sysname
	,@save_object_id	int
	,@DBID			int
	,@iSPID			int

DECLARE  
	 @cu11UName		sysname

DECLARE  
	  @cu12UName		sysname
	 ,@cu12SName		sysname

DECLARE  
	 @cu13UName		sysname

DECLARE
	 @cu14fileid		smallint
	,@cu14groupid		smallint
	,@cu14name		nvarchar(128)
	,@cu14filename		nvarchar(260)


----------------  initial values  -------------------
Select @error_count = 0


Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)

Create table #objects (the_object_id int)



/****************************************************************
 *                MainLine
 ***************************************************************/

Print '-- Prepare the Restore process for database: ' + Upper(@dbname)
Print ' '
Print ' '


--  If the DB is not ONLINE, drop the database
If DATABASEPROPERTYEX(@dbname, N'Status') != N'ONLINE'
   begin
    Select @query_text = 'drop database [' + @dbname + ']'
    print @query_text
    Exec(@query_text)

    print ' '
    goto label99
   end



--  Disable Service Broker
Select @query_text = 'alter database [' + @dbname + '] SET DISABLE_BROKER with ROLLBACK IMMEDIATE;'
print @query_text
Exec(@query_text)

print ' '

--  Pause for a couple seconds
waitfor delay '00:00:02'




--  Kill process
Select @DBID = dbid FROM master.sys.sysdatabases where name = @dbname

Select @iSPID = 10
WHILE @iSPID IS NOT NULL
   begin
	Select @iSPID = min(spid) from master.sys.sysprocesses where dbid = @DBID and spid > @iSPID
	IF @iSPID IS NOT NULL
	   begin
		Select @query_text = 'KILL ' + convert(varchar(12), @iSPID )
		Print @query_text
		exec(@query_text)
	   end
   end

----  Alter the database to single user mode
--print ' '
--Print '-- Section to set the database to single user'

--Select @query_text = 'alter database [' + @dbname + '] set SINGLE_USER with ROLLBACK IMMEDIATE '
--print @query_text
--Exec(@query_text)

--print ' '

--  Pause for a couple seconds
waitfor delay '00:00:02'



--  Alter the database to offline mode
print ' '
Print '-- Section to set the database to offline'

Select @query_text = 'alter database [' + @dbname + '] set OFFLINE with ROLLBACK IMMEDIATE '
print @query_text
Exec(@query_text)

print ' '

--  Pause for a couple seconds
waitfor delay '00:00:02'



--  Alter the database to online mode
print ' '
Print '-- Section to set the database to online'

Select @query_text = 'alter database [' + @dbname + '] set ONLINE with ROLLBACK IMMEDIATE '
print @query_text
Exec(@query_text)

print ' '

--  Pause for a couple seconds
waitfor delay '00:00:02'



If @dropDB = 'n'
   begin
	goto start_drop_DBusers
   end



--  Section to Drop all DB Users
Print '-- Drop Assemblies and related objects for Database ' + @DBname


--  Drop any assemblies

--  Remove type dependencies
Print '-- Start Remove type dependencies'
Select @cmd = 'use [' + @dbname + '] SELECT o.object_id
  FROM (
        SELECT object_id, name, user_type_id, ''SQL_COLUMN'' AS type_desc
          FROM sys.columns
     UNION ALL
        SELECT object_id, name, user_type_id, ''SQL_PROCEDURE_PARAMETER''
          FROM sys.parameters
     ) AS c
  JOIN sys.objects AS o
    ON o.object_id = c.object_id
  JOIN sys.assembly_types AS at
    ON at.user_type_id = c.user_type_id;'

delete from #objects
Insert into #objects exec (@cmd)
--select * from #objects

If (select count(*) from #objects) > 0
   begin
	start_delete_tpye_dependents:

	Select @save_object_id = (select top 1 the_object_id from #objects order by the_object_id)

	Select @cmd = 'use [' + @dbname + '] select @save_object_name = (select name from sys.objects where object_id = ' + convert(nvarchar(20), @save_object_id) + ')'
	--print @cmd
	EXEC sp_executesql @cmd, N'@save_object_name sysname output', @save_object_name output

	Select @cmd = 'use [' + @dbname + '] select @save_object_type = (select type from sys.objects where object_id = ' + convert(nvarchar(20), @save_object_id) + ')'
	--print @cmd
	EXEC sp_executesql @cmd, N'@save_object_type sysname output', @save_object_type output

	Select @cmd = 'use [' + @dbname + '] select @save_schema_name = (select s.name from sys.objects o, sys.schemas s where o.object_id = ' + convert(nvarchar(20), @save_object_id) + ' and o.schema_id = s.schema_id)'
	--print @cmd
	EXEC sp_executesql @cmd, N'@save_schema_name sysname output', @save_schema_name output

	If @save_object_type in ('P', 'PC')
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP procedure [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
	   end
	Else If @save_object_type in ('FN', 'FS', 'TF')
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP function [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
	   end
	Else If @save_object_type = 'AF'
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP AGGREGATE [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
	   end
	Else If @save_object_type = 'U'
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP table [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
	   end
	Else If @save_object_type = 'TR'
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP trigger [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
	   end


	delete from #objects where the_object_id = @save_object_id
	If (select count(*) from #objects) > 0
	   begin
		goto start_delete_tpye_dependents
	   end
   end



--  First, drop any related types
Print '-- Start drop any related types'
start_drop_types:

Select @cmd = 'use [' + @dbname + '] select @return_type = (SELECT top 1 name from sys.assembly_types order by name)'
--print @cmd
EXEC sp_executesql @cmd, N'@return_type sysname output', @return_type output

If @return_type is not null
   begin
	Select @cmd = 'use [' + @dbname + '] DROP type [' + @return_type + '];'
	Print @cmd
	Exec (@cmd)
	goto start_drop_types
   end



--  Next, drop any assembly_modules
Print '-- Start drop any assembly_modules'
start_dropassembly_modules:

Select @cmd = 'use [' + @dbname + '] select @return_object_id = (select top 1 object_id FROM sys.ASSEMBLY_MODULES)'
--print @cmd
EXEC sp_executesql @cmd, N'@return_object_id int output', @return_object_id output

If @return_object_id is not null
   begin
	Select @cmd = 'use [' + @dbname + '] select @save_object_name = (select name from sys.objects where object_id = ' + convert(nvarchar(20), @return_object_id) + ')'
	--print @cmd
	EXEC sp_executesql @cmd, N'@save_object_name sysname output', @save_object_name output

	Select @cmd = 'use [' + @dbname + '] select @save_object_type = (select type from sys.objects where object_id = ' + convert(nvarchar(20), @return_object_id) + ')'
	--print @cmd
	EXEC sp_executesql @cmd, N'@save_object_type sysname output', @save_object_type output

	Select @cmd = 'use [' + @dbname + '] select @save_schema_name = (select s.name from sys.objects o, sys.schemas s where o.object_id = ' + convert(nvarchar(20), @return_object_id) + ' and o.schema_id = s.schema_id)'
	--print @cmd
	EXEC sp_executesql @cmd, N'@save_schema_name sysname output', @save_schema_name output


	If @save_object_type in ('P', 'PC')
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP procedure [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
		goto start_dropassembly_modules
	   end
	Else If @save_object_type in ('FN', 'FS', 'TF')
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP function [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
		goto start_dropassembly_modules
	   end
	Else If @save_object_type = 'AF'
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP AGGREGATE [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
		goto start_dropassembly_modules
	   end
	Else If @save_object_type = 'TR'
	   begin
		Select @cmd = 'use [' + @dbname + '] DROP trigger [' + @save_schema_name + '].[' + @save_object_name + '];'
		Print @cmd
		Exec (@cmd)
		goto start_dropassembly_modules
	   end
   end


Print '-- Start drop assemblies'
start_dropassemblies:
	
Select @cmd = 'use [' + @dbname + '] select @return_name = (select top 1 name FROM sys.assemblies where principal_id > 4 and principal_id < 16384)'
--print @cmd
EXEC sp_executesql @cmd, N'@return_name sysname output', @return_name output

If @return_name is not null
   begin
	Select @cmd = 'use [' + @dbname + '] DROP ASSEMBLY [' + @return_name + '];'
	Print @cmd
	Exec (@cmd)
	goto start_dropassemblies
   end



start_drop_DBusers:

--  Section to Drop all DB Users
Print '-- Drop All Database Users for Database ' + @DBname


--  Drop any schemas with the same name as the user
--------------------  Cursor for database users -----------------------
EXECUTE('DECLARE cursor_11 Insensitive Cursor For ' + 
  'SELECT u.Name
   From [' + @DBname + '].sys.sysusers  u ' + 
  'Where u.hasdbaccess = 1
   and u.uid > 4
   Order by u.name For Read Only')


OPEN cursor_11

WHILE (11=11)
   Begin
	FETCH Next From cursor_11 Into @cu11UName
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11
	      BREAK
           end


	Select @cmd = 'use [' + @DBname + '] if exists (select 1 from sys.schemas where name = ''' + @cu11UName + ''') DROP SCHEMA [' + @cu11UName + '];'
	Print @cmd
	Exec (@cmd)
  


   End  -- loop 11
Deallocate cursor_11

Print ' '


--  Modify ownership of any schema that is owned by a user we are about to drop
--------------------  Cursor for database schemas -----------------------
EXECUTE('DECLARE cursor_12 Insensitive Cursor For ' + 
  'SELECT u.Name, s.name
   From [' + @DBname + '].sys.sysusers  u, [' + @DBname + '].sys.schemas  s ' + 
  'Where u.uid = s.principal_id 
   and u.hasdbaccess = 1
   and u.uid > 4
   Order by u.name For Read Only')


OPEN cursor_12

WHILE (12=12)
   Begin
	FETCH Next From cursor_12 Into @cu12UName, @cu12SName
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_12
	      BREAK
           end


	Select @cmd = 'use [' + @DBname + '] If exists(select 1 from sys.sysusers where name = ''' + @cu12SName + ''')
   begin
	ALTER AUTHORIZATION ON SCHEMA::' + @cu12SName + ' TO ' + @cu12SName + '
   end
Else
   begin
	ALTER AUTHORIZATION ON SCHEMA::' + @cu12SName + ' TO dbo
   end
'
	Print @cmd
	Exec (@cmd)
  

   End  -- loop 12
Deallocate cursor_12

Print ' '


--  Now, drop the users
--------------------  Cursor for database users -----------------------
EXECUTE('DECLARE cursor_13 Insensitive Cursor For ' + 
  'SELECT u.Name
   From [' + @DBname + '].sys.sysusers  u ' + 
  'Where u.hasdbaccess = 1
   and u.uid > 4
   Order by u.name For Read Only')


OPEN cursor_13

WHILE (13=13)
   Begin
	FETCH Next From cursor_13 Into @cu13UName
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_13
	      BREAK
           end


	Select @cmd = 'use [' + @DBname + '] DROP USER [' + @cu13UName + '];'
	Print @cmd
	Exec (@cmd)



   End  -- loop 13
Deallocate cursor_13

Print ' '


--  Set the DB to DBO Use Only
Print ' '
Print ' '
Print '-- Section to set the database to RESTRICTED_USER'

Select @query_text = 'alter database [' + @dbname + '] set RESTRICTED_USER with ROLLBACK IMMEDIATE '
print @query_text
Exec(@query_text)

print ' '


--  Drop the DB if requested (and make sure the DB files no longer exist)
If @dropDB = 'y'
   begin
	Print ' '
	Print ' '
	Print '-- Section to Drop the Database'

	--  Capture sysfile info for this database
	Print ''
	Print '-- Capture sysfiles info for this database.'
	select @cmd = 'If (object_id(''dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'') is not null)
	   begin
		drop table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles
	   end'
	--Print  @cmd
	exec  (@cmd)
	Select @cmd = 'Create table dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles (
			fileid smallint,
	 		groupid smallint,
			size int,
			maxsize int,
			growth int,
			status int,
	    		perf int,
			name nchar(128),
			filename nchar(260))'
	--Print  @cmd
	exec  (@cmd)

	Select @cmd = 'Delete from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
	--Print  @cmd
	exec  (@cmd)
	Select @cmd = 'Insert into dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  select * from [' + @dbname + '].sys.sysfiles'
	--Print  @cmd
	exec  (@cmd)

	Select @cmd = 'select * from dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles'
	Print  @cmd
	exec  (@cmd)

	Select @cmd = 'drop database [' + @dbname + ']'
	Print  @cmd
	Exec(@cmd)

	waitfor delay '00:00:05'


	--  Verify the DB no longer exists
	If exists (select 1 from master.sys.databases where name = @dbname)
	   BEGIN
		Select @miscprint = 'DBA ERROR: Unable to drop database ' + @dbname + '. The Database must be dropped and the process restarted in the next step.' 
		Print  @miscprint
		Select @error_count = @error_count + 1
		goto label99
	   END


	--  Now make sure the DB files were deleted
	--------------------  Cursor for 14DB  -----------------------
	select @cmd = 'DECLARE cu14_file Insensitive Cursor For ' + 
	  'SELECT f.fileid, f.groupid, f.name, f.filename
	   From dbaadmin.dbo.' + rtrim(@dbname) + '_temp_sysfiles  f ' + 
	  'Order By f.fileid For Read Only'

	EXECUTE(@cmd)

	OPEN cu14_file

	WHILE (14=14)
	   Begin
		FETCH Next From cu14_file Into @cu14fileid, @cu14groupid, @cu14name, @cu14filename 
		IF (@@fetch_status < 0)
		   begin
		      CLOSE cu14_file
		      BREAK
		   end
        	
		Select @cmd = rtrim(@cu14filename)
		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @cmd
		If (select doesexist from #fileexists) = 1
		   begin
			Select @cmd = 'Del ' + rtrim(@cmd)
			Print @cmd
			EXEC master.sys.xp_cmdshell @cmd--, no_output 
		   end

		waitfor delay '00:00:05'

		Delete from #fileexists
		Insert into #fileexists exec master.sys.xp_fileexist @cmd
		If (select doesexist from #fileexists) = 1
		   begin
			Select @miscprint = 'DBA ERROR: Unable to delete database files for ' + @dbname + ' (file - ' + rtrim(@cu14filename) + ').  The files for this DB must be deleted and the process restarted in the next step.' 
			Print  @miscprint
			Select @error_count = @error_count + 1
			goto label99
		   end

	   End  -- loop 14
	   DEALLOCATE cu14_file

   end



--  Finalization  -------------------------------------------------------------------

label99:

drop table #fileexists
drop table #objects

If @error_count = 0
   begin
	Print ' '
	Print '-- Completed prepare for the Restore process for database: ' + Upper(@dbname)
	Print ' '
	Print ' '
   end
Else
   begin
	Print ' '
	Print '-- PROCESS FAILED: Prepare for the Restore process for database: ' + Upper(@dbname)
	Print ' '
	Print ' '
	raiserror(@miscprint,16,-1) with log
   end






 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_ShrinkLDFFiles
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_ShrinkLDFFiles]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_ShrinkLDFFiles]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO




CREATE PROCEDURE dbo.dbasp_ShrinkLDFFiles (@DBname sysname = null)
 
/*********************************************************
 **  Stored Procedure dbasp_ShrinkLDFFiles                  
 **  Written by Jim Wilson, Getty Images                
 **  July 22, 2003                                      
 **
 **  This proc accepts one optional input parm; DBname.
 **  If an input parm is not given, all non-system LDF files 
 **  will be processed.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	07/22/2003	Jim Wilson		New process
--	01/23/2006	Jim Wilson		Added skip for no-check databases
--	05/03/2006	Jim Wilson		Modified for SQL 2005
--	07/17/2008	Jim Wilson		Do not skip DB if specified with @Dname input parm.
--	01/02/2009	Jim Wilson		Converted to new no_check table.
--	02/25/2009	Jim Wilson		New code for skipping DB's
--	03/12/2009	Jim Wilson		Fixed bug with @dbname variable.
--	06/08/2009	Jim Wilson		Added brackets [] for dbname.
--	======================================================================================


/***
Declare @DBname sysname

--Select @DBname = 'dbaadmin'
--***/

-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(255)
	,@cursor_text			nvarchar(500)
	,@cmd				sysname
	,@DB_done_flag			char(1)
	,@hold_backup_start_date	datetime
	,@hold_backup_set_id		int
	,@hold_file_type		char(1)
	,@saveDBName			sysname

DECLARE
	 @cu11DBName			sysname

DECLARE
	 @cu22fileid			smallint
	,@cu22name			nvarchar(128)
	,@cu22filename			nvarchar(260)

----------------  initial values  -------------------


/****************************************************************
 *                MainLine
 ***************************************************************/

If @DBname is null or @DBname = ''
   begin
	Select @cursor_text = 'DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.sysdatabases   d ' + 
  'Where d.name not in (''master'', ''msdb'', ''model'', ''tempdb'')
   Order By d.dbid For Read Only'
   end
Else
   begin
	Select @cursor_text = 'DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.sysdatabases   d ' + 
  'Where d.name = ''' + @DBname + '''
   Order By d.dbid For Read Only'
   end


--------------------  Cursor for DB names  -------------------
EXECUTE(@cursor_text)


OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	

	If @cu11DBName in (select detail01 from dbo.no_check where NoCheck_type = 'backup')
	   begin
		Print 'Skip database ' + @cu11DBName
		Print ' '
		goto skip_database
	   end

	If @cu11DBName like 'z_%' or @cu11DBName like '%_new'
	   begin
		Print 'Skip database ' + @cu11DBName
		Print ' '
		goto skip_database
	   end

	If DATABASEPROPERTYEX (@cu11DBName,'status') <> 'ONLINE'
	   begin
		Print 'Skip database ' + @cu11DBName
		Print ' '
		goto skip_database
	   end

	If DATABASEPROPERTY(rtrim(@cu11DBName), 'IsReadOnly') = 1
	   begin
		Print 'Skip read only database ' + @cu11DBName
		Print ' '
		goto skip_database
	   end



	--------------------  Cursor for 22DB  -----------------------
	EXECUTE('DECLARE cu22_file Insensitive Cursor For ' + 
	  'SELECT f.fileid, f.name, f.filename
	   From [' + @cu11DBName + '].sys.sysfiles  f ' + 
	  'Where f.groupid = 0
	   Order By f.fileid For Read Only')

	OPEN cu22_file

	WHILE (22=22)
	   Begin
		FETCH Next From cu22_file Into @cu22fileid, @cu22name, @cu22filename 
		IF (@@fetch_status < 0)
	           begin
	  CLOSE cu22_file
		      BREAK
	           end

 
		Select @cmd = 'sqlcmd -S' + @@servername + ' -d' + @cu11DBName + ' -Q"DBCC SHRINKFILE ([' + rtrim(@cu22name) + '])" -E'

		Print @cmd

		EXEC master.sys.xp_cmdshell @cmd

		Print ' '


	   End  -- loop 22
	   DEALLOCATE cu22_file

skip_database:

End  -- loop 11
DEALLOCATE cu11_DBNames

---------------------------  Finalization  -----------------------

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SQLSecurityCopy_process
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SQLSecurityCopy_process]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SQLSecurityCopy_process]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SQLSecurityCopy_process

/**************************************************************
 **  Stored Procedure dbasp_SQLSecurityCopy_process                  
 **  Written by Jim Wilson, Getty Images                
 **  December 27, 2002                                      
 **  
 **  This dbasp is set up to gather and combine the SQL security
 **  reports.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/27/2002	Jim Wilson		New copy process.
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	06/19/2003	Jim Wilson		Fix for instance file name.
--	06/09/2006	Jim Wilson		Updated for SQL 2005.
--	08/22/2008	Jim Wilson		New table dba_serverinfo.
--	======================================================================================


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@command 		nvarchar(4000)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_domain			sysname
	,@charpos		int

DECLARE
	 @cu11sqlservername	sysname
	,@cu11sqlservername2	sysname
	,@cu11sqlservername3	sysname



----------------  initial values  -------------------
Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


Select @save_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')

Select @command = 'copy \\' + @save_servername + '\' + @save_servername2 + '_dbasql\security_header.txt \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\SQLServer_SecurityRpt.txt'
EXEC master..xp_cmdshell @command, no_output 


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Cursor for SQL Servers to scan
EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
  'SELECT u.SQLname
   From dbaadmin.dbo.DBA_Serverinfo  u ' +
  'Where u.active = ''y''
     and u.DomainName = ''' + @save_domain + '''
   Order by u.SQLname for Read Only')

OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11sqlservername
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end


	Select @cu11sqlservername2 = @cu11sqlservername
	Select @cu11sqlservername3 = @cu11sqlservername

	Select @charpos = charindex('\', @cu11sqlservername)
	IF @charpos <> 0
	   begin
		Select @cu11sqlservername = rtrim(substring(@cu11sqlservername, 1, (CHARINDEX('\', @cu11sqlservername)-1)))

		Select @cu11sqlservername2 = rtrim(stuff(@cu11sqlservername2, @charpos, 1, '$'))

		Select @cu11sqlservername3 = stuff(@cu11sqlservername3, @charpos, 1, '(')
		Select @cu11sqlservername3 = @cu11sqlservername3 + ')'

	   end


	Select @command = 'copy \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\SQLServer_SecurityRpt.txt + \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_dbasql\dba_reports\' + @cu11sqlservername3 + '_REPORTsecurity.txt   \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\SQLServer_SecurityRpt.txt'
	EXEC master.sys.xp_cmdshell @command, no_output 


	Select @miscprint = 'Copy process completed for SQL Server ' + @cu11sqlservername
	Print  @miscprint


 End  -- loop 11
DEALLOCATE cu11_cursor




----------------  End  -------------------

Print  ' '
Select @miscprint = 'SQL Security Report copy process completed.'
Print  @miscprint





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SQLtrace
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SQLtrace]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SQLtrace]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_SQLtrace (@outPath sysname = null
					,@trace_name sysname = 'UTILtrace'
					,@dbid int = null
					,@maxfilesize bigint = 200
					,@events varchar(512) = ''
					,@columns varchar(512) = ''
					,@adtnl_events varchar(512) = ''
					,@adtnl_columns varchar(512) = ''
					,@stoponly char(1) = 'n')
 
/***************************************************************
 **  Stored Procedure dbasp_SQLtrace                  
 **  Converted from unknown and various sources by Jim Wilson, Getty Images                
 **  April 11, 2008                                      
 **
 **  This proc accepts the followinf input parms:
 **  @outPath       - Drive letter output path where the trace files are written to.
 **
 **  @trace_name    - Defaults to UTILtrace and is used as part of the output file name.
 **
 **  @dbid          - For when you want to trace on a single DB.
 **
 **  @maxfilesize   - Maximul file size before roll-over.
 **
 **  @events        - Default to '10,11,12,16,17,21,33,37,43,45,55,58,61,67,69,80,81,92,93,94,95' 
 **
 **  @columns       - Default to '1,2,3,4,8,10,11,12,13,14,15,16,17,18,21,22,24,25,27,28,30,31'
 **
 **  @adtnl_events  - Events added to the default list.
 **
 **  @adtnl_columns - Columns added to the default list.
 **
 **  @stoponly      - Used to stop previous traces.
 **
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	04/30/2008	Jim Wilson		New process
--	05/19/2008	Jim Wilson		Added event 11 (RPC:Starting)
--	06/03/2008	Jim Wilson		Fixed code with the backup share.
--	11/24/2009	Jim Wilson		Fixed code for @outpath input parm usage.
--	======================================================================================

/*
Declare @outPath sysname
Declare @trace_name sysname
Declare @dbid int
Declare @maxfilesize bigint
Declare @events varchar(512)
Declare @columns varchar(512)
Declare @adtnl_events varchar(512)
Declare @adtnl_columns varchar(512)
Declare @stoponly char(1)

Select @outPath = 'e:\'
--Select @outPath = 'e:\SQLTrace'
Select @trace_name = 'UTILtrace'
--Select @dbid = 6
Select @maxfilesize = 200
Select @events = ''
Select @columns = ''
Select @adtnl_events = ''
Select @adtnl_columns = ''
Select @stoponly = 'y'
--*/

           
declare 
	 @miscprint	    nvarchar(500)
	,@date		    nvarchar(30)
	,@traceid	    int
	,@options	    int
	,@tracefile	    nvarchar (245)
	,@stoptime	    datetime
	,@minMBfree	    bigint
	,@rc		    int
	,@on		    bit
	,@cmd		    nvarchar(4000)
	,@cmd1		    nvarchar(512)
	,@event		    int
	,@column	    int
	,@estart	    int
	,@enext		    int
	,@cstart	    int
	,@cnext		    int
	,@le		    int
	,@lc		    int
	,@filter	    nvarchar(245)
	,@filter_num	    int
	,@save_servername   sysname
	,@save_servername2  sysname
	,@save_outpath	    sysname
	,@charpos	    int
	,@Result	    int
	,@fileexist_path    sysname
	,@old_traceID	    int
	,@old_file_name	    nvarchar(245)



----------------  initial values  -------------------
Select @save_servername		= @@servername
Select @save_servername2	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


Create table #ShareTempTable(path nvarchar(500) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)


--  Find or create the SQLTrace folder
Delete from #ShareTempTable
Select @cmd = 'RMTSHARE \\' + @save_servername
Insert into #ShareTempTable exec master.sys.xp_cmdshell @cmd
delete from #ShareTempTable where path is null or path = ''
delete from #ShareTempTable where path not like @save_servername2 + '_backup%'

--select * from #ShareTempTable

If (select count(*) from #ShareTempTable) = 0
   begin
	Select @miscprint = 'DBA ERROR: Backup share was not found.  Unable to create trace file output path.' 
	Print  @miscprint
	goto label99
   end
	

Select @save_outpath = (Select top 1 path from #ShareTempTable where path like @save_servername2 + '_backup%')
Select @charpos = charindex(':\', @save_outpath)
IF @charpos <> 0
   begin
	Select @save_outpath = substring(@save_outpath, @charpos-1, 3)
   end
Else
   begin
	Select @miscprint = 'DBA ERROR: Backup share is not formatted correctly.  Unable to create trace file output path.' 
	Print  @miscprint
	goto label99
   end


--  If input parm for @outPath is specified, use it
If @outPath is not null and @outPath like '%:\%'
   begin
	If reverse(@outPath) not like '\%'
	   begin
		Select @outPath = @outPath + '\'
	   end

	Select @save_outpath = @outPath
   end



Select @save_outpath = @save_outpath + 'SQLTrace'


--  check to see if the SQLTrace folder exists.  If not, create it.
Delete from #fileexists
Select @fileexist_path = @save_outpath + '\'
Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
If (select fileindir from #fileexists) <> 1
   begin
	Select @cmd = 'mkdir "' + @save_outpath + '"'
	Print 'Creating SQLTrace folder using command '+ @cmd
	EXEC @Result = master.sys.xp_cmdshell @cmd, no_output

	IF @Result <> 0
	   BEGIN
		PRINT 'DBA ERROR: FILE PATH ' + @save_outpath + ' COULD NOT BE CREATED'
		goto label99
	   end
   end


--  Set event and columns
If @events is null or @events = ''
   begin
	Select @events = '10,11,12,16,17,21,33,37,43,45,55,58,61,67,69,80,81,92,93,94,95'
  end


If @columns is null or @columns = ''
   begin
	select @columns = '1,2,3,4,8,10,11,12,13,14,15,16,17,18,21,22,24,25,27,28,30,31'
   end


If @adtnl_events is not null and @adtnl_events <> ''
   begin
	select @events = @events + ',' + @adtnl_events
	select @events = replace(@events, ',,', ',')
   end

If @adtnl_columns is not null and @adtnl_columns <> ''
   begin
	select @columns = @columns + ',' + @adtnl_columns
	select @columns = replace(@columns, ',,', ',')
   end



/****************************************************************
 *                MainLine
 ***************************************************************/

-- Stop an old traces from this process if running
check_oldtrace:
If exists (Select * from :: fn_trace_getinfo(DEFAULT)
	    where property = 2	-- TRACE FILE NAME
	    and convert(sysname, value) like '%\'+ @trace_name +'%')
   begin
	Select @old_traceID = traceid, @old_file_name = convert(nvarchar(245), value)
	from :: fn_trace_getinfo(DEFAULT)
	where property = 2 -- TRACE FILE NAME
	and convert(sysname, value)like '%\'+ @trace_name +'%'

	Print 'Stopping trace ' + @old_file_name + '.  Trace number ' + convert(sysname, @old_traceID)

	EXEC @Result = sp_trace_setstatus @OLD_TRACEID, 0	-- STOPS SPECIFIED TRACE
	If @Result = 0  Print 'DBA Message: SP_TRACE_SETSTATUS: STOPPED TRACE ID ' + STR(@OLD_TRACEID )
	If @Result = 1  Print 'DBA ERROR: SP_TRACE_SETSTATUS: - UNKNOWN ERROR'
	If @Result = 8  Print 'DBA ERROR: SP_TRACE_SETSTATUS: THE SPECIFIED STATUS IS NOT VALID'
	If @Result = 9  Print 'DBA ERROR: SP_TRACE_SETSTATUS: THE SPECIFIED TRACE HANDLE IS NOT VALID'
	If @Result = 13 Print 'DBA ERROR: SP_TRACE_SETSTATUS: OUT OF MEMORY'
	If @Result <> 0 goto label99

	EXEC sp_trace_setstatus @OLD_TRACEID, 2 -- DELETE SPECIFIED TRACE

	If @Result = 0  Print 'DBA Message: SP_TRACE_SETSTATUS: DELETED TRACE ID ' + STR(@OLD_TRACEID)
	If @Result = 1  Print 'DBA ERROR: SP_TRACE_SETSTATUS: - UNKNOWN ERROR'
	If @Result = 8  Print 'DBA ERROR: SP_TRACE_SETSTATUS: THE SPECIFIED STATUS IS NOT VALID'
	If @Result = 9  Print 'DBA ERROR: SP_TRACE_SETSTATUS: THE SPECIFIED TRACE HANDLE IS NOT VALID'
	If @Result = 13 Print 'DBA ERROR: SP_TRACE_SETSTATUS: OUT OF MEMORY'
	If @Result <> 0 goto label99

	Waitfor delay '00:00:04'

	goto check_oldtrace
   end

If @stoponly = 'y'
   begin
	goto label99
   end


-- Build the trace file name (with date/time stamp)
Select @date = convert(sysname, getdate(), 120)
Select @date = replace(@date, '-', '')
Select @date = replace(@date, ':', '')
Select @date = replace(@date, ' ', '_')
Select @date = rtrim(@date)

Select @trace_name = @trace_name + '_' + @save_servername2 + '_' + @date + '_'

print @trace_name

select @tracefile = @save_outpath + '\' + @trace_name    --- Define Trace file Path
select @stoptime = (select dateadd(hh,2, getdate()))	--- Limits Trace to 2 Hour duration
select @options = 2


-- If trace is defined, start it
set @traceid = 0
select @traceid = traceid FROM :: fn_trace_getinfo(0) where property = 2 and value = @tracefile
if @traceid != 0 goto finish

--  Delete any files that could be named like this trace
set @cmd1 = 'if exist ' + @tracefile + '*.trc ' + 'del ' + @tracefile + '*.trc'
exec @rc = master.sys.xp_cmdshell @cmd1, no_output

--  create the trace
exec @rc = sp_trace_create @traceid output, @options, @tracefile, @maxfilesize, @stoptime


--Set Trace Definitions
select @estart = 1
select @enext = charindex(',',@events,@estart)
select @cstart = 1
select @cnext = charindex(',',@columns,@cstart)
set @le = len(@events)
set @lc = len(@columns)
set @on = 1

while @enext > 0
   begin
	select @event = cast(substring(@events,@estart,@enext-@estart) as int)
	while @cnext > 0
	   begin
		select @column = cast(substring(@columns,@cstart,@cnext-@cstart) as int)
		exec sp_trace_setevent @traceid, @event, @column, @on
		select @cstart = @cnext + 1
		select @cnext = charindex(',',@columns,@cstart)
		if @cnext = 0 set @cnext = @lc + 1
		if @cstart >@lc set @cnext = 0
	   end

	select @cstart = 1
	select @cnext = charindex(',',@columns,@cstart)
	select @estart = @enext + 1
	select @enext = charindex(',',@events,@estart)
	if @enext = 0 set @enext = @le + 1
	if @estart > @le set @enext = 0
   end


--  set database filter if requested
If @dbid is not null
   begin
	EXEC sp_trace_setfilter @traceid, 3, 1, 0, @dbid
   end


-- Define each Filter event
exec sp_trace_setfilter @traceid, 10, 0, 7, N'SQL Profiler' 
exec sp_trace_setfilter @traceid, 10, 0, 7, N'SQLAgent%' 
exec sp_trace_setfilter @traceid, 10, 0, 7, N'SQL Query%' 
exec sp_trace_setfilter @traceid, 10, 0, 7, N'MS SQLEM%' 

--  exclude system objects
exec sp_trace_setfilter @traceid, 22, 0, 4, 100


finish:

-- start the trace
exec sp_trace_setstatus @traceid, 1 


----------------  End  -------------------

label99:
drop table #ShareTempTable
drop table #fileexists





 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SQLUsageCopy_process
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SQLUsageCopy_process]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SQLUsageCopy_process]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SQLUsageCopy_process

/**************************************************************
 **  Stored Procedure dbasp_SQLUsageCopy_process                  
 **  Written by Jim Wilson, Getty Images                
 **  December 27, 2002                                      
 **  
 **  This dbasp is set up to gather and combine the SQL Usage
 **  reports.
 ***************************************************************/
  as
  SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/27/2002	Jim Wilson		New copy process.
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	06/19/2003	Jim Wilson		Fix for instance file name.
--	06/09/2006	Jim Wilson		Updated for SQL 2005.
--	08/22/2008	Jim Wilson		New table dba_serverinfo.
--	======================================================================================


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(4000)
	,@command 		nvarchar(4000)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_domain			sysname
	,@charpos		int

DECLARE
	 @cu11sqlservername	sysname
	,@cu11sqlservername2	sysname
	,@cu11sqlservername3	sysname



----------------  initial values  -------------------
Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = rtrim(substring(@@servername, 1, (CHARINDEX('\', @@servername)-1)))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_domain = (select env_detail from dbo.Local_ServerEnviro where env_type = 'domain')

Select @command = 'copy \\' + @save_servername + '\' + @save_servername2 + '_dbasql\usage_header.txt \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\SQLServer_UsageRpt.txt'
EXEC master..xp_cmdshell @command, no_output 


/****************************************************************
 *                MainLine
 ***************************************************************/

--  Cursor for SQL Servers to scan
EXECUTE('DECLARE cu11_cursor Insensitive Cursor For ' +
  'SELECT u.SQLname
   From dbaadmin.dbo.DBA_Serverinfo  u ' +
  'Where u.active = ''y''
     and u.DomainName = ''' + @save_domain + '''
   Order by u.SQLname for Read Only')

OPEN cu11_cursor

WHILE (11=11)
 Begin
	FETCH Next From cu11_cursor Into @cu11sqlservername
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_cursor
	      BREAK
           end


	Select @cu11sqlservername2 = @cu11sqlservername
	Select @cu11sqlservername3 = @cu11sqlservername

	Select @charpos = charindex('\', @cu11sqlservername)
	IF @charpos <> 0
	   begin
		Select @cu11sqlservername = rtrim(substring(@cu11sqlservername, 1, (CHARINDEX('\', @cu11sqlservername)-1)))

		Select @cu11sqlservername2 = rtrim(stuff(@cu11sqlservername2, @charpos, 1, '$'))

		Select @cu11sqlservername3 = stuff(@cu11sqlservername3, @charpos, 1, '(')
		Select @cu11sqlservername3 = @cu11sqlservername3 + ')'

	   end


	Select @command = 'copy \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\SQLServer_UsageRpt.txt + \\' + @cu11sqlservername + '\' + @cu11sqlservername2 + '_dbasql\dba_reports\' + @cu11sqlservername3 + '_REPORTusage.txt   \\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\SQLServer_UsageRpt.txt'
	EXEC master.sys.xp_cmdshell @command, no_output 


	Select @miscprint = 'Copy process completed for SQL Server ' + @cu11sqlservername
	Print  @miscprint


 End  -- loop 11
DEALLOCATE cu11_cursor





----------------  End  -------------------

Print  ' '
Select @miscprint = 'SQL Usage Report copy process completed.'
Print  @miscprint





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSadddbrolemembers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSadddbrolemembers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSadddbrolemembers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SYSadddbrolemembers

/***************************************************************
 **  Stored Procedure dbasp_SYSadddbrolemembers                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add database role member  
 **        
 **  Output member is SYSadddbrolemembers.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	06/11/2002	Jim Wilson		Added brackets around DB name in use stmt.
--	05/23/2006	Jim Wilson		Updated for SQL 2005.
--	======================================================================================


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(255)
	,@G_O             	nvarchar(2)
	,@output_flag01		char(1)
	,@output_flag02		char(1)
	,@filegrowth		nvarchar(20)
	,@saverolename		sysname

DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu22Urole		sysname
	,@cu22Uname		sysname

----------------  initial values  -------------------
Select
	 @G_O		= 'g' + 'o'
	,@saverolename	= ''
	,@output_flag01	= 'n'

/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/*******************************************************************'
Select @miscprint = 'Generated SQL - SYSadddbrolemembers'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '

--------------------  Cursor for DB names  -------------------
EXECUTE('DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.sysdatabases   d ' + 
  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')
   Order By d.dbid For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Print the headers  ----------------------
   Print  '/**************************************************************'
   Select @miscprint = 'Add Database Role Members for server: ' + @@servername  
   Print  @miscprint
   Print  '**************************************************************/'
   Print  ' '

   
OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	
----------------------  Print the headers  ----------------------
   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'Add Role Members for Database: ' + @cu11DBName  
   Print  @miscprint
   Print  '***********************************************/'
   Select @miscprint = 'USE [' + @cu11DBName + ']'
   Print  @miscprint  
   Print  @G_O

   Select @output_flag02 = 'n'
  
--------------------  Cursor for 22DB  -----------------------
EXECUTE('DECLARE cu22_DBRole Insensitive Cursor For ' + 
  'SELECT r.name, u.name
   From [' + @cu11DBName + '].sys.sysusers  u, [' + @cu11DBName + '].sys.sysusers  r, [' + @cu11DBName + '].sys.sysmembers  m ' + 
  'Where u.uid > 3
     and u.uid = m.memberuid
     and m.groupuid = r.uid
 Order By r.name, u.uid For Read Only')

OPEN cu22_DBRole

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBRole Into @cu22Urole, @cu22Uname 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_DBRole
	      BREAK
           end

	IF @cu22Urole <> @saverolename
	   begin
		Print ''
		Select @miscprint = '/*****  Add for Role ''' + @cu22Urole + '''  *****/'
		Print  @miscprint
		Print ''
		Select @saverolename = @cu22Urole
	   end
	 
	Select @miscprint = 'sp_addrolemember ''' + @cu22Urole + ''', '''  + @cu22Uname + ''''
	Print  @miscprint
	Print  @G_O
	Print  ' '
	Select @output_flag02 = 'y'

   End  -- loop 22
   DEALLOCATE cu22_DBRole


If @output_flag02 = 'n'
   begin
	Print ''
	Print '-- No output for this database.'
	Print ''
   end
Else
   begin
	Select @output_flag02 = 'n' 
   end


Select @output_flag01 = 'y'

 End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cu11_DBNames

If @output_flag01 = 'n'
   begin
	Print '-- No output for this script.'
	Print ''
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSadddbroles
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSadddbroles]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSadddbroles]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE dbo.dbasp_SYSadddbroles

/***************************************************************
 **  Stored Procedure dbasp_SYSadddbroles                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add database roles  
 **        
 **  Output member is SYSadddbroles.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	06/11/2002	Jim Wilson		Added brackets around DB name in use stmt.
--	05/22/2006	Jim Wilson		Updated for SQL 2005.
--	03/05/2008	Jim Wilson		Modified sysuser cursor - added uid > 16399.
--	======================================================================================


-----------------  declares  ------------------
DECLARE
	 @miscprint		nvarchar(255)
	,@G_O			nvarchar(2)
	,@output_flag01		char(1)
	,@output_flag02		char(1)
	,@save_altname		sysname
	,@save_schemaname	sysname
	,@cmd			nvarchar(500)

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint

DECLARE
	 @cu22Uname		nvarchar(128)
	,@cu22Ualtuid		smallint
	,@cu22Uissqlrole	int
	,@cu22Uisapprole	int



----------------  initial values  -------------------
Select
	 @G_O		= 'g' + 'o'
	,@output_flag01	= 'n'


/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/**************************************************************'
Select @miscprint = 'Generated SQL - SYSadddbroles'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '**************************************************************/'
Print  ' '
Print  ' '


--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name, d.dbid
   From master.sys.sysdatabases   d ' + 
  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')
   Order By d.dbid For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Print the headers  ----------------------
   Print  '/***********************************************'
   Select @miscprint = 'Add Database Roles for server: ' + @@servername  
   Print  @miscprint
   Print  '***********************************************/'
   Print  ' '
   Select @output_flag02 = 'n'

   
OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName, @cu11DBId
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	
 
----------------------  Print the headers  ----------------------
   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'Add Roles for Database: ' + @cu11DBName  
   Print  @miscprint
   Print  '***********************************************/'
   Select @miscprint = 'USE [' + @cu11DBName + '];'
   Print  @miscprint  
   Print  @G_O
   Print  ' ' 
  

--------------------  Cursor for 22DB  -----------------------
EXECUTE('DECLARE cu22_DBRole Insensitive Cursor For ' + 
  'SELECT u.name, u.altuid, u.issqlrole, u.isapprole
   From [' + @cu11DBName + '].sys.sysusers  u ' + 
  'Where (u.issqlrole = 1 or u.isapprole = 1)
	 and (u.uid < 16380 or u.uid > 16399)
	 and u.name <> ''public''
   Order By u.uid For Read Only')

OPEN cu22_DBRole

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBRole Into @cu22Uname, @cu22Ualtuid, @cu22Uissqlrole, @cu22Uisapprole 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_DBRole
	      BREAK
           end

	 
	If @cu22Uissqlrole = 1
	   begin

		Select @cmd = 'USE ' + quotename(@cu11DBName) 
				+ ' SELECT @save_altname = (select name from sys.sysusers where uid = ' + convert(varchar(10), @cu22Ualtuid) + ')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_altname sysname output', @save_altname output
		--print @save_altname

		Select @miscprint = 'CREATE ROLE [' + @cu22Uname + '] AUTHORIZATION [' + @save_altname + '];'
		Print  @miscprint
		Print  @G_O
		Print  ' '
		goto end_01
	   end



	If @cu22Uisapprole = 1
	   begin
		Select @cmd = 'USE ' + quotename(@cu11DBName) 
				+ ' SELECT @save_schemaname = (select default_schema_name from sys.database_principals where name = ''' + @cu22Uname + ''')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_schemaname sysname output', @save_schemaname output
		--print @save_schemaname

		Select @miscprint = '/* CREATE APPLICATION ROLE ---------------------------------------------  */'
		Print  @miscprint
		Select @miscprint = '/* To avoid disclosure of passwords, the password is generated in script. */'
		Print  @miscprint
		Select @miscprint = 'declare @idx as int'
		Print  @miscprint
		Select @miscprint = 'declare @randomPwd as nvarchar(64)'
		Print  @miscprint
		Select @miscprint = 'declare @rnd as float'
		Print  @miscprint
		Select @miscprint = 'declare @cmd nvarchar(4000)'
		Print  @miscprint
		Select @miscprint = 'select @idx = 0'
		Print  @miscprint
		Select @miscprint = 'select @randomPwd = N'''
		Print  @miscprint
		Select @miscprint = 'select @rnd = rand((@@CPU_BUSY % 100) + ((@@IDLE % 100) * 100) +'
		Print  @miscprint
		Select @miscprint = '       (DATEPART(ss, GETDATE()) * 10000) + ((cast(DATEPART(ms, GETDATE()) as int) % 100) * 1000000))'
		Print  @miscprint
		Select @miscprint = 'while @idx < 64'
		Print  @miscprint
		Select @miscprint = 'begin'
		Print  @miscprint
		Select @miscprint = '   select @randomPwd = @randomPwd + char((cast((@rnd * 83) as int) + 43))'
		Print  @miscprint
		Select @miscprint = '   select @idx = @idx + 1'
		Print  @miscprint
		Select @miscprint = '   select @rnd = rand()'
		Print  @miscprint
		Select @miscprint = 'end'
		Print  @miscprint
		Select @miscprint = 'select @cmd = N''CREATE APPLICATION ROLE [' + @cu22Uname + '] WITH DEFAULT_SCHEMA = [' + @save_schemaname + '], '' + N''PASSWORD = N'' + QUOTENAME(@randomPwd,'''''''')'
		Print  @miscprint
		Select @miscprint = 'EXEC dbo.sp_executesql @cmd'
		Print  @miscprint
		Print  @G_O
		Print  ' '
	   end


	end_01:

	Select @output_flag02 = 'y'

   End  -- loop 22
   DEALLOCATE cu22_DBRole


If @output_flag02 = 'n'
   begin
	Print '-- No output for this database.'
   end

Select @output_flag01 = 'y'
Select @output_flag02 = 'n'

 End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cu11_DBNames

If @output_flag01 = 'n'
   begin
	Print '-- No output for this script.'
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSaddjobs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSaddjobs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSaddjobs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SYSaddjobs
	 @jobname sysname = null     /** job name input parm **/
	,@leave_enabled char(1) = 'n'
	,@appl_name char(5)= null

/*********************************************************
 **  Stored Procedure dbasp_SYSaddjobs                  
 **  Written by Jim Wilson, Getty Images                
 **  May 5, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add sql jobs  
 **        
 **  Output member is SYSaddjobs.gsql
 ***************************************************************
 **  Execution Instructions:      
 **  This sproc can be used to script all SQL jobs on the server,
 **  or select jobs based on the input parameter provided.  If the 
 **  input parameter is left blank, all jobs will be scripted.
 **  
 **  If script(s) for a specific job or set of jobs are desired,
 **  code the job name (or the first few characters of the job name)
 **  in the input parameter.  For example;
 **
 **  exec dbasp_sysaddjobs @jobname = 'APPL'
 **
 **  This will script out all jobs that start with 'APPL'
 **
 **  If script(s) for a specific set of jobs by application are desired,
 **  first look in the job description, note the first 2-4 characters.
 **  Then, supply those characters as the input parameter.  For example;
 **
 **  exec dbasp_sysaddjobs @appl_name = 'gmsa'
 **
 **  This will script out all jobs that are with 'GMSA'
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	06/10/2002	Jim Wilson		@@servername changes to support multiple instances
--	07/03/2002	Jim Wilson		Added code to delete the job if it exists prior 
--						to re-adding it.
--	07/05/2002	Jim Wilson		Fixed null 'muser' problem (job owner not in sysxlogins). 
--	08/21/2002	Jim Wilson		Mass re-write fixed multi schedule problem, added input
--						parm for job name and fixed the multiple 'go' issue. 
--	09/20/2002	Jim Wilson		Fixed code in the delete job section 
--	09/24/2002	Jim Wilson		Modified fix servername code for shares 
--	09/27/2002	Jim Wilson		Fixed long lines (over 255) 
--	10/03/2002	Jim Wilson		Fixed problem with dynamic servername change 
--	10/10/2002	Jim Wilson		Change query so only local jobs are scripted and
--						fixed the orphaned line feed an CR problem 
--	02/10/2003	Jim Wilson		Added dynamic code for output file path resolution 
--	03/31/2003	Jim Wilson		Jobs will now be scripted out disabled by default. A
--						new input parm has been added to allow for scripting leaving
--						enabled intact. 
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	05/29/2003	Jim Wilson		Added dynamic code for @@servername in cmd field
--	04/21/2004	Jim Wilson		Convert servername with instance and no leading back slash
--	09/01/2004	Jim Wilson		Fixed problem with @server in job step when specified.
--	05/09/2005	Jim Wilson		Added code for production job status systeminfo table update.
--	02/22/2006	Jim Wilson		Modified for sql 2005
--	08/04/2006	Jim Wilson		Updated the fix servername process throughout.
--	11/30/2006	Jim Wilson		Changes nvarchar(4000) to nvarchar(max).
--	05/22/2008	Jim Wilson		Change output to chunks (up to 9) of just over 3000 bytes.
--	07/30/2008	Jim Wilson		Split step code into 3000 byte chunks in the output script
--						because of some truncation selecting large amounts of text in
--						an nvarchar(max) variable.  It seems to work if you do it in chunks.
--	12/05/2008	David Spriggs		Added parameter to allow for application jobs can be scripted out.
--	02/02/2009	Jim Wilson		Added code for production job status DEPLinfo table update.
--	10/09/2009	Jim Wilson		Removed code for DB systeminfo.
--	======================================================================================

/***
DECLARE @jobname sysname
DECLARE @leave_enabled char(1)
DECLARE @appl_name char(10)

Select @jobname = null
Select @leave_enabled = 'n'
Select @appl_name = 'GMSA'
--***/


-----------------  declares  ------------------

DECLARE
	 @miscprint						nvarchar(max)
	,@cmd							nvarchar(max)
	,@outprint01						nvarchar(max)
	,@G_O             					nvarchar(2)
	,@save_servername					sysname
	,@save_servername2					sysname
	,@save_servername3					sysname
	,@save_servername4b					sysname
	,@charpos						int
	,@startpos						int
	,@charpos02						int
	,@charpos_diff						int	
	,@cmd_planname						sysname
	,@saveplanname						sysname
	,@saveserver_name					sysname
	,@saveplanid						uniqueidentifier
	,@hold_jobid						varchar(200)
	,@save_mname						sysname
	,@save_cat_class					sysname
	,@save_cat_type						sysname
	,@currentserver_name					sysname
	,@currentserver_name_len				int
	,@currentserver_name2					sysname
	,@currentserver_name2_len				int
	,@currentserver_name3					sysname
	,@currentserver_name3_len				int
	,@currentserver_name4					sysname
	,@currentserver_name4_len				int
	,@currentserver_name4b					sysname
	,@currentserver_name4b_len				int
	,@currentserver_name5					sysname
	,@currentserver_name5_len				int
	,@currentserver_name6					sysname
	,@currentserver_name6_len				int
	,@currentserver_share1					sysname
	,@currentserver_share1_len				int
	,@currentserver_share2					sysname
	,@currentserver_share2_len				int
	,@currentserver_share_spcl				sysname
	,@currentserver_share_spcl_len				int
	,@command_num						int			
	,@command_name						sysname	
	,@output_flag						char(1)
	,@cursor_text						nvarchar(max)
	,@parm01						varchar(100)
	,@logpath						varchar(255)
	,@logpath_len						int

DECLARE
	 @cu11jjob_id						uniqueidentifier
	,@cu11jname						sysname
	,@cu11jenabled						tinyint
	,@cu11jdescription					nvarchar(512)
	,@cu11jstart_step_id					int
	,@cu11jcategory_id					int
	,@cu11jnotify_level_eventlog				int
	,@cu11jnotify_level_email				int
	,@cu11jnotify_level_netsend				int
	,@cu11jnotify_level_page				int
	,@cu11jnotify_email_operator_id				int
	,@cu11jnotify_netsend_operator_id			int
	,@cu11jnotify_page_operator_id				int
	,@cu11jdelete_level					int
	,@cu11jowner_sid					varbinary(85)
	,@cu11vserver_id					int
	,@cu11cname						sysname
	,@cu11category_class					int
	,@cu11category_type					tinyint

Declare
	 @len							int
	,@pos							int
	,@ascii							nvarchar(max)

DECLARE
	 @cu22tstep_id						int
	,@cu22tstep_name					sysname
	,@cu22tsubsystem					nvarchar(40)
	,@cu22tcommand						nvarchar(max)
	,@cu22tflags						int
	,@cu22tcmdexec_success_code				int
	,@cu22ton_success_action				tinyint
	,@cu22ton_success_step_id				int
	,@cu22ton_fail_action					tinyint
	,@cu22ton_fail_step_id					int
	,@cu22tserver						sysname
	,@cu22tdatabase_name					sysname
	,@cu22tdatabase_user_name				sysname
	,@cu22tretry_attempts					int
	,@cu22tretry_interval					int
	,@cu22tos_run_priority					int
	,@cu22toutput_file_name					nvarchar(200)

DECLARE
	 @cu33dschedule_id					int
	,@cu33dname						sysname
	,@cu33denabled						int
	,@cu33dfreq_type					int
	,@cu33dfreq_interval					int
	,@cu33dfreq_subday_type					int
	,@cu33dfreq_subday_interval				int
	,@cu33dfreq_relative_interval				int
	,@cu33dfreq_recurrence_factor				int
	,@cu33dactive_start_date				int
	,@cu33dactive_end_date					int
	,@cu33dactive_start_time				int
	,@cu33dactive_end_time					int
	,@cu33dnext_run_date					int
	,@cu33dnext_run_time					int
	,@cu33ddate_created					datetime
	
----------------  initial values  -------------------

Select @save_servername		= @@servername
Select @save_servername2	= @@servername
Select @save_servername3	= @@servername
Select @save_servername4b	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
	Select @save_servername3 = @save_servername3 + ')'

	Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
   end

Select @G_O				= 'g' + 'o'
Select @currentserver_name		= '\\' + @save_servername
Select @currentserver_name_len		= len(@currentserver_name)
Select @currentserver_name2		= '\' + @save_servername2
Select @currentserver_name2_len		= len(@currentserver_name2)
Select @currentserver_name3		= '\' + @save_servername3
Select @currentserver_name3_len		= len(@currentserver_name3)
Select @currentserver_name4		= @@servername
Select @currentserver_name4_len		= len(@currentserver_name4)
Select @currentserver_name4b		= @save_servername4b
Select @currentserver_name4b_len	= len(@currentserver_name4b)
Select @currentserver_name5		= @save_servername2
Select @currentserver_name5_len		= len(@currentserver_name5)
Select @currentserver_name6		= @save_servername
Select @currentserver_name6_len		= len(@currentserver_name6)
Select @currentserver_share1		= '\' + @save_servername + '_'
Select @currentserver_share1_len	= len(@currentserver_share1)
Select @currentserver_share2		= '\' + @save_servername2 + '_'
Select @currentserver_share2_len	= len(@currentserver_share2)
Select @command_num			= 0
Select @output_flag			= 'n'

Select @parm01 = @save_servername2 + '_SQLjob_logs'
exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
Select @logpath_len = len(@logpath)


--  Create table variable
declare @jobs table	
			(jjob_id				uniqueidentifier
			,jname					sysname
			,jenabled				tinyint
			,jdescription				nvarchar(512) null
			,jstart_step_id				int
			,jcategory_id				int
			,jnotify_level_eventlog			int
			,jnotify_level_email			int
			,jnotify_level_netsend			int
			,jnotify_level_page			int
			,jnotify_email_operator_id		int
			,jnotify_netsend_operator_id		int
			,jnotify_page_operator_id		int
			,jdelete_level				int
			,jowner_sid				varbinary(85)
			,vserver_id				int
			,cname					sysname
			,category_class				int
			,category_type				tinyint
			)

declare @steps table	
			(tstep_id				int
			,tstep_name				sysname
			,tsubsystem				nvarchar(40)
			,tcommand				nvarchar(max)
			,tflags					int
			,tcmdexec_success_code			int
			,ton_success_action			tinyint
			,ton_success_step_id			int
			,ton_fail_action			tinyint
			,ton_fail_step_id			int
			,tserver				sysname null
			,tdatabase_name				sysname null
			,tdatabase_user_name			sysname null
			,tretry_attempts			int
			,tretry_interval			int
			,tos_run_priority			int
			,toutput_file_name			nvarchar(200) null
			)

declare @schedules table	
			(dschedule_id				int
			,dname					sysname
			,denabled				int
			,dfreq_type				int
			,dfreq_interval				int
			,dfreq_subday_type			int
			,dfreq_subday_interval			int
			,dfreq_relative_interval		int
			,dfreq_recurrence_factor		int
			,dactive_start_date			int
			,dactive_end_date			int
			,dactive_start_time			int
			,dactive_end_time			int
			,dnext_run_date				int
			,dnext_run_time				int
			,ddate_created				datetime
			)
	 


----------------------  Main header  ----------------------
Print  ' '
Print  '/**************************************************************'
Select @miscprint = 'Generated SQL - SYSaddjobs'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  ' '
If @leave_enabled = 'y'
   begin
	Select @miscprint = 'NOTE:  The following SQL jobs were scripted using the input parm'
	Print  @miscprint
	Select @miscprint = '       @leave_enabled = ''y''.'
	Print  @miscprint
   end
Else
   begin
	Select @miscprint = 'NOTE:  By default, jobs are scripted as disabled by'
	Print  @miscprint
	Select @miscprint = '       this process.  To script jobs reflecting the current'
	Print  @miscprint
	Select @miscprint = '       run status of enabled or disabled, use the input parm'
	Print  @miscprint
	Select @miscprint = '       @leave_enabled = ''y'', and re-script the jobs.'
	Print  @miscprint
   end

Print  '**************************************************************/'
Print  'use [msdb]'
Print  'go'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  set cmd syntax ----------------------
If @jobname is null
   begin
	Select @cmd = 'Select j.job_id, j.name, j.enabled, j.description, 
				j.start_step_id, j.category_id, j.notify_level_eventlog, 
				j.notify_level_email, j.notify_level_netsend, j.notify_level_page, 
				j.notify_email_operator_id, j.notify_netsend_operator_id, 
				j.notify_page_operator_id, j.delete_level, j.owner_sid, 
				v.server_id, c.name, c.category_class, c.category_type
				From msdb.dbo.sysjobs  j, msdb.dbo.sysjobservers  v, msdb.dbo.syscategories  c, master.sys.sysservers  m
				Where j.job_id = v.job_id
				and j.category_id = c.category_id
				and j.originating_server_id = m.srvid
				and m.srvname = @@servername'
   end
Else
   begin
	Select @cmd = 'Select j.job_id, j.name, j.enabled, j.description, 
				j.start_step_id, j.category_id, j.notify_level_eventlog, 
				j.notify_level_email, j.notify_level_netsend, j.notify_level_page, 
				j.notify_email_operator_id, j.notify_netsend_operator_id, 
				j.notify_page_operator_id, j.delete_level, j.owner_sid, 
				v.server_id, c.name, c.category_class, c.category_type
				From msdb.dbo.sysjobs  j, msdb.dbo.sysjobservers  v, msdb.dbo.syscategories  c, master.sys.sysservers  m
				Where j.job_id = v.job_id
				and j.category_id = c.category_id
				and j.originating_server_id = m.srvid
				and m.srvname = @@servername
				and j.name like ''' + @jobname + '%'''
   end

delete from @jobs

insert into @jobs (jjob_id
					,jname
					,jenabled
					,jdescription
					,jstart_step_id
					,jcategory_id
					,jnotify_level_eventlog
					,jnotify_level_email
					,jnotify_level_netsend
					,jnotify_level_page
					,jnotify_email_operator_id
					,jnotify_netsend_operator_id
					,jnotify_page_operator_id
					,jdelete_level
					,jowner_sid
					,vserver_id
					,cname
					,category_class
					,category_type)
					exec (@cmd)

delete from @jobs where jname is null or jname = ''
--select * from @jobs

--Checking to see if the application name and/or job name is requested.--
if @appl_name  is not null and @jobname is not null
   begin
	
	if exists (SELECT 1 from msdb.dbo.sysjobs where name = @jobname)
	   begin
		delete from @jobs where jname <> @jobname	
		raiserror('DBA WARNING: --Full Job Name found, ignoring @APPL_Name parameter',-1,-1)
	   end
	else
	   begin
		delete from @jobs where ltrim(jdescription) not like ''+RTRIM(@appl_name)+'%'
	   end
   end   
else if @appl_name  is not null
   begin
	delete from @jobs where ltrim(jdescription) not like ''+RTRIM(@appl_name)+'%'
   end
-------------------------------------------------------------------------------------------------
--  Start the jobs loop here  -------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
If (select count(*) from @jobs) > 0
   begin
	start_jobs:

	Select @cu11jjob_id = (select top 1 jjob_id from @jobs order by jname)
	Select @cu11jname = (select jname from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jenabled = (select jenabled from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jdescription = (select jdescription from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jstart_step_id = (select jstart_step_id from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jcategory_id = (select jcategory_id from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jnotify_level_eventlog = (select jnotify_level_eventlog from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jnotify_level_email = (select jnotify_level_email from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jnotify_level_netsend = (select jnotify_level_netsend from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jnotify_level_page = (select jnotify_level_page from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jnotify_email_operator_id = (select jnotify_email_operator_id from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jnotify_netsend_operator_id = (select jnotify_netsend_operator_id from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jnotify_page_operator_id = (select jnotify_page_operator_id from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jdelete_level = (select jdelete_level from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11jowner_sid = (select jowner_sid from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11vserver_id = (select vserver_id from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11cname = (select cname from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11category_class = (select category_class from @jobs where jjob_id = @cu11jjob_id)
	Select @cu11category_type = (select category_type from @jobs where jjob_id = @cu11jjob_id)



	/***  Hold the job ID in text format ***/ 
	Select @hold_jobid = convert(varchar(200), @cu11jjob_id)


	/***  Fix @cu11jname - single quote problem ***/ 
	Select @startpos = 1
	label14:
		Select @charpos = charindex('''', @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu11jname = stuff(@cu11jname, @charpos, 1, '''''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex('''', @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    goto label14
	 	   end


	/***  Fix @cu11jname - servername problem ***/ 
	Select @startpos = 1
	label14b:
		Select @charpos = charindex(@currentserver_name4, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu11jname = stuff(@cu11jname, @charpos, @currentserver_name4_len, ''' + @@servername + ''')
		    Select @startpos = @charpos + 1
		   end	

		Select @charpos = charindex(@currentserver_name4, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    goto label14b
	 	   end

	Select @startpos = 1
	label14c:
		Select @charpos = charindex(@currentserver_name4b, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu11jname = stuff(@cu11jname, @charpos, @currentserver_name4b_len, ''' + @save_servername4b + ''')
		    Select @startpos = @charpos + 1
		   end	

		Select @charpos = charindex(@currentserver_name4b, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    goto label14c
	 	   end

	Select @startpos = 1
	label14d:
		Select @charpos = charindex(@currentserver_name5, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu11jname = stuff(@cu11jname, @charpos, @currentserver_name5_len, ''' + @save_servername2 + ''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_name5, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    goto label14d
	 	   end


	Select @startpos = 1
	label14e:
		Select @charpos = charindex(@currentserver_name6, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu11jname = stuff(@cu11jname, @charpos, @currentserver_name6_len, ''' + @save_servername + ''')
		    Select @startpos = @charpos + 1
		   end	
	
		Select @charpos = charindex(@currentserver_name6, @cu11jname, @startpos)
		IF @charpos <> 0
		   begin
		    goto label14e
	 	   end




	/***  Fix @cu11jdescription - single quote problem ***/ 
	Select @startpos = 1
	label16:
		Select @charpos = charindex('''', @cu11jdescription, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu11jdescription = stuff(@cu11jdescription, @charpos, 1, '''''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex('''', @cu11jdescription, @startpos)
		IF @charpos <> 0
		   begin
		    goto label16
	 	   end


	/***  Fix @cu11mname - null problem ***/ 
	Select @save_mname = (select top 1 name from master.sys.syslogins where sid = @cu11jowner_sid)
	If @save_mname is null
	   begin
		Select @save_mname = 'sa'
	   end	



	/***  Print Banner ***/ 
	Select @miscprint = '/*************************************************************************************************' 
	Print  @miscprint
	Select @miscprint = 'Create new job: ' + @cu11jname 
	Print  @miscprint
	Select @miscprint = '**************************************************************************************************/' 
	Print  @miscprint


	/***  Print declares and begin tran ***/ 
	Select @miscprint = 'BEGIN TRANSACTION' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @JobID BINARY(16)' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @ReturnCode INT' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @charpos INT' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @miscprint nvarchar(500)' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @save_servername sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @save_servername2 sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @save_servername3 sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @save_servername4b sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @save_output_filename sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @save_jname sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @save_sname sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @parm01 sysname' 
	Print  @miscprint
	Select @miscprint = '  DECLARE @logpath sysname' 
	Print  @miscprint
	Select @miscprint = '  Select  @ReturnCode = 0' 
	Print  @miscprint
	Print  ' '


	/***  Set the servername variables ***/ 
	Select @miscprint = '  -- Set up the servername variables' 
	Print  @miscprint
	Select @miscprint = '  Select @save_servername = @@servername' 
	Print  @miscprint
	Select @miscprint = '  Select @save_servername2 = @@servername' 
	Print  @miscprint
	Select @miscprint = '  Select @save_servername3 = @@servername' 
	Print  @miscprint
	Select @miscprint = '  Select @save_servername4b = @@servername' 
	Print  @miscprint
	Print  ' '

	Select @miscprint = '  Select @charpos = charindex(''\'', @save_servername)' 
	Print  @miscprint
	Select @miscprint = '  IF @charpos <> 0' 
	Print  @miscprint
	Select @miscprint = '     begin' 
	Print  @miscprint
	Select @miscprint = '        Select @save_servername = substring(@@servername, 1, (CHARINDEX(''\'', @@servername)-1))' 
	Print  @miscprint
	Select @miscprint = '        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, ''$'')'
	Print  @miscprint
	Select @miscprint = '        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, ''('')' 
	Print  @miscprint
	Select @miscprint = '        Select @save_servername3 = @save_servername3 + '')''' 
	Print  @miscprint
	Select @miscprint = '        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, ''_'')'
	Print  @miscprint
	Select @miscprint = '     end' 
	Print  @miscprint
	Print  ' '


	/***  Set the SQL job log output file name and path ***/ 
	Select @miscprint = '  -- Set up the output file path variable' 
	Print  @miscprint
	Select @miscprint = '  Select @parm01 = @save_servername2 + ''_SQLjob_logs''' 
	Print  @miscprint
	Select @miscprint = '  If exists(select 1 from master.sys.sysdatabases where name = ''dbaadmin'')' 
	Print  @miscprint
	Select @miscprint = '     begin' 
	Print  @miscprint
	Select @miscprint = '        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output' 
	Print  @miscprint
	Select @miscprint = '     end' 
	Print  @miscprint
	Print  ' '


	/***  Print add catagory name command ***/
	Select @save_cat_class = CASE
								WHEN @cu11category_class = 1 THEN 'Job'
								WHEN @cu11category_class = 2 THEN 'Alert'
								WHEN @cu11category_class = 3 THEN 'Operator'
							    ELSE 'Job'
							  END

	Select @save_cat_type = CASE
								WHEN @cu11category_type = 1 THEN 'Local'
								WHEN @cu11category_type = 2 THEN 'Multiserver'
								WHEN @cu11category_type = 3 THEN 'None'
							    ELSE 'Local'
							  END
 
	Select @miscprint = '  -- Verify the proper category exists' 
	Print  @miscprint
	Select @miscprint = '  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'''+ @cu11cname + ''' AND category_class=' + convert(varchar(10), @cu11category_class) + ')' 
	Print  @miscprint
	Select @miscprint = '     begin' 
	Print  @miscprint
	Select @miscprint = '        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N''' + @save_cat_class + ''', @type=N''' + @save_cat_type + ''', @name=N''' + @cu11cname + '''' 
	Print  @miscprint
	Select @miscprint = '        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback' 
	Print  @miscprint
	Select @miscprint = '     end' 
	Print  @miscprint
	Print  ' '


	/***  Print check and delete old job ***/ 
  	Select @miscprint = '  -- Delete the job with the same name (if it exists)' 
	Print  @miscprint
	Select @miscprint = '  Select @JobID = job_id' 
	Print  @miscprint
	Select @miscprint = '  from   msdb.dbo.sysjobs'
	Print  @miscprint
	Select @miscprint = '  where (name = N''' + @cu11jname + ''')'
	Print  @miscprint
	Select @miscprint = '  If (@JobID is not null)'
	Print  @miscprint
	Select @miscprint = '     begin'
	Print  @miscprint
	Select @miscprint = '        -- Check if the job is a multi-server job'
	Print  @miscprint
	Select @miscprint = '        IF (exists (Select * From msdb.dbo.sysjobservers'
	Print  @miscprint
	Select @miscprint = '                    Where (job_id = @JobID) and (server_id <> 0)))'
	Print  @miscprint
	Select @miscprint = '           begin'
	Print  @miscprint
	Select @miscprint = '              -- This is a mult server job, so abort the script'
	Print  @miscprint
	Select @miscprint = '              Select @miscprint = ''Unable to delete job ''''' + @cu11jname + ''''' since there is already a multi-server job with this name.'''
	Print  @miscprint
	Select @miscprint = '              RAISERROR (@miscprint, 16, 1)'
	Print  @miscprint
	Select @miscprint = '              GOTO QuitWithRollback'
	Print  @miscprint
	Select @miscprint = '           end'
	Print  @miscprint
	Select @miscprint = '        Else'
	Print  @miscprint
	Select @miscprint = '           begin'
	Print  @miscprint
	Select @miscprint = '              -- Delete the [local] job'
	Print  @miscprint
	Select @miscprint = '              Select @miscprint = N'''+ @cu11jname + ''''
	Print  @miscprint
	Select @miscprint = '              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint'
	Print  @miscprint
	Select @miscprint = '              Select @JobID = null'
	Print  @miscprint
	Select @miscprint = '           end'
	Print  @miscprint
	Select @miscprint = '     end'
	Print  @miscprint
	Print  ' '


	/***  Print add job command ***/ 
	Select @miscprint = '  -- Add the job' 
	Print  @miscprint
	Select @miscprint = '  Select @save_jname = N'''+ @cu11jname + ''''
	Print  @miscprint
	Select @miscprint = '  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT' 
	Print  @miscprint
	Select @miscprint = '                                           ,@job_name = @save_jname' 
	Print  @miscprint
	Select @miscprint = '                                           ,@owner_login_name = N''' + @save_mname + '''' 
	Print  @miscprint
	Select @miscprint = '                                           ,@description = N''' + @cu11jdescription + '''' 
	Print  @miscprint
	Select @miscprint = '                                           ,@category_name = N''' + @cu11cname + '''' 
	Print  @miscprint
	If @leave_enabled = 'n'
	   begin
		Select @miscprint = '                                           ,@enabled = 0' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = '                                           ,@enabled = ' + convert(varchar(10),@cu11jenabled) 
		Print  @miscprint
	   end
	Select @miscprint = '                                           ,@notify_level_email = ' + convert(varchar(10),@cu11jnotify_level_email) 
	Print  @miscprint
	Select @miscprint = '                                           ,@notify_level_page = ' + convert(varchar(10),@cu11jnotify_level_page) 
	Print  @miscprint
	Select @miscprint = '                                           ,@notify_level_netsend = ' + convert(varchar(10),@cu11jnotify_level_netsend) 
	Print  @miscprint
	Select @miscprint = '                                           ,@notify_level_eventlog = ' + convert(varchar(10),@cu11jnotify_level_eventlog) 
	Print  @miscprint
	Select @miscprint = '                                           ,@delete_level= ' + convert(varchar(10),@cu11jdelete_level) 
	Print  @miscprint
	Select @miscprint = '  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback' 
	Print  @miscprint
	Print  ' '



	/***  Start Job step processing ***/ 
	Select @cmd = 'Select t.step_id, t.step_name, t.subsystem, t.command, t.flags, t.cmdexec_success_code, t.on_success_action, t.on_success_step_id, t.on_fail_action, 
		t.on_fail_step_id, t.server, t.database_name, t.database_user_name, t.retry_attempts, t.retry_interval, t.os_run_priority, t.output_file_name
	   From msdb.dbo.sysjobsteps  t ' + 
	  'Where t.job_id = ''' + @hold_jobid + ''''

	delete from @steps

	insert into @steps (tstep_id,
						tstep_name,
						tsubsystem,
						tcommand,
						tflags,
						tcmdexec_success_code,
						ton_success_action,
						ton_success_step_id,
						ton_fail_action,
						ton_fail_step_id,
						tserver,
						tdatabase_name,
						tdatabase_user_name, 
						tretry_attempts, 
						tretry_interval,
						tos_run_priority,
						toutput_file_name)
					exec (@cmd)

	delete from @steps where tstep_id is null
	--select * from @steps

	-------------------------------------------------------------------------------------------------
	--  Start the steps loop here  -------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------
	If (select count(*) from @steps) > 0
	   begin
		start_steps:

		Select @cu22tstep_id = (select top 1 tstep_id from @steps order by tstep_id)
		Select @cu22tstep_name = (select tstep_name from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tsubsystem = (select tsubsystem from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tcommand = (select tcommand from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tflags = (select tflags from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tcmdexec_success_code = (select tcmdexec_success_code from @steps where tstep_id = @cu22tstep_id)
		Select @cu22ton_success_action = (select ton_success_action from @steps where tstep_id = @cu22tstep_id)
		Select @cu22ton_success_step_id = (select ton_success_step_id from @steps where tstep_id = @cu22tstep_id)
		Select @cu22ton_fail_action = (select ton_fail_action from @steps where tstep_id = @cu22tstep_id)
		Select @cu22ton_fail_step_id = (select ton_fail_step_id from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tserver = (select tserver from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tdatabase_name = (select tdatabase_name from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tdatabase_user_name = (select tdatabase_user_name from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tretry_attempts = (select tretry_attempts from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tretry_interval = (select tretry_interval from @steps where tstep_id = @cu22tstep_id)
		Select @cu22tos_run_priority = (select tos_run_priority from @steps where tstep_id = @cu22tstep_id)
		Select @cu22toutput_file_name = (select toutput_file_name from @steps where tstep_id = @cu22tstep_id)
		Select @outprint01 = ''
			

		/***  Fix @cu22tcommand - single quote problem ***/ 
		Select @startpos = 1
		label01:
		Select @charpos = charindex('''', @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, 1, '''''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex('''', @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label01
	 	   end


		/***  Fix @cu22tcommand - PlanID problem.  This will convert PlanID references to PlanName references ***/ 
		Select @startpos = 1
		Select @charpos = charindex('PlanID', @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @saveplanid = substring(@cu22tcommand, @charpos + 7, 36)
		    Select @saveplanname = (Select plan_name from msdb.dbo.sysdbmaintplans where plan_id = @saveplanid)
		    Select @cmd_planname = 'PlanName ' + @saveplanname 
		    Select @charpos02 = charindex(' -', @cu22tcommand, @charpos + 1)
		    Select @charpos_diff = (@charpos02 - @charpos)
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @charpos_diff, @cmd_planname)
		   end	


		/***  Fix @cu22tcommand - hard coded servername problem ***/ 
		-- fix \\servername
		Select @startpos = 1
		label02:
		Select @charpos = charindex(@currentserver_name, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_name_len, '\\'' + @save_servername + ''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_name, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label02
	 	   end

		--  fix \sharenames that are sql instance specific
		Select @startpos = 1
		label03:
		Select @charpos = charindex(@currentserver_share2, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share2_len, '\'' + @save_servername2 + ''_')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share2, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label03
	 	   end

		--  fix \sharenames that must be sql instance specific at the target (backup)
		select @currentserver_share_spcl = '\' + @save_servername + '_backup'
		Select @currentserver_share_spcl_len = len(@currentserver_share_spcl)

		Select @startpos = 1
		label20:
		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share_spcl_len, '\'' + @save_servername2 + ''_backup')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label20
	 	   end


		--  fix \sharenames that must be sql instance specific at the target (dbasql)
		select @currentserver_share_spcl = '\' + @save_servername + '_dbasql'
		Select @currentserver_share_spcl_len = len(@currentserver_share_spcl)

		Select @startpos = 1
		label21:
		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share_spcl_len, '\'' + @save_servername2 + ''_dbasql')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label21
	 	   end


		--  fix \sharenames that must be sql instance specific at the target (dba_archive)
		select @currentserver_share_spcl = '\' + @save_servername + '_dba_archive'
		Select @currentserver_share_spcl_len = len(@currentserver_share_spcl)

		Select @startpos = 1
		label22:
		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share_spcl_len, '\'' + @save_servername2 + ''_dba_archive')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label22
	 	   end


		--  fix \sharenames that must be sql instance specific at the target (log)
		select @currentserver_share_spcl = '\' + @save_servername + '_log'
		Select @currentserver_share_spcl_len = len(@currentserver_share_spcl)

		Select @startpos = 1
		label23:
		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share_spcl_len, '\'' + @save_servername2 + ''_log')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label23
	 	   end


		--  fix \sharenames that must be sql instance specific at the target (mdf)
		select @currentserver_share_spcl = '\' + @save_servername + '_mdf'
		Select @currentserver_share_spcl_len = len(@currentserver_share_spcl)

		Select @startpos = 1
		label24:
		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share_spcl_len, '\'' + @save_servername2 + ''_mdf')	
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label24
	 	   end


		--  fix \sharenames that must be sql instance specific at the target (ldf)
		select @currentserver_share_spcl = '\' + @save_servername + '_ldf'
		Select @currentserver_share_spcl_len = len(@currentserver_share_spcl)

		Select @startpos = 1
		label25:
		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share_spcl_len, '\'' + @save_servername2 + ''_ldf')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label25
	 	   end


		--  fix \sharenames that must be sql instance specific at the target (SQLjob_logs)
		select @currentserver_share_spcl = '\' + @save_servername + '_SQLjob_logs'
		Select @currentserver_share_spcl_len = len(@currentserver_share_spcl)

		Select @startpos = 1
		label26:
		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share_spcl_len, '\'' + @save_servername2 + ''_SQLjob_logs')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share_spcl, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label26
	 	   end


		--  fix \sharenames that are non-sql instance specific (server centric)
		Select @startpos = 1
		label04:
		Select @charpos = charindex(@currentserver_share1, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_share1_len, '\'' + @save_servername + ''_')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_share1, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label04
	 	   end


		--  fix file names that are sql instance specific using ()
		Select @startpos = 1
		label05:
		Select @charpos = charindex(@currentserver_name3, @cu22tcommand, @startpos)	
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_name3_len, '\'' + @save_servername3 + ''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_name3, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label05
	 	   end


		--  fix sharenames that are sql instance specific and do not have leading back slash or following underscore
		Select @startpos = 1
		label06:
		Select @charpos = charindex(@currentserver_name5, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_name5_len, ''' + @save_servername2 + ''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_name5, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label06
	 	   end


		--  fix remaining local servernames
		Select @startpos = 1
		label07:
		Select @charpos = charindex(@currentserver_name4, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_name4_len, ''' + @@servername + ''')
		    Select @startpos = @charpos + 1
		   end	

		Select @charpos = charindex(@currentserver_name4, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label07
	 	   end

		Select @startpos = 1
		label07b:
		Select @charpos = charindex(@currentserver_name4b, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_name4b_len, ''' + @save_servername4b + ''')
		    Select @startpos = @charpos + 1
		   end	

		Select @charpos = charindex(@currentserver_name4b, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label07b
	 	   end

		Select @startpos = 1
		label07a:
		Select @charpos = charindex(@currentserver_name6, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tcommand = stuff(@cu22tcommand, @charpos, @currentserver_name6_len, ''' + @save_servername + ''')
		    Select @startpos = @charpos + 1
		   end	
	
		Select @charpos = charindex(@currentserver_name6, @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
		    goto label07a
	 	   end

		/***  Fix @cu22tcommand - multiple go problem (103,111) ***/ 
		Select @startpos = 1
		Select @charpos = charindex(char(103) + char(111), @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
			Select @startpos = 1
			label31:
			Select @charpos = charindex(char(10) + char(103) + char(111) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(103) + char(111)+ char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label31
		 	   end

			Select @startpos = 1
			label32:
			Select @charpos = charindex(char(10) + char(103) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(103) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label32
		 	   end

			Select @startpos = 1
			label33:
			Select @charpos = charindex(char(32) + char(103) + char(111) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(103) + char(111) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label33
		 	   end

			Select @startpos = 1
			label34:
			Select @charpos = charindex(char(32) + char(103) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(103) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label34
		 	   end

		   end


		/***  Fix @cu22tcommand - multiple go problem (71,79) ***/ 
		Select @startpos = 1
		Select @charpos = charindex(char(71) + char(79), @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
			Select @startpos = 1
			label41:
			Select @charpos = charindex(char(10) + char(71) + char(79) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(71) + char(79)+ char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label41
	 		   end

			Select @startpos = 1
			label42:
			Select @charpos = charindex(char(10) + char(71) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(71) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label42
		 	   end

			Select @startpos = 1
			label43:
			Select @charpos = charindex(char(32) + char(71) + char(79) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(71) + char(79) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label43
		 	   end

			Select @startpos = 1
			label44:
			Select @charpos = charindex(char(32) + char(71) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(71) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label44
		 	   end

		   end



		/***  Fix @cu22tcommand - multiple go problem (103,79) ***/ 
		Select @startpos = 1
		Select @charpos = charindex(char(103) + char(79), @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
			Select @startpos = 1
			label51:
			Select @charpos = charindex(char(10) + char(103) + char(79) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(103) + char(79)+ char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label51
		 	   end

			Select @startpos = 1
			label52:
			Select @charpos = charindex(char(10) + char(103) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(103) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label52
		 	   end

			Select @startpos = 1
			label53:
			Select @charpos = charindex(char(32) + char(103) + char(79) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(103) + char(79) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label53
		 	   end

			Select @startpos = 1
			label54:
			Select @charpos = charindex(char(32) + char(103) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(103) + char(79) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(103) + char(79) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label54
		 	   end

		   end


		/***  Fix @cu22tcommand - multiple go problem (71,111) ***/ 
		Select @startpos = 1
		Select @charpos = charindex(char(71) + char(111), @cu22tcommand, @startpos)
		IF @charpos <> 0
		   begin
			Select @startpos = 1
			label61:
			Select @charpos = charindex(char(10) + char(71) + char(111) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(71) + char(111)+ char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label61
		 	   end

			Select @startpos = 1
			label62:
			Select @charpos = charindex(char(10) + char(71) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(10) + char(71) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label62
		 	   end

			Select @startpos = 1
			label63:
			Select @charpos = charindex(char(32) + char(71) + char(111) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(71) + char(111) + char(13), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label63
		 	   end

			Select @startpos = 1
			label64:
			Select @charpos = charindex(char(32) + char(71) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
				Select @cu22tcommand = stuff(@cu22tcommand, @charpos+1, 2, ''' + char(71) + char(111) + ''')
				Select @startpos = @charpos + 3
			   end	

			Select @charpos = charindex(char(32) + char(71) + char(111) + char(32), @cu22tcommand, @startpos)
			IF @charpos <> 0
			   begin
			    goto label64
		 	   end

		   end


		/***  Fix @cu22tstep_name - single quote problem ***/ 
		Select @startpos = 1
		label65:
		Select @charpos = charindex('''', @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tstep_name = stuff(@cu22tstep_name, @charpos, 1, '''''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex('''', @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    goto label65
	 	   end


		/***  Fix @cu22tstep_name - servername problem ***/ 
		Select @startpos = 1
		label65b:
		Select @charpos = charindex(@currentserver_name4, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tstep_name = stuff(@cu22tstep_name, @charpos, @currentserver_name4_len, ''' + @@servername + ''')
		    Select @startpos = @charpos + 1
		   end	

		Select @charpos = charindex(@currentserver_name4, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    goto label65b
	 	   end

		Select @startpos = 1
		label65c:
		Select @charpos = charindex(@currentserver_name4b, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tstep_name = stuff(@cu22tstep_name, @charpos, @currentserver_name4b_len, ''' + @save_servername4b + ''')
		    Select @startpos = @charpos + 1
		   end	

		Select @charpos = charindex(@currentserver_name4b, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    goto label65c
	 	   end

		Select @startpos = 1
		label65d:
		Select @charpos = charindex(@currentserver_name5, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tstep_name = stuff(@cu22tstep_name, @charpos, @currentserver_name5_len, ''' + @save_servername2 + ''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex(@currentserver_name5, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    goto label65d
	 	   end

		Select @startpos = 1
		label65e:
		Select @charpos = charindex(@currentserver_name6, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu22tstep_name = stuff(@cu22tstep_name, @charpos, @currentserver_name6_len, ''' + @save_servername + ''')
		    Select @startpos = @charpos + 1
		   end	
	
		Select @charpos = charindex(@currentserver_name6, @cu22tstep_name, @startpos)
		IF @charpos <> 0
		   begin
		    goto label65e
	 	   end



		/***  Header for job step Preparation ***/ 
		Print  ' '
		Select @miscprint = '  -- Preparation for job step ' + convert(varchar(10),@cu22tstep_id) 
		Print  @miscprint
		Print  ' '



		/***  Fix @cu22toutput_file_name - job output file path (use the standard share 'servername_sqljob_logs') ***/ 
		Select @miscprint = '  -- Move the output file name and path to a variable' 
		Print  @miscprint

		If @cu22toutput_file_name is not null
		   begin
			Select @charpos = charindex(@logpath, @cu22toutput_file_name)
			IF @charpos <> 0
			   begin
				Select @cu22toutput_file_name = substring(@cu22toutput_file_name, @logpath_len+ 1, 200)
				Select @miscprint = '  If @logpath is not null' 
				Print  @miscprint
				Select @miscprint = '     begin' 
				Print  @miscprint
				Select @miscprint = '        Select @save_output_filename = @logpath + ''' + @cu22toutput_file_name + '''' 
				Print  @miscprint
				Select @miscprint = '     end' 
				Print  @miscprint
				Select @miscprint = '  Else' 
				Print  @miscprint
				Select @miscprint = '     begin' 
				Print  @miscprint
				Select @miscprint = '        Select @save_output_filename = ''c:' + @cu22toutput_file_name + '''' 
				Print  @miscprint
				Select @miscprint = '     end' 
				Print  @miscprint
				Print ' '
			   end
			Else
			   begin
				Select @miscprint = '  Select @save_output_filename = ''' + @cu22toutput_file_name + '''' 
				Print  @miscprint
				Print ' '
			   end
		   end
		Else
		   begin
			Select @miscprint = '  Select @save_output_filename = ''''' 
			Print  @miscprint
			Print ' '
		   end



		/***  Print the process to save the command to a variable (needed to get the servername correct). ***/ 
		Select @miscprint = '  -- Move the command syntax for this job step to a variable' 
		Print  @miscprint
		Select @command_num  = @command_num + 1 
		Select @command_name = '@command_vrb' + convert(varchar(05), @command_num)
		Select @miscprint = '  Declare ' + @command_name + '  NVARCHAR(MAX)' 
		Print  @miscprint
		Select @miscprint = '  Select ' + @command_name + ' = ''''' 
		Print  @miscprint

		--  Fix CR's with out line feeds
		Select @pos = 1
		Label90:
		Select @charpos = charindex(char(13), @cu22tcommand, @pos)
		IF @charpos <> 0
		   begin
			Select @pos = @charpos
			If substring(@cu22tcommand, @charpos+1, 1) <> char(10)
			   begin
				select @cu22tcommand = stuff(@cu22tcommand, @charpos, 1, char(13)+char(10))
				Select @pos = @pos + 1
			   end
		   end

		Select @pos = @pos + 1
		Select @charpos = charindex(char(13), @cu22tcommand, @pos)
		IF @charpos <> 0
		   begin
			goto label90
		   end

		--  Fix line feeds with no preceeding CR
		Select @pos = 1
		Label91:
		Select @charpos = charindex(char(10), @cu22tcommand, @pos)
		IF @charpos <> 0
		   begin
			Select @pos = @charpos
			If substring(@cu22tcommand, @charpos-1, 1) <> char(13)
			   begin
				select @cu22tcommand = stuff(@cu22tcommand, @charpos, 1, char(13)+char(10))
				Select @pos = @pos + 1
			   end
		   end

		Select @pos = @pos + 1
		Select @charpos = charindex(char(10), @cu22tcommand, @pos)
		IF @charpos <> 0
		   begin
			goto label91
		   end



		--  Split output into 3000 byte chunks, because print cannot handle more than 4000 at a time.
	    	--Select @miscprint = '  Select  ' + @command_name + ' = ' + @command_name + ''''
		--Print  @miscprint

		Start_chunk:
		If len(@cu22tcommand) < 4000
		   begin
			Select @outprint01 = @cu22tcommand

	    		Select @miscprint = '  Select  ' + @command_name + ' = ' + @command_name + ' + ''' + @outprint01 + ''''
			Print  @miscprint

			goto end_chunks
		   end


		Select @pos = 3000
		Select @charpos = charindex(char(10), @cu22tcommand, @pos)
		IF @charpos <> 0
		   begin
			select @outprint01 = left(@cu22tcommand, @charpos)
			select @cu22tcommand = substring(@cu22tcommand, @charpos+1, len(@cu22tcommand)-@charpos)

	    		Select @miscprint = '  Select  ' + @command_name + ' = ' + @command_name + ' + ''' + @outprint01 + ''''
			Print  @miscprint
		   end


		If len(@cu22tcommand) > 0
		   begin
			goto Start_chunk
		   end


		end_chunks:

		Print  ' '


		/***  Now print the add job step command. ***/ 
		Select @miscprint = '  -- Add job step ' + convert(varchar(10),@cu22tstep_id) 
		Print  @miscprint
		Select @miscprint = '  Select @save_sname = N'''+ @cu22tstep_name + ''''
		Print  @miscprint
		Select @miscprint = '  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID' 
		Print  @miscprint
		Select @miscprint = '                                               ,@step_id = ' + convert(varchar(10),@cu22tstep_id) 
		Print  @miscprint
		Select @miscprint = '                                               ,@step_name = @save_sname' 
		Print  @miscprint
		Select @miscprint = '                                               ,@command = ' + @command_name 
		Print  @miscprint

		If @cu22tdatabase_name is null
		   begin
			Select @miscprint = '                                               ,@database_name = N'''''
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '                                               ,@database_name = N''' + @cu22tdatabase_name + ''''
			Print  @miscprint
		   end

		If @cu22tserver is null
		   begin
			Select @miscprint = '                                               ,@server = N''''' 
			Print  @miscprint
		   end
		Else If @cu22tserver = @@servername
		   begin
			Select @miscprint = '                                               ,@server = @@servername' 
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '                                               ,@server = N''' + @cu22tserver + '''' 
			Print  @miscprint
		   end

		If @cu22tdatabase_user_name is null
		   begin
			Select @miscprint = '                                               ,@database_user_name = N'''''
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '                                               ,@database_user_name = N''' + @cu22tdatabase_user_name + ''''
			Print  @miscprint
		   end

		Select @miscprint = '                                               ,@subsystem = N''' + @cu22tsubsystem + ''''
		Print  @miscprint
		Select @miscprint = '                                               ,@cmdexec_success_code = ' + convert(varchar(10),@cu22tcmdexec_success_code)
		Print  @miscprint
		Select @miscprint = '                                               ,@flags = ' + convert(varchar(10),@cu22tflags)
		Print  @miscprint
		Select @miscprint = '                                               ,@retry_attempts = ' + convert(varchar(10),@cu22tretry_attempts) 
		Print  @miscprint
		Select @miscprint = '                                               ,@retry_interval = ' + convert(varchar(10),@cu22tretry_interval) 
		Print  @miscprint
		Select @miscprint = '                                               ,@os_run_priority = ' + convert(varchar(10),@cu22tos_run_priority) 
		Print  @miscprint


		If @cu22toutput_file_name is null
		   begin
			Select @miscprint = '                                               ,@output_file_name = N'''''
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '                                               ,@output_file_name = @save_output_filename'
			Print  @miscprint
		   end

		Select @miscprint = '                                               ,@on_success_step_id = ' + convert(varchar(10),@cu22ton_success_step_id) 
		Print  @miscprint
		Select @miscprint = '                                               ,@on_success_action = ' + convert(varchar(10),@cu22ton_success_action) 
		Print  @miscprint
		Select @miscprint = '                                               ,@on_fail_step_id = ' + convert(varchar(10),@cu22ton_fail_step_id) 
		Print  @miscprint
		Select @miscprint = '                                               ,@on_fail_action = ' + convert(varchar(10),@cu22ton_fail_action) 
		Print  @miscprint
		Select @miscprint = '  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback' 
		Print  @miscprint
		Print  ' ' 



		--  check for more steps to process
		delete from @steps where tstep_id = @cu22tstep_id
		If (select count(*) from @steps) > 0
		   begin
			goto start_steps
		   end


	   end





	/***  Start Job schedule processing ***/ 
	Select @cmd = 'Select d.schedule_id, d.name, d.enabled, d.freq_type, d.freq_interval, 
				d.freq_subday_type, d.freq_subday_interval, d.freq_relative_interval, 
				d.freq_recurrence_factor, d.active_start_date, d.active_end_date, 
				d.active_start_time, d.active_end_time, js.next_run_date, js.next_run_time, d.date_created
		From msdb.dbo.sysjobschedules  js, msdb.dbo.sysschedules  d
		where js.schedule_id = d.schedule_id
		  and js.job_id = ''' + @hold_jobid + ''''

	delete from @schedules

	insert into @schedules (dschedule_id
						,dname
						,denabled
						,dfreq_type
						,dfreq_interval
						,dfreq_subday_type
						,dfreq_subday_interval
						,dfreq_relative_interval
						,dfreq_recurrence_factor
						,dactive_start_date
						,dactive_end_date
						,dactive_start_time
						,dactive_end_time
						,dnext_run_date
						,dnext_run_time
						,ddate_created)
					exec (@cmd)

	delete from @schedules where dschedule_id is null
	--select * from @schedules

	-------------------------------------------------------------------------------------------------
	--  Start the @schedules loop here  -------------------------------------------------------------------
	-------------------------------------------------------------------------------------------------
	If (select count(*) from @schedules) > 0
	   begin
		start_@schedules:

		Select @cu33dschedule_id = (select top 1 dschedule_id from @schedules order by dschedule_id)
		Select @cu33dname = (select dname from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33denabled = (select denabled from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dfreq_type = (select dfreq_type from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dfreq_interval = (select dfreq_interval from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dfreq_subday_type = (select dfreq_subday_type from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dfreq_subday_interval = (select dfreq_subday_interval from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dfreq_relative_interval = (select dfreq_relative_interval from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dfreq_recurrence_factor = (select dfreq_recurrence_factor from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dactive_start_date = (select dactive_start_date from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dactive_end_date = (select dactive_end_date from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dactive_start_time = (select dactive_start_time from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dactive_end_time = (select dactive_end_time from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dnext_run_date = (select dnext_run_date from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33dnext_run_time = (select dnext_run_time from @schedules where dschedule_id = @cu33dschedule_id)
		Select @cu33ddate_created = (select ddate_created from @schedules where dschedule_id = @cu33dschedule_id)


		/***  Fix @cu33dname - single quote problem ***/ 
		Select @startpos = 1
		label08:
		Select @charpos = charindex('''', @cu33dname, @startpos)
		IF @charpos <> 0
		   begin
		    Select @cu33dname = stuff(@cu33dname, @charpos, 1, '''''')
		    Select @startpos = @charpos + 2
		   end	

		Select @charpos = charindex('''', @cu33dname, @startpos)
		IF @charpos <> 0
		   begin
			goto label08
	 	   end


		/***  Print add job schedule command ***/ 
		If @cu33dschedule_id is not null
		   begin
			Select @miscprint = '  -- Add the job schedules' 
			Print  @miscprint
			Select @miscprint = '  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID' 
			Print  @miscprint
			Select @miscprint = '                                                   ,@name = N''' + @cu33dname + '''' 
			Print  @miscprint
			Select @miscprint = '                                                   ,@enabled = ' + convert(varchar(10),@cu33denabled) 
			Print  @miscprint		
			Select @miscprint = '                                                   ,@freq_type = ' + convert(varchar(10),@cu33dfreq_type) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@active_start_date = ' + convert(varchar(10),@cu33dactive_start_date) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@active_start_time = ' + convert(varchar(10),@cu33dactive_start_time) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@freq_interval = ' + convert(varchar(10),@cu33dfreq_interval) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@freq_subday_type = ' + convert(varchar(10),@cu33dfreq_subday_type) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@freq_subday_interval = ' + convert(varchar(10),@cu33dfreq_subday_interval) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@freq_relative_interval = ' + convert(varchar(10),@cu33dfreq_relative_interval)	
			Print  @miscprint
			Select @miscprint = '                                                   ,@freq_recurrence_factor = ' + convert(varchar(10),@cu33dfreq_recurrence_factor) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@active_end_date = ' + convert(varchar(10),@cu33dactive_end_date) 
			Print  @miscprint
			Select @miscprint = '                                                   ,@active_end_time = ' + convert(varchar(10),@cu33dactive_end_time) 
			Print  @miscprint
			Select @miscprint = '  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback' 
			Print  @miscprint
			Print  ' '
		   end 


		--  check for more schedules to process
		delete from @schedules where dschedule_id = @cu33dschedule_id
		If (select count(*) from @schedules) > 0
		   begin
			goto start_@schedules
		   end

	   end


		/***  Print update job command ***/ 
		Select @miscprint = '  -- Update the job start step' 
		Print  @miscprint
		Select @miscprint = '  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = ' + convert(varchar(10),@cu11jstart_step_id) 
		Print  @miscprint
		Select @miscprint = '  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback' 
		Print  @miscprint
		Print  ' '


		/***  Print add job server command ***/ 
		Select @miscprint = '  -- Add the Target Servers' 
		Print  @miscprint
		If @cu11vserver_id = 0
		   begin
			Select @miscprint = '  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N''(local)'''
			Print  @miscprint
		   end
		Else
		   begin
			Select @saveserver_name = (Select srvname from master.sys.sysservers where srvid = @cu11vserver_id)  
			Select @miscprint = '  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N''' + @saveserver_name + ''''
			Print  @miscprint
		   end
		Select @miscprint = '  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback' 
		Print  @miscprint
		Print  ' '


		/***  Print Update Production Job Status Info command ***/ 
		Select @miscprint = '  -- Update Production Job Status Info' 
		Print  @miscprint
		Select @miscprint = '  IF exists(select * from master.sys.sysdatabases where name = ''DEPLinfo'')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = ''ProdJobStatus'')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = ''' + @cu11jname + ''')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = ' + convert(varchar(10),@cu11jenabled) + ' where JobName = ''' + @cu11jname + '''
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values (''' + + @cu11jname + ''', ' + convert(varchar(10),@cu11jenabled) + ')
		     end
	     end
     end
'
		Print  @miscprint
		Print  ''


		/***  Print the commit transaction commands ***/ 
		Select @miscprint = 'COMMIT TRANSACTION' 
		Print  @miscprint
		Select @miscprint = 'GOTO   EndSave' 
		Print  @miscprint
		Select @miscprint = 'QuitWithRollback:' 
		Print  @miscprint
		Select @miscprint = '  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION ' 
		Print  @miscprint
		Select @miscprint = 'EndSave:' 
		Print  @miscprint
		Select @miscprint = 'GO' 
		Print  @miscprint
		Print  ' '

		Select @output_flag	= 'y' 




	--  Check for more jobs to process
	delete from @jobs where jjob_id = @cu11jjob_id
	If (select count(*) from @jobs) > 0
	   begin
		goto start_jobs
	   end


   end

---------------------------  Finalization  -----------------------



If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSaddlinkedservers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSaddlinkedservers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSaddlinkedservers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_SYSaddlinkedservers

/**************************************************************
 **  Stored Procedure dbasp_SYSaddlinkedservers                  
 **  Written by Jim Wilson, Getty Images                
 **  April 24, 2001                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add linked servers and linked logons  
 **        
 **  Output member is SYSaddlinkedservers.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	05/06/2002	Jim Wilson		Removed unused 'sa' select sid code.
--	06/14/2002	Jim Wilson		Complete re-write.  Passwords not handeled.
--	06/20/2002	Jim Wilson		Added code for status 96, found in 7.0 cluster.
--	12/16/2002	Jim Wilson		Only linked servers will be included in this
--						output via 'isremote = 1'.
--	12/27/2002	Jim Wilson		Disabled processing for SQL 7.0
--	05/11/2006	Jim Wilson		Modified for SQL 2005.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint				varchar(255)
	,@G_O					varchar (2)
	,@output_flag			char(1)
	,@cur_text				varchar(2000)
	,@save_local_loginname	sysname

DECLARE
	 @cu11srvname				sysname
	,@cu11srvid					smallint
	,@cu11srvstatus				int
	,@cu11srvproduct			nvarchar(128)
	,@cu11providername			nvarchar(128)
	,@cu11datasource			nvarchar(4000)
	,@cu11location				nvarchar(4000)
	,@cu11providerstring		nvarchar(4000)
	,@cu11catalog				sysname
	,@cu11connecttimeout		int
	,@cu11querytimeout			int
	,@cu11rpc					bit
	,@cu11pub					bit
	,@cu11sub					bit
	,@cu11dist					bit
	,@cu11rpcout				bit
	,@cu11dataaccess			bit
	,@cu11collationcompatible	bit	
	,@cu11useremotecollation	bit
	,@cu11lazyschemavalidation	bit
	,@cu11collation				sysname

DECLARE
	 @cu22server_id				int
	,@cu22local_principal_id	int
	,@cu22uses_self_credential	bit
	,@cu22remote_name			sysname



----------------  initial values  -------------------

Select @G_O				= 'g' + 'o'
Select @output_flag		= 'n'



/*********************************************************************
 *                Initialization
 ********************************************************************/


----------------------  Main header  ----------------------

Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSaddlinkedserver'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/

	
----------------------  Print the headers  ----------------------

   Print  '/*********************************************************'
   Select @miscprint = 'ADD LINKED SERVERS ' 
   Print  @miscprint
   Print  ' '
   Select @miscprint = 'NOTE:  You may need to modify the some of the following'
   Print  @miscprint
   Select @miscprint = '       commands prior to execution (i.e. @rmtpassword).'
   Print  @miscprint
   Print  '*********************************************************/'
   Print  ' '

   Select @miscprint = 'USE master'
   Print  @miscprint  
   Print  @G_O
   Print  ' '
  
--------------------  Cursor 11  -----------------------

EXECUTE('DECLARE cursor_11 Insensitive Cursor For ' + 
  'SELECT s.srvname, s.srvid, s.srvstatus, s.srvproduct, s.providername, s.datasource, s.location, s.providerstring, 
			s.catalog, s.connecttimeout, s.querytimeout, s.rpc, s.pub, s.sub, s.dist, s.rpcout, 
			s.dataaccess, s.collationcompatible, s.useremotecollation, s.lazyschemavalidation, s.collation
   From master.sys.sysservers   s ' + 
  'Where s.srvid > 0
     and s.isremote = 0
   Order By s.srvname For Read Only')

OPEN cursor_11

WHILE (11=11)
   Begin
	FETCH Next From cursor_11 Into @cu11srvname, @cu11srvid, @cu11srvstatus, @cu11srvproduct, @cu11providername, 
									@cu11datasource, @cu11location, @cu11providerstring, @cu11catalog, @cu11connecttimeout, @cu11querytimeout, 
									@cu11rpc, @cu11pub, @cu11sub, @cu11dist, @cu11rpcout, @cu11dataaccess, 
									@cu11collationcompatible, @cu11useremotecollation, @cu11lazyschemavalidation, @cu11collation
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11
	      BREAK
           end


	--  Header Info
	Print  ' '
	Select @miscprint = '-------------------------------------------------------' 
	Print  @miscprint
	Select @miscprint = '--  Add Linked Server ''' + @cu11srvname + '''' 
	Print  @miscprint
	Select @miscprint = '-------------------------------------------------------' 
	Print  @miscprint


	--  Add Linked server commands
	Select @miscprint = 'EXEC sp_addlinkedserver @server = ''' + @cu11srvname + '''' 
	Print  @miscprint

	Select @miscprint = '                       ,@srvproduct = ''' + @cu11srvproduct + '''' 
	Print  @miscprint
	
	If @cu11srvproduct <> 'SQL Server'
	   begin
		Select @miscprint = '                       ,@provider = ''' + @cu11providername + '''' 
		Print  @miscprint
		Select @miscprint = '                       ,@datasrc = ''' + @cu11datasource + '''' 
		Print  @miscprint
	   end

	If @cu11location is not null and @cu11srvproduct <> 'SQL Server'
	   begin
		Select @miscprint = '                       ,@location = ''' + @cu11location + '''' 
		Print  @miscprint
	   end

	If @cu11providerstring is not null and @cu11srvproduct <> 'SQL Server'
	   begin
		Select @miscprint = '                       ,@provstr = ''' + @cu11providerstring + '''' 
		Print  @miscprint
	   end

	If @cu11catalog is not null and @cu11srvproduct <> 'SQL Server'
	   begin
		Select @miscprint = '                       ,@catalog = ''' + @cu11catalog + '''' 
		Print  @miscprint
	   end


	Print  @G_O
	Print  ' '



	--  Add sp_serveroption commands
	If @cu11collationcompatible = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''collation compatible'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''collation compatible'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	If @cu11dataaccess = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''data access'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''data access'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	If @cu11dist = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''dist'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''dist'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	If @cu11pub = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''pub'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''pub'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	If @cu11rpc = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''rpc'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''rpc'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	If @cu11rpcout = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''rpc out'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''rpc out'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	If @cu11sub = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''sub'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''sub'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''connect timeout'', @optvalue=N''' + convert(nvarchar(10), @cu11connecttimeout) + '''' 
	Print  @miscprint
	Print  @G_O
	Print  ' '

	Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''query timeout'', @optvalue=N''' + convert(nvarchar(10), @cu11querytimeout) + '''' 
	Print  @miscprint
	Print  @G_O
	Print  ' '

	If @cu11collation is null
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''collation name'', @optvalue=null' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''collation name'', @optvalue=N''' + rtrim(@cu11collation) + '''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '

	If @cu11lazyschemavalidation = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''lazy schema validation'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''lazy schema validation'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '


	If @cu11useremotecollation = 0
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''use remote collation'', @optvalue=N''false''' 
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'EXEC master.sys.sp_serveroption @server=N''' + @cu11srvname + ''', @optname=N''use remote collation'', @optvalue=N''true''' 
		Print  @miscprint
	   end

	Print  @G_O
	Print  ' '



	--  Add Linked server logins for this linked server
	Print  ' '
	Select @miscprint = '--  Add Linked Server Logins for ''' + @cu11srvname + '''' 
	Print  @miscprint

	If not exists (select 1 from master.sys.linked_logins where server_id = @cu11srvid)
	   begin
	        Select @miscprint = 'EXEC master.sys.sp_droplinkedsrvlogin @rmtsrvname = ''' + @cu11srvname + ''', @locallogin=null' 
	        Print  @miscprint
		Print  @G_O
		Print  ' '
	   end	
	Else
	   begin
		Select @cur_text = 'DECLARE cursor_22 Insensitive Cursor For ' + 
		  'SELECT s.server_id, s.local_principal_id, s.uses_self_credential, s.remote_name
		   From master.sys.linked_logins  s ' + 
		  'Where s.server_id = ' + convert(varchar(10), @cu11srvid) + '
		   Order By s.local_principal_id For Read Only'

		EXECUTE(@cur_text)

		OPEN cursor_22

		WHILE (22=22)
		   Begin
			FETCH Next From cursor_22 Into @cu22server_id, @cu22local_principal_id, @cu22uses_self_credential, @cu22remote_name
			IF (@@fetch_status < 0)
		        begin
					CLOSE cursor_22
					BREAK
		        end



			If @cu22uses_self_credential = 0 and @cu22local_principal_id = 0 and @cu22remote_name is null
			   begin
				Select @miscprint = 'EXEC master.sys.sp_addlinkedsrvlogin @rmtsrvname = ''' + @cu11srvname + ''', @useself = ''false''' 
				Print  @miscprint
				Print  @G_O
				Print  ' '
			   end	  	

			If @cu22uses_self_credential = 1 and @cu22local_principal_id = 0 and @cu22remote_name is null
			   begin
				Select @miscprint = 'EXEC master.sys.sp_addlinkedsrvlogin @rmtsrvname = ''' + @cu11srvname + ''', @useself = ''true''' 
				Print  @miscprint
				Print  @G_O
				Print  ' '
			   end	  	

			If @cu22uses_self_credential = 0 and @cu22local_principal_id = 0 and @cu22remote_name is not null
			   begin
				Print  ' '
				Select @miscprint = '-- NOTE:  Update @rmtpassword in the following command before you execute it!' 
				Print  @miscprint
				Select @miscprint = 'EXEC master.sys.sp_addlinkedsrvlogin @rmtsrvname = ''' + @cu11srvname + ''', @useself = ''false'', @rmtuser = ''' + @cu22remote_name + ''',  @rmtpassword = ''xyz''' 
				Print  @miscprint
				Print  @G_O
				Print  ' '
			   end	  	


			If @cu22local_principal_id > 0 and @cu22uses_self_credential = 1
			   begin
				Select @save_local_loginname = name from master.sys.server_principals where principal_id = @cu22local_principal_id 
				Select @miscprint = 'EXEC master.sys.sp_addlinkedsrvlogin @rmtsrvname = ''' + @cu11srvname + ''', @locallogin = ''' + rtrim(@save_local_loginname) + ''', @useself = ''true''' 
				Print  @miscprint
				Print  @G_O
				Print  ' '
			   end	  	


			If @cu22local_principal_id > 0 and @cu22uses_self_credential = 0
			   begin
				Print  ' '
				Select @miscprint = '-- NOTE:  Update @rmtpassword in the following command before you execute it!' 
				Print  @miscprint
				Select @save_local_loginname = name from master.sys.server_principals where principal_id = @cu22local_principal_id 
				Select @miscprint = 'EXEC master.sys.sp_addlinkedsrvlogin @rmtsrvname = ''' + @cu11srvname + ''', @locallogin = ''' + rtrim(@save_local_loginname) + ''', @useself = ''false'', @rmtuser = ''' + @cu22remote_name + ''',  @rmtpassword = ''xyz''' 
				Print  @miscprint
				Print  @G_O
				Print  ' '
			   end	  	


		  End  -- loop 22

		DEALLOCATE cursor_22
	   end



	Print  ' '
	Select @output_flag	= 'y' 
            
 
   End  -- loop 11

DEALLOCATE cursor_11

---------------------------  Finalization  -----------------------

label99:


If @output_flag = 'n'
   begin
	Select @miscprint = '-- No linked server to configure '
	Print  @miscprint
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSaddmasterlogins
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSaddmasterlogins]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSaddmasterlogins]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_SYSaddmasterlogins

/**************************************************************
 **  Stored Procedure dbasp_SYSaddmasterlogins                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add logins  
 **        
 **  Output member is SYSaddmasterlogins.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	10/22/2002	Jim Wilson		Now using isntgroup and isntuser
--	03/20/2006	Jim Wilson		Modified for SQL 2005.
--	11/08/2006	Jim Wilson		Added code for trusted logins.
--	04/16/2008	Jim Wilson		Added check expiration and check policy.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(2000)
	,@G_O			nvarchar(2)
	,@DFLTdatabase		nvarchar(30)
	,@VCHARpassword		nvarchar(256)
	,@VCHARsid		nvarchar(128)
	,@pwlen			int
	,@pwpos			int
	,@i			int
	,@length		int
	,@binvalue		varbinary(256)
	,@hexstring		nchar(16)
	,@savename		sysname
	,@output_flag		char(1)
	,@tempint		int
	,@firstint		int
	,@secondint		int
     
DECLARE
	 @cu11Lname		sysname
	,@cu11Lpassword		sysname
	,@cu11Lsid		varbinary(85)
	,@cu11Lstatus		smallint
	,@cu11Ldbname		sysname
	,@cu11Llanguage		sysname	
	,@cu11isntgroup		int
	,@cu11isntuser		int	

DECLARE
	 @cu12Lname		sysname
	,@cu12Lpassword		sysname
	,@cu12Lsid		varbinary(85)
	,@cu12Lstatus		smallint
	,@cu12Ldbname		sysname
	,@cu12Llanguage		sysname	
	,@cu12isntgroup		int
	,@cu12isntuser		int	

----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @savename 	= ' '
Select @output_flag	= 'n'

/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/*****************************************************************************'
Select @miscprint = 'Generated SQL - SYSaddmasterlogins'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '*****************************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/
	
----------------------  Print the headers  ----------------------
Print  '/***********************************************'
Select @miscprint = 'ADD SQL LOGINS for master ' 
Print  @miscprint
Print  '***********************************************/'
Print  ' '
Select @miscprint = 'USE master'
Print  @miscprint  
Print  @G_O
Print  ' '
   

--------------------  Cursor 11  -----------------------

EXECUTE('DECLARE cursor_11 Insensitive Cursor For ' + 
  'SELECT y.name, y.password, y.sid, y.status, y.dbname, y.language, y.isntgroup, y.isntuser
   From  master.sys.syslogins  y ' + 
  'Where y.hasaccess = 1
     And y.name not in (''probe'',''sa'',''repl_publisher'',''repl_subscriber'')
     And y.name not like ''##%''
     And y.name not like ''%BUILTIN\Administrators%''
     And y.name not like ''%AUTHORITY\SYSTEM%''
     And y.name not like ''%MSSQLSERVER%''
     And y.isntgroup = 0
     And y.isntuser = 0
   Order By y.name For Read Only')


--------------------  start cursor processing  -----------------------

OPEN cursor_11

WHILE (11=11)
   Begin
	FETCH Next From cursor_11 Into @cu11Lname, @cu11Lpassword, @cu11Lsid, @cu11Lstatus, @cu11Ldbname, @cu11Llanguage, @cu11isntgroup, @cu11isntuser
		IF (@@fetch_status < 0)
		   begin
			CLOSE cursor_11
			BREAK
		   end


--------------------  convert the password to unicode values  -----------------------
--print @cu11Lpassword
select @pwlen = len(@cu11Lpassword)
Select @pwpos = 1
Select @VCHARpassword = ''

If @pwpos <= @pwlen
   begin
	start_pw_revision:

	Select @VCHARpassword = @VCHARpassword + 'nchar(' + convert(varchar(10), unicode(Substring(@cu11Lpassword,@pwpos,1))) + ') + '

	Select @pwpos = @pwpos + 1

	If @pwpos <= @pwlen
	   begin
		goto start_pw_revision
	   end
   end


--------------------  convert the sid from varbinary to varchar  -----------------------
select @VCHARsid = '0x'
select @i = 1
select @binvalue = @cu11Lsid
select @length = datalength(@binvalue)
select @hexstring = '0123456789ABCDEF'

while (@i <= @length)
   begin
	select @tempint = convert(int, substring(@binvalue,@i,1))
	select @firstint = floor(@tempint/16)
	select @secondint = @tempint - (@firstint*16)
 
	select @VCHARsid = @VCHARsid + substring(@hexstring, @firstint+1, 1) + substring(@hexstring, @secondint+1, 1)
	select @i = @i + 1
   end

--------------------  set the default database  -----------------------

	SELECT @DFLTdatabase = @cu11Ldbname


--------------------  Format the output  -----------------------
	If @cu11Lname <> @savename 
	   begin
		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint
		Select @miscprint = '-- Create login ''' + @cu11Lname + '''' 
		Print  @miscprint
		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint

		--  If this is being run on a sql2005 server, add logic to make sure the result script is used on a sql2005 server.
		If ( 0 <> ( SELECT PATINDEX( '%[9].[00]%', @@version ) ) )
		   begin
			Select @miscprint = 'If ( 0 = ( SELECT PATINDEX( ''%[9].[00]%'', @@version ) ) )'
			Print  @miscprint
			Select @miscprint = '   Begin' 
			Print  @miscprint
			Select @miscprint = '      Print ''ERROR:  Unable to create login ''''' + @cu11Lname + ''''' to this server.  This login was scripted from a SQL 9.00 environment.'''
			Print  @miscprint
			Select @miscprint = '   End' 
			Print  @miscprint
			Select @miscprint = 'Else' 
			Print  @miscprint
		   end

		Select @miscprint = 'If not exists (select * from master.sys.syslogins where name = N''' + @cu11Lname + ''')' 
		Print  @miscprint
		Select @miscprint = '   Begin' 
		Print  @miscprint
		Select @miscprint = '      Declare @cmd nvarchar(3000)'
		Print  @miscprint
		Select @miscprint = '      '
		Print  @miscprint
		Select @miscprint = '      select @cmd = ''CREATE LOGIN ' + @cu11Lname
		Print  @miscprint

		Select @miscprint = '             WITH PASSWORD = '''''' + '

		Select @miscprint = @miscprint + @VCHARpassword

		Select @miscprint = @miscprint + ''''''' HASHED'
		Print  @miscprint

		Select @miscprint = '                                 ,DEFAULT_DATABASE = [' + @DFLTdatabase + ']' 
		Print  @miscprint

		IF @cu11Llanguage is not null
		   begin
			Select @miscprint = '                                 ,DEFAULT_LANGUAGE = ' + @cu11Llanguage 
			Print  @miscprint
		   end

		If (select is_policy_checked from master.sys.sql_logins where name = @cu11Lname) = 1
		   begin
			Select @miscprint = '                                 ,CHECK_POLICY = ON'
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '                                 ,CHECK_POLICY = OFF'
			Print  @miscprint
		   end

		If (select is_expiration_checked from master.sys.sql_logins where name = @cu11Lname) = 1
		   begin
			Select @miscprint = '                                 ,CHECK_EXPIRATION = ON'
			Print  @miscprint
		   end
		Else
		 begin
			Select @miscprint = '                                 ,CHECK_EXPIRATION = OFF'
			Print  @miscprint
		   end

		Select @miscprint = '                                 ,SID = ' + @VCHARsid + ''''
		Print  @miscprint
		Select @miscprint = '        Print @cmd'
		Print  @miscprint
		Select @miscprint = '        Exec (@cmd)'
		Print  @miscprint
		Select @miscprint = '   End' 
		Print  @miscprint
		Select @miscprint = 'Else' 
		Print  @miscprint
		Select @miscprint = '   Begin' 
		Print  @miscprint
		Select @miscprint = '      Print ''Note:  Login ''''' + @cu11Lname + ''''' already exists on this server.'''
		Print  @miscprint
		Select @miscprint = '   End' 
		Print  @miscprint
		Print  @G_O
		Print  ' '
	   end

	select @savename = @cu11Lname

	Select @output_flag	= 'y' 

   End  -- loop 11
   DEALLOCATE cursor_11



----------------------  Print the headers  ----------------------
Print  ' '
Print  ' '
Print  ' '
Print  '/***********************************************'
Select @miscprint = 'ADD NT LOGINS for master ' 
Print  @miscprint
Print  '***********************************************/'
Print  ' '
Select @miscprint = 'USE master'
Print  @miscprint  
Print  @G_O
Print  ' '
   

--------------------  Cursor 12  -----------------------

EXECUTE('DECLARE cursor_12 Insensitive Cursor For ' + 
  'SELECT y.name, y.password, y.sid, y.status, y.dbname, y.language, y.isntgroup, y.isntuser
   From  master.sys.syslogins  y ' + 
  'Where y.hasaccess = 1
     And y.name not in (''probe'',''sa'',''repl_publisher'',''repl_subscriber'')
     And y.name not like ''##%''
     And y.name not like ''%BUILTIN\Administrators%''
     And y.name not like ''%AUTHORITY\SYSTEM%''
     And y.name not like ''%MSSQLSERVER%''
     And (y.isntgroup <> 0 or y.isntuser <> 0)
   Order By y.name For Read Only')


--------------------  start cursor processing  -----------------------

OPEN cursor_12

WHILE (12=12)
   Begin
	FETCH Next From cursor_12 Into @cu12Lname, @cu12Lpassword, @cu12Lsid, @cu12Lstatus, @cu12Ldbname, @cu12Llanguage, @cu12isntgroup, @cu12isntuser
		IF (@@fetch_status < 0)
		   begin
			CLOSE cursor_12
			BREAK
		   end



--------------------  set the default database  -----------------------

	SELECT @DFLTdatabase = @cu12Ldbname


--------------------  Format the output  -----------------------
	If @cu12Lname <> @savename 
	   begin
		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint
		Select @miscprint = '-- Create login ''' + @cu12Lname + '''' 
		Print  @miscprint
		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint

		--  If this is being run on a sql2005 server, add logic to make sure the result script is used on a sql2005 server.
		If ( 0 <> ( SELECT PATINDEX( '%[9].[00]%', @@version ) ) )
		   begin
			Select @miscprint = 'If ( 0 = ( SELECT PATINDEX( ''%[9].[00]%'', @@version ) ) )'
			Print  @miscprint
			Select @miscprint = '   Begin' 
			Print  @miscprint
			Select @miscprint = '      Print ''ERROR:  Unable to create login ''''' + @cu12Lname + ''''' to this server.  This login was scripted from a SQL 9.00 environment.'''
			Print  @miscprint
			Select @miscprint = '   End' 
			Print  @miscprint
			Select @miscprint = 'Else' 
			Print  @miscprint
		   end

		If @cu12isntgroup <> 0 or @cu12isntuser <> 0
		   begin
			Select @miscprint = 'If not exists (select * from master.sys.syslogins where name = N''' + @cu12Lname + ''')' 
			Print  @miscprint
			Select @miscprint = '   Begin' 
			Print  @miscprint
			Select @miscprint = '      Print ''Add NT Login ''''' + @cu12Lname + ''''''''
			Print  @miscprint
			Select @miscprint = '      CREATE LOGIN [' + @cu12Lname + '] FROM WINDOWS'
			Print  @miscprint
			Select @miscprint = '             WITH DEFAULT_DATABASE = [' + @DFLTdatabase + ']' 
			Print  @miscprint
			IF @cu12Llanguage is not null
			   begin
				Select @miscprint = '                 ,DEFAULT_LANGUAGE = ' + @cu12Llanguage 
				Print  @miscprint
			   end

			Select @miscprint = '   End' 
			Print  @miscprint
			Select @miscprint = 'Else' 
			Print  @miscprint
			Select @miscprint = '   Begin' 
			Print  @miscprint
			Select @miscprint = '      Print ''Note:  Login ''''' + @cu12Lname + ''''' already exists on this server.'''
			Print  @miscprint
			Select @miscprint = '   End' 
			Print  @miscprint
			Print  @G_O
			Print  ' '
		   end
	   end

	select @savename = @cu12Lname

	Select @output_flag	= 'y' 

   End  -- loop 12
   DEALLOCATE cursor_12


---------------------------  Finalization  -----------------------

If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSaddsrvrolemembers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSaddsrvrolemembers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSaddsrvrolemembers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE dbo.dbasp_SYSaddsrvrolemembers

/*********************************************************
 **  Stored Procedure dbasp_SYSaddsrvrolemembers                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add server role members  
 **        
 **  Output member is SYSaddsrvrolemembers.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	03/10/2008	Jim Wilson		Updated for SQL2005.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@G_O			nvarchar(2)
	,@output_flag		char(1)
      
DECLARE
	 @cu11SPVname		nvarchar(128)
	,@cu11LGNname		nvarchar(128)
	,@cu11LGNsid		varbinary(85)

----------------  initial values  -------------------
Select @G_O		= 'g' + 'o'
Select @output_flag	= 'n'


/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------

Print  ' '
Print  '/*******************************************************************'
Select @miscprint = 'Generated SQL - SYSaddsrvrolemembers'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/
	
----------------------  Print the headers  ----------------------

   Print  ' '
   Print  '/*********************************************************'
   Select @miscprint = 'Add Server Role Members for server: ' + @@servername 
   Print  @miscprint
   Print  '*********************************************************/'
   Print  ' '
   Select @miscprint = 'USE master'
   Print  @miscprint  
   Print  @G_O
   Print  ' '
   
--------------------  Cursor 11  -----------------------

EXECUTE('DECLARE cursor_11 Insensitive Cursor For ' + 
  'SELECT SUSER_NAME(rm.role_principal_id), lgn.name, lgn.sid
   From master.sys.server_role_members rm, master.sys.server_principals lgn ' + 
  'Where rm.role_principal_id >=3 
	and rm.role_principal_id <=10 
	and rm.member_principal_id = lgn.principal_id
	and lgn.name not like ''%Administrators%''
	and lgn.name not like ''%NT AUTHORITY%''
	and lgn.name <> ''sa''
   Order By lgn.name For Read Only')


--------------------  start cursor processing  -----------------------

OPEN cursor_11

WHILE (11=11)
   Begin
	FETCH Next From cursor_11 Into @cu11SPVname, @cu11LGNname, @cu11LGNsid
           IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11
	      BREAK
           end

--------------------  Format the output  -----------------------

	Select @miscprint = 'exec sp_addsrvrolemember ''' + @cu11LGNname + ''', ''' + @cu11SPVname + ''';'  
        Print  @miscprint
	Print  @G_O
	Print  ' '

	Select @output_flag	= 'y' 

   End  -- loop 11

---------------------------  Finalization  -----------------------
   DEALLOCATE cursor_11

If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSaddsysdbrolemembers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSaddsysdbrolemembers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSaddsysdbrolemembers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO




CREATE PROCEDURE dbo.dbasp_SYSaddsysdbrolemembers

/*********************************************************
 **  Stored Procedure dbasp_SYSaddsysdbrolemembers                  
 **  Written by Jim Wilson, Getty Images                
 **  October 16, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add system database role member  
 **        
 **  Output member is SYSaddsysdbrolemembers.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	06/11/2002	Jim Wilson		Added brackets around DB name in use stmt.
--	05/23/2006	Jim Wilson		Updated for SQL 2005.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar(255)
	,@G_O				nvarchar(2)
	,@filegrowth		nvarchar(20)
	,@saverolename		sysname
	,@output_flag		char(1)
	,@output_flag2		char(1)

DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu22Urole			sysname
	,@cu22Uname			sysname

----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @saverolename	= ''
Select @output_flag	= 'n'
Select @output_flag2	= 'n'

/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------


Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSaddsysdbrolemembers'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '

--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.sysdatabases   d ' + 
  'Where d.name in (''master'', ''model'', ''msdb'', ''tempdb'')
   Order By d.dbid For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Print the headers  ----------------------

   Print  ' '
   Print  '/*******************************************************************'
   Select @miscprint = 'Add System Database Role Members for server: ' + @@servername  
   Print  @miscprint
   Print  '*******************************************************************/'
   Print  ' '

   
OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	
 
----------------------  Print the headers  ----------------------

   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'Add Role Members for Database: ' + @cu11DBName  
   Print  @miscprint
   Print  '***********************************************/'
   Select @miscprint = 'USE [' + @cu11DBName + ']'
   Print  @miscprint  
   Print  @G_O
   Print  ' ' 
  

--------------------  Cursor for 22DB  -----------------------

EXECUTE('DECLARE cu22_DBRole Insensitive Cursor For ' + 
  'SELECT r.name, u.name
   From [' + @cu11DBName + '].sys.sysusers  u, [' + @cu11DBName + '].sys.sysusers  r, [' + @cu11DBName + '].sys.sysmembers  m ' + 
  'Where u.uid > 3
     and u.uid = m.memberuid
     and m.groupuid = r.uid
   Order By r.name, u.uid For Read Only')

OPEN cu22_DBRole

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBRole Into @cu22Urole, @cu22Uname 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_DBRole
	      BREAK
           end

	IF @cu22Urole <> @saverolename
	   begin
		Print ''
		Select @miscprint = '/*****  Add for Role ''' + @cu22Urole + '''  *****/'
		Print  @miscprint
		Print ''
		Select @saverolename = @cu22Urole
	   end
	 
	Select @miscprint = 'sp_addrolemember ''' + @cu22Urole + ''', '''  + @cu22Uname + ''''
	Print  @miscprint
	Print  @G_O
	Print  ' '

	Select @output_flag	= 'y' 


   End  -- loop 22
   DEALLOCATE cu22_DBRole

If @output_flag = 'n'
   begin
	Select @miscprint = '-- No output for database: ' + @cu11DBName
	Print  @miscprint
	Print  ' ' 
   end
Else
   begin
	Select @output_flag = 'n' 
   end
        

Select @output_flag2 = 'y' 


 End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cu11_DBNames

If @output_flag2 = 'n'
   begin
	Print '-- No output for this script.'
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSaddsysmessages
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSaddsysmessages]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSaddsysmessages]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_SYSaddsysmessages

/*********************************************************
 **  Stored Procedure dbasp_SYSaddsysmessages                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add system messages  
 **        
 **  Output member is SYSaddsysmessages.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/26/2006	Jim Wilson		Change double quotes to single quotes for message.
--	11/09/2006	Jim Wilson		Modified for SQL 2005
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@G_O			nvarchar(2)
	,@output_flag		char(1)
	,@startpos		int
	,@charpos		int
	,@save_log		nvarchar(10)

DECLARE
	 @cu11Mmessage_id	nvarchar(10)
	,@cu11Mlanguage_id	nvarchar(50)
	,@cu11Mseverity		nvarchar(10)
	,@cu11Mis_event_logged	bit
	,@cu11Mtext		nvarchar(2048)

----------------  initial values  -------------------
Select @G_O	= 'g' + 'o'
Select @output_flag	= 'n'
     
/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/*******************************************************************'
Select @miscprint = 'Generated SQL - SYSaddsysmessages'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/

	
----------------------  Print the headers  ----------------------

   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'ADD MESSAGES for master ' 
   Print  @miscprint
   Print  '***********************************************/'
   Print  ' '
   Select @miscprint = 'USE master'
   Print  @miscprint  
   Print  @G_O
   Print  ' '


--------------------  Cursor 11  -----------------------

EXECUTE('DECLARE cursor_11 Insensitive Cursor For ' + 
  'SELECT convert(varchar(10),m.message_id), convert(sysname,l.name), convert(varchar(10),m.severity), m.is_event_logged, convert(varchar(255),m.text)
   From master.sys.messages  m , master.sys.syslanguages  l ' + 
  'Where m.message_id > 49999
     and m.language_id = l.lcid
   Order By m.message_id For Read Only')


OPEN cursor_11

WHILE (11=11)
   Begin
	FETCH Next From cursor_11 Into @cu11Mmessage_id, @cu11Mlanguage_id, @cu11Mseverity, @cu11Mis_event_logged, @cu11Mtext
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11
	      BREAK
           end


	--  Fix single quote problem in @cu11name
	Select @startpos = 1
	label01:
	select @charpos = charindex('''', @cu11Mtext, @startpos)
	IF @charpos <> 0
	   begin
		select @cu11Mtext = stuff(@cu11Mtext, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @cu11Mtext, @startpos)
	IF @charpos <> 0
	   begin
		goto label01
	   end	

	IF @cu11Mis_event_logged = 1
	   begin
		select @save_log = 'True'
	   end
	Else
	   begin
		select @save_log = 'False'
	   end


	Print  ' '
	Select @miscprint = 'exec sp_addmessage @msgnum = ' +@cu11Mmessage_id 
	Print  @miscprint
	Select @miscprint = '                  ,@severity = ' +@cu11Mseverity 
	Print  @miscprint
	Select @miscprint = '                  ,@lang = ''' +@cu11Mlanguage_id+ '''' 
	Print  @miscprint
	Select @miscprint = '                  ,@msgtext = N''' +@cu11Mtext+ '''' 
	Print  @miscprint
	Select @miscprint = '                  ,@with_log = ''' +@save_log+ '''' 
	Print  @miscprint
	Select @miscprint = '                  ,@replace = ''replace''' 
	Print  @miscprint
	Print  @G_O


	Select @output_flag	= 'y' 
 
   End  -- loop 11

---------------------------  Finalization  -----------------------
   DEALLOCATE cursor_11

If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSattach_userDBs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSattach_userDBs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSattach_userDBs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SYSattach_userDBs

/**************************************************************
 **  Stored Procedure dbasp_SYSattach_userDBs                  
 **  Written by Jim Wilson, Getty Images                
 **  June 10, 2002                                      
 **  
 **  This dbasp is set up to create a script that will
 **  attach all user database files.
 ** 
 **  Output member is SYSattach_userDBs.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	06/10/2002	Jim Wilson		Created
--	06/21/2002	Jim Wilson		Removed bracket formatting for database name.
--	04/27/2007	Jim Wilson		sql 2005 - added logical names and filegroup names to output.
--	09/24/2008	Jim Wilson		Added brackets for filegroup.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@fileseed		smallint
	,@cmd			nvarchar(500)
	,@first_flag		nchar(1)
	,@save_groupid		smallint
	,@save_groupname	sysname

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint

DECLARE
	 @cu12fileid		smallint
	,@cu12name		nvarchar(128)
	,@cu12filename		nvarchar(260)
	,@cu12groupid		smallint



----------------  initial values  -------------------

--  Create table variable
declare @dbnames table	
			(name		sysname
			,dbid		smallint
			)

declare @filenames table	
			(fileid		smallint
			,name		sysname
			,filename	nvarchar(260)
			,groupid	smallint
			)

declare @groupname table (name		sysname)



/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/**************************************************************'
Select @miscprint = 'Generated SQL - SYSattach_userDBs'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '**************************************************************/'
Print  ' '


Select @cmd = 'SELECT d.name, d.dbid
   From master.sys.sysdatabases   d ' + 
  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

delete from @DBnames

insert into @DBnames (name, dbid) exec (@cmd)

delete from @DBnames where name is null or name = ''
--select * from @DBnames


If (select count(*) from @DBnames) > 0
   begin
	start_dbnames:

	Select @cu11DBId = (select top 1 dbid from @DBnames order by dbid)
	Select @cu11DBName = (select name from @DBnames where dbid = @cu11DBId)
	
 
	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'Attach files for Database: ' + @cu11DBName  
	Print  @miscprint
	Print  ' '
	Print  '*********************************************************/'
	Print  'Use [master] ' 
	Print  'go ' 
	Print  ' ' 
 

	Select @miscprint = 'CREATE DATABASE ' + quotename(@cu11DBName , '[') 
	Print  @miscprint
	

	--  Now get the file names and paths
	Select @cmd = 'SELECT f.fileid, f.name, f.filename, f.groupid
	   From [' + @cu11DBName + '].sys.sysfiles f where groupid <> 0'

	delete from @filenames
	insert into @filenames (fileid, name, filename, groupid) exec (@cmd)
	delete from @filenames where name is null or name = ''
	--select * from @filenames

	If (select count(*) from @filenames) > 0
	   begin
		Select @first_flag = 'y'

		start_filenames:

		Select @cu12fileid = (select top 1 fileid from @filenames order by fileid)
		Select @cu12name = (select name from @filenames where fileid = @cu12fileid)
		Select @cu12filename = (select filename from @filenames where fileid = @cu12fileid)
		Select @cu12groupid = (select groupid from @filenames where fileid = @cu12fileid)


		If @first_flag = 'y'
		   begin
			Select @cmd = 'SELECT groupname From [' + @cu11DBName + '].sys.sysfilegroups where groupid = ' + convert(nvarchar(10), @cu12groupid)
			delete from @groupname
			insert into @groupname (name) exec (@cmd)
			delete from @groupname where name is null or name = ''
			--select * from @groupname
			Select @save_groupname = (select name from @groupname)

			Select @miscprint = 'ON ' +  @save_groupname
			Print  @miscprint
			Select @miscprint = '    (NAME = ' + @cu12name + ', FILENAME = ''' + @cu12filename + ''')'
			Print  @miscprint
			Select @save_groupid = @cu12groupid
			Select @first_flag = 'n'
		   end
		Else If @save_groupid <> @cu12groupid
		   begin
			Select @cmd = 'SELECT groupname From [' + @cu11DBName + '].sys.sysfilegroups where groupid = ' + convert(nvarchar(10), @cu12groupid)
			delete from @groupname
			insert into @groupname (name) exec (@cmd)
			delete from @groupname where name is null or name = ''
			--select * from @groupname
			Select @save_groupname = (select name from @groupname)

			Select @miscprint = ',FILEGROUP [' +  @save_groupname + ']'
			Print  @miscprint
			Select @miscprint = '    (NAME = ' + @cu12name + ', FILENAME = ''' + @cu12filename + ''')'
			Print  @miscprint
			Select @save_groupid = @cu12groupid
		   end
		Else
		   begin
			Select @miscprint = '   ,(NAME = ' + @cu12name + ', FILENAME = ''' + @cu12filename + ''')'
			Print  @miscprint
			Select @save_groupid = @cu12groupid
		   end


		--  Check for more file rows to process
		Delete from @filenames where fileid = @cu12fileid
		If (select count(*) from @filenames) > 0
		   begin
			goto start_filenames
		  end


	   end

	--  Now check to see if there are any full-text catalogs associated with this database
	Select @cmd = 'SELECT f.ftcatid, f.name, f.path
	   From [' + @cu11DBName + '].sys.sysfulltextcatalogs  f '

	delete from @filenames

	insert into @filenames (fileid, name, filename) exec (@cmd)

	delete from @filenames where name is null or name = ''
	--select * from @filenames

	If (select count(*) from @filenames) > 0
	   begin
		start_ftnames:

		Select @cu12fileid = (select top 1 fileid from @filenames order by fileid)
		Select @cu12name = (select name from @filenames where fileid = @cu12fileid)
		Select @cu12filename = (select filename from @filenames where fileid = @cu12fileid)

		Select @miscprint = '   ,(FILENAME = ''' + @cu12filename + ''') -- This is a full-text catalog file'  
		Print  @miscprint


		--  Check for more ft rows to process
		Delete from @filenames where fileid = @cu12fileid
		If (select count(*) from @filenames) > 0
		   begin
			goto start_ftnames
		  end


	   end


	--  Now get the LOG file names and paths
	Select @cmd = 'SELECT f.fileid, f.name, f.filename, f.groupid
	   From [' + @cu11DBName + '].sys.sysfiles f where groupid = 0'

	delete from @filenames
	insert into @filenames (fileid, name, filename, groupid) exec (@cmd)
	delete from @filenames where name is null or name = ''
	--select * from @filenames

	If (select count(*) from @filenames) > 0
	   begin
		Select @first_flag = 'y'

		start_logfilenames:

		Select @cu12fileid = (select top 1 fileid from @filenames order by fileid)
		Select @cu12name = (select name from @filenames where fileid = @cu12fileid)
		Select @cu12filename = (select filename from @filenames where fileid = @cu12fileid)

		If @first_flag = 'y'
		   begin
			Select @miscprint = 'LOG ON'
			Print  @miscprint
			Select @miscprint = '    (NAME = ' + @cu12name + ', FILENAME = ''' + @cu12filename + ''')'
			Print  @miscprint
			Select @first_flag = 'n'
		   end
		Else
		   begin
			Select @miscprint = '   ,(NAME = ' + @cu12name + ', FILENAME = ''' + @cu12filename + ''')'
			Select @save_groupid = @cu12groupid
		   end


		--  Check for more file rows to process
		Delete from @filenames where fileid = @cu12fileid
		If (select count(*) from @filenames) > 0
		   begin
			goto start_logfilenames
		  end


	   end


	Print  'FOR ATTACH;'
	Print  'go'
	Print  ' '
	Print  ' '


	--  Check for more rows to process
	Delete from @DBnames where dbid = @cu11DBId
	If (select count(*) from @DBnames) > 0
	   begin
		goto start_dbnames
	  end



   end

---------------------------  Finalization  ----------------------- 




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSbase_archive
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSbase_archive]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSbase_archive]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SYSbase_archive 
 
/***************************************************************
 **  Stored Procedure dbasp_SYSbase_archive                 
 **  Written by Jim Wilson, Getty Images                
 **  August 31, 2009                                      
 **
 **  This proc will archive all the local baseline folders and 
 **  related SQL files in a folder under the backup share.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	==============================================
--	08/31/2009	Jim Wilson		New process
--	======================================================================================

/***

--***/



Declare	
	 @miscprint		nvarchar(500) 
	,@BkUpPath		nvarchar(500)
	,@save_sharepath	nvarchar(500)
	,@save_sharename	sysname
	,@save_foldername	sysname
	,@cmd			nvarchar(2000)
	,@parm01		nvarchar(100)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@charpos		int
	,@fileexist_path	nvarchar(255)



----------------  initial values  -------------------

Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end


--  Creat temp tables
Create table #ShareTempTable1(path nvarchar(500) null)

Create table #fileexists ( 
		doesexist smallint,
		fileindir smallint,
		direxist smallint)



--  set the backup path
Select @parm01 = @save_servername2 + '_backup'
exec dbaadmin.dbo.dbasp_get_share_path @parm01, @BkUpPath output




/****************************************************************
 *                MainLine
 ***************************************************************/

--  Develope a list of shares on the local server
Select @cmd = 'net share'

--print @cmd /* for debugging */
Insert into #ShareTempTable1 
exec master.sys.xp_cmdshell @cmd

delete from #ShareTempTable1 where path not like '%_BASE_%'
delete from #ShareTempTable1 where path is null
--select * from #ShareTempTable1 /* for debugging */


If (select count(*) from #ShareTempTable1) > 0
   begin
	--  check to see if the BASE_archive folder exists (create it if needed)
	Delete from #fileexists
	Select @fileexist_path = @BkUpPath  + '\BASE_archive'
	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) <> 1
	   begin
		Select @cmd = 'mkdir "' + @BkUpPath + '\BASE_archive"'
		Print 'Creating BASE_archive folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 
	   end

	--  set @BkUpPath
	Select @BkUpPath = @BkUpPath + '\BASE_archive'


	start01:
	Select @save_sharename = (select top 1 path from #ShareTempTable1)

	--  Get drive letter path to this share
	Select @parm01 = @save_sharename
	exec dbaadmin.dbo.dbasp_get_share_path @parm01, @save_sharepath output
	--print @save_sharepath


	--  Get folder name for this share
	set @save_foldername = right(@save_sharepath,charindex('\',reverse(@save_sharepath))-1)
	--print @save_foldername


	--  check to see if this folder exists under the BASE_archive folder (create it if needed)
	Delete from #fileexists
	Select @fileexist_path = @BkUpPath  + '\' + @save_foldername
	Insert into #fileexists exec master.sys.xp_fileexist @fileexist_path
	If (select fileindir from #fileexists) <> 1
	   begin
		Select @cmd = 'mkdir "' + @BkUpPath + '\' + @save_foldername + '"'
		Print 'Creating BASE_archive\' + @save_foldername + ' folder using command '+ @cmd
		EXEC master.sys.xp_cmdshell @cmd, no_output 
	   end

	select @cmd = 'robocopy /Z /R:5 ' + @save_sharepath + ' ' + @BkUpPath + '\' + @save_foldername + ' *.sql'
	Print @cmd
	exec master.sys.xp_cmdshell @cmd


	--  Check for more folders to process
	delete from #ShareTempTable1 where path = @save_sharename
	If (select count(*) from #ShareTempTable1) > 0
	   begin
		goto start01
	   end

   end



--  End ---------------------------------------------------------------------------------------------
	
Label99:

drop table #ShareTempTable1
drop table #fileexists



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSchgdbowner
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSchgdbowner]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSchgdbowner]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_SYSchgdbowner

/*********************************************************
 **  Stored Procedure dbasp_SYSchgdbowner                  
 **  Written by Jim Wilson, Getty Images                
 **  October 4, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  change database owner  
 **        
 **  Output member is SYSchgdbowner.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	06/21/2002	Jim Wilson		Removed bracket formatting for database name.
--	10/01/2002	Jim Wilson		Removed unused declares
--	10/28/2003	Jim Wilson		Added set user status
--	11/09/2006	Jim Wilson		Modified for SQL 2005
--	03/09/2007	Jim Wilson		Added quotename for non-sa owners.
--	01/02/2009	Jim Wilson		Converted to new no_check table.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@save_sidname		sysname
	,@G_O			varchar (2)
	,@output_flag		char(1)

      
DECLARE
	 @cu11DBName		sysname
	,@cu11DBsid		varbinary(85)


----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @output_flag	= 'n'
Select @save_sidname = ''

--  Create table variable
declare @dbnames table	(name		sysname
			,sid		varbinary(85))


----------------------  Main header  ----------------------

Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSchgdbowner'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/
--------------------  Capture DB names  -------------------
Insert into @dbnames (name, sid)
SELECT d.name, d.owner_sid
From master.sys.databases d with (NOLOCK)
Where d.name not in ('master', 'model', 'msdb', 'tempdb')
  and d.name not in (select detail01 from dbo.no_check where NoCheck_type = 'backup')

delete from @dbnames where name is null or name = ''
--select * from @dbnames

--, master.sys.server_principals p with (NOLOCK)
If (select count(*) from @dbnames) > 0
   begin
	start_dbnames:

	Select @cu11DBName = (select top 1 name from @dbnames order by name)
	Select @cu11DBsid = (select sid from @dbnames where name = @cu11DBName)

	Select @save_sidname = ''
	Select @save_sidname = (select name from master.sys.server_principals where sid = @cu11DBsid)

	If @save_sidname = '' or @save_sidname is null
	   begin
		SELECT @save_sidname = SUSER_SNAME(@cu11DBsid)
	   end

	----------------------  Output for database owner change  ----------------------

	Print  ' '
	Print  '/****************************************************'
	Select @miscprint = 'CHANGE DATABASE OWNER for Database: ' + @cu11DBName  
	Print  @miscprint
	Print  '****************************************************/'
	Select @miscprint = 'USE [master]'
	Print  @miscprint  
	Print  @G_O
	Print  ' ' 

	If @save_sidname = 'sa'
	   begin
		Select @miscprint = 'ALTER AUTHORIZATION ON DATABASE::' + @cu11DBName + ' TO sa;' 
		Print  @miscprint
		Print  @G_O
		Print  ' '
	   end
	Else
	   begin
		Select @miscprint = 'If (suser_sid(''' + @save_sidname + ''')) is null' 
		Print  @miscprint
		Select @miscprint = '   begin' 
		Print  @miscprint
		Select @miscprint = '      ALTER AUTHORIZATION ON DATABASE::' + @cu11DBName + ' TO sa;' 
		Print  @miscprint
		Select @miscprint = '   end' 
		Print  @miscprint
		Select @miscprint = 'Else' 
		Print  @miscprint
		Select @miscprint = '   begin' 
		Print  @miscprint
		Select @miscprint = '      ALTER AUTHORIZATION ON DATABASE::' + @cu11DBName + ' TO ' + QUOTENAME(@save_sidname) + ';' 
		Print  @miscprint
		Select @miscprint = '   end' 
		Print  @miscprint
		Print  @G_O
		Print  ' '
	   end

	Select @output_flag	= 'y' 


	--  Remove this record from @dbnames and go to the next
	delete from @dbnames where name = @cu11DBName
	If (select count(*) from @dbnames) > 0
	   begin
		goto start_dbnames
	   end

   end

---------------------------  Finalization  -----------------------


If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYScreatedatabases
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYScreatedatabases]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYScreatedatabases]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SYScreatedatabases

/*********************************************************
 **  Stored Procedure dbasp_SYScreatedatabases                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  create databases  
 **        
 **  Output member is SYScreatedatabases.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	05/06/2002	Jim Wilson		Changed dbname type to sysname.
--	05/26/2006	Jim Wilson		Updated for SQL 2005.
--	09/24/2008	Jim Wilson		Added brackets for filegroup.
--	04/14/2009	Jim Wilson		Skip db's not online.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@G_O			nvarchar(2)
	,@savegroupid		smallint
	,@savedefault		nvarchar(128)
	,@filegrowth		nvarchar(20)
	,@logfilegrowth		nvarchar(20)
	,@logname		nchar(128)
	,@logfilename		nchar(260)
	,@logsize		int
	,@logmaxsize		bigint
	,@AlterFlag		nchar(01)
 
DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu22fileid		smallint
	,@cu22groupid		smallint
	,@cu22size		int
	,@cu22maxsize		bigint
	,@cu22growth		int
	,@cu22status		int
	,@cu22perf		int
	,@cu22name		nchar(128)
	,@cu22filename		nchar(260)
	,@cu22FGname		nvarchar(128)
	,@cu22FGstatus		tinyint

----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'


/*********************************************************************
 *                Initialization
 ********************************************************************/

Print  ' '

--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.databases   d ' + 
  'Order By d.name For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Print the headers  ----------------------


   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'Create Databases '  
   Print  @miscprint
   Print  '***********************************************/'
   Print  ' '
   Select @miscprint = 'USE master'
   Print  @miscprint  
   Print  @G_O
   Print  ' '

   
OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	

	if DATABASEPROPERTYEX (@cu11DBName ,'status') <> 'ONLINE'
	   begin
		goto skip_dbname
	   end

 
----------------------  Print the headers  ----------------------


   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'Create database ' + @cu11DBName  
   Print  @miscprint
   Print  '***********************************************/'
   Print  ' ' 
   
   Select @savegroupid	= 0    
   Select @logfilegrowth = ' '
   Select @logname = ' '
   Select @logfilename = ' '
   Select @logsize = null
   Select @logmaxsize = null	
   Select @savedefault = ' '
   Select @AlterFlag = 'N'

   If @cu11DBName in ('master', 'model', 'msdb', 'tempdb')
	Print  '/*****'
	Print  ' ' 

   Select @miscprint = 'CREATE DATABASE ' + @cu11DBName
   Print  @miscprint
   Select @miscprint = 'ON'
   Print  @miscprint

--------------------  Cursor for 22DB  -----------------------

EXECUTE('DECLARE cu22_DBFile Insensitive Cursor For ' + 
  'SELECT f.fileid, f.groupid, f.size, f.maxsize, f.growth, f.status, f.perf, f.name, f.filename, g.groupname, g.status
   From [' + @cu11DBName + '].sys.sysfiles  f LEFT OUTER JOIN  
        [' + @cu11DBName + '].sys.sysfilegroups g
   on f.groupid = g.groupid
   Order By f.fileid For Read Only')


OPEN cu22_DBFile

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBFile Into @cu22fileid, @cu22groupid, @cu22size, @cu22maxsize, @cu22growth, @cu22status, @cu22perf, @cu22name, @cu22filename, @cu22FGname, @cu22FGstatus 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_DBFile
	      BREAK
           end


	IF @cu22FGstatus = 16
	   begin
	     Select @savedefault = @cu22FGname
	   end


	IF @AlterFlag = 'N'
	   begin
		IF @cu22groupid > 0 and @cu22groupid <> @savegroupid
		   begin
			Select @savegroupid = @cu22groupid
			Select @filegrowth = (case @cu22status & 0x100000 when 0x100000 then
				convert(nvarchar(15), @cu22growth) + N'%'
				else
				convert(nvarchar(15), convert (bigint, @cu22growth) * 8) + N'KB' end)
			Select @miscprint = @cu22FGname 
			Print  @miscprint
			Select @miscprint = '( NAME = ''' + rtrim(@cu22name) + ''''
			Print  @miscprint
			Select @miscprint = ' ,FILENAME = ''' + rtrim(@cu22filename) + ''''
			Print  @miscprint
			Select @miscprint = ' ,SIZE = ' + convert(nvarchar(15), convert(bigint, @cu22size) * 8) + N'KB'
			Print  @miscprint
			IF @cu22maxsize > 0
			   begin
				Select @miscprint = ' ,MAXSIZE = ' + convert(nvarchar(15), (convert (bigint, @cu22maxsize) * 8)/1024) + N'MB'	
				Print  @miscprint
			   end
			Else IF @cu22maxsize = -1
			   begin
				Select @miscprint = ' ,MAXSIZE = N''Unlimited'''	
				Print  @miscprint
			   end	
			Select @miscprint = ' ,FILEGROWTH = ' +@filegrowth + ' )'
			Print  @miscprint
		   end
		Else IF @cu22groupid > 0 and @cu22groupid = @savegroupid
		   begin
			Select @filegrowth = (case @cu22status & 0x100000 when 0x100000 then
				convert(nvarchar(15), @cu22growth) + N'%'
				else
				convert(nvarchar(15), convert (bigint, @cu22growth) * 8) + N'KB' end)
			Select @miscprint = ',( NAME = ''' + rtrim(@cu22name) + '''' 
			Print  @miscprint
			Select @miscprint = '  ,FILENAME = ''' + rtrim(@cu22filename) + ''''
			Print  @miscprint
			Select @miscprint = '  ,SIZE = ' + convert(nvarchar(15), convert(bigint, @cu22size) * 8) + N'KB'
			Print  @miscprint
			IF @cu22maxsize > 0
			   begin
				Select @miscprint = '  ,MAXSIZE = ' + convert(nvarchar(15), (convert (bigint, @cu22maxsize) * 8)/1024) + N'MB'	
				Print  @miscprint
			   end	
			Else IF @cu22maxsize = -1
			   begin
				Select @miscprint = ' ,MAXSIZE = N''Unlimited'''	
				Print  @miscprint
			   end	
			Select @miscprint = '  ,FILEGROWTH = ' +@filegrowth + ' )'
			Print  @miscprint	
			IF @AlterFlag = 'Y'
			   begin
				Select @miscprint = 'GO'
				Print  @miscprint
				Select @miscprint = ' '
				Print  @miscprint
			   end
		   end
		else if	@cu22groupid = 0
		   begin
		   	Select @miscprint = 'LOG ON'
		   	Print  @miscprint
			Select @logfilegrowth = (case @cu22status & 0x100000 when 0x100000 then
				  convert(nvarchar(15), @cu22growth) + N'%'
				  else
				  convert(nvarchar(15), convert (bigint, @cu22growth) * 8) + N'KB' end)
			Select @logname = @cu22name
		   	Select @logfilename = @cu22filename
		   	Select @logsize = @cu22size
		   	Select @logmaxsize = @cu22maxsize	
		   	Select @miscprint = '( NAME = ''' + rtrim(@logname) + ''''
		   	Print  @miscprint
		   	Select @miscprint = ' ,FILENAME = ''' + rtrim(@logfilename) + ''''
		   	Print  @miscprint
		   	Select @miscprint = ' ,SIZE = ' + convert(nvarchar(15), convert(bigint, @logsize) * 8) + N'KB'
		   	Print  @miscprint
			IF @logmaxsize > 0
		   	   begin
				Select @miscprint = ' ,MAXSIZE = ' + convert(nvarchar(15), (convert (bigint, @logmaxsize) * 8)/1024) + N'MB'	
				Print  @miscprint
		   	   end	
			Else IF @logmaxsize = -1
			   begin
				Select @miscprint = ' ,MAXSIZE = N''Unlimited'''	
				Print  @miscprint
			   end	
		   	Select @miscprint = ' ,FILEGROWTH = ' +@logfilegrowth + ' )'
		   	Print  @miscprint
		   	Print  @G_O
		   	Print  ' '
			Select @AlterFlag = 'Y'
		   end
	   end
	Else IF @AlterFlag = 'Y'
   	   begin
		IF @cu22groupid > 0 and @cu22FGname <> 'PRIMARY' and @cu22groupid <> @savegroupid 
		   begin
			Select @savegroupid = @cu22groupid
			Select @miscprint = 'ALTER DATABASE ' + @cu11DBName
			Print  @miscprint
			Select @miscprint = 'ADD FILEGROUP [' + @cu22FGname + ']'
			Print  @miscprint
		   	Print  @G_O
		   	Print  ' '
		   end	
		IF @cu22groupid > 0
		   begin
			Select @filegrowth = (case @cu22status & 0x100000 when 0x100000 then
				convert(nvarchar(15), @cu22growth) + N'%'
				else
				convert(nvarchar(15), convert (bigint, @cu22growth) * 8) + N'KB' end)
			Select @miscprint = 'ALTER DATABASE ' + @cu11DBName
			Print  @miscprint
			Select @miscprint = 'ADD FILE'
			Print  @miscprint
			Select @miscprint = '( NAME = ''' + rtrim(@cu22name) + '''' 
			Print  @miscprint
			Select @miscprint = '  ,FILENAME = ''' + rtrim(@cu22filename) + ''''
			Print  @miscprint
			Select @miscprint = '  ,SIZE = ' + convert(nvarchar(15), convert(bigint, @cu22size) * 8) + N'KB'
			Print  @miscprint
			IF @cu22maxsize > 0
			   begin
				Select @miscprint = '  ,MAXSIZE = ' + convert(nvarchar(15), (convert (bigint, @cu22maxsize) * 8)/1024) + N'MB'	
				Print  @miscprint
			   end	
			Else IF @cu22maxsize = -1
			   begin
				Select @miscprint = ' ,MAXSIZE = N''Unlimited'''	
				Print  @miscprint
			   end	
			Select @miscprint = '  ,FILEGROWTH = ' + @filegrowth + ' )'
			Print  @miscprint	
			Select @miscprint = 'TO FILEGROUP [' + @cu22FGname + ']'
			Print  @miscprint	
			Select @miscprint = 'GO'
			Print  @miscprint
			Select @miscprint = ' '
			Print  @miscprint
		   end
		else if	@cu22groupid = 0
		   begin
			Select @logfilegrowth = (case @cu22status & 0x100000 when 0x100000 then
				  convert(nvarchar(15), @cu22growth) + N'%'
				  else
				  convert(nvarchar(15), convert (bigint, @cu22growth) * 8) + N'KB' end)
			Select @logname = @cu22name
		   	Select @logfilename = @cu22filename
		   	Select @logsize = @cu22size
		   	Select @logmaxsize = @cu22maxsize	
			Select @miscprint = 'ALTER DATABASE ' + @cu11DBName
			Print  @miscprint
			Select @miscprint = 'ADD LOG FILE'
			Print  @miscprint
		   	Select @miscprint = '( NAME = ''' + rtrim(@logname) + ''''
		   	Print  @miscprint
		   	Select @miscprint = ' ,FILENAME = ''' + rtrim(@logfilename) + ''''
		   	Print  @miscprint
		   	Select @miscprint = ' ,SIZE = ' + convert(nvarchar(15), convert(bigint, @logsize) * 8) + N'KB'
		   	Print  @miscprint
		   	 IF @logmaxsize > 0
		   	   begin
		   	     Select @miscprint = ' ,MAXSIZE = ' + convert(nvarchar(15), (convert (bigint, @logmaxsize) * 8)/1024) + N'MB'	
		   	     Print  @miscprint
		   	   end	
			Else IF @logmaxsize = -1
			   begin
				Select @miscprint = ' ,MAXSIZE = N''Unlimited'''	
				Print  @miscprint
			   end	
		   	Select @miscprint = ' ,FILEGROWTH = ' +@logfilegrowth + ' )'
		   	Print  @miscprint
		   	Print  @G_O
		   	Print  ' '
		   end
	   end
	

   End  -- loop 22
   DEALLOCATE cu22_DBFile


   IF @savedefault <> 'PRIMARY'
      begin
	Select @miscprint = 'ALTER DATABASE ' + @cu11DBName 
	Print  @miscprint
	Select @miscprint = 'MODIFY FILEGROUP [' + @savedefault + '] DEFAULT' 
	Print  @miscprint
	Print  @G_O
	Print  ' '
      end	

   If @cu11DBName in ('master', 'model', 'msdb', 'tempdb')
	Print  '*****/'
	Print  ' ' 


   skip_dbname:

 End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cu11_DBNames

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYScreateDBusers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYScreateDBusers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYScreateDBusers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_SYScreateDBusers

/*********************************************************
 **  Stored Procedure dbasp_SYScreateDBusers                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  grant database access  
 **        
 **  Output member is SYScreateDBusers.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	05/06/2002	Jim Wilson		Changed dbname type to sysname.
--	06/11/2002	Jim Wilson		Added brackets around DB name in use stmt.
--	11/09/2006	Jim Wilson		Modified for SQL 2005
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar(255)
	,@G_O				nvarchar(2)
	,@output_flag			char(1)
	,@output_flag2			char(1)

DECLARE
	 @cu11DBName			sysname
	,@cu11DBId			smallint

DECLARE
	 @cu22name			sysname
	,@cu22type			sysname
	,@cu22default_schema_name	sysname


----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @output_flag	= 'n'
Select @output_flag2	= 'n'


/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------

Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYScreateDBusers'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '


--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name, d.database_id
   From master.sys.databases   d ' + 
  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')
   Order By d.name For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Print the headers  ----------------------

   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'Create Database Users'  
   Print  @miscprint
   Print  '***********************************************/'
   Print  ' '

   
OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName, @cu11DBId
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	
 
----------------------  Print the headers  ----------------------

   Print  ' '
   Print  '/****************************************************'
   Select @miscprint = 'Create Users for Database: ' + @cu11DBName  
   Print  @miscprint
   Print  '****************************************************/'
   Select @miscprint = 'USE [' + @cu11DBName + ']'
   Print  @miscprint  
   Print  @G_O
   Print  ' ' 
  

--------------------  Cursor for 22DB  -----------------------

EXECUTE('DECLARE cu22_DBAccess Insensitive Cursor For ' + 
  'SELECT dp.name, dp.type, dp.default_schema_name
   From [' + @cu11DBName + '].sys.database_principals  dp ' + 
  'Where dp.type <> ''R''
     and dp.principal_id > 4
   Order By dp.type, dp.name For Read Only')

OPEN cu22_DBAccess

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBAccess Into @cu22name, @cu22type, @cu22default_schema_name 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_DBAccess
	      BREAK
           end

	If @cu22default_schema_name is null or @cu22default_schema_name = 'dbo'
	   begin
		Select @miscprint = 'CREATE USER [' + @cu22name + '];'
		Print  @miscprint
		Print  @G_O
		Print  ' '
	   end
	Else
	   begin
		Select @miscprint = 'CREATE USER [' + @cu22name + '] WITH DEFAULT_SCHEMA = ' + @cu22default_schema_name + ';'
		Print  @miscprint
		Print  @G_O
		Print  ' '
	   end

	--  This code will fix the schema ownership for users that may have been previously removed from the database
	Select @miscprint = 'If exists (select 1 from [' + @cu11DBName + '].sys.schemas where name = ''' + @cu22name + ''' and principal_id = 1)'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '      ALTER AUTHORIZATION ON SCHEMA::[' + @cu22name + '] TO [' + @cu22name + '];'
	Print  @miscprint
	Select @miscprint = '   end'
	Print  @miscprint
	Print  @G_O
	Print  ' '
	Print  ' '


	Select @output_flag	= 'y' 

   End  -- loop 22
   DEALLOCATE cu22_DBAccess


If @output_flag = 'n'
   begin
	Select @miscprint = '-- No output for database: ' + @cu11DBName
	Print  @miscprint
	Print  ' '
   end
Else
   begin
	Select @output_flag = 'n' 
	Print  ' '
   end
        

Select @output_flag2 = 'y' 


 End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cu11_DBNames

If @output_flag2 = 'n'
   begin
	Print '-- No output for this script.'
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_syscreateshares
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_syscreateshares]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_syscreateshares]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_syscreateshares

/**************************************************************
 **  Stored Procedure dbasp_syscreateshares                  
 **  Written by Jim Wilson, Getty Images                
 **  September 16, 2003                                      
 **  
 **  This dbasp is set up to help recreate shares.  The output
 **  from this process is executable code that will recreate the
 **  shares as they existed when the script was run.
 **
 **  Output member is SYScreateshares.gsql
 ***************************************************************/
  as
SET NOCOUNT ON

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/08/2003	Jim Wilson		New sproc
--	12/22/2003	Jim Wilson		Change for short share names
--	08/16/2006	Jim Wilson		Updated for SQL 2005
--	05/27/2008	Jim Wilson		Fix servername with instance in the output.
--	11/03/2008	Jim Wilson		Coverted to dynamic servername within the output script.
--	11/04/2008	Jim Wilson		Added ode for clustered shares.
--	======================================================================================


-----------------  declares  ------------------
DECLARE
	 @miscprint			nvarchar(4000)
	,@cmd				nvarchar(4000)
	,@charpos			int	
	,@save_sharepath		sysname
	,@perm_flag01			char(1)
	,@spcl_access_flag		char(1)
	,@first_flag			char(1)
	,@hold_user			sysname
	,@save_user			sysname
	,@save_user2			sysname
	,@save_perm			sysname
	,@save_perm_small		char(1)
	,@save_security_level		char(1)
	,@hold_parm			sysname
	,@save_servername		sysname
	,@save_servername2		sysname
	,@save_domain			sysname

	
DECLARE
	 @cu12path			nvarchar(500)

DECLARE
	 @cu14sharename			sysname

DECLARE
	 @cu16path			nvarchar(500)

DECLARE
	 @cu18path			nvarchar(500)

DECLARE
	 @cu26path			nvarchar(500)


----------------  initial values  -------------------

Select @save_servername = @@servername
Select @save_servername2 = @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
   end

Select @save_domain = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = 'domain')


--  Creat temp tables
Create table #ShareTempTable1(path nvarchar(500) null)

Create table #ShareList(sharename sysname null)

Create table #ShareTempTable2(path nvarchar(500) null)

Create table #ShareTempTable3(path nvarchar(500) null)



----------------------  Main header  ----------------------
Print  '/**************************************************************'
Select @miscprint = 'Generated SQL - SYScreateshares'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '**************************************************************/'
Print  ' '



--  Develope a list of shares on the local server
Select @cmd = 'net share'

--print @cmd /* for debugging */
Insert into #ShareTempTable1 
exec master.sys.xp_cmdshell @cmd

--select * from #ShareTempTable1 /* for debugging */


--  cursor for the share temp table results - list of local shares
EXECUTE('DECLARE cu12_cursor Insensitive Cursor For ' +
  'SELECT p.path
   From #ShareTempTable1   p ' +
  'Order by p.path for Read Only')
	
OPEN cu12_cursor
	
WHILE (12=12)
 Begin
	FETCH Next From cu12_cursor Into @cu12path
	IF (@@fetch_status < 0)
           begin
              CLOSE cu12_cursor
	      BREAK
           end


	If left(@cu12path, 2) not in ('  ', '--') and left(@cu12path, 11) not in ('Share name ', 'The command')
	   begin
		select @charpos = charindex('  ', @cu12path)
		IF @charpos <> 0
		   begin
			select @cu12path = rtrim(substring(@cu12path, 1, @charpos-1))
		   end	

		select @charpos = charindex(':\', @cu12path)
		IF @charpos <> 0
		   begin
			select @cu12path = rtrim(substring(@cu12path, 1, @charpos-2))
		   end	

		If @cu12path not like '%$'
		   begin
			Insert into #ShareList (sharename) Values (@cu12path)
		   end
	   end

 End  -- loop 12
DEALLOCATE cu12_cursor

--select * from #ShareList /* for debugging */



--  Process each share one at a time, getting information via RMTSHARE and creating the output script
EXECUTE('DECLARE cu14_cursor Insensitive Cursor For ' +
  'SELECT s.sharename
   From #ShareList   s ' +
  'Order by s.sharename for Read Only')
	
OPEN cu14_cursor
	
WHILE (14=14)
 Begin
	FETCH Next From cu14_cursor Into @cu14sharename
	IF (@@fetch_status < 0)
           begin
              CLOSE cu14_cursor
	      BREAK
           end


	--  Get information about this share using RMTSHARE
	Select @cmd = 'RMTSHARE \\' + @save_servername + '\' + @cu14sharename
	--print @cmd /* for debugging */
	Insert into #ShareTempTable2 
	exec master.sys.xp_cmdshell @cmd

	--  parse the drive letter path to the share and verify the path exists
	select @save_sharepath = ltrim(substring(path, 5, 100)) from #ShareTempTable2 where left(path, 4) = 'Path'

	--Select * from #ShareTempTable2 /* for debugging */
	--Print @cu14sharename
	--Print @save_sharepath



	Print  ' '
	Print  '--  **************************************************************************************'
	Print  '--  Create Share ''' + @cu14sharename + ''''
	Print  '--  **************************************************************************************'

	If @cu14sharename like '%' + @save_servername + '%' 
	    and (@cu14sharename like '%dba_mail%' 
		or @cu14sharename like '%builds%'
		or @cu14sharename like '%Central_Archive%'
		or @cu14sharename like '%filescan%'
		or @cu14sharename like '%SQL_Register%'
		or @cu14sharename like '%SQLPerfReports%'
		or @cu14sharename like '%restore%')
	   begin
		Select @cu14sharename = replace(@cu14sharename, @save_servername, ''' + @save_servername + ''')
	   end

	If @cu14sharename like '%' + @save_servername2 + '%'
	   begin
		Select @cu14sharename = replace(@cu14sharename, @save_servername2, ''' + @save_servername2 + ''')
	   end

	Select @miscprint = 'Set nocount on'
	Print  @miscprint
	Select @miscprint = 'Declare @share_path sysname'
	Print  @miscprint
	Select @miscprint = '       ,@cmd nvarchar(4000)'
	Print  @miscprint
	Select @miscprint = '       ,@charpos int'
	Print  @miscprint
	Select @miscprint = '       ,@save_servername sysname'
	Print  @miscprint
	Select @miscprint = '       ,@save_servername2 sysname'
	Print  @miscprint
	Select @miscprint = '       ,@save_drive_letter_part char(2)'
	Print  @miscprint
	Select @miscprint = '       ,@save_data2 nvarchar(4000)'
	Print  @miscprint
	Select @miscprint = '       ,@save_disk_resname sysname'
	Print  @miscprint
	Select @miscprint = '       ,@save_group_resname sysname'
	Print  @miscprint
	Select @miscprint = '       ,@save_network_resname sysname'
	Print  @miscprint
	Select @miscprint = '       ,@save_domain sysname'
	Print  @miscprint
	Print  ' '

	Select @miscprint = 'Select @share_path = ''' + @save_sharepath + ''''
	Print  @miscprint
	Print  ' '

	Select @miscprint = 'Create table #cluster_info2 (data2 nvarchar(4000))'
	Print  @miscprint
	Select @miscprint = 'Create table #fileexists (doesexist smallint, fileindir smallint, direxist smallint)'
	Print  @miscprint
	Select @miscprint = 'Insert into #fileexists exec master.sys.xp_fileexist @share_path'
	Print  @miscprint
	Print  ' '

	Select @miscprint = 'If (SERVERPROPERTY(''IsClustered'')) = 1'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '	Select @save_domain = (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = ''domain'')'
	Print  @miscprint
	Select @miscprint = '	Select @cmd = ''cluster . res /status'''
	Print  @miscprint
	Select @miscprint = '	Insert into #cluster_info2 exec master.sys.xp_cmdshell @cmd'
	Print  @miscprint
	Select @miscprint = '	delete from #cluster_info2 where data2 is null'
	Print  @miscprint
	Select @miscprint = '	delete from #cluster_info2 where rtrim(data2) = '''''
	Print  @miscprint
	Select @miscprint = '   end'
	Print  @miscprint
	Print  ' '

	Select @miscprint = 'Select @save_servername = @@servername'
	Print  @miscprint
	Select @miscprint = 'Select @save_servername2 = @@servername'
	Print  @miscprint
	Print  ' '

	Select @miscprint = 'Select @charpos = charindex(''\'', @save_servername)'
	Print  @miscprint
	Select @miscprint = 'IF @charpos <> 0'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '	Select @save_servername = substring(@@servername, 1, (CHARINDEX(''\'', @@servername)-1))'
	Print  @miscprint
	Select @miscprint = '	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, ''$'')'
	Print  @miscprint
	Select @miscprint = '   end'
	Print  @miscprint
	Print  ' '

	Select @miscprint = 'If (select fileindir from #fileexists) = 0'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '	Print '' ''' 
	Print  @miscprint
	Select @miscprint = '	Print ''ERROR: Share "' + @cu14sharename + '" will not be created.''' 
	Print  @miscprint
	Select @miscprint = '	Print ''       Path "'' + @share_path + ''" could not be found.''' 
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = '   end'
	Print  @miscprint
	Select @miscprint = 'Else If (SERVERPROPERTY(''IsClustered'')) = 0'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '	Select @cmd = ''rmtshare \\'' + @save_servername + ''\' + @cu14sharename + ' = "'' + @share_path + ''" /unlimited'''
	Print  @miscprint
	Select @miscprint = '	Print ''Creating the "' + @cu14sharename + '" share using command: '' + @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output' 
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint
	Select @miscprint = '	Select @cmd = ''rmtshare \\'' + @save_servername + ''\' + @cu14sharename + ' /grant administrators:f'''
	Print  @miscprint
	Select @miscprint = '	Print ''Assign FULL Permissions, Local administrators to the "' + @cu14sharename + '" share using command: '' + @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output' 
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint
	Select @miscprint = '	Select @cmd = ''rmtshare \\'' + @save_servername + ''\' + @cu14sharename + ' /Remove everyone'''
	Print  @miscprint
	Select @miscprint = '	Print ''Remove Share permissions for "Everyone" from the "' + @cu14sharename + '" share using command: '' + @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output' 
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint

	Select @perm_flag01 = 'n'
	Select @hold_user = ' '


	--  Get the share permissions
	EXECUTE('DECLARE cu16_cursor Insensitive Cursor For ' +
	  'SELECT t.path
	   From #ShareTempTable2   t ' +
	  'for Read Only')
	
	OPEN cu16_cursor
	
	WHILE (16=16)
	 Begin
		FETCH Next From cu16_cursor Into @cu16path
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu16_cursor
		      BREAK
	           end


		If @perm_flag01 = 'y' and @cu16path is not null
		   begin
			Select @charpos = charindex(':', @cu16path)
			IF @charpos <> 0
			   begin
				Select @save_user = ltrim(substring(@cu16path, 1, @charpos-1))
				Select @save_perm = ltrim(substring(@cu16path, @charpos+1, 20))

				If rtrim(@save_user) <> rtrim(@hold_user)
				   and @save_user <> 'BUILTIN\Administrators'
				   begin
					If rtrim(@save_perm) = 'FULL CONTROL'
					   begin
						Select @save_perm_small = 'f'
					   end
					Else  If rtrim(@save_perm) = 'CHANGE'
					   begin
						Select @save_perm_small = 'c'
					   end
					Else
					   begin
						Select @save_perm_small = 'r'
					   end
					If left(@save_user, 1) = '\'
					   begin
						Select @save_user = substring(@save_user, 2, len(@save_user)-1)
					   end

					If @save_user like '%\' + @save_servername2 + '%'
					   begin
						Select @save_user = replace(@save_user, @save_servername2, ''' + @save_servername2 + ''')
					   end

					If @save_user like '%' + @save_servername + '%'
					   begin
						Select @save_user = replace(@save_user, @save_servername, ''' + @save_servername + ''')
					   end


					--  Create the script for share permissions
					Select @miscprint = ' ' 
					Print  @miscprint
					Select @miscprint = '	Select @cmd = ''rmtshare \\'' + @save_servername + ''\' + @cu14sharename + ' /grant "' + rtrim(@save_user) + '":' + @save_perm_small + ''''
					Print  @miscprint
					Select @miscprint = '	Print ''Assign ' + @save_perm + ' Permissions: "' + rtrim(@save_user) + '" to the "' + @cu14sharename + '" share using command: ''+ @cmd'
					Print  @miscprint
					Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output' 
					Print  @miscprint
					Select @miscprint = '	Print '' '''
					Print  @miscprint

				   end

			   end

		   end
		Else If @cu16path is null
		   begin
			Select @perm_flag01 = 'n' 
		   end


		--  The rows after the permissions header are what we need.  This sets a flag
		--  telling the program we are there.
		If left(@cu16path, 11) = 'Permissions'
		   begin
			Select @perm_flag01 = 'y' 
		   end
		

	 End  -- loop 16
	DEALLOCATE cu16_cursor




	--  Get information about this share using XCACLS
	Select @cmd = 'XCACLS "' + @save_sharepath + '"' /* double quotes are used in case folder names have spaces */
	--print @cmd /* for debugging */
	Insert into #ShareTempTable3 
	exec master.sys.xp_cmdshell @cmd

	--Select * from #ShareTempTable3 /* for debugging */


	Select @hold_user = ' '
	Select @hold_parm = '/G'
	Select @spcl_access_flag = 'n'
	Select @first_flag = 'y'


	--  Get the share security info
	EXECUTE('DECLARE cu18_cursor Insensitive Cursor For ' +
	  'SELECT s.path
	   From #ShareTempTable3   s ' +
	  'for Read Only')
	
	OPEN cu18_cursor
	
	WHILE (18=18)
	 Begin
		FETCH Next From cu18_cursor Into @cu18path
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu18_cursor
		      BREAK
	           end


		If @cu18path is not null

/***
C:\share_test BUILTIN\Administrators:(OI)(CI)R 
              AMER\dmarsten:(CI)R 
              AMER\dmarsten:(OI)(CI)(special access:)

                                    SYNCHRONIZE
                                    FILE_EXECUTE
 
              AMER\jwilson:(OI)(CI)C 
              NT AUTHORITY\SYSTEM:(OI)(CI)F 
***/


		   begin
			Select @charpos = charindex('special access:', @cu18path)
			IF @charpos <> 0
			   begin
				Select @spcl_access_flag = 'y'
			   end
			Else
			   begin
				Select @save_security_level = right(rtrim(@cu18path), 1)
			   end

			If @cu18path = ' ' and @spcl_access_flag = 'y'
			   begin
				Select @spcl_access_flag = 'n'
				Select @miscprint = '	Print '' '''
				Print  @miscprint
				goto label45
			   end

			Select @charpos = charindex(@save_sharepath, @cu18path)
			IF @charpos <> 0
			   begin
				Select @cu18path = ltrim(substring(@cu18path, len(@save_sharepath)+1, 200))
			   end

			Select @cu18path = ltrim(rtrim(@cu18path)) 

			Select @charpos = charindex(':', @cu18path)
			IF @charpos <> 0
			   begin
				Select @cu18path = left(@cu18path, @charpos-1)
			   end

			IF left(@cu18path, 8) = 'BUILTIN\'
			   begin
				Select @cu18path = Right(@cu18path, len(@cu18path)-8)
			   end



			If @spcl_access_flag = 'y'
			   begin
				Select @miscprint = ' ' 
				Print  @miscprint
				If @first_flag = 'y'
				   begin
					Select @miscprint = '	Print ''Unable to Assign Special Access NTFS Permissions for "' + @cu18path + '".'''
					Print  @miscprint
					Select @hold_user = @cu18path
					Select @first_flag = 'n'
				   end
				Else
				   begin
					Select @miscprint = '	Print ''Unable to Assign Special Access NTFS Permissions for "' + @hold_user + '", "' + @cu18path + '".'''
					Print  @miscprint
				   end
			   end
			Else If @hold_user <> @cu18path
			   begin
				Select @save_user2 = @cu18path
				If @save_user2 like '%\' + @save_servername2 + '%'
				   begin
					Select @save_user2 = replace(@cu18path, @save_servername2, ''' + @save_servername2 + ''')
				   end

				If @save_user2 like '%' + @save_servername + '%'
				   begin
					Select @save_user2 = replace(@save_user2, @save_servername, ''' + @save_servername + ''')
				   end

				Select @miscprint = ' ' 
				Print  @miscprint
				Select @miscprint = '	Select @cmd = ''XCACLS "'' + @share_path + ''" ' + @hold_parm + ' "' + @save_user2 + '":' + @save_security_level + ' /Y'''
				Print  @miscprint
				Select @miscprint = '	Print ''Assign NTFS Permissions, "' + @save_user2 + '" to the path "'' + @share_path + ''" using command: '' + @cmd'
				Print  @miscprint
				Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output' 
				Print  @miscprint
				Select @miscprint = '	Print '' '''
				Print  @miscprint
			   end


			If @spcl_access_flag = 'n'
			   begin
				Select @hold_user = @cu18path
				Select @hold_parm = '/E /G'
			   end

			label45:

		   end

	 End  -- loop 18
	DEALLOCATE cu18_cursor




	Select @miscprint = '   end'
	Print  @miscprint


	--  Start process for clustered shares
	Select @miscprint = 'Else If (SERVERPROPERTY(''IsClustered'')) = 1'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	
	--  If any standard shares are found, delete them (we will recreate them)
	Select @miscprint = '	--  Delete the share before we re-create it'
	Print  @miscprint
	Select @miscprint = '	Select @cmd = ''cluster . res ' + @cu14sharename + ' /off'''
	Print  @miscprint
	Select @miscprint = '	Print ''Take the File Share Resource "' + @cu14sharename + '" offline using command: '' + @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output' 
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint
	Select @miscprint = '	Select @cmd = ''cluster . res ' + @cu14sharename + ' /delete'''
	Print  @miscprint
	Select @miscprint = '	Print ''Deleting the File Share Resource "' + @cu14sharename + '" using command: '' + @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output' 
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	--  Get selected cluster info (disk)
	Select @miscprint = '	--  Get selected cluster info (disk)'
	Print  @miscprint
	Select @miscprint = '	Select @save_drive_letter_part = substring(@share_path, 1,2)'
	Print  @miscprint
	Select @miscprint = '	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like ''%'' + @save_drive_letter_part + ''%'')'
	Print  @miscprint
	Select @miscprint = '	Select @save_disk_resname = @save_data2'
	Print  @miscprint
	Select @miscprint = '	Select @charpos = charindex(''   '', @save_data2)'
	Print  @miscprint
	Select @miscprint = '	If @charpos > 0'
	Print  @miscprint
	Select @miscprint = '	   begin'
	Print  @miscprint
	Select @miscprint = '		Select @save_disk_resname = left(@save_data2, @charpos-1)'
	Print  @miscprint
	Select @miscprint = '		Select @save_group_resname = substring(@save_data2, @charpos, 200)'
	Print  @miscprint
	Select @miscprint = '		Select @save_group_resname = ltrim(@save_group_resname)'
	Print  @miscprint   
	Select @miscprint = '		Select @charpos = charindex(''   '', @save_group_resname)'
	Print  @miscprint
	Select @miscprint = '		If @charpos > 0'
	Print  @miscprint
	Select @miscprint = '		   begin'
	Print  @miscprint
	Select @miscprint = '			Select @save_group_resname = left(@save_group_resname, @charpos-1)'
	Print  @miscprint
	Select @miscprint = '		   end'
	Print  @miscprint
	Select @miscprint = '	   end'
	Print  @miscprint
	Select @miscprint = '	Else'
	Print  @miscprint
	Select @miscprint = '	   begin'
	Print  @miscprint
	Select @miscprint = '		Print ''Unable to find the cluster resource for the disk '' + @save_drive_letter_part + ''\.  Skipping create share process for ' + @cu14sharename + '.'''
	Print  @miscprint
	Select @miscprint = '		goto skip_create_share'
	Print  @miscprint
	Select @miscprint = '	   end'
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	--  Get selected cluster info (network)
	Select @miscprint = '	--  Get selected cluster info (network)'
	Print  @miscprint
	Select @miscprint = '	Select @save_data2 = (select top 1 data2 from #cluster_info2 where data2 like ''%network%'' and data2 like ''%'' + @save_group_resname + '' %'')'
	Print  @miscprint
	Select @miscprint = '	Select @save_network_resname = @save_data2'
	Print  @miscprint
	Select @miscprint = '	Select @charpos = charindex(@save_group_resname + '' '', @save_network_resname)'
	Print  @miscprint
	Select @miscprint = '	If @charpos > 0'
	Print  @miscprint
	Select @miscprint = '	   begin'
	Print  @miscprint
	Select @miscprint = '		Select @save_network_resname = left(@save_network_resname, @charpos-1)'
	Print  @miscprint
	Select @miscprint = '		Select @save_network_resname = rtrim(@save_network_resname)'
	Print  @miscprint
	Select @miscprint = '	   end'
	Print  @miscprint
	Select @miscprint = '	Else'
	Print  @miscprint
	Select @miscprint = '	   begin'
	Print  @miscprint
	Select @miscprint = '		Print ''Unable to find the cluster network resource for the group '' + @save_group_resname + ''.  Skipping create share process for ' + @cu14sharename + '.'''
	Print  @miscprint
	Select @miscprint = '		goto skip_create_share'
	Print  @miscprint
	Select @miscprint = '	   end'
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	
	--  Create the share, and share security
	Select @miscprint = '	--  Create the share, and share security'
	Print  @miscprint
	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /Create /Group:"'' + @save_group_resname + ''" /Type:"File Share"'''
	Print  @miscprint
	Select @miscprint = '	Print ''Create the File Share Resource in the cluster group ['' + @save_group_resname + ''] using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /priv Path="'' + @share_path + ''"'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share Path using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /priv ShareName=' + @cu14sharename + ''''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share ShareName using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint
	
	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /priv Remark="DBA File Share"'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share Remark using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /prop Description="DBA Clustered Share"'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share Description using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /AddDep:"'' + @save_disk_resname + ''"'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share dependency using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /AddDep:"'' + @save_network_resname + ''"'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share dependency using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /On'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share OnLine using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /priv security="' + @save_domain + '\Domain Admins",grant,f:security'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share permissions using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint

	Select @miscprint = '	Select @cmd = ''XCACLS '' + @share_path + '' /E /G "' + @save_domain + '\Domain Admins":F /Y'''
	Print  @miscprint
	Select @miscprint = '	Print ''Assign FULL NTFS Permissions using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint
	
	Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /priv security=everyone,revoke:security'''
	Print  @miscprint
	Select @miscprint = '	Print ''Set the File Share permissions using command: ''+ @cmd'
	Print  @miscprint
	Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
	Print  @miscprint
	Select @miscprint = '	Print '' '''
	Print  @miscprint
	Select @miscprint = ' ' 
	Print  @miscprint


	Select @perm_flag01 = 'n'
	Select @hold_user = ' '

	--  Get the share permissions
	EXECUTE('DECLARE cu26_cursor Insensitive Cursor For ' +
	  'SELECT t.path
	   From #ShareTempTable2   t ' +
	  'for Read Only')
	
	OPEN cu26_cursor
	
	WHILE (26=26)
	 Begin
		FETCH Next From cu26_cursor Into @cu26path
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu26_cursor
		      BREAK
	           end

		If @perm_flag01 = 'y' and @cu26path is not null
		   begin
			Select @charpos = charindex(':', @cu26path)
			IF @charpos <> 0
			   begin
				Select @save_user = ltrim(substring(@cu26path, 1, @charpos-1))
				Select @save_perm = ltrim(substring(@cu26path, @charpos+1, 20))

				If rtrim(@save_user) <> rtrim(@hold_user)
				   and @save_user <> 'BUILTIN\Administrators'
				   and @save_user not like '%Domain Admins%'

				   begin
					If rtrim(@save_perm) = 'FULL CONTROL'
					   begin
						Select @save_perm_small = 'F'
					   end
					Else  If rtrim(@save_perm) = 'CHANGE'
					   begin
						Select @save_perm_small = 'C'
					   end
					Else
					   begin
						Select @save_perm_small = 'R'
					   end
					If left(@save_user, 1) = '\'
					   begin
						Select @save_user = substring(@save_user, 2, len(@save_user)-1)
					   end

					If @save_user like '%\' + @save_servername2 + '%'
					   begin
						Select @save_user = replace(@save_user, @save_servername2, ''' + @save_servername2 + ''')
					   end

					If @save_user like '%' + @save_servername + '%'
					   begin
						Select @save_user = replace(@save_user, @save_servername, ''' + @save_servername + ''')
					   end


					--  Create the script for share permissions
					Select @miscprint = '	Select @cmd = ''cluster . res "' + @cu14sharename + '" /priv security="' + rtrim(@save_user) + '",grant,' + @save_perm_small + ':security'''
					Print  @miscprint
					Select @miscprint = '	Print ''Assign ' + @save_perm + ' Permissions: "' + rtrim(@save_user) + '" to the "' + @cu14sharename + '" share using command: ''+ @cmd'
					Print  @miscprint
					Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
					Print  @miscprint
					Select @miscprint = '	Print '' '''
					Print  @miscprint
					Select @miscprint = ' ' 
					Print  @miscprint

					Select @miscprint = '	Select @cmd = ''XCACLS '' + @share_path + '' /E /G "' + @save_user + '":' + @save_perm_small + ' /Y'''
					Print  @miscprint
					Select @miscprint = '	Print ''Assign XCACLS ' + @save_perm + ' Permissions: "' + rtrim(@save_user) + '" to the "' + @cu14sharename + '" share using command: ''+ @cmd'
					Print  @miscprint
					Select @miscprint = '	EXEC master.sys.xp_cmdshell @cmd, no_output'
					Print  @miscprint
					Select @miscprint = '	Print '' '''
					Print  @miscprint
					Select @miscprint = ' ' 
					Print  @miscprint
				   end
			   end
		   end
		Else If @cu26path is null
		   begin
			Select @perm_flag01 = 'n' 
		   end

		--  The rows after the permissions header are what we need.  This sets a flag
		--  telling the program we are there.
		If left(@cu26path, 11) = 'Permissions'
		   begin
			Select @perm_flag01 = 'y' 
		   end
		

	 End  -- loop 26
	DEALLOCATE cu26_cursor

	

	Select @miscprint = '   end'
	Print  @miscprint

	Print  ' '
	Select @miscprint = 'skip_create_share:'
	Print  @miscprint
	Select @miscprint = 'Print '' '''
	Print  @miscprint
	Select @miscprint = 'Print '' '''
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Drop table #fileexists'
	Print  @miscprint
	Select @miscprint = 'Drop table #cluster_info2'
	Print  @miscprint
	Print  'go '
	Print  ' '
	Print  ' '
	Print  ' '
	Print  ' '


	delete from #ShareTempTable1
	delete from #ShareTempTable3


 End  -- loop 14
DEALLOCATE cu14_cursor



--  fyi, security related info (xcacls)
/***
OUTPUT    		ACE Applies To
OI 			- This folder and files 
CI 			- This folder and subfolders 
IO 			- The ACE does not apply to the current file/directory. 
No output message 	- This folder only 
(IO)(CI) 		- This folder, subfolders and files 
(OI)(CI)(IO) 		- Subfolders and files only 
(CI)(IO) 		- Subfolders only 
(OI)(IO) 		- Files only 
***/


----------------  End  -------------------

drop table #ShareTempTable1

drop table #ShareList

drop table #ShareTempTable2

drop table #ShareTempTable3
    

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSdbRestore
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSdbRestore]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSdbRestore]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_SYSdbRestore

/*********************************************************
 **  Stored Procedure dbasp_SYSdbRestore                  
 **  Written by Jim Wilson, Getty Images                
 **  October 13, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Restore databases  
 **        
 **  Output member is SYSdbRestore.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	06/22/2004	Jim Wilson		Added code for diferential restores.
--	08/19/2005	Jim Wilson		Added code for LiteSpeed processing.
--	12/22/2005	Jim Wilson		New code for mutilple backup files.
--	05/30/2006	Jim Wilson		Updated for SQL 2005.
--	07/24/2007	Jim Wilson		Added RedGate processing.
--	06/11/2008	Jim Wilson		Change sys.sysfiles to sys,database_files.
--	01/02/2009	Jim Wilson		Converted to new no_check table.
--	04/14/2009	Jim Wilson		Skip db's not online.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@cmd			nvarchar(500)
	,@G_O			nvarchar(2)
	,@firstflag		char(1)
	,@HoldBackupName	nvarchar(260)
	,@maxBSI_D		int
	,@maxBSI_I		int
	,@output_flag		char(1)
	,@BkUpMethod		nvarchar(10)
	,@Holdfam_seq_num	tinyint
	,@hold_from		nvarchar(5)
	,@hold_comma		nvarchar(1)

DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu22fileid		int
	,@cu22name		nvarchar(128)
	,@cu22filename		nvarchar(260)

----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @output_flag	= 'n'
Select @BkUpMethod 	= 'MS'

--  Create table variable
declare @dbnames table	(name		sysname)

create table #filenames (fileid		int
			,name		sysname
			,filename	sysname
			)

create table #holdbackupnames	(filename		sysname
				,family_sequence_number	tinyint
				,process_flag		char(1)
				)


/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSdbRestore'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '

--------------------  Capture DB names  -------------------
Insert into @dbnames (name)
SELECT d.name
From master.sys.databases d with (NOLOCK) 
Where d.name not in ('master', 'model', 'msdb', 'tempdb')
  and d.name not in (select detail01 from dbo.no_check where NoCheck_type = 'backup')

delete from @dbnames where name is null or name = ''
--select * from @dbnames



/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Print the headers  ----------------------
Print  ' '
Print  '/*********************************************************'
Select @miscprint = 'Restore Database''s for server: ' + @@servername  
Print  @miscprint
Print  '*********************************************************/'
Print  ' '
Print  ' '

If (select count(*) from @dbnames) > 0
   begin
	start_dbnames:

	Select @cu11DBName = (select top 1 name from @dbnames order by name)

	if DATABASEPROPERTYEX (@cu11DBName ,'status') <> 'ONLINE'
	   begin
		goto skip_dbname
	   end


	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'Restore for Database: ' + @cu11DBName  
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Note: Prior to running the following restore command,'  
	Print  @miscprint
	Select @miscprint = '      some changes in the syntax may be required, such'
	Print  @miscprint
	Select @miscprint = '      as the name of the backup file, or the path of the'  
	Print  @miscprint
	Select @miscprint = '      restored files.' 
	Print  @miscprint
	Print  '*********************************************************/'
	Print  ' ' 
 
	Select @firstflag = 'y'

	--------------------  Capture File Names  -------------------
	Select @cmd = 'Insert into #filenames (fileid, name, filename)
	SELECT f.file_id, f.name, f.physical_name
	From [' + @cu11DBName + '].sys.database_files  f with (NOLOCK)'

	EXEC sp_executesql @cmd

	delete from #filenames where name is null or name = '' or fileid is null
	--select * from #filenames

	If (select count(*) from #filenames) > 0
	   begin
		start_filenames:

		Select @cu22fileid = (select top 1 fileid from #filenames order by fileid)
		Select @cu22name = name from #filenames where fileid = @cu22fileid
		Select @cu22filename = filename from #filenames where fileid = @cu22fileid

		If @firstflag = 'y'
		   begin
			Select @maxBSI_D = 0
			Select @maxBSI_I = 0
			Select @firstflag = 'n'
			Select @maxBSI_D = (select max(bf.backup_set_id) 
						from msdb.dbo.backupfile bf, msdb.dbo.backupset bs 
						where bf.backup_set_id = bs.backup_set_id
						and bs.type = 'D'
						and bf.logical_name = @cu22name 
						and bf.physical_name = @cu22filename)

 		
			Select @maxBSI_I = (select max(bf.backup_set_id) 
						from msdb.dbo.backupfile bf, msdb.dbo.backupset bs 
						where bf.backup_set_id = bs.backup_set_id
						and bs.type = 'I'
						and bf.logical_name = @cu22name 
						and bf.physical_name = @cu22filename) 


			delete from #holdbackupnames

			--  Capture backup file name(s)
			Insert into #holdbackupnames (filename, family_sequence_number)
			select mf.physical_device_name, mf.family_sequence_number
			from msdb.dbo.backupmediafamily mf, msdb.dbo.backupset bs 
			where mf.media_set_id = bs.media_set_id
			  and bs.backup_set_id = @maxBSI_D

			delete from #holdbackupnames where filename is null or filename = ''
			--select * from #holdbackupnames


			Select @HoldBackupName = (select top 1 filename from #holdbackupnames order by family_sequence_number) 
		

			Select @miscprint = 'select @@servername, getdate()'
			Print  @miscprint
			Print  @G_O
			Print  ' '
			Print  ' '

			--  Check file name to determine if we can process the file
			If @HoldBackupName like '%.bkp%'
			   begin
				Print '--  Note:  LiteSpeed Syntax will be used for this restore'
				Print ' '
				Select @BkUpMethod = 'LS'
			   end

			If @HoldBackupName like '%.sqb%'
			   begin
				Print '--  Note:  RedGate Syntax will be used for this restore'
				Print ' '
				Select @BkUpMethod = 'RG'
			   end


			If @HoldBackupName is not null
			   begin
				If @BkUpMethod = 'LS'
				   begin
					select @miscprint = 'EXEC master.dbo.xp_restore_filelistonly'
					print  @miscprint
					select @miscprint = '  @filename = ''' + @HoldBackupName + ''''
					print  @miscprint
					select @miscprint = 'EXEC master.dbo.xp_restore_database'
					print  @miscprint
					select @miscprint = '  @database =  ''' + @cu11DBName + ''''
					print  @miscprint
					select @miscprint = ', @filename = ''' + @HoldBackupName + ''''
					print  @miscprint

					If @maxBSI_I > @maxBSI_D
					   begin
						select @miscprint = ', @with = NORECOVERY'
						print  @miscprint
						select @miscprint = ', @with = ''REPLACE'''
						print  @miscprint
					   end	
					Else
					   begin
						select @miscprint = ', @with = RECOVERY'
						print  @miscprint
						select @miscprint = ', @with = ''REPLACE'''
						print  @miscprint
					   end	
				   end
				Else If @BkUpMethod = 'RG'
				   begin
					select @miscprint = 'Exec master.dbo.sqlbackup ''-SQL "RESTORE FILELISTONLY FROM DISK = ''''' + @HoldBackupName + '''''"'''
					print  @miscprint
					select @miscprint = 'go'
					print  @miscprint
					select @miscprint = 'Declare @cmd nvarchar(4000)'
					print  @miscprint
					select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @cu11DBName + ']'
					print  @miscprint
					select @miscprint = '	 FROM DISK = ''''' + @HoldBackupName + ''''''
					print  @miscprint

					If @maxBSI_I > @maxBSI_D
					   begin
						select @miscprint = '	 WITH NORECOVERY'
						print  @miscprint
					   end	
					Else
					   begin
						select @miscprint = '	 WITH RECOVERY'
						print  @miscprint
					   end	
				   end
				Else
				   begin
					Select @miscprint = 'RESTORE FILELISTONLY'
					Print  @miscprint

					update #holdbackupnames set process_flag = 'n'
					Select @hold_from = 'FROM '
					Select @hold_comma = ''
					start_holdbackupnames_01:
					Select @Holdfam_seq_num = (select top 1 family_sequence_number from #holdbackupnames where process_flag = 'n' order by family_sequence_number) 
					Select @HoldBackupName = (select filename from #holdbackupnames where family_sequence_number = @Holdfam_seq_num)
					If (select count(*) from #holdbackupnames where process_flag = 'y') > 0
					   begin
						Select @hold_from = '    '
						Select @hold_comma = ','
					   end

					Select @miscprint = @hold_from + '     ' + + @hold_comma + 'Disk = ''' + @HoldBackupName + ''''
					Print  @miscprint

					update #holdbackupnames set process_flag = 'y' where family_sequence_number = @Holdfam_seq_num
					If (select count(*) from #holdbackupnames where process_flag = 'n') > 0
					   begin
						goto start_holdbackupnames_01
					   end


					Print  @G_O
					Print  ' '
					Select @miscprint = 'RESTORE DATABASE ' + @cu11DBName
					Print  @miscprint

					update #holdbackupnames set process_flag = 'n'
					Select @hold_from = 'FROM '
					Select @hold_comma = ''
					start_holdbackupnames_02:
					Select @Holdfam_seq_num = (select top 1 family_sequence_number from #holdbackupnames where process_flag = 'n' order by family_sequence_number) 
					Select @HoldBackupName = (select filename from #holdbackupnames where family_sequence_number = @Holdfam_seq_num)
					If (select count(*) from #holdbackupnames where process_flag = 'y') > 0
					   begin
						Select @hold_from = '    '
						Select @hold_comma = ','
					   end

					Select @miscprint = @hold_from + '     ' + + @hold_comma + 'Disk = ''' + @HoldBackupName + ''''
					Print  @miscprint

					update #holdbackupnames set process_flag = 'y' where family_sequence_number = @Holdfam_seq_num
					If (select count(*) from #holdbackupnames where process_flag = 'n') > 0
					   begin
						goto start_holdbackupnames_02
					   end


					If @maxBSI_I > @maxBSI_D
					   begin
						select @miscprint = 'WITH      NORECOVERY'
						print  @miscprint
						select @miscprint = '         ,REPLACE'
						print  @miscprint
					   end
					Else
					   begin
						Select @miscprint = 'WITH      REPLACE'
						Print  @miscprint
					   end
				   end
			   end
			Else
			   begin
				Select @miscprint = '-- Warning:  No Backup File found for database: ' + @cu11DBName
				Print  @miscprint
				Select @miscprint = ' '
				Print  @miscprint
				Select @miscprint = '-- Note:  The following lines document this databases file names and paths'
				Print  @miscprint
				Select @miscprint = '--        and can be used as part of a database restore script.'
				Print  @miscprint
				Select @miscprint = ' '
				Print  @miscprint
			   end
		   end


		If @HoldBackupName is not null
		   begin
			If @BkUpMethod = 'LS'
			   begin
				select @miscprint = ', @with = ''MOVE "' + rtrim(@cu22name) + '" to "' + rtrim(@cu22filename) + '"'''
				print  @miscprint
			   end
			Else If @BkUpMethod = 'RG'
			   begin
				select @miscprint = '	,MOVE ''''' + rtrim(@cu22name) + ''''' to ''''' + rtrim(@cu22filename) + ''''''
				print  @miscprint
			   end
			Else
			   begin
				Select @miscprint = '	,MOVE ''' + rtrim(@cu22name) + '''' + ' to ' + '''' + rtrim(@cu22filename) + ''''
				Print  @miscprint
			   end
		   end
		Else
		   begin
			Select @miscprint = '--       ,MOVE ''' + rtrim(@cu22name) + '''' + ' to ' + '''' + rtrim(@cu22filename) + ''''
			Print  @miscprint
		   end

	
		--  Remove this record from #filenames and go to the next
		delete from #filenames where fileid = @cu22fileid
		If (select count(*) from #filenames) > 0
		   begin
			goto start_filenames
		   end

	   end



	If @HoldBackupName is not null
	   begin
		If @BkUpMethod = 'LS'
		   begin
			select @miscprint = ', @with = ''stats'''
			print  @miscprint
			select @miscprint = 'go'
			print  @miscprint
			Print ' '
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			select @miscprint = '	,REPLACE"'''
			print  @miscprint

			select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
			print  @miscprint
			select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
			print  @miscprint
			select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
			print  @miscprint
			select @miscprint = 'go'
			print  @miscprint
			Print ' '
		   end
		Else
		   begin
			Select @miscprint = '         ,stats'
			Print  @miscprint
			Print  @G_O
			Print  ' '
		   end
	   end



	--  Process Differential File if found
	If @maxBSI_I > @maxBSI_D
	   begin
		Select @HoldBackupName = (select mf.physical_device_name 
					  from msdb.dbo.backupmediafamily mf, msdb.dbo.backupset bs 
					  where mf.media_set_id = bs.media_set_id
					    and mf.family_sequence_number = 1
					    and bs.backup_set_id = @maxBSI_I) 



		Select @BkUpMethod = 'MS'
		If @HoldBackupName like '%.dfl'
		   begin
			Print '--  Note:  LiteSpeed Syntax will be used for this restore'
			Print ' '
			Select @BkUpMethod = 'LS'
		   end
		If @HoldBackupName like '%.SQD'
		   begin
			Print '--  Note:  RedGate Syntax will be used for this restore'
			Print ' '
			Select @BkUpMethod = 'RG'
		   end

		If @BkUpMethod = 'LS'
		   begin
			select @miscprint = 'EXEC master.dbo.xp_restore_database'
			print  @miscprint
			select @miscprint = '  @database = ''' + @cu11DBName + ''''
			print  @miscprint
			select @miscprint = ', @filename = ''' + @HoldBackupName + ''''
			print  @miscprint
			select @miscprint = ', @with = RECOVERY'
			print  @miscprint
			select @miscprint = 'go'
			print  @miscprint
			Print ' '
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			select @miscprint = 'Declare @cmd nvarchar(4000)'
			print  @miscprint
			select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @cu11DBName + ']'
			print  @miscprint
			select @miscprint = ' FROM DISK = ''''' + @HoldBackupName + ''''''
			print  @miscprint
			select @miscprint = ' WITH RECOVERY"'''
			print  @miscprint
			select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
			print  @miscprint
			select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
			print  @miscprint
			select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
			print  @miscprint
			select @miscprint = 'go'
			print  @miscprint
			Print ' '
		   end
		Else
		   begin
			select @miscprint = 'RESTORE DATABASE ' + @cu11DBName
			print  @miscprint
			select @miscprint = 'FROM DISK = ''' + @HoldBackupName + ''''
			print  @miscprint
			select @miscprint = 'WITH RECOVERY,'
			print  @miscprint
			select @miscprint = 'stats'
			print  @miscprint
			select @miscprint = 'go'
			print  @miscprint
			Print ' '
		   end

	   end


	Print  ' '
	Select @miscprint = 'select getdate()'
	Print  @miscprint
	Print  @G_O
	Print  ' '

	Select @output_flag = 'y' 

	skip_dbname:

	--  Remove this record from @dbnames and go to the next
	delete from @dbnames where name = @cu11DBName
	If (select count(*) from @dbnames) > 0
	   begin
		goto start_dbnames
	   end


   end

---------------------------  Finalization  -----------------------

drop table #filenames
drop table #holdbackupnames


If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSdbRestore_singleDB
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSdbRestore_singleDB]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSdbRestore_singleDB]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_SYSdbRestore_singleDB (@dbname sysname = null)

/*********************************************************
 **  Stored Procedure dbasp_SYSdbRestore_singleDB                  
 **  Written by Jim Wilson, Getty Images                
 **  September 20, 2007                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Restore databases  
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	09/20/2007	Jim Wilson		New process
--	09/21/2007	Jim Wilson		Updated for SQL2005.
--	06/11/2008	Jim Wilson		Change sys.sysfiles to sys.database_files.
--	04/14/2009	Jim Wilson		Errorfor DB not online.
--	======================================================================================

/*
declare @dbname sysname

select @dbname = 'Getty_Images_US_Inc__MSCRM'
--*/

-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar(255)
	,@cmd				nvarchar(500)
	,@G_O				nvarchar(2)
	,@firstflag			char(1)
	,@HoldBackupName		nvarchar(260)
	,@error_count			int
	,@maxBSI_D			int
	,@maxBSI_I			int
	,@maxBSI_L			int
	,@backup_set_id_end 		int
	,@output_flag			char(1)
	,@BkUpMethod			nvarchar(10)
	,@Holdfamily_sequence_number	tinyint
	,@hold_from			nvarchar(5)
	,@hold_comma			nvarchar(1)
	,@save_backup_set_id		int
	,@save_bkfile_name		nvarchar(500)

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint

DECLARE
	 @cu22fileid		int
	,@cu22name		nvarchar(128)
	,@cu22filename		nvarchar(260)

DECLARE
	 @cu23fileid		int
	,@cu23name		nvarchar(128)
	,@cu23filename		nvarchar(260)

----------------  initial values  -------------------
Select @error_count 	= 0
Select @G_O		= 'g' + 'o'
Select @output_flag	= 'n'
Select @BkUpMethod 	= 'MS'


--  Create table variable
create table #filenames (fileid		int
			,groupid	smallint
			,name		sysname
			,filename	sysname
			)

create table #lognames (backup_set_id	int
			,bkfile_name	nvarchar(500)
			)

create table #holdbackupnames	(filename		sysname
				,family_sequence_number	tinyint
				,process_flag		char(1)
				)


/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------


Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSdbRestore_singleDB'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '

--  Check input parms
if not exists (select * from master.sys.databases where name = @dbname)
   BEGIN
	Select @miscprint = 'DBA WARNING: Invalid input parm for @dbname' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   END

if DATABASEPROPERTYEX (@cu11DBName ,'status') <> 'ONLINE'
   begin
	Select @miscprint = 'DBA WARNING: Database not online.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end




/****************************************************************
 *                MainLine
 ***************************************************************/

Select @cu11DBName = @dbname
Select @cu11DBId = database_id from master.sys.databases with (NOLOCK) where name = @cu11DBName


----------------------  Print the headers  ----------------------
Print  ' '
Print  '/*********************************************************'
Select @miscprint = 'Restore for Database: ' + @cu11DBName  
Print  @miscprint
Print  ' '
Select @miscprint = 'Note: Prior to running the following restore command,'  
Print  @miscprint
Select @miscprint = '      some changes in the syntax may be required, such'
Print  @miscprint
Select @miscprint = '      as the name of the backup file, or the path of the'  
Print  @miscprint
Select @miscprint = '      restored files.' 
Print  @miscprint
Print  '*********************************************************/'
Print  ' ' 
 
Select @firstflag = 'y'

--------------------  Capture File Names  -------------------
Select @cmd = 'Insert into #filenames (fileid, groupid, name, filename)
SELECT f.file_id, f.data_space_id, f.name, f.physical_name
From [' + @cu11DBName + '].sys.database_files  f with (NOLOCK)'

EXEC sp_executesql @cmd

delete from #filenames where name is null or name = '' or fileid is null
--select * from #filenames

If (select count(*) from #filenames) > 0
   begin
	Select @output_flag = 'y' 

	start_filenames:

	Select @cu22fileid = (select top 1 fileid from #filenames order by fileid)
	Select @cu22name = name from #filenames where fileid = @cu22fileid
	Select @cu22filename = filename from #filenames where fileid = @cu22fileid

	Select @cu23fileid = (select top 1 fileid from #filenames where groupid = 0 order by fileid)
	Select @cu23name = name from #filenames where fileid = @cu23fileid
	Select @cu23filename = filename from #filenames where fileid = @cu23fileid

	If @firstflag = 'y'
	   begin
		Select @maxBSI_D = 0
		Select @maxBSI_I = 0
		Select @firstflag = 'n'
		Select @maxBSI_D = (select max(bf.backup_set_id) 
					from msdb.dbo.backupfile bf, msdb.dbo.backupset bs 
					where bf.backup_set_id = bs.backup_set_id
					and bs.type = 'D'
					and bs.database_name = @cu11DBName
					and bf.logical_name = @cu22name 
					and bf.physical_name = @cu22filename)

 		
		Select @maxBSI_I = (select max(bf.backup_set_id) 
					from msdb.dbo.backupfile bf, msdb.dbo.backupset bs 
					where bf.backup_set_id = bs.backup_set_id
					and bs.type = 'I'
					and bs.database_name = @cu11DBName
					and bf.logical_name = @cu22name 
					and bf.physical_name = @cu22filename) 


		Select @maxBSI_L = (select max(bf.backup_set_id) 
					from msdb.dbo.backupfile bf, msdb.dbo.backupset bs 
					where bf.backup_set_id = bs.backup_set_id
					and bs.type = 'L'
					and bs.database_name = @cu11DBName
					and bf.logical_name = @cu23name 
					and bf.physical_name = @cu23filename) 


		delete from #holdbackupnames

		--  Capture backup file name(s)
		Insert into #holdbackupnames (filename, family_sequence_number)
		select mf.physical_device_name, mf.family_sequence_number
		from msdb.dbo.backupmediafamily mf, msdb.dbo.backupset bs 
		where mf.media_set_id = bs.media_set_id
		  and bs.backup_set_id = @maxBSI_D

		delete from #holdbackupnames where filename is null or filename = ''
		--select * from #holdbackupnames


		Select @HoldBackupName = (select top 1 filename from #holdbackupnames order by family_sequence_number) 
		

		Select @miscprint = 'select @@servername, getdate()'
		Print  @miscprint
		Print  @G_O
		Print  ' '
		Print  ' '

		--  Check file name to determine if we can process the file
		If @HoldBackupName like '%.bkp%'
		   begin
			Print '--  Note:  LiteSpeed Syntax will be used for this restore'
			Print ' '
			Select @BkUpMethod = 'LS'
		   end

		If @HoldBackupName like '%.sqb%'
		   begin
			Print '--  Note:  RedGate Syntax will be used for this restore'
			Print ' '
			Select @BkUpMethod = 'RG'
		   end


		If @HoldBackupName is not null
		   begin
			If @BkUpMethod = 'LS'
			   begin
				select @miscprint = 'Print ''--  LiteSpeed SQL restore database for [' + @dbname + '] using file (' + @HoldBackupName + ')'''
				print  @miscprint

				select @miscprint = 'EXEC master.dbo.xp_restore_filelistonly'
				print  @miscprint
				select @miscprint = '  @filename = ''' + @HoldBackupName + ''''
				print  @miscprint
				print  ''
				select @miscprint = 'EXEC master.dbo.xp_restore_database'
				print  @miscprint
				select @miscprint = '  @database =  ''' + @cu11DBName + ''''
				print  @miscprint
				select @miscprint = ', @filename = ''' + @HoldBackupName + ''''
				print  @miscprint
				select @miscprint = ', @with = NORECOVERY'
				print  @miscprint
				select @miscprint = ', @with = ''REPLACE'''
				print  @miscprint
			   end
			Else If @BkUpMethod = 'RG'
			   begin
				select @miscprint = 'Print ''--  RedGate SQL restore database for [' + @dbname + '] using file (' + @HoldBackupName + ')'''
				print  @miscprint

				select @miscprint = 'Exec master.dbo.sqlbackup ''-SQL "RESTORE FILELISTONLY FROM DISK = ''''' + @HoldBackupName + '''''"'''
				print  @miscprint
				select @miscprint = 'go'
				print  @miscprint
				print  ''
				select @miscprint = 'Declare @cmd nvarchar(4000)'
				print  @miscprint
				select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @cu11DBName + ']'
				print  @miscprint
				select @miscprint = '	 FROM DISK = ''''' + @HoldBackupName + ''''''
				print  @miscprint
				select @miscprint = '	 WITH NORECOVERY'
				print  @miscprint
			   end
			Else
			   begin
				select @miscprint = 'Print ''--  Standard SQL restore database for [' + @dbname + '] using file (' + @HoldBackupName + ')'''
				print  @miscprint

				Select @miscprint = 'RESTORE FILELISTONLY'
				Print  @miscprint

				update #holdbackupnames set process_flag = 'n'
				Select @hold_from = 'FROM '
				Select @hold_comma = ''
				start_holdbackupnames_01:
				Select @Holdfamily_sequence_number = (select top 1 family_sequence_number from #holdbackupnames where process_flag = 'n' order by family_sequence_number) 
				Select @HoldBackupName = (select filename from #holdbackupnames where family_sequence_number = @Holdfamily_sequence_number)
				If (select count(*) from #holdbackupnames where process_flag = 'y') > 0
				   begin
					Select @hold_from = '    '
					Select @hold_comma = ','
				   end

				Select @miscprint = @hold_from + '     ' + + @hold_comma + 'Disk = ''' + @HoldBackupName + ''''
				Print  @miscprint

				update #holdbackupnames set process_flag = 'y' where family_sequence_number = @Holdfamily_sequence_number
				If (select count(*) from #holdbackupnames where process_flag = 'n') > 0
				   begin
					goto start_holdbackupnames_01
				   end


				Print  @G_O
				Print  ' '
				Select @miscprint = 'RESTORE DATABASE ' + @cu11DBName
				Print  @miscprint

				update #holdbackupnames set process_flag = 'n'
				Select @hold_from = 'FROM '
				Select @hold_comma = ''
				start_holdbackupnames_02:
				Select @Holdfamily_sequence_number = (select top 1 family_sequence_number from #holdbackupnames where process_flag = 'n' order by family_sequence_number) 
				Select @HoldBackupName = (select filename from #holdbackupnames where family_sequence_number = @Holdfamily_sequence_number)
				If (select count(*) from #holdbackupnames where process_flag = 'y') > 0
				   begin
					Select @hold_from = '    '
					Select @hold_comma = ','
				   end

				Select @miscprint = @hold_from + '     ' + + @hold_comma + 'Disk = ''' + @HoldBackupName + ''''
				Print  @miscprint

				update #holdbackupnames set process_flag = 'y' where family_sequence_number = @Holdfamily_sequence_number
				If (select count(*) from #holdbackupnames where process_flag = 'n') > 0
				   begin
					goto start_holdbackupnames_02
				   end

				select @miscprint = 'WITH      NORECOVERY'
				print  @miscprint
				select @miscprint = '         ,REPLACE'
				print  @miscprint

			   end
		   end
		Else
		   begin
			Select @miscprint = '-- Warning:  No Backup File found for database: ' + @cu11DBName
			Print  @miscprint
			Select @miscprint = ' '
			Print  @miscprint
			Select @miscprint = '-- Note:  The following lines document this databases file names and paths'
			Print  @miscprint
			Select @miscprint = '--        and can be used as part of a database restore script.'
			Print  @miscprint
			Select @miscprint = ' '
			Print  @miscprint
		   end
	   end

	If @HoldBackupName is not null
	   begin
		If @BkUpMethod = 'LS'
		   begin
			select @miscprint = ', @with = ''MOVE "' + rtrim(@cu22name) + '" to "' + rtrim(@cu22filename) + '"'''
			print  @miscprint
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			select @miscprint = '	,MOVE ''''' + rtrim(@cu22name) + ''''' to ''''' + rtrim(@cu22filename) + ''''''
			print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '         ,MOVE ''' + rtrim(@cu22name) + '''' + ' to ' + '''' + rtrim(@cu22filename) + ''''
			Print  @miscprint
		   end
	   end
	Else
	   begin
		Select @miscprint = '--       ,MOVE ''' + rtrim(@cu22name) + '''' + ' to ' + '''' + rtrim(@cu22filename) + ''''
		Print  @miscprint
	   end

	
	--  Remove this record from #filenames and go to the next
	delete from #filenames where fileid = @cu22fileid
	If (select count(*) from #filenames) > 0
	   begin
		goto start_filenames
	   end

   end



If @HoldBackupName is not null
   begin
	If @BkUpMethod = 'LS'
	   begin
		select @miscprint = ', @with = ''stats'''
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		select @miscprint = '	,REPLACE"'''
		print  @miscprint

		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
		print  @miscprint
		select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end
	Else
	   begin
		Select @miscprint = '         ,stats'
		Print  @miscprint
		Print  @G_O
		Print  ' '
	   end
   end


--  Process Differential File if found
If @maxBSI_I > @maxBSI_D
   begin
	Select @HoldBackupName = (select mf.physical_device_name 
				  from msdb.dbo.backupmediafamily mf, msdb.dbo.backupset bs 
				  where mf.media_set_id = bs.media_set_id
				    and mf.family_sequence_number = 1
				    and bs.backup_set_id = @maxBSI_I) 


	Select @BkUpMethod = 'MS'
	If @HoldBackupName like '%.dfl'
	   begin
		Print '--  Note:  LiteSpeed Syntax will be used for this restore'
		Print ' '
		Select @BkUpMethod = 'LS'
	   end

	If @HoldBackupName like '%.SQD'
	   begin
		Print '--  Note:  RedGate Syntax will be used for this restore'
		Print ' '
		Select @BkUpMethod = 'RG'
	   end


	If @BkUpMethod = 'LS'
	   begin
		select @miscprint = 'Print ''--  LiteSpeed SQL restore differential for [' + @dbname + '] using file (' + @HoldBackupName + ')'''
		print  @miscprint
		select @miscprint = 'EXEC master.dbo.xp_restore_database'
		print  @miscprint
		select @miscprint = '  @database = ''' + @cu11DBName + ''''
		print  @miscprint
		select @miscprint = ', @filename = ''' + @HoldBackupName + ''''
		print  @miscprint
		select @miscprint = ', @with = NORECOVERY'
		print  @miscprint
		select @miscprint = ', @with = ''stats'''
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		select @miscprint = 'Print ''--  RedGate SQL restore differential for [' + @dbname + '] using file (' + @HoldBackupName + ')'''
		print  @miscprint
		select @miscprint = 'Declare @cmd nvarchar(4000)'
		print  @miscprint
		select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @cu11DBName + ']'
		print  @miscprint
		select @miscprint = ' FROM DISK = ''''' + @HoldBackupName + ''''''
		print  @miscprint
		select @miscprint = ' WITH NORECOVERY"'''
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
		print  @miscprint
		select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end
	Else
	   begin
		select @miscprint = 'Print ''--  Standard SQL restore differential for [' + @dbname + '] using file (' + @HoldBackupName + ')'''
		print  @miscprint
		select @miscprint = 'RESTORE DATABASE ' + @cu11DBName
		print  @miscprint
		select @miscprint = 'FROM DISK = ''' + @HoldBackupName + ''''
		print  @miscprint
		select @miscprint = 'WITH NORECOVERY,'
		print  @miscprint
		select @miscprint = 'stats'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end

   end



--  Process transaction logs
If @maxBSI_I is not null and @maxBSI_L is not null
   begin
	If @maxBSI_L > @maxBSI_I
	   begin
		SELECT @backup_set_id_end = MIN(backup_set_id) 
						FROM  msdb.dbo.backupset 
						WHERE database_name = @cu11DBName AND type = 'I'
						AND backup_set_id > @maxBSI_I

		IF @backup_set_id_end IS NULL 
		   begin
			SET @backup_set_id_end = 999999999
		   end

		delete from #lognames

		insert into #lognames
		select bs.backup_set_id, mf.physical_device_name 
		from msdb.dbo.backupfile bf, msdb.dbo.backupset bs, msdb.dbo.backupmediafamily mf
		where bf.backup_set_id = bs.backup_set_id
		and bs.database_name = @cu11DBName
		and mf.media_set_id = bs.media_set_id
		and mf.family_sequence_number = 1
		and bs.type = 'L'
		and bf.logical_name = @cu23name 
		and bf.physical_name = @cu23filename
		and bs.backup_set_id >= @maxBSI_I
		and bs.backup_set_id < @backup_set_id_end
		order by bs.backup_set_id

	   end
   end
Else If @maxBSI_D is not null and @maxBSI_L is not null
   begin
	If @maxBSI_L > @maxBSI_D
	   begin
		SELECT @backup_set_id_end = MIN(backup_set_id) 
						FROM  msdb.dbo.backupset 
						WHERE database_name = @cu11DBName AND type = 'D'
						AND backup_set_id > @maxBSI_I

		IF @backup_set_id_end IS NULL 
		   begin
			SET @backup_set_id_end = 999999999
		   end

		delete from #lognames

		insert into #lognames
		select bs.backup_set_id, mf.physical_device_name 
		from msdb.dbo.backupfile bf, msdb.dbo.backupset bs, msdb.dbo.backupmediafamily mf
		where bf.backup_set_id = bs.backup_set_id
		and bs.database_name = @cu11DBName
		and mf.media_set_id = bs.media_set_id
		and mf.family_sequence_number = 1
		and bs.type = 'L'
		and bf.logical_name = @cu23name 
		and bf.physical_name = @cu23filename
		and bs.backup_set_id >= @maxBSI_D
		order by bs.backup_set_id

	   end
   end

If (select count(*) from #lognames) > 0
   begin
	start_log01:

	Select @save_backup_set_id = (select top 1 backup_set_id from #lognames order by backup_set_id)
	Select @save_bkfile_name = (select bkfile_name from #lognames where backup_set_id = @save_backup_set_id)

	Select @BkUpMethod = 'MS'
	If @save_bkfile_name like '%.tnl'
	   begin
		Print '--  Note:  LiteSpeed Syntax will be used for this restore'
		Print ' '
		Select @BkUpMethod = 'LS'
	   end

	If @save_bkfile_name like '%.SQT'
	   begin
		Print '--  Note:  RedGate Syntax will be used for this restore'
		Print ' '
		Select @BkUpMethod = 'RG'
	   end


	If @BkUpMethod = 'LS'
	   begin
		select @miscprint = 'Print ''--  LiteSpeed SQL restore log for [' + @dbname + '] using file (' + @save_bkfile_name + ')'''
		print  @miscprint
		select @miscprint = 'EXEC master.dbo.xp_restore_log'
		print  @miscprint
		select @miscprint = '  @database = ''' + @cu11DBName + ''''
		print  @miscprint
		select @miscprint = ', @filename = ''' + @save_bkfile_name + ''''
		print  @miscprint
		select @miscprint = ', @with = NORECOVERY'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		select @miscprint = 'Print ''--  RedGate SQL restore log for [' + @dbname + '] using file (' + @save_bkfile_name + ')'''
		print  @miscprint
		select @miscprint = 'Declare @cmd nvarchar(4000)'
		print  @miscprint
		select @miscprint = 'Select @cmd = ''-SQL "RESTORE LOG [' + @cu11DBName + ']'
		print  @miscprint
		select @miscprint = ' FROM DISK = ''''' + @save_bkfile_name + ''''''
		print  @miscprint
		select @miscprint = ' WITH NORECOVERY"'''
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
		print  @miscprint
		select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end
	Else
	   begin
		select @miscprint = 'Print ''--  Standard SQL restore log for [' + @dbname + '] using file (' + @save_bkfile_name + ')'''
		print  @miscprint
		select @miscprint = 'RESTORE LOG ' + @cu11DBName
		print  @miscprint
		select @miscprint = 'FROM DISK = ''' + @save_bkfile_name + ''''
		print  @miscprint
		select @miscprint = 'WITH NORECOVERY,'
		print  @miscprint
		select @miscprint = 'stats'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end


	Delete from #lognames where backup_set_id = @save_backup_set_id
	If (select count(*) from #lognames) > 0
	   begin
		goto start_log01
	   end

   end


If @output_flag = 'y'
   begin
	select @miscprint = '--  Note:  Complete restore using standard tsql "with recovery"'
	print  @miscprint
	Print ' '
	select @miscprint = 'Print ''--  Note:  Complete restore for [' + @dbname + '] using standard tsql "with recovery"'''
	print  @miscprint
	select @miscprint = 'RESTORE DATABASE ' + @dbname + ' WITH RECOVERY'
	print  @miscprint
	select @miscprint = 'go'
	print  @miscprint
	Print ' '
   end

Print  ' '
Select @miscprint = 'select getdate()'
Print  @miscprint
Print  @G_O
Print  ' '


---------------------------  Finalization  -----------------------
label99:

drop table #filenames
drop table #lognames
drop table #holdbackupnames


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSdetach_userDBs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSdetach_userDBs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSdetach_userDBs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_SYSdetach_userDBs


/**************************************************************
 **  Stored Procedure dbasp_SYSdetach_userDBs                  
 **  Written by Jim Wilson, Getty Images                
 **  June 10, 2002                                      
 **  
 **  This dbasp is set up to create a script that will
 **  detach all user databases.
 ** 
 **  Output member is SYSdetach_userDBs.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	06/10/2002	Jim Wilson		Created
--	06/21/2002	Jim Wilson		Removed bracket formatting for database name.
--	02/21/2006	Jim Wilson		Modified for sql 2005
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@cmd			nvarchar(500)

DECLARE
	 @cu11DBName	sysname
	,@cu11DBId		smallint


----------------  initial values  -------------------


--  Create table variable
declare @dbnames table	
			(name		sysname
			,dbid		smallint
			)

declare @filenames table	
			(fileid		smallint
			,name		sysname
			,filename	nvarchar(260)
			)


/****************************************************************
 *                MainLine
 ***************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/**************************************************************'
Select @miscprint = 'Generated SQL - SYSdetach_userDBs'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '**************************************************************/'
Print  ' '


Select @cmd = 'SELECT d.name, d.dbid
   From master.sys.sysdatabases   d ' + 
  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

delete from @DBnames

insert into @DBnames (name, dbid) exec (@cmd)

delete from @DBnames where name is null or name = ''
--select * from @DBnames


If (select count(*) from @DBnames) > 0
   begin
	start_dbnames:

	Select @cu11DBId = (select top 1 dbid from @DBnames order by dbid)
	Select @cu11DBName = (select name from @DBnames where dbid = @cu11DBId)


	----------------------  Print the headers  ----------------------
	Print  ' '
	Print  '/*********************************************************'
	Select @miscprint = 'detach files for Database: ' + @cu11DBName  
	Print  @miscprint
	Print  ' '
	Print  '*********************************************************/'
	Print  ' ' 
	Print  'Use [master]' 
	Print  'go' 
	Print  ' ' 

	--  Now check to see if there are any full-text catalogs associated with this database
	Select @cmd = 'SELECT f.ftcatid, f.name, f.path
	   From [' + @cu11DBName + '].sys.sysfulltextcatalogs  f '

	delete from @filenames

	insert into @filenames (fileid, name, filename) exec (@cmd)

	delete from @filenames where name is null or name = ''
	--select * from @filenames

	If (select count(*) from @filenames) > 0
	   begin
		Select @miscprint = 'exec sp_detach_db @dbname = ''' + rtrim(@cu11DBName) + ''', @skipchecks = ''true'', @KeepFulltextIndexFile = ''true'';'
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = 'exec sp_detach_db @dbname = ''' + rtrim(@cu11DBName) + ''', @skipchecks = ''true'';'
		Print  @miscprint
	   end


	Print  'go '
	Print  ' '
	Print  ' '


	--  Check for more rows to process
	Delete from @DBnames where dbid = @cu11DBId
	If (select count(*) from @DBnames) > 0
	   begin
		goto start_dbnames
	  end

   end


---------------------------  Finalization -----------------------






 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSdropDBusers
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSdropDBusers]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSdropDBusers]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_SYSdropDBusers

/*********************************************************
 **  Stored Procedure dbasp_SYSdropDBusers                  
 **  Written by Jim Wilson, Getty Images                
 **  October 11, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  revoke database access  
 **        
 **  Output member is SYSdropDBusers.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	05/06/2002	Jim Wilson		Changed dbname type to sysname.
--	06/11/2002	Jim Wilson		Added brackets around DB name in use stmt.
--	08/27/2002	Jim Wilson		Added code for deleting all users.
--	10/11/2002	Jim Wilson		Changed code for deleting all users - now
--						referencing the 'islogin' field.
--	04/14/2003	Jim Wilson		Added code for cleaning up permissions and objects owners
--	11/10/2006	Jim Wilson		Modified for SQL 2005.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@G_O			nvarchar(2)
	,@filegrowth		nvarchar(20)
	,@output_flag		char(1)
	,@output_flag2		char(1)

DECLARE
	 @cu11DBName		sysname
	,@cu11DBId		smallint
	,@cu11DBStatus		int

DECLARE
	 @cu22name		sysname
	,@cu22type		sysname
	,@cu22principal_id	int

----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @output_flag	= 'n'
Select @output_flag2	= 'n'


/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------


Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSdropDBusers'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  ' '
Select @miscprint = 'Drop Database Users'  
Print  @miscprint
Print  '************************************************************************/'
Print  ' '

--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cu11_DBNames Insensitive Cursor For ' + 
  'SELECT d.name, d.database_id
   From master.sys.databases   d ' + 
  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')
   Order By d.name For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

OPEN cu11_DBNames

WHILE (11=11)
 Begin
	FETCH Next From cu11_DBNames Into @cu11DBName, @cu11DBId
	IF (@@fetch_status < 0)
           begin
              CLOSE cu11_DBNames
	      BREAK
           end
	
 
----------------------  Print the headers  ----------------------
   Print  ' '
   Print  '/****************************************************'
   Select @miscprint = 'Drop Users for Database: ' + @cu11DBName  
   Print  @miscprint
   Print  '****************************************************/'
   Select @miscprint = 'USE [' + @cu11DBName + ']'
   Print  @miscprint  
   Print  @G_O
   Print  ' ' 
  

--------------------  Cursor for 22DB  -----------------------

EXECUTE('DECLARE cu22_DBAccess Insensitive Cursor For ' + 
  'SELECT dp.name, dp.type, dp.principal_id
   From [' + @cu11DBName + '].sys.database_principals  dp ' + 
  'Where dp.type <> ''R''
and dp.principal_id > 4
   Order By dp.type, dp.name For Read Only')

OPEN cu22_DBAccess

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBAccess Into @cu22name, @cu22type, @cu22principal_id 
	IF (@@fetch_status < 0)
           begin
              CLOSE cu22_DBAccess
	      BREAK
           end


	Select @miscprint = '--  DROP User ' + @cu22name + '  --------------------------------------------------------------------'
	Print  @miscprint
	Select @miscprint = 'If exists (select 1 from ' + @cu11DBName + '.sys.schemas  s, ' + @cu11DBName + '.sys.database_principals  dp'
	Print  @miscprint
	Select @miscprint = '                    where dp.name = ''' + @cu22name + ''' and s.principal_id = dp.principal_id)'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '      Declare @save_sname sysname'
	Print  @miscprint
	Select @miscprint = '      Declare @cmd nvarchar(500)'
	Print  @miscprint
	Select @miscprint = '      drop_user01:'
	Print  @miscprint
	Select @miscprint = '      Select @save_sname = (select top 1 s.name from ' + @cu11DBName + '.sys.schemas  s, ' + @cu11DBName + '.sys.database_principals  dp'
	Print  @miscprint
	Select @miscprint = '                                              where dp.name = ''' + @cu22name + ''' and s.principal_id = dp.principal_id)'
	Print  @miscprint
	Select @miscprint = '      Select @cmd = ''ALTER AUTHORIZATION ON SCHEMA::['' + @save_sname + ''] TO dbo;'''
	Print  @miscprint
	Select @miscprint = '      Print @cmd'
	Print  @miscprint
	Select @miscprint = '      Exec (@cmd)'
	Print  @miscprint
	Select @miscprint = '      If exists (select 1 from ' + @cu11DBName + '.sys.schemas  s, ' + @cu11DBName + '.sys.database_principals  dp'
	Print  @miscprint
	Select @miscprint = '                          where dp.name = ''' + @cu22name + ''' and s.principal_id = dp.principal_id)'
	Print  @miscprint
	Select @miscprint = '         begin'
	Print  @miscprint
	Select @miscprint = '            goto drop_user01'
	Print  @miscprint
	Select @miscprint = '         end'
	Print  @miscprint
	Select @miscprint = '   end'
	Print  @miscprint
	Print  ' '


	Select @miscprint = 'Print ''Drop User [' + @cu22name + ']'''
	Print  @miscprint
	Select @miscprint = 'drop user [' + @cu22name + '];'
	Print  @miscprint
	Print  @G_O
	Print  ' '
	Print  ' '


   End  -- loop 22
   DEALLOCATE cu22_DBAccess



	Select @miscprint = '---------------------------------------------------------------------------------------------------------------------------'
	Print  @miscprint
	Select @miscprint = '--  Use the Following code to DROP all Users from ''' + @cu11DBName + ''''
	Print  @miscprint
	Select @miscprint = '---------------------------------------------------------------------------------------------------------------------------'
	Print  @miscprint
	Select @miscprint = 'If exists (select 1 from ' + @cu11DBName + '.sys.schemas where principal_id > 4 and principal_id < 16384)'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '      Declare @save_sname sysname'
	Print  @miscprint
	Select @miscprint = '      Declare @cmd nvarchar(500)'
	Print  @miscprint
	Select @miscprint = '      drop_user02:'
	Print  @miscprint
	Select @miscprint = '      Select @save_sname = (select top 1 name from ' + @cu11DBName + '.sys.schemas where principal_id > 4 and principal_id < 16384)'
	Print  @miscprint
	Select @miscprint = '      Select @cmd = ''ALTER AUTHORIZATION ON SCHEMA::['' + @save_sname + ''] TO dbo;'''
	Print  @miscprint
	Select @miscprint = '      Print @cmd'
	Print  @miscprint
	Select @miscprint = '      Exec (@cmd)'
	Print  @miscprint
	Select @miscprint = '      If exists (select 1 from ' + @cu11DBName + '.sys.schemas where principal_id > 4 and principal_id < 16384)'
	Print  @miscprint
	Select @miscprint = '         begin'
	Print  @miscprint
	Select @miscprint = '            goto drop_user02'
	Print  @miscprint
	Select @miscprint = '         end'
	Print  @miscprint
	Select @miscprint = '   end'
	Print  @miscprint
	Print  @G_O
	Print  ' '

	Select @miscprint = 'If exists (select 1 from ' + @cu11DBName + '.sys.database_principals where principal_id > 4 and type <> ''R'')'
	Print  @miscprint
	Select @miscprint = '   begin'
	Print  @miscprint
	Select @miscprint = '      Declare @save_uname sysname'
	Print  @miscprint
	Select @miscprint = '      Declare @cmd nvarchar(500)'
	Print  @miscprint
	Select @miscprint = '      drop_user03:'
	Print  @miscprint
	Select @miscprint = '      Select @save_uname = (select top 1 name from ' + @cu11DBName + '.sys.database_principals where principal_id > 4 and type <> ''R'')'
	Print  @miscprint
	Select @miscprint = '      Select @cmd = ''DROP USER ['' + @save_uname + ''];'''
	Print  @miscprint
	Select @miscprint = '      Print @cmd'
	Print  @miscprint
	Select @miscprint = '      Exec (@cmd)'
	Print  @miscprint
	Select @miscprint = '      If exists (select 1 from ' + @cu11DBName + '.sys.database_principals where principal_id > 4 and type <> ''R'')'
	Print  @miscprint
	Select @miscprint = '         begin'
	Print  @miscprint
	Select @miscprint = '            goto drop_user03'
	Print  @miscprint
	Select @miscprint = '         end'
	Print  @miscprint
	Select @miscprint = '   end'
	Print  @miscprint
	Print  ' '
	Print  ' '
        

Select @output_flag2 = 'y' 


 End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cu11_DBNames

If @output_flag2 = 'n'
   begin
	Print '-- No output for this script.'
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSgrantobjectprivileges
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSgrantobjectprivileges]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSgrantobjectprivileges]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.dbasp_SYSgrantobjectprivileges (@outpath varchar(100) = null
						,@suppress_use_stmt nchar(1) = 'n'
						)

/*********************************************************
 **  Stored Procedure dbasp_SYSgrantobjectprivileges                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  grant object privileges  
 **        
 **  Input parm @outpath:  Is the path the database specific files        
 **  should be written to (e.g. \\servername\servername_dba_archive\)      
 **        
 **        
 **  Output member is SYSgrantobjectprivileges.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/30/2002	Jim Wilson		Added brackets around dbname variable in select stmts.
--	05/06/2002	Jim Wilson		Changed dbname type to sysname.
--	06/07/2002	Jim Wilson		Modified output path to handel cluster instance.
--	06/11/2002	Jim Wilson		Added brackets around DB name in use stmt.
--	06/28/2002	Jim Wilson		Adjusted osql output.
--	08/02/2002	Jim Wilson		Added 'no_output' parm to xp_cmdshell command.
--	09/24/2002	Jim Wilson		Modified default output share
--	04/18/2003	Jim Wilson		Changes for new instance share names.
--	05/24/2006	Jim Wilson		Updated for SQL 2005.
--	11/30/2006	Jim Wilson		Added suppress of the use stmt (for sfp processing)
--	03/12/2008	Jim Wilson		Many updates including now using sys.all_objects
--						and including master and msdb.
--	======================================================================================

/*
Declare @outpath varchar(100)
Declare @suppress_use_stmt nchar(1)

Select @outpath = null
Select @suppress_use_stmt = 'n'
--*/

DECLARE
	 @miscprint		nvarchar(255)
	,@grantoption		nvarchar (25)
	,@G_O			nvarchar  (2)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_servername3	sysname
	,@charpos		int	
	,@cmd			nvarchar(255)
	,@result		int
	,@outfilename		sysname
	,@outfullpath		nvarchar(250)
	,@sqlcmd		nvarchar(4000)
	,@selectcmd		nvarchar(4000)
	,@output_flag		char(1)
	,@output_flag2		char(1)

DECLARE
	 @cu11DBName		sysname

DECLARE
	 @cu22action		int
	,@cu22protecttype	int
	,@cu22puid		int
	,@cu22objtype		nvarchar(20)
	,@cu22Schemaname	sysname
	,@cu22OBJname		sysname
	,@cu22grantee		sysname
	,@cu22uid		smallint
	,@cu22id		int
	,@cu22is_ms_shipped	bit	

Declare
	 @cu33ActionName	sysname
	,@cu33ProtectTypeName	sysname
	,@cu33OwnerName		sysname
	,@cu33ObjectName	sysname
	,@cu33GranteeName	sysname
	,@cu33ColumnName	sysname
	,@cu33All_Col_Bits_On	tinyint

----------------  initial values  -------------------
Select @G_O			= 'go'
Select @selectcmd		= 'set nocount on select * from ##output01'
Select @output_flag		= 'n'
Select @output_flag2		= 'n'
Select @save_servername		= @@servername
Select @save_servername2	= @@servername
Select @save_servername3	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
	select @save_servername3 = @save_servername3 + ')'
   end

If @outpath is null
   begin
	Select @outpath = '\\' + @save_servername + '\' + @save_servername2 + '_dba_archive\' 
   end


/*********************************************************************
 *                Initialization
 ********************************************************************/

-- Create temp table for DENY processing
If (object_id('tempdb..#t1_Prots') is not null)
            drop table #t1_Prots

CREATE Table #t1_Prots
	(Id			int				Null
	,Type1Code		char(6)			NOT Null
	,ObjType		char(2)			Null
	,ActionName		varchar(20)		Null
	,ActionCategory		char(2)			Null
	,ProtectTypeName	char(10)		Null
	,Columns_Orig		varbinary(32)	Null
	,OwnerName		sysname			Null
	,ObjectName		sysname			Null
	,GranteeName		sysname			Null
	,GrantorName		sysname			Null
	,ColumnName		sysname			Null
	,ColId			smallint		Null
	,Max_ColId		smallint		Null
	,All_Col_Bits_On	tinyint			Null
	,new_Bit_On		tinyint			Null 
	)

----------------------  Main header  ----------------------
Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSgrantobjectprivileges'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'

--------------------  Cursor for DB names  -------------------

EXECUTE('DECLARE cursor_11DBNames Insensitive Cursor For ' + 
  'SELECT d.name
   From master.sys.databases   d ' + 
  'Where d.name not in (''model'', ''tempdb'')
  Order By d.database_id For Read Only')


/****************************************************************
 *                MainLine
 ***************************************************************/

OPEN cursor_11DBNames

WHILE (11=11)
   Begin
	FETCH Next From cursor_11DBNames Into @cu11DBName
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11DBNames
	      BREAK
           end
	
----------------------  Print the headers  ----------------------
Print  ' '
Print  '/*********************************************************'
Select @miscprint = 'GRANT OBJECT PRIVILEGES for database ' + @cu11DBName  
Print  @miscprint
Print  '*********************************************************/'
Print  ' '

If @suppress_use_stmt = 'y'
   begin
	Select @miscprint = '--USE [' + @cu11DBName + ']'
	Print  @miscprint  
	Print  @G_O
   end
Else
   begin
	Select @miscprint = 'USE [' + @cu11DBName + ']'
	Print  @miscprint  
	Print  @G_O
   end

Select @miscprint = ' '
Print  @miscprint  
Select @miscprint = 'Print ''Start GRANT OBJECT PRIVILEGES'''
Print  @miscprint  
Select @miscprint = 'Select getdate()'
Print  @miscprint  
Print  @G_O

--------------------  Set the output file name and path  -----------------------
Select @outfilename = @save_servername3 + '_SYSgrantpriv_' + @cu11DBName + '.gsql'
Select @outfullpath = @outpath + @outfilename 


--------------------  Create the temp table for permissions  -----------------------
If (object_id('tempdb..##output01') is not null)
            drop table ##output01

CREATE TABLE ##output01 (
	[permission_commands] [nvarchar] (255) NULL 
		)

----------------------  Write headers to the temp table  ----------------------
Insert into ##output01 (permission_commands) 
values (' ')

Insert into ##output01 (permission_commands) 
values ('/****************************************************')

Select @miscprint = 'GRANT OBJECT PRIVILEGES for database ' + @cu11DBName  
Insert into ##output01 (permission_commands) 
values (@miscprint)

Select @miscprint = 'From Server: ' + @@servername + '  Created on '  + convert(varchar(30),getdate(),9)
Insert into ##output01 (permission_commands) 
values (@miscprint)

Insert into ##output01 (permission_commands) 
values ('****************************************************/')

Insert into ##output01 (permission_commands) 
values (' ')

If @suppress_use_stmt = 'y'
   begin
	Select @miscprint = '--USE [' + @cu11DBName + ']'
   end
Else
   begin
	Select @miscprint = 'USE [' + @cu11DBName + ']'
   end
Insert into ##output01 (permission_commands) 
values (@miscprint)

Insert into ##output01 (permission_commands) 
values ('GO')

Insert into ##output01 (permission_commands) 
values (' ')


Select @miscprint = 'Print ''Start GRANT OBJECT PRIVILEGES'''
Insert into ##output01 (permission_commands) 
values (@miscprint)

Select @miscprint = 'Select getdate()'
Insert into ##output01 (permission_commands) 
values (@miscprint)
  
Insert into ##output01 (permission_commands) 
values ('GO')

Insert into ##output01 (permission_commands) 
values (' ')


--  Create the temp table for sysprotects
If (object_id('tempdb..##tempprotects') is not null)
            drop table ##tempprotects

Exec('select * into ##tempprotects from ['+ @cu11DBName + '].sys.sysprotects')


--------------------  Cursor for 22out  -----------------------
 EXECUTE('DECLARE cursor_22out Insensitive Cursor For ' + 
        'SELECT distinct CONVERT(int,p.action), p.protecttype, p.uid, o.type, x.name, o.name, u.name, u.uid, p.id, o.is_ms_shipped
         From ##tempprotects  p
             , [' + @cu11DBName + '].sys.all_objects  o
             , [' + @cu11DBName + '].sys.sysusers  u
             , [' + @cu11DBName + '].sys.schemas  x
      Where  p.id = o.object_id
      And    u.uid = p.uid
      And    o.schema_id = x.schema_id
      And    p.action in (193, 195, 196, 197, 224, 26) 
      And    p.uid not in (16382, 16383)
      Order By p.uid, o.name, p.protecttype, CONVERT(int,p.action)
   For Read Only')


OPEN cursor_22out

WHILE (22=22)
   Begin
	FETCH Next From cursor_22out Into @cu22action, @cu22protecttype, @cu22puid, @cu22objtype, @cu22Schemaname, @cu22OBJname, @cu22grantee, @cu22uid, @cu22id, @cu22is_ms_shipped
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_22out
	      BREAK
           end

	If @cu22is_ms_shipped = 1 and @cu22uid < 5
	   begin
		goto skip22
	   end

	If @cu22is_ms_shipped = 1 and @cu22grantee in ('TargetServersRole'
						    , 'SQLAgentUserRole'
						    , 'SQLAgentReaderRole'
						    , 'SQLAgentOperatorRole'
						    , 'DatabaseMailUserRole'
						    , 'db_dtsadmin'
						    , 'db_dtsltduser'
						    , 'db_dtsoperator')
	   begin
		goto skip22
	   end

	If @cu22protecttype = 204
	   begin
		select @grantoption = 'WITH GRANT OPTION'
	   end
	Else
	   begin
		select @grantoption = ''
	   end


	IF @cu22action = 224 and @cu22protecttype in (204, 205)
	   begin
		Print  ' '
		Insert into ##output01 (permission_commands) 
		values (' ')
		Select @miscprint = 'GRANT EXECUTE ON OBJECT::[' + @cu22Schemaname + '].[' + @cu22OBJname + '] to [' + @cu22grantee + '] ' + @grantoption
		Print  @miscprint
		Insert into ##output01 (permission_commands) 
		values (@miscprint)
		Print  @G_O
		Insert into ##output01 (permission_commands) 
		values ('GO')

	   end
	ELSE
	IF @cu22action = 26 and @cu22protecttype in (204, 205) 
	   begin
		Print  ' '
		Insert into ##output01 (permission_commands) 
		values (' ')
		Select @miscprint = 'GRANT REFERENCES ON [' + @cu22Schemaname + '].[' + @cu22OBJname + '] to [' + @cu22grantee + '] ' + @grantoption
		Print  @miscprint
		Insert into ##output01 (permission_commands) 
		values (@miscprint)
		Print  @G_O
		Insert into ##output01 (permission_commands) 
		values ('GO')
	   end
	ELSE
	IF @cu22action = 193 and @cu22protecttype in (204, 205) 
	   begin
		Print  ' '
		Insert into ##output01 (permission_commands) 
		values (' ')
		Select @miscprint = 'GRANT SELECT ON OBJECT::[' + @cu22Schemaname + '].[' + @cu22OBJname + '] to [' + @cu22grantee + '] ' + @grantoption
		Print  @miscprint
		Insert into ##output01 (permission_commands) 
		values (@miscprint)
		Print  @G_O
		Insert into ##output01 (permission_commands) 
		values ('GO')
	   end
	ELSE
	IF @cu22action = 195 and @cu22protecttype in (204, 205)
	   begin
		Print  ' '
		Insert into ##output01 (permission_commands) 
		values (' ')
		Select @miscprint = 'GRANT INSERT ON OBJECT::[' + @cu22Schemaname + '].[' + @cu22OBJname + '] to [' + @cu22grantee + '] ' + @grantoption
		Print  @miscprint
		Insert into ##output01 (permission_commands) 
		values (@miscprint)
		Print  @G_O
		Insert into ##output01 (permission_commands) 
		values ('GO')
	   end
	ELSE
	IF @cu22action = 196 and @cu22protecttype in (204, 205)
	   begin
		Print  ' '
		Insert into ##output01 (permission_commands) 
		values (' ')
		Select @miscprint = 'GRANT DELETE ON OBJECT::[' + @cu22Schemaname + '].[' + @cu22OBJname + '] to [' + @cu22grantee + '] ' + @grantoption
		Print  @miscprint
		Insert into ##output01 (permission_commands) 
		values (@miscprint)
		Print  @G_O
		Insert into ##output01 (permission_commands) 
		values ('GO')
	   end
	ELSE
	IF @cu22action = 197 and @cu22protecttype in (204, 205) 
	   begin
		Print  ' '
		Insert into ##output01 (permission_commands) 
		values (' ')
		Select @miscprint = 'GRANT UPDATE ON OBJECT::[' + @cu22Schemaname + '].[' + @cu22OBJname + '] to [' + @cu22grantee + '] ' + @grantoption
		Print  @miscprint
		Insert into ##output01 (permission_commands) 
		values (@miscprint)
		Print  @G_O
		Insert into ##output01 (permission_commands) 
		values ('GO')
	   end
	ELSE
	IF @cu22protecttype = 206 
	   begin 
		delete from #t1_Prots

		--  Insert data into the temp table
		INSERT	#t1_Prots
		        (Id
			,Type1Code
			,ObjType
			,ActionName
			,ActionCategory
			,ProtectTypeName
			,Columns_Orig
			,OwnerName
			,ObjectName
			,GranteeName
			,GrantorName
			,ColumnName
			,ColId
			,Max_ColId
			,All_Col_Bits_On
			,new_Bit_On
			)
			/*	1Regul indicates action can be at column level,
				2Simpl indicates action is at the object level */
			SELECT	sysp.id
				,case
					when sysp.columns is null then '2Simpl'
					else '1Regul'
					end
				,Null
				,val1.name
				,'Ob'
				,val2.name
				,sysp.columns
				,null
				,null
				,null
				,null
				,case
					when sysp.columns is null then '.'
					else Null
					end
				,-123
				,Null
				,Null
				,Null
			FROM	##tempprotects sysp
				,master.dbo.spt_values  val1
				,master.dbo.spt_values  val2
			where	sysp.id  = @cu22id
			and	val1.type     = 'T'
			and	val1.number   = sysp.action
			and	val2.type     = 'T' --T is overloaded.
			and	val2.number   = sysp.protecttype
			and	sysp.protecttype = 206
			and 	sysp.id != 0
			and	sysp.uid = @cu22uid


		IF EXISTS (SELECT * From #t1_Prots)
		   begin
			--  set owner name
			select @cmd = 'UPDATE #t1_Prots set OwnerName = ''' + @cu22Schemaname + ''' WHERE id = ' + convert(varchar(20), @cu22id)
			exec(@cmd)

			--  set object name
			select @cmd = 'UPDATE #t1_Prots set ObjectName = ''' + @cu22OBJname + ''' WHERE id = ' + convert(varchar(20), @cu22id)
			exec(@cmd)

			--  set grantee name
			select @cmd = 'UPDATE #t1_Prots set GranteeName = ''' + @cu22grantee + ''' WHERE id = ' + convert(varchar(20), @cu22id)
			exec(@cmd)

			--  set object type
			Exec('UPDATE #t1_Prots 
			set ObjType = ob.type
			FROM ['+ @cu11DBName + '].sys.objects ob
			WHERE ob.object_id = #t1_Prots.Id')
		
			--  set Max_ColId
			Exec('UPDATE #t1_Prots
			set Max_ColId = (select max(column_id) From ['+ @cu11DBName + '].sys.columns sysc where #t1_Prots.Id = sysc.object_id)	-- colid may not consecutive if column dropped
			where Type1Code = ''1Regul''')
		
		
			-- First bit set indicates actions pretains to new columns. (i.e. table-level permission)
			-- Set new_Bit_On accordinglly
			UPDATE	#t1_Prots 
			SET new_Bit_On = CASE convert(int,substring(Columns_Orig,1,1)) & 1
						WHEN	1 then	1
						ELSE	0
						END
			WHERE	ObjType	<> 'V'	and	 Type1Code = '1Regul'
		
			-- Views don't get new columns
			UPDATE #t1_Prots 
			set new_Bit_On = 0
			WHERE  ObjType = 'V'

			-- Indicate enties where column level action pretains to all columns in table All_Col_Bits_On = 1					*/
			Exec('UPDATE #t1_Prots
			set All_Col_Bits_On = 1
			where #t1_Prots.Type1Code = ''1Regul''
			  and not exists (select * from ['+ @cu11DBName + '].sys.columns sysc, master.dbo.spt_values v
						where #t1_Prots.Id = sysc.object_id and sysc.column_id = v.number
						and v.number <= Max_ColId		-- column may be dropped/added after Max_ColId snap-shot 
						and v.type = ''P'' and
						-- Columns_Orig where first byte is 1 means off means on and on means off
						-- where first byte is 0 means off means off and on means on
							case convert(int,substring(#t1_Prots.Columns_Orig, 1, 1)) & 1
								when 0 then convert(tinyint, substring(#t1_Prots.Columns_Orig, v.low, 1))
								else (~convert(tinyint, isnull(substring(#t1_Prots.Columns_Orig, v.low, 1),0)))
							end & v.high = 0)')
			

			-- Indicate entries where column level action pretains to only some of columns in table All_Col_Bits_On = 0
			UPDATE	#t1_Prots	
			set All_Col_Bits_On = 0
			WHERE #t1_Prots.Type1Code = '1Regul'
			  and All_Col_Bits_On is null

			Update #t1_Prots
			set ColumnName = case
						when All_Col_Bits_On = 1 and new_Bit_On = 1 then '(All+New)'
						when All_Col_Bits_On = 1 and new_Bit_On = 0 then '(All)'
						when All_Col_Bits_On = 0 and new_Bit_On = 1 then '(New)'
						end
			from #t1_Prots
			where ObjType IN ('S ' ,'U ', 'V ')
			  and Type1Code = '1Regul'
			  and NOT (All_Col_Bits_On = 0 and new_Bit_On = 0)
		
			-- Expand and Insert individual column permission rows
			Exec('INSERT	into   #t1_Prots
				(Id
				,Type1Code
				,ObjType
				,ActionName
				,ActionCategory
				,ProtectTypeName
				,OwnerName
				,ObjectName
				,GranteeName
				,GrantorName
				,ColumnName
				,ColId	)
			   SELECT	prot1.Id
					,''1Regul''
					,ObjType
					,ActionName
					,ActionCategory
					,ProtectTypeName
					,OwnerName
					,ObjectName
					,GranteeName
					,GrantorName
					,null
					,val1.number
				from	#t1_Prots              prot1
					,master.dbo.spt_values  val1
					,['+ @cu11DBName + '].sys.columns sysc
				where	prot1.ObjType    IN (''S '' ,''U '' ,''V '')
				and prot1.Id = sysc.object_id
				and	val1.type   = ''P''
				and	val1.number = sysc.column_id
				and	case convert(int,substring(prot1.Columns_Orig, 1, 1)) & 1
						when 0 then convert(tinyint, substring(prot1.Columns_Orig, val1.low, 1))
						else (~convert(tinyint, isnull(substring(prot1.Columns_Orig, val1.low, 1),0)))
						end & val1.high <> 0
				and prot1.All_Col_Bits_On <> 1')
		
			--  set column names
			Exec('UPDATE #t1_Prots 
			set ColumnName = c.name
			FROM ['+ @cu11DBName + '].sys.columns c
			WHERE c.object_id = #t1_Prots.Id
			and   c.column_id = #t1_Prots.ColId')


			delete from #t1_Prots
			where ObjType IN ('S ' ,'U ' ,'V ')
			  and All_Col_Bits_On = 0
			  and new_Bit_On = 0
		
		   end
		
		--------------------  Cursor for DB names  -------------------
		EXECUTE('DECLARE cursor_33 Insensitive Cursor For ' + 
		  'SELECT t.ActionName, t.ProtectTypeName, t.OwnerName, t.ObjectName, t.GranteeName, t.ColumnName, t.All_Col_Bits_On
		   From #t1_Prots   t ' + 
		  'Order By t.GranteeName For Read Only')

		
		OPEN cursor_33
		
		WHILE (33=33)
		   Begin
			FETCH Next From cursor_33 Into @cu33ActionName, @cu33ProtectTypeName, @cu33OwnerName, @cu33ObjectName, @cu33GranteeName, @cu33ColumnName, @cu33All_Col_Bits_On
			IF (@@fetch_status < 0)
		           begin
		              CLOSE cursor_33
			      BREAK
		           end
		

			If @cu33All_Col_Bits_On is not null or @cu33ColumnName = '.'
			   begin
				Print  ' '
				Insert into ##output01 (permission_commands) 
				values (' ')
				Select @miscprint = rtrim(upper(@cu33ProtectTypeName)) + ' ' + rtrim(upper(@cu33ActionName)) + ' ON OBJECT::[' + rtrim(@cu33OwnerName) + '].[' + @cu33ObjectName + '] To [' + @cu33GranteeName + '] CASCADE' 
				Print  @miscprint
				Insert into ##output01 (permission_commands) 
				values (@miscprint)
				Print  'Go'
				Insert into ##output01 (permission_commands) 
				values ('GO')
			   end
			Else
			   begin
				Print  ' '
				Insert into ##output01 (permission_commands) 
				values (' ')
				Select @miscprint = rtrim(upper(@cu33ProtectTypeName)) + ' ' + rtrim(upper(@cu33ActionName)) + ' ON OBJECT::[' + rtrim(@cu33OwnerName) + '].[' + @cu33ObjectName + '] ([' + @cu33ColumnName + ']) To [' + @cu33GranteeName + '] CASCADE' 
				Print  @miscprint
				Insert into ##output01 (permission_commands) 
				values (@miscprint)
				Print  'Go'
				Insert into ##output01 (permission_commands) 
				values ('GO')
			   end
		
		   End  -- loop 33	
		DEALLOCATE cursor_33
	   end
	ELSE
	   begin
		Print  ' '
		Insert into ##output01 (permission_commands) 
		values (' ')
		Select @miscprint = '-- Error on OBJECT::[' + @cu22Schemaname + '].[' + @cu22OBJname + '] for user [' + @cu22grantee + ']'
		Print  @miscprint
		Insert into ##output01 (permission_commands) 
		values (@miscprint)
	   end

	Select @output_flag	= 'y' 

   skip22:
 
   End  -- loop 22
	
   DEALLOCATE cursor_22out


----------------------  Write a seperate permissions file for this database  ----------------------

If @output_flag = 'n'
   begin
	Print  ' '
	Select @miscprint = '-- No output for database: ' + @cu11DBName
	Print  @miscprint
	Print  ' '
	Insert into ##output01 (permission_commands) 
	values (@miscprint)
   end
Else
   begin
	Select @miscprint = ' '
	Print  @miscprint  
	Insert into ##output01 (permission_commands) 
	values (@miscprint)

	Select @miscprint = 'Print ''End GRANT OBJECT PRIVILEGES'''
	Print  @miscprint  
	Insert into ##output01 (permission_commands) 
	values (@miscprint)

	Select @miscprint = 'Select getdate()'
	Print  @miscprint
	Insert into ##output01 (permission_commands) 
	values (@miscprint)
  
	Print  @G_O
	Insert into ##output01 (permission_commands) 
	values ('GO')

	Select @output_flag = 'n' 
   end


SELECT 	@sqlcmd = 'sqlcmd -S' + @@servername + ' -w265 -h-1 -Q"' + @selectcmd + '" -E -o' + @outfullpath
--print @sqlcmd
EXEC @result = master.sys.xp_cmdshell @sqlcmd, no_output


DROP TABLE ##output01

drop table ##tempprotects

Select @output_flag2 = 'y' 



End  -- loop 11

---------------------------  Finalization  -----------------------

DEALLOCATE cursor_11DBNames

drop Table #t1_Prots

If @output_flag2 = 'n'
   begin
	Print '-- No output for this script.'
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSrestoreBYdb
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSrestoreBYdb]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSrestoreBYdb]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_SYSrestoreBYdb (@outfiles char(1) = 'n')

/*********************************************************
 **  Stored Procedure dbasp_SYSrestoreBYdb                  
 **  Written by Jim Wilson, Getty Images                
 **  October 01, 2002                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Perform a full Restore of a user database  
 **  using a full set of scripts 
 **        
 **  Output member is SYSRestore_<dbname>.gsql if @outfiles = 'y'
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/01/2002	Jim Wilson		New process
--	04/17/2003	Jim Wilson		Changes for new instance share names.
--	04/18/2003	Jim Wilson		Modified revoke db access section.
--	10/16/2003	Jim Wilson		Added identity column to output temp table to
--						force order.
--	10/28/2003	Jim Wilson		Added set user status
--	06/22/2004	Jim Wilson		Added code for set user status
--	07/20/2005	Jim Wilson		Added code for change object owner
--	09/21/2005	Jim Wilson		System objects will now be excluded from the 
--						change object owner process
--	10/02/2005	Jim Wilson		Added brackets for DBname in change object owner section
--	04/26/2006	Jim Wilson		In sysmessages, changed double quotes to single quotes
--	11/07/2006	Jim Wilson		Added code for LiteSpeed processing and mutilple backup files.
--	11/15/2006	Jim Wilson		Re-created for SQL 2005.
--	11/27/2006	Jim Wilson		Fixed double quotes in drop user section.  Added ^ for echo > and <.
--	12/21/2006	Jim Wilson		This new sproc calls sproc dbasp_SYSrestoreBYsingledb.
--	05/01/2007	Jim Wilson		Changed sqlcmd outpt to unicode.
--	04/14/2009	Jim Wilson		Skip db's not online.
--	======================================================================================

/***
Declare @outfiles char(1)

Select @outfiles = 'y'
--***/

-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(4000)
	,@cmd			nvarchar(4000)
	,@sqlcmd		nvarchar(4000)
	,@charpos		int
	,@output_flag		char(1)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_servername3	sysname
	,@out_file_name		nvarchar(500)
	,@result		int

DECLARE
	 @cu11DBName		sysname
	,@cu11DBsid		varbinary(85)
	,@cu11DBid		int
	,@cu11DBcmptlevel	tinyint



----------------  initial values  -------------------

Select @output_flag	= 'n'
Select @out_file_name = null


--  Set servername variables
Select @save_servername		= @@servername
Select @save_servername2	= @@servername
Select @save_servername3	= @@servername

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))

	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')

	select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
	select @save_servername3 = @save_servername3 + ')'
   end


--  Create temp tables and table variables
declare @dbnames table	(name		sysname
			,sid		varbinary(85)
			,dbid		smallint
			,cmptlevel	smallint
			)



--------------------  Capture DB names  -------------------
Insert into @dbnames (name, sid, dbid, cmptlevel)
SELECT d.name, d.owner_sid, d.database_id, d.compatibility_level
From master.sys.databases d with (NOLOCK) 
Where d.name not in ('master', 'model', 'msdb', 'tempdb')

delete from @dbnames where name is null or name = ''
--select * from @dbnames


/****************************************************************
 *                MainLine
 ***************************************************************/


If (select count(*) from @dbnames) > 0
   begin
	start_dbnames:

	Select @cu11DBName = (select top 1 name from @dbnames order by name)
	Select @cu11DBsid = (select top 1 sid from @dbnames where name = @cu11DBName)
	Select @cu11DBid = (select top 1 dbid from @dbnames where name = @cu11DBName)
	Select @cu11DBcmptlevel = (select top 1 cmptlevel from @dbnames where name = @cu11DBName)

	if DATABASEPROPERTYEX (@cu11DBName,'status') <> 'ONLINE'
	   begin
		goto skip_dbname
	   end



	If @outfiles = 'y'
	   begin
		--  Create the output file
		Select @out_file_name =  '\\' + @save_servername + '\' + @save_servername2 + '_DBA_Archive\' + @save_servername3 + '_SYSRestore_' + @cu11DBName + '.gsql'
		--Print @out_file_name

		SELECT @sqlcmd = 'sqlcmd -S' + @@servername + ' -ddbaadmin -w265 -u -Q"exec dbaadmin.dbo.dbasp_SYSrestoreBYsingledb @dbname = ''' + @cu11DBName + '''" -E -o' + @out_file_name
		--Print @sqlcmd
		EXEC @result = master.sys.xp_cmdshell @sqlcmd
	   end
	Else
	   begin
		exec dbaadmin.dbo.dbasp_SYSrestoreBYsingledb @dbname = @cu11DBName
	   end	    

	skip_dbname:

	--  Remove this record from @dbnames and go to the next
	delete from @dbnames where name = @cu11DBName
	If (select count(*) from @dbnames) > 0
	   begin
		goto start_dbnames
	   end


   end

---------------------------  Finalization  -----------------------





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSrestoreBYsingledb
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSrestoreBYsingledb]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSrestoreBYsingledb]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE dbo.dbasp_SYSrestoreBYsingledb (@dbname sysname = null)

/*********************************************************
 **  Stored Procedure dbasp_SYSrestoreBYsingledb                  
 **  Written by Jim Wilson, Getty Images                
 **  October 01, 2002                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Perform a full Restore of a user database  
 **  using a full set of scripts 
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/01/2002	Jim Wilson		New process
--	04/17/2003	Jim Wilson		Changes for new instance share names.
--	04/18/2003	Jim Wilson		Modified revoke db access section.
--	10/16/2003	Jim Wilson		Added identity column to output temp table to
--						force order.
--	10/28/2003	Jim Wilson		Added set user status
--	06/22/2004	Jim Wilson		Added code for set user status
--	07/20/2005	Jim Wilson		Added code for change object owner
--	09/21/2005	Jim Wilson		System objects will now be excluded from the 
--						change object owner process
--	10/02/2005	Jim Wilson		Added brackets for DBname in change object owner section
--	04/26/2006	Jim Wilson		In sysmessages, changed double quotes to single quotes
--	11/07/2006	Jim Wilson		Added code for LiteSpeed processing and mutilple backup files.
--	11/15/2006	Jim Wilson		Re-created for SQL 2005.
--	11/27/2006	Jim Wilson		Fixed double quotes in drop user section.  Added ^ for echo > and <.
--	12/21/2006	Jim Wilson		Converted this to a 2 sproc process.  This sproc will now be
--						run for only a single DB at a time.
--	03/09/2007	Jim Wilson		Added quotename to change db owner section.
--	07/25/2007	Jim Wilson		Added RedGate processing.
--	08/23/2007	Jim Wilson		Added Report Services processing for key extraction and adding.
--	03/12/2008	Jim Wilson		Added sections for master and msdb access and permissions.
--	04/16/2008	Jim Wilson		Added check expiration and check policy.
--	05/08/2008	Jim Wilson		Added code to drop unused schemas.
--	05/16/2008	Jim Wilson		Fixed syntax in drop user section (added brackets and 'go').
--	06/20/2008	Jim Wilson		Added code for assemblies (alter authorization).
--	07/21/2008	Jim Wilson		Fix for DBroles section.
--	09/23/2008	Jim Wilson		Removed Report Services processing for key extraction.
--	07/16/2009	Jim Wilson		Added bracketsd for dbname in sections 16 and 17.
--	======================================================================================

/***
Declare @dbname sysname

Select @dbname = 'SharePoint_AdminContent_8ad7ea7e-4ff7-48a9-9326-1dc1f8400583'
--***/

-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(1000)
	,@cmd			nvarchar(1000)
	,@G_O			nvarchar(2)
	,@firstflag		char(1)
	,@rs_flag		char(1)
	,@HoldBackupName	nvarchar(260)
	,@charpos		int
	,@maxBSI_D		int
	,@maxBSI_I		int
	,@output_flag		char(1)
	,@output_flag2		char(1)
	,@BkUpMethod		nvarchar(10)
	,@Holdfam_seq_num	tinyint
	,@hold_from		nvarchar(5)
	,@hold_comma		nvarchar(1)
	,@out_file_name		nvarchar(500)
	,@save_servername	sysname
	,@save_servername2	sysname
	,@save_instname		sysname

DECLARE
	 @DFLTdatabase		nvarchar   (30)
	,@VCHARpassword		nvarchar  (256)
	,@VCHARsid		nvarchar  (128)
	,@pwlen			int
	,@pwpos			int
	,@i			int
	,@length		int
	,@binvalue		varbinary(256)
	,@hexstring		nchar      (16)
	,@savename		sysname
	,@tempint		int
	,@firstint		int
	,@secondint		int
	,@startpos		int
	,@save_log		nvarchar(10)
	,@save_sidname		sysname
	,@optvalue		nvarchar(5)
	,@CommentThisDBOption	char(1)
	,@recovery_flag		char(1)
	,@restrict_flag		char(1) 
	,@fulloptname		sysname
	,@alt_optname		sysname
	,@alt_optvalue		sysname	
	,@exec_stmt		nvarchar(2000)
	,@save_repl_options	nvarchar(1000)
	,@catvalue		int	
	,@output_flag02		char(1)
	,@save_altname		sysname
	,@save_schemaname	sysname
	,@grantoption		nvarchar (25)

DECLARE
	 @allstatopts		int
	,@alloptopts		int
	,@allcatopts		int

DECLARE
	 @cu11DBName		sysname
	,@cu11DBsid		varbinary(85)
	,@cu11DBid		int
	,@cu11DBcmptlevel	tinyint

DECLARE
	 @cu12fileid		smallint
	,@cu12name		nvarchar(128)
	,@cu12filename		nvarchar(260)

DECLARE
	 @cu16Lname		sysname
	,@cu16Lpassword		sysname
	,@cu16Lsid		varbinary (85)
	,@cu16Lstatus		smallint
	,@cu16Ldbname		sysname
	,@cu16Llanguage		sysname	
	,@cu16isntgroup		int
	,@cu16isntuser		int	

DECLARE
	 @cu17Lname		sysname
	,@cu17Lpassword		sysname
	,@cu17Lsid		varbinary (85)
	,@cu17Lstatus		smallint
	,@cu17Ldbname		sysname
	,@cu17Llanguage		sysname	
	,@cu17isntgroup		int
	,@cu17isntuser		int


DECLARE
	 @cu18name			sysname
	,@cu18type			sysname
	,@cu18default_schema_name	sysname

DECLARE
	 @cu20Uname		nvarchar(128)
	,@cu20Ualtuid		smallint
	,@cu20Uissqlrole	int
	,@cu20Uisapprole	int


DECLARE
	 @cu22Urole		sysname
	,@cu22Uname		sysname


DECLARE
	 @cu24action		int
	,@cu24protecttype	int
	,@cu24puid		int
	,@cu24objtype		nvarchar(20)
	,@cu24Schemaname	sysname
	,@cu24OBJname		sysname
	,@cu24grantee		sysname
	,@cu24uid		smallint
	,@cu24id		int
	,@cu24is_ms_shipped	bit	

DECLARE
	 @cu26name			sysname
	,@cu26type			sysname
	,@cu26default_schema_name	sysname

DECLARE
	 @cu28Uname		nvarchar(128)
	,@cu28Ualtuid		smallint
	,@cu28Uissqlrole	int
	,@cu28Uisapprole	int

DECLARE
	 @cu30Urole		sysname
	,@cu30Uname		sysname

DECLARE
	 @cu32action		int
	,@cu32protecttype	int
	,@cu32puid		int
	,@cu32objtype		nvarchar(20)
	,@cu32Schemaname	sysname
	,@cu32OBJname		sysname
	,@cu32grantee		sysname
	,@cu32uid		smallint
	,@cu32id		int
	,@cu32is_ms_shipped	bit	

DECLARE
	 @cu34Mmessage_id	nvarchar(10)
	,@cu34Mlanguage_id	nvarchar(50)
	,@cu34Mseverity		nvarchar(10)
	,@cu34Mis_event_logged	bit
	,@cu34Mtext		nvarchar(2048)

DECLARE
	 @cu36name			sysname
	,@cu36type			sysname
	,@cu36default_schema_name	sysname

DECLARE
	 @cu38Aname			sysname
	,@cu38Pname			sysname

DECLARE
	 @cu41Uname		nvarchar(128)
	,@cu41Ualtuid		smallint
	,@cu41Uissqlrole	int
	,@cu41Uisapprole	int

DECLARE
	 @cu46Urole		sysname
	,@cu46Uname		sysname

DECLARE
	 @cu51action		int
	,@cu51protecttype	int
	,@cu51puid		int
	,@cu51objtype		nvarchar(20)
	,@cu51Schemaname	sysname
	,@cu51OBJname		sysname
	,@cu51grantee		sysname
	,@cu51uid		smallint
	,@cu51id		int
	,@cu51is_ms_shipped	bit	

Declare
	 @cu56ActionName	sysname
	,@cu56ProtectTypeName	sysname
	,@cu56OwnerName		sysname
	,@cu56ObjectName	sysname
	,@cu56GranteeName	sysname
	,@cu56ColumnName	sysname
	,@cu56All_Col_Bits_On	tinyint



----------------  initial values  -------------------

Select @G_O		= 'g' + 'o'
Select @output_flag	= 'n'
Select @rs_flag		= 'n'
Select @BkUpMethod 	= 'MS'
Select @out_file_name = null

Select @save_servername	= @@servername
Select @save_servername2 = @@servername
Select @save_instname = ''

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
	Select @save_instname = substring(@@servername, @charpos+1, len(@@servername)-len(@save_servername)-1)
   end



--  Create temp tables and table variables
create table #filenames (fileid		smallint
			,name		sysname
			,filename	sysname
			)

create table #holdbackupnames	(filename		sysname
				,family_sequence_number	tinyint
				,process_flag		char(1)
				)

declare @tblvar_spt_values table 
			(name			sysname
			,process_flag	char(1)
			)

declare @temp_options table (name		sysname)


declare @repl_options table (output		nvarchar(1000))


If (object_id('tempdb..#t1_Prots') is not null)
            drop table #t1_Prots

Create table #temp_dbusers (name		sysname)

CREATE Table #t1_Prots
	(Id			int		Null
	,Type1Code		char(6)		NOT Null
	,ObjType		char(2)		Null
	,ActionName		varchar(20)	Null
	,ActionCategory		char(2)		Null
	,ProtectTypeName	char(10)	Null
	,Columns_Orig		varbinary(32)	Null
	,OwnerName		sysname		Null
	,ObjectName		sysname		Null
	,GranteeName		sysname		Null
	,GrantorName		sysname		Null
	,ColumnName		sysname		Null
	,ColId			smallint	Null
	,Max_ColId		smallint	Null
	,All_Col_Bits_On	tinyint		Null
	,new_Bit_On		tinyint		Null 
	)


/*
** Get bitmap of all options that can be set by sp_dboption.
*/
select @allstatopts=number from master.dbo.spt_values where type = 'D'
   and name = 'ALL SETTABLE OPTIONS'

select @allcatopts=number from master.dbo.spt_values where type = 'DC'
   and name = 'ALL SETTABLE OPTIONS'

select @alloptopts=number from master.dbo.spt_values where type = 'D2'
   and name = 'ALL SETTABLE OPTIONS'


		
--  Load the temp table for spt_values
Select @cmd = 'select name
		from master.dbo.spt_values
		where (type = ''D''
			and number & ' + convert(varchar(10), @allstatopts) + ' <> 0
			and number not in (0,' + convert(varchar(10), @allstatopts) + '))	-- Eliminate non-option entries
		 or (type = ''DC''
			and number & ' + convert(varchar(10), @allcatopts) + ' <> 0
			and number not in (0,' + convert(varchar(10), @allcatopts) + '))
		 or (type = ''D2''
			and number & ' + convert(varchar(10), @alloptopts) + ' <> 0
			and number not in (0,' + convert(varchar(10), @alloptopts) + '))
		order by name'

delete from @tblvar_spt_values

insert into @tblvar_spt_values (name) exec (@cmd)

delete from @tblvar_spt_values where name is null or name = ''
--select * from @tblvar_spt_values

--  Check input parm
If not exists(select 1 from master.sys.sysdatabases where name = @DBname)
   begin
	Print 'DBA Warning:  Invalid input parameter.  Database ' + @DBname + ' does not exist on this server.'
	Goto label99
   end



/*********************************************************************
 *                SYSdbRestore
 ********************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'Generated SQL - SYSrestoreBYdb'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '************************************************************************/'
Print  ' '



/****************************************************************
 *                MainLine
 ***************************************************************/



Select @cu11DBName = rtrim(@dbname)
Select @cu11DBsid = (select top 1 owner_sid from master.sys.databases where name = @cu11DBName)
Select @cu11DBid = (select top 1 database_id from master.sys.databases where name = @cu11DBName)
Select @cu11DBcmptlevel = (select top 1 compatibility_level from master.sys.databases where name = @cu11DBName)


----------------------  Print the headers  ----------------------
Select @miscprint = ''
Print  @miscprint

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = '****************************************************************************************'
Print  @miscprint

Select @miscprint = 'START: Complete Restore script for database: ''' + @cu11DBName + '''   From server: ' + @@servername  
Print  @miscprint

Select @miscprint = '****************************************************************************************'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = ''
Print  @miscprint


-------------------------------------------------------------------------------
--  START SYSdbRestore Section ------------------------------------------------
-------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Restore for Database: ' + @cu11DBName  
Print  @miscprint

Select @miscprint = ''
Print  @miscprint

Select @miscprint = 'Note: Prior to running the following restore command,'  
Print  @miscprint

Select @miscprint = '      some changes in the syntax may be required, such'
Print  @miscprint

Select @miscprint = '      as the name of the backup file, or the path of the'  
Print  @miscprint

Select @miscprint = '      restored files.' 
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = ''
Print  @miscprint


Select @firstflag = 'y'

--------------------  Capture File Names  -------------------
Select @cmd = 'Insert into #filenames (fileid, name, filename)
SELECT f.fileid, f.name, f.filename
From [' + @cu11DBName + '].sys.sysfiles  f with (NOLOCK)'

EXEC sp_executesql @cmd

delete from #filenames where name is null or name = '' or fileid is null
--select * from #filenames

If (select count(*) from #filenames) > 0
   begin
	start_filenames:

	Select @cu12fileid = (select top 1 fileid from #filenames order by fileid)
	Select @cu12name = name from #filenames where fileid = @cu12fileid
	Select @cu12filename = filename from #filenames where fileid = @cu12fileid

	If @firstflag = 'y'
	   begin
		Select @maxBSI_D = 0
		Select @maxBSI_I = 0
		Select @firstflag = 'n'
		Select @maxBSI_D = (select max(bf.backup_set_id) 
					from msdb.dbo.backupfile bf, msdb.dbo.backupset bs 
					where bf.backup_set_id = bs.backup_set_id
					and bs.type = 'D'
					and bf.logical_name = @cu12name 
					and bf.physical_name = @cu12filename)

		
		Select @maxBSI_I = (select max(bf.backup_set_id) 
					from msdb.dbo.backupfile bf, msdb.dbo.backupset bs 
					where bf.backup_set_id = bs.backup_set_id
					and bs.type = 'I'
					and bf.logical_name = @cu12name 
					and bf.physical_name = @cu12filename) 


		delete from #holdbackupnames

		--  Capture backup file name(s)
		Insert into #holdbackupnames (filename, family_sequence_number)
		select mf.physical_device_name, mf.family_sequence_number
		from msdb.dbo.backupmediafamily mf, msdb.dbo.backupset bs 
		where mf.media_set_id = bs.media_set_id
		  and bs.backup_set_id = @maxBSI_D

		delete from #holdbackupnames where filename is null or filename = ''
		--select * from #holdbackupnames


		Select @HoldBackupName = (select top 1 filename from #holdbackupnames order by family_sequence_number) 
	

		Select @miscprint = 'select @@servername, getdate()'
		Print  @miscprint

		Print  @G_O
		Print  ' '
		Print  ' '


		--  Check file name to determine if we can process the file
		If @HoldBackupName like '%.bkp%'
		   begin
			Select @miscprint = '--  Note:  LiteSpeed Syntax will be used for this restore'
			Print  @miscprint

			Print ' '
			Select @BkUpMethod = 'LS'
		   end

		If @HoldBackupName like '%.sqb%'
		   begin
			Select @miscprint = '--  Note:  RedGate Syntax will be used for this restore'
			Print  @miscprint

			Print ' '
			Select @BkUpMethod = 'RG'
		   end


		If @HoldBackupName is not null
		   begin
			If @BkUpMethod = 'LS'
			   begin
				select @miscprint = 'EXEC master.dbo.xp_restore_filelistonly'
				print  @miscprint
				select @miscprint = '  @filename = ''' + @HoldBackupName + ''''
				print  @miscprint
				select @miscprint = 'EXEC master.dbo.xp_restore_database'
				print  @miscprint
				select @miscprint = '  @database =  ''' + @cu11DBName + ''''
				print  @miscprint
				select @miscprint = ', @filename = ''' + @HoldBackupName + ''''
				print  @miscprint

				If @maxBSI_I > @maxBSI_D
				   begin
					select @miscprint = ', @with = NORECOVERY'
					print  @miscprint
					select @miscprint = ', @with = ''REPLACE'''
					print  @miscprint
				   end	
				Else
				   begin
					select @miscprint = ', @with = RECOVERY'
					print  @miscprint
					select @miscprint = ', @with = ''REPLACE'''
					print  @miscprint
				   end	
			   end
				Else If @BkUpMethod = 'RG'
				   begin
					select @miscprint = 'Exec master.dbo.sqlbackup ''-SQL "RESTORE FILELISTONLY FROM DISK = ''''' + @HoldBackupName + '''''"'''
					print  @miscprint
					select @miscprint = 'go'
					print  @miscprint
					select @miscprint = 'Declare @cmd nvarchar(4000)'
					print  @miscprint
					select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @cu11DBName + ']'
					print  @miscprint
					select @miscprint = '	 FROM DISK = ''''' + @HoldBackupName + ''''''
					print  @miscprint

					If @maxBSI_I > @maxBSI_D
					   begin
						select @miscprint = '	 WITH NORECOVERY'
						print  @miscprint
					   end	
					Else
					   begin
						select @miscprint = '	 WITH RECOVERY'
						print  @miscprint
					   end	
				   end
			Else
			   begin
				Select @miscprint = 'RESTORE FILELISTONLY'
				Print  @miscprint

				update #holdbackupnames set process_flag = 'n'
				Select @hold_from = 'FROM '
				Select @hold_comma = ''
				start_holdbackupnames_01:
				Select @Holdfam_seq_num = (select top 1 family_sequence_number from #holdbackupnames where process_flag = 'n' order by family_sequence_number) 
				Select @HoldBackupName = (select filename from #holdbackupnames where family_sequence_number = @Holdfam_seq_num)
				If (select count(*) from #holdbackupnames where process_flag = 'y') > 0
				   begin
					Select @hold_from = '    '
					Select @hold_comma = ','
				   end

				Select @miscprint = @hold_from + '     ' + + @hold_comma + 'Disk = ''' + @HoldBackupName + ''''
				Print  @miscprint


				update #holdbackupnames set process_flag = 'y' where family_sequence_number = @Holdfam_seq_num
				If (select count(*) from #holdbackupnames where process_flag = 'n') > 0
				   begin
					goto start_holdbackupnames_01
				   end

				Print  @G_O
				Print  ' '

				Select @miscprint = 'RESTORE DATABASE ' + @cu11DBName
				Print  @miscprint


				update #holdbackupnames set process_flag = 'n'
				Select @hold_from = 'FROM '
				Select @hold_comma = ''
				start_holdbackupnames_02:
				Select @Holdfam_seq_num = (select top 1 family_sequence_number from #holdbackupnames where process_flag = 'n' order by family_sequence_number) 
				Select @HoldBackupName = (select filename from #holdbackupnames where family_sequence_number = @Holdfam_seq_num)
				If (select count(*) from #holdbackupnames where process_flag = 'y') > 0
				   begin
					Select @hold_from = '    '
					Select @hold_comma = ','
				   end

				Select @miscprint = @hold_from + '     ' + + @hold_comma + 'Disk = ''' + @HoldBackupName + ''''
				Print  @miscprint

				update #holdbackupnames set process_flag = 'y' where family_sequence_number = @Holdfam_seq_num
				If (select count(*) from #holdbackupnames where process_flag = 'n') > 0
				   begin
					goto start_holdbackupnames_02
				   end


				If @maxBSI_I > @maxBSI_D
				   begin
					select @miscprint = 'WITH      NORECOVERY'
					print  @miscprint

					select @miscprint = '         ,REPLACE'
					print  @miscprint
				   end
				Else
				   begin
					Select @miscprint = 'WITH      REPLACE'
					Print  @miscprint
				   end
			   end
		   end
		Else
		   begin
			Select @miscprint = '-- Warning:  No Backup File found for database: ' + @cu11DBName
			Print  @miscprint

			Select @miscprint = ' '
			Print  @miscprint

			Select @miscprint = '-- Note:  The following lines document this databases file names and paths'
			Print  @miscprint

			Select @miscprint = '--        and can be used as part of a database restore script.'
			Print  @miscprint

			Select @miscprint = ' '
			Print  @miscprint
		   end
	   end

	If @HoldBackupName is not null
	   begin
		If @BkUpMethod = 'LS'
		   begin
			select @miscprint = ', @with = ''MOVE "' + rtrim(@cu12name) + '" to "' + rtrim(@cu12filename) + '"'''
			print  @miscprint
		   end
		Else If @BkUpMethod = 'RG'
		   begin
			select @miscprint = '	,MOVE ''''' + rtrim(@cu12name) + ''''' to ''''' + rtrim(@cu12filename) + ''''''
			print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '         ,MOVE ''' + rtrim(@cu12name) + '''' + ' to ' + '''' + rtrim(@cu12filename) + ''''
			Print  @miscprint
		   end
	   end
	Else
	   begin
		Select @miscprint = '--       ,MOVE ''' + rtrim(@cu12name) + '''' + ' to ' + '''' + rtrim(@cu12filename) + ''''
		Print  @miscprint
	   end


	--  Remove this record from #filenames and go to the next
	delete from #filenames where fileid = @cu12fileid
	If (select count(*) from #filenames) > 0
	   begin
		goto start_filenames
	   end

   end


If @HoldBackupName is not null
   begin
	If @BkUpMethod = 'LS'
	   begin
		select @miscprint = ', @with = ''stats'''
		print  @miscprint

		Print  @G_O

		Print ' '
	   end
	Else If @BkUpMethod = 'RG'
	   begin
		select @miscprint = '	,REPLACE"'''
		print  @miscprint

		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
		print  @miscprint
		select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
		print  @miscprint
		select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
		print  @miscprint
		select @miscprint = 'go'
		print  @miscprint
		Print ' '
	   end
	Else
	   begin
		Select @miscprint = '         ,stats'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end
   end


--  Process Differential File if found
If @maxBSI_I > @maxBSI_D
   begin
	Select @HoldBackupName = (select mf.physical_device_name 
				  from msdb.dbo.backupmediafamily mf, msdb.dbo.backupset bs 
				  where mf.media_set_id = bs.media_set_id
				    and mf.family_sequence_number = 1
				    and bs.backup_set_id = @maxBSI_I) 

	Select @BkUpMethod = 'MS'
	If @HoldBackupName like '%.dfl'
	   begin
		Select @miscprint = '--  Note:  LiteSpeed Syntax will be used for this restore'
		Print  @miscprint

		Print ' '
		Select @BkUpMethod = 'LS'
	   end
	If @HoldBackupName like '%.SQD'
	   begin
		Select @miscprint = '--  Note:  RedGate Syntax will be used for this restore'
		Print  @miscprint

		Print ' '
		Select @BkUpMethod = 'RG'
	   end


	If @BkUpMethod = 'LS'
	   begin
		select @miscprint = 'EXEC master.dbo.xp_restore_database'
		print  @miscprint
		select @miscprint = '  @database = ''' + @cu11DBName + ''''
		print  @miscprint
		select @miscprint = ', @filename = ''' + @HoldBackupName + ''''
		print  @miscprint
		select @miscprint = ', @with = RECOVERY'
		print  @miscprint
		select @miscprint = ', @with = ''stats'''
		print  @miscprint
		Print  @G_O
		Print ' '
	   end
		Else If @BkUpMethod = 'RG'
		   begin
			select @miscprint = 'Declare @cmd nvarchar(4000)'
			print  @miscprint
			select @miscprint = 'Select @cmd = ''-SQL "RESTORE DATABASE [' + @cu11DBName + ']'
			print  @miscprint
			select @miscprint = ' FROM DISK = ''''' + @HoldBackupName + ''''''
			print  @miscprint
			select @miscprint = ' WITH RECOVERY"'''
			print  @miscprint
			select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(9),'''')'
			print  @miscprint
			select @miscprint = 'SET @cmd = REPLACE(@cmd,CHAR(13)+char(10),'' '')'
			print  @miscprint
			select @miscprint = 'Exec master.dbo.sqlbackup @cmd'
			print  @miscprint
			select @miscprint = 'go'
			print  @miscprint
			Print ' '
		   end
	Else
	   begin
		select @miscprint = 'RESTORE DATABASE ' + @cu11DBName
		print  @miscprint
		select @miscprint = 'FROM DISK = ''' + @HoldBackupName + ''''
		print  @miscprint
		select @miscprint = 'WITH RECOVERY,'
		print  @miscprint
		select @miscprint = 'stats'
		print  @miscprint
		Print  @G_O
		Print ' '
	   end
   end


Print  ' '

Select @miscprint = 'select getdate()'
Print  @miscprint
Print  @G_O
Print  ' '
Print  ' '

Select @output_flag = 'y' 



-------------------------------------------------------------------------------------
--  END SYSdbRestore Section --------------------------------------------------------
-------------------------------------------------------------------------------------



-------------------------------------------------------------------------------------
--  START SYSaddmasterlogins Section ------------------------------------------------
-------------------------------------------------------------------------------------


----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'ADD SQL and NT LOGINS for Database: ' + @cu11DBName  
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE master'
Print  @miscprint

Print  @G_O

Print  ' '

Select @savename = ''

--------------------  Cursor 16  -----------------------

EXECUTE('DECLARE cursor_16 Insensitive Cursor For ' + 
  'SELECT y.name, y.password, y.sid, y.status, y.dbname, y.language, y.isntgroup, y.isntuser
   From  master.sys.syslogins  y, [' + @cu11DBName + '].sys.database_principals  dp ' + 
  'Where y.sid = dp.sid
	 And y.hasaccess = 1
	 And y.name not in (''probe'',''sa'',''repl_publisher'',''repl_subscriber'')
	 And y.name not like ''##%''
	 And y.name not like ''%BUILTIN\Administrators%''
	 And y.name not like ''%AUTHORITY\SYSTEM%''
	 And y.name not like ''%MSSQLSERVER%''
	 And y.isntgroup = 0
	 And y.isntuser = 0
   Order By y.name For Read Only')


--------------------  start cursor processing  -----------------------
OPEN cursor_16

WHILE (16=16)
   Begin
	FETCH Next From cursor_16 Into @cu16Lname, @cu16Lpassword, @cu16Lsid, @cu16Lstatus, @cu16Ldbname, @cu16Llanguage, @cu16isntgroup, @cu16isntuser
		IF (@@fetch_status < 0)
		   begin
			CLOSE cursor_16
			BREAK
		   end

--------------------  convert the password to unicode values  -----------------------
--print @cu16Lpassword
select @pwlen = len(@cu16Lpassword)
Select @pwpos = 1
Select @VCHARpassword = ''

If @pwpos <= @pwlen
   begin
	start_pw_revision:

	Select @VCHARpassword = @VCHARpassword + 'nchar(' + convert(varchar(10), unicode(Substring(@cu16Lpassword,@pwpos,1))) + ') + '

	Select @pwpos = @pwpos + 1

	If @pwpos <= @pwlen
	   begin
		goto start_pw_revision
	   end
   end


--------------------  convert the sid from varbinary to varchar  -----------------------
select @VCHARsid = '0x'
select @i = 1
select @binvalue = @cu16Lsid
select @length = datalength(@binvalue)
select @hexstring = '0123456789ABCDEF'

while (@i <= @length)
   begin
 
	select @tempint = convert(int, substring(@binvalue,@i,1))
	select @firstint = floor(@tempint/16)
	select @secondint = @tempint - (@firstint*16)
 
	select @VCHARsid = @VCHARsid +
		substring(@hexstring, @firstint+1, 1) +
		substring(@hexstring, @secondint+1, 1)
 
	select @i = @i + 1
 
   end

--------------------  set the default database  -----------------------

	SELECT @DFLTdatabase = @cu16Ldbname


--------------------  Format the output  -----------------------
	If @cu16Lname <> @savename 
	   begin
		Insert into #temp_dbusers values(@cu16Lname)

		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint

		Select @miscprint = '-- Create login ''' + @cu16Lname + '''' 
		Print  @miscprint

		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint

		--  If this is being run on a sql2005 server, add logic to make sure the result script is used on a sql2005 server.
		If ( 0 <> ( SELECT PATINDEX( '%[9].[00]%', @@version ) ) )
		   begin
			Select @miscprint = 'If ( 0 = ( SELECT PATINDEX( ''%[9].[00]%'', @@version ) ) )'
			Print  @miscprint

			Select @miscprint = '   Begin' 
			Print  @miscprint

			Select @miscprint = '      Print ''ERROR:  Unable to create login ''''' + @cu16Lname + ''''' to this server.  This login was scripted from a SQL 9.00 environment.'''
			Print  @miscprint

			Select @miscprint = '   End' 
			Print  @miscprint

			Select @miscprint = 'Else' 
			Print  @miscprint

		   end

		Select @miscprint = 'If not exists (select * from master.sys.syslogins where name = N''' + @cu16Lname + ''')' 
		Print  @miscprint

		Select @miscprint = '   Begin' 
		Print  @miscprint

		Select @miscprint = '      Declare @cmd nvarchar(3000)'
		Print  @miscprint

		Select @miscprint = '      '
		Print  @miscprint

		Select @miscprint = '      select @cmd = ''CREATE LOGIN ' + @cu16Lname
		Print  @miscprint


		Select @miscprint = '             WITH PASSWORD = '''''' + '

		Select @miscprint = @miscprint + @VCHARpassword

		Select @miscprint = @miscprint + ''''''' HASHED'
		Print  @miscprint


		Select @miscprint = '                                 ,DEFAULT_DATABASE = [' + @DFLTdatabase + ']' 
		Print  @miscprint


		IF @cu16Llanguage is not null
		   begin
			Select @miscprint = '                                 ,DEFAULT_LANGUAGE = ' + @cu16Llanguage 
			Print  @miscprint
		   end


		If (select is_policy_checked from master.sys.sql_logins where name = @cu16Lname) = 1
		   begin
			Select @miscprint = '                                 ,CHECK_POLICY = ON'
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '                                 ,CHECK_POLICY = OFF'
			Print  @miscprint
		   end

		If (select is_expiration_checked from master.sys.sql_logins where name = @cu16Lname) = 1
		   begin
			Select @miscprint = '                                 ,CHECK_EXPIRATION = ON'
			Print  @miscprint
		   end
		Else
		   begin
			Select @miscprint = '                                 ,CHECK_EXPIRATION = OFF'
			Print  @miscprint
		   end


		Select @miscprint = '                                 ,SID = ' + @VCHARsid + ''''
		Print  @miscprint

		Select @miscprint = '        Print @cmd'
		Print  @miscprint

		Select @miscprint = '        Exec (@cmd)'
		Print  @miscprint

		Select @miscprint = '   End' 
		Print  @miscprint

		Select @miscprint = 'Else' 
		Print  @miscprint

		Select @miscprint = '   Begin' 
		Print  @miscprint

		Select @miscprint = '      Print ''Note:  Login ''''' + @cu16Lname + ''''' already exists on this server.'''
		Print  @miscprint

		Select @miscprint = '   End' 
		Print  @miscprint

		Print  @G_O

		Print  ' '

	   end

	select @savename = @cu16Lname

	Select @output_flag	= 'y' 

   End  -- loop 16
   DEALLOCATE cursor_16


   

--------------------  Cursor 17  -----------------------

EXECUTE('DECLARE cursor_17 Insensitive Cursor For ' + 
  'SELECT y.name, y.password, y.sid, y.status, y.dbname, y.language, y.isntgroup, y.isntuser
   From  master.sys.syslogins  y, [' + @cu11DBName + '].sys.database_principals  dp ' + 
  'Where y.sid = dp.sid
	 And y.hasaccess = 1
	 And y.name not in (''probe'',''sa'',''repl_publisher'',''repl_subscriber'')
	 And y.name not like ''##%''
	 And y.name not like ''%BUILTIN\Administrators%''
	 And y.name not like ''%AUTHORITY\SYSTEM%''
	 And y.name not like ''%MSSQLSERVER%''
	 And (y.isntgroup <> 0 or y.isntuser <> 0)
   Order By y.name For Read Only')


--------------------  start cursor processing  -----------------------

OPEN cursor_17

WHILE (17=17)
   Begin
	FETCH Next From cursor_17 Into @cu17Lname, @cu17Lpassword, @cu17Lsid, @cu17Lstatus, @cu17Ldbname, @cu17Llanguage, @cu17isntgroup, @cu17isntuser
		IF (@@fetch_status < 0)
		   begin
			CLOSE cursor_17
			BREAK
		   end

	--------------------  set the default database  -----------------------
	SELECT @DFLTdatabase = @cu17Ldbname


	--------------------  Format the output  -----------------------
	If @cu17Lname <> @savename 
	   begin
		Insert into #temp_dbusers values(@cu17Lname)

		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint

		Select @miscprint = '-- Create login ''' + @cu17Lname + '''' 
		Print  @miscprint

		Select @miscprint = '-------------------------------------------------' 
		Print  @miscprint


		--  If this is being run on a sql2005 server, add logic to make sure the result script is used on a sql2005 server.
		If ( 0 <> ( SELECT PATINDEX( '%[9].[00]%', @@version ) ) )
		   begin
			Select @miscprint = 'If ( 0 = ( SELECT PATINDEX( ''%[9].[00]%'', @@version ) ) )'
			Print  @miscprint

			Select @miscprint = '   Begin' 
			Print  @miscprint

			Select @miscprint = '      Print ''ERROR:  Unable to create login ''''' + @cu17Lname + ''''' to this server.  This login was scripted from a SQL 9.00 environment.'''
			Print  @miscprint

			Select @miscprint = '   End' 
			Print  @miscprint

			Select @miscprint = 'Else' 
			Print  @miscprint
		   end

		If @cu17isntgroup <> 0 or @cu17isntuser <> 0
		   begin
			Select @miscprint = 'If not exists (select * from master.sys.syslogins where name = N''' + @cu17Lname + ''')' 
			Print  @miscprint

			Select @miscprint = '   Begin' 
			Print  @miscprint

			Select @miscprint = '      Print ''Add NT Login ''''' + @cu17Lname + ''''''''
			Print  @miscprint

			Select @miscprint = '      CREATE LOGIN [' + @cu17Lname + '] FROM WINDOWS'
			Print  @miscprint

			Select @miscprint = '             WITH DEFAULT_DATABASE = [' + @DFLTdatabase + ']' 
			Print  @miscprint

			IF @cu17Llanguage is not null
			   begin
				Select @miscprint = '                 ,DEFAULT_LANGUAGE = ' + @cu17Llanguage 
				Print  @miscprint
			   end

			Select @miscprint = '   End' 
			Print  @miscprint

			Select @miscprint = 'Else' 
			Print  @miscprint

			Select @miscprint = '   Begin' 
			Print  @miscprint

			Select @miscprint = '      Print ''Note:  Login ''''' + @cu17Lname + ''''' already exists on this server.'''
			Print  @miscprint

			Select @miscprint = '   End' 
			Print  @miscprint

			Print  @G_O

			Print  ' '
		   end
	   end

	select @savename = @cu17Lname

	Select @output_flag	= 'y' 

   End  -- loop 17
   DEALLOCATE cursor_17


-----------------------------------------------------------------------------------
--  END SYSaddmasterlogins Section ------------------------------------------------
-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
--  START SYScreateMASTERusers Section ------------------------------------------------
-----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Create Users for Master'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [master]'
Print  @miscprint

Print  @G_O

Print  ' '



--------------------  Cursor for 18DB  -----------------------
EXECUTE('DECLARE cu18_DBAccessb Insensitive Cursor For ' + 
  'SELECT dp.name, dp.type, dp.default_schema_name
   From [master].sys.database_principals  dp ' + 
  'Where dp.type <> ''R''
	 and dp.name in (select name from #temp_dbusers)
   Order By dp.type, dp.name For Read Only')


OPEN cu18_DBAccessb

WHILE (18=18)
   Begin
	FETCH Next From cu18_DBAccessb Into @cu18name, @cu18type, @cu18default_schema_name 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu18_DBAccessb
		  BREAK
		   end

	If @cu18default_schema_name is null or @cu18default_schema_name = 'dbo'
	   begin
		Select @miscprint = 'If not exists (select 1 from [master].sys.database_principals where name = ''' + @cu18name + ''' and type = ''' + @cu18type + ''')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      CREATE USER [' + @cu18name + '];'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end
	Else
	   begin
		Select @miscprint = 'CREATE USER [' + @cu18name + '] WITH DEFAULT_SCHEMA = ' + @cu18default_schema_name + ';'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end

	--  This code will fix the schema ownership for users that may have been previously removed from the database
	Select @miscprint = 'If exists (select 1 from [master].sys.schemas where name = ''' + @cu18name + ''' and principal_id = 1)'
	Print  @miscprint

	Select @miscprint = '   begin'
	Print  @miscprint

	Select @miscprint = '      ALTER AUTHORIZATION ON SCHEMA::[' + @cu18name + '] TO [' + @cu18name + '];'
	Print  @miscprint

	Select @miscprint = '   end'
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Print  ' '


	Select @output_flag	= 'y' 

   End  -- loop 18
   DEALLOCATE cu18_DBAccessb


-----------------------------------------------------------------------------------
--  END SYScreateMASTERusers Section --------------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
--  START SYSaddMASTERroles Section ---------------------------------------------------
-----------------------------------------------------------------------------------

Select @output_flag02 = 'n' 

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Add Roles for Master'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [master]'
Print  @miscprint

Print  @G_O

Print  ' '


--------------------  Cursor for 20DB  -----------------------
EXECUTE('DECLARE cu20_DBRoleb Insensitive Cursor For ' + 
  'SELECT r.name, r.altuid, r.issqlrole, r.isapprole
   From [master].sys.sysusers  u, [master].sys.sysusers  r, [master].sys.sysmembers  m ' + 
  'Where (r.issqlrole = 1 or r.isapprole = 1)
	 and (r.uid < 16380 or r.name = ''RSExecRole'')
	 and r.name <> ''public''
         and u.uid > 4
	 and u.uid = m.memberuid
	 and m.groupuid = r.uid
         and u.name in (select name from #temp_dbusers)
   Order By r.uid For Read Only')


OPEN cu20_DBRoleb

WHILE (20=20)
   Begin
	FETCH Next From cu20_DBRoleb Into @cu20Uname, @cu20Ualtuid, @cu20Uissqlrole, @cu20Uisapprole 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu20_DBRoleb
		  BREAK
		   end


	If @cu20Uissqlrole = 1
	   begin

		Select @cmd = 'USE master' 
				+ ' SELECT @save_altname = (select name from sys.sysusers where uid = ' + convert(varchar(10), @cu20Ualtuid) + ')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_altname sysname output', @save_altname output
		--print @save_altname

		Select @miscprint = 'If not exists (select 1 from master.sys.database_principals where name = ''' + @cu20Uname + ''' and type = ''R'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      CREATE ROLE [' + @cu20Uname + '] AUTHORIZATION [' + @save_altname + '];'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Print  @G_O

		Print  ' '

		goto end_01b
	   end


	If @cu20Uisapprole = 1
	   begin
		Select @cmd = 'USE master' 
				+ ' SELECT @save_schemaname = (select default_schema_name from sys.database_principals where name = ''' + @cu20Uname + ''')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_schemaname sysname output', @save_schemaname output
		--print @save_schemaname

		Select @miscprint = '/* CREATE APPLICATION ROLE ---------------------------------------------  */'
		Print  @miscprint

		Select @miscprint = '/* To avoid disclosure of passwords, the password is generated in script. */'
		Print  @miscprint

		Select @miscprint = 'declare @idx as int'
		Print  @miscprint

		Select @miscprint = 'declare @randomPwd as nvarchar(64)'
		Print  @miscprint

		Select @miscprint = 'declare @rnd as float'
		Print  @miscprint

		Select @miscprint = 'declare @cmd nvarchar(4000)'
		Print  @miscprint

		Select @miscprint = 'select @idx = 0'
		Print  @miscprint

		Select @miscprint = 'select @randomPwd = N'''
		Print  @miscprint

		Select @miscprint = 'select @rnd = rand((@@CPU_BUSY % 100) + ((@@IDLE % 100) * 100) +'
		Print  @miscprint

		Select @miscprint = '       (DATEPART(ss, GETDATE()) * 10000) + ((cast(DATEPART(ms, GETDATE()) as int) % 100) * 1000000))'
		Print  @miscprint

		Select @miscprint = 'while @idx < 64'
		Print  @miscprint

		Select @miscprint = 'begin'
		Print  @miscprint

		Select @miscprint = '   select @randomPwd = @randomPwd + char((cast((@rnd * 83) as int) + 43))'
		Print  @miscprint

		Select @miscprint = '   select @idx = @idx + 1'
		Print  @miscprint

		Select @miscprint = '   select @rnd = rand()'
		Print  @miscprint

		Select @miscprint = 'end'
		Print  @miscprint

		Select @miscprint = 'select @cmd = N''CREATE APPLICATION ROLE [' + @cu20Uname + '] WITH DEFAULT_SCHEMA = [' + @save_schemaname + '], '' + N''PASSWORD = N'' + QUOTENAME(@randomPwd,'''''''')'
		Print  @miscprint

		Select @miscprint = 'EXEC dbo.sp_executesql @cmd'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end

	end_01b:

	Select @output_flag02 = 'y'

   End  -- loop 20
   DEALLOCATE cu20_DBRoleb

If @output_flag02 = 'n'
   begin
	Select @miscprint = '-- No output for master.'
	Print  @miscprint

	Print  ' '
   end


-----------------------------------------------------------------------------------
--  END SYSaddMASTERroles Section -----------------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
--  START SYSaddMASTERrolemembers Section ---------------------------------------------
-----------------------------------------------------------------------------------

Select @output_flag02 = 'n' 

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Add Role Members for Master'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [master]'
Print  @miscprint

Print  @G_O

Print  ' '


--------------------  Cursor for 22DB  -----------------------
EXECUTE('DECLARE cu22_DBRoleb Insensitive Cursor For ' + 
  'SELECT r.name, u.name
   From [master].sys.sysusers  u, [master].sys.sysusers  r, [master].sys.sysmembers  m ' + 
  'Where u.uid > 4
	 and u.uid = m.memberuid
	 and m.groupuid = r.uid
         and u.name in (select name from #temp_dbusers)
   Order By r.name, u.uid For Read Only')

OPEN cu22_DBRoleb

WHILE (22=22)
   Begin
	FETCH Next From cu22_DBRoleb Into @cu22Urole, @cu22Uname 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu22_DBRoleb
		  BREAK
		   end

	 
	Select @miscprint = 'sp_addrolemember ''' + @cu22Urole + ''', '''  + @cu22Uname + ''''
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Select @output_flag02 = 'y'

   End  -- loop 22
   DEALLOCATE cu22_DBRoleb


If @output_flag02 = 'n'
   begin
	Print ''

	Select @miscprint = '-- No output for master.'
	Print  @miscprint

	Print ''
   end
Else
   begin
	Select @output_flag02 = 'n' 
   end


-----------------------------------------------------------------------------------
--  END SYSaddMASTERrolemembers Section -----------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
--  START SYSgrantobjectprivileges (Master) Section -------------------------------
-----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'GRANT OBJECT PRIVILEGES for Master'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [master]'
Print  @miscprint

Print  @G_O

Print  ' '


--  Create the temp table for sysprotects
If (object_id('tempdb..##tempprotects') is not null)
			drop table ##tempprotects

Exec('select * into ##tempprotects from [master].sys.sysprotects')

--------------------  Cursor for 24out  -----------------------
 EXECUTE('DECLARE cursor_24outb Insensitive Cursor For ' + 
		'SELECT distinct CONVERT(int,p.action), p.protecttype, p.uid, o.type, x.name, o.name, u.name, u.uid, p.id, o.is_ms_shipped
		 From ##tempprotects  p
			 , [master].sys.all_objects  o
			 , [master].sys.sysusers  u
			 , [master].sys.schemas  x
	  Where  p.id = o.object_id
	  And    u.uid = p.uid
	  And    o.schema_id = x.schema_id
	  And    p.action in (193, 195, 196, 197, 224, 26) 
	  And    p.uid not in (16382, 16383)
	  And    u.name in (select name from #temp_dbusers)
	  Order By p.uid, o.name, p.protecttype, CONVERT(int,p.action)
   For Read Only')


OPEN cursor_24outb

WHILE (24=24)
   Begin
	FETCH Next From cursor_24outb Into @cu24action, @cu24protecttype, @cu24puid, @cu24objtype, @cu24Schemaname, @cu24OBJname, @cu24grantee, @cu24uid, @cu24id, @cu24is_ms_shipped

	IF (@@fetch_status < 0)
		   begin
			  CLOSE cursor_24outb
		  BREAK
		   end


	If @cu24is_ms_shipped = 1 and @cu24uid < 5
	   begin
		goto skip24b
	   end

	If @cu24is_ms_shipped = 1 and @cu24grantee in ('TargetServersRole'
						    , 'SQLAgentUserRole'
						    , 'SQLAgentReaderRole'
						    , 'SQLAgentOperatorRole'
						    , 'DatabaseMailUserRole'
						    , 'db_dtsadmin'
						    , 'db_dtsltduser'
						    , 'db_dtsoperator')
	   begin
		goto skip24b
	   end

	If @cu24protecttype = 204
	   begin
		select @grantoption = 'WITH GRANT OPTION'
	   end
	Else
	   begin
		select @grantoption = ''
	   end


	IF @cu24action = 224 and @cu24protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT EXECUTE ON OBJECT::[' + @cu24Schemaname + '].[' + @cu24OBJname + '] to [' + @cu24grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu24action = 26 and @cu24protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT REFERENCES ON [' + @cu24Schemaname + '].[' + @cu24OBJname + '] to [' + @cu24grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu24action = 193 and @cu24protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT SELECT ON OBJECT::[' + @cu24Schemaname + '].[' + @cu24OBJname + '] to [' + @cu24grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu24action = 195 and @cu24protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT INSERT ON OBJECT::[' + @cu24Schemaname + '].[' + @cu24OBJname + '] to [' + @cu24grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu24action = 196 and @cu24protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT DELETE ON OBJECT::[' + @cu24Schemaname + '].[' + @cu24OBJname + '] to [' + @cu24grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu24action = 197 and @cu24protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT UPDATE ON OBJECT::[' + @cu24Schemaname + '].[' + @cu24OBJname + '] to [' + @cu24grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu24protecttype = 206 
	   begin 
		delete from #t1_Prots

		--  Insert data into the temp table
		INSERT	#t1_Prots
				(Id
			,Type1Code
			,ObjType
			,ActionName
			,ActionCategory
			,ProtectTypeName
			,Columns_Orig
			,OwnerName
			,ObjectName
			,GranteeName
			,GrantorName
			,ColumnName
			,ColId
			,Max_ColId
			,All_Col_Bits_On
			,new_Bit_On
			)
			/*	1Regul indicates action can be at column level,
				2Simpl indicates action is at the object level */
			SELECT	sysp.id
				,case
					when sysp.columns is null then '2Simpl'
					else '1Regul'
					end
				,Null
				,val1.name
				,'Ob'
				,val2.name
				,sysp.columns
				,null
				,null
				,null
				,null
				,case
					when sysp.columns is null then '.'
					else Null
					end
				,-123
				,Null
				,Null
				,Null
			FROM	##tempprotects sysp
				,master.dbo.spt_values  val1
				,master.dbo.spt_values  val2
			where	sysp.id  = @cu24id
			and	val1.type     = 'T'
			and	val1.number   = sysp.action
			and	val2.type     = 'T' --T is overloaded.
			and	val2.number   = sysp.protecttype
			and	sysp.protecttype = 206
			and 	sysp.id != 0
			and	sysp.uid = @cu24uid


		IF EXISTS (SELECT * From #t1_Prots)
		   begin
			--  set owner name
			select @cmd = 'UPDATE #t1_Prots set OwnerName = ''' + @cu24Schemaname + ''' WHERE id = ' + convert(varchar(20), @cu24id)
			exec(@cmd)

			--  set object name
			select @cmd = 'UPDATE #t1_Prots set ObjectName = ''' + @cu24OBJname + ''' WHERE id = ' + convert(varchar(20), @cu24id)
			exec(@cmd)

			--  set grantee name
			select @cmd = 'UPDATE #t1_Prots set GranteeName = ''' + @cu24grantee + ''' WHERE id = ' + convert(varchar(20), @cu24id)
			exec(@cmd)

			--  set object type
			Exec('UPDATE #t1_Prots 
			set ObjType = ob.type
			FROM [master].sys.objects ob
			WHERE ob.object_id = #t1_Prots.Id')
		
			--  set Max_ColId
			Exec('UPDATE #t1_Prots
			set Max_ColId = (select max(colid) From [master].sys.columns sysc where #t1_Prots.Id = sysc.object_id)	-- colid may not consecutive if column dropped
			where Type1Code = ''1Regul''')
		
		
			-- First bit set indicates actions pretains to new columns. (i.e. table-level permission)
			-- Set new_Bit_On accordinglly
			UPDATE	#t1_Prots 
			SET new_Bit_On = CASE convert(int,substring(Columns_Orig,1,1)) & 1
						WHEN	1 then	1
						ELSE	0
						END
			WHERE	ObjType	<> 'V'	and	 Type1Code = '1Regul'
		
			-- Views don't get new columns
			UPDATE #t1_Prots 
			set new_Bit_On = 0
			WHERE  ObjType = 'V'

			-- Indicate enties where column level action pretains to all columns in table All_Col_Bits_On = 1					*/
			Exec('UPDATE #t1_Prots
			set All_Col_Bits_On = 1
			where #t1_Prots.Type1Code = ''1Regul''
			  and not exists (select * from [master].sys.columns sysc, master.dbo.spt_values v
						where #t1_Prots.Id = sysc.object_id and sysc.column_id = v.number
						and v.number <= Max_ColId		-- column may be dropped/added after Max_ColId snap-shot 
						and v.type = ''P'' and
						-- Columns_Orig where first byte is 1 means off means on and on means off
						-- where first byte is 0 means off means off and on means on
							case convert(int,substring(#t1_Prots.Columns_Orig, 1, 1)) & 1
								when 0 then convert(tinyint, substring(#t1_Prots.Columns_Orig, v.low, 1))
								else (~convert(tinyint, isnull(substring(#t1_Prots.Columns_Orig, v.low, 1),0)))
							end & v.high = 0)')
			
			-- Indicate entries where column level action pretains to only some of columns in table All_Col_Bits_On = 0
			UPDATE	#t1_Prots	
			set All_Col_Bits_On = 0
			WHERE #t1_Prots.Type1Code = '1Regul'
			  and All_Col_Bits_On is null

			Update #t1_Prots
			set ColumnName = case
						when All_Col_Bits_On = 1 and new_Bit_On = 1 then '(All+New)'
						when All_Col_Bits_On = 1 and new_Bit_On = 0 then '(All)'
						when All_Col_Bits_On = 0 and new_Bit_On = 1 then '(New)'
						end
			from #t1_Prots
			where ObjType IN ('S ' ,'U ', 'V ')
			  and Type1Code = '1Regul'
			  and NOT (All_Col_Bits_On = 0 and new_Bit_On = 0)
		
			-- Expand and Insert individual column permission rows
			Exec('INSERT	into   #t1_Prots
				(Id
				,Type1Code
				,ObjType
				,ActionName
				,ActionCategory
				,ProtectTypeName
				,OwnerName
				,ObjectName
				,GranteeName
				,GrantorName
				,ColumnName
				,ColId	)
			   SELECT	prot1.Id
					,''1Regul''
					,ObjType
					,ActionName
					,ActionCategory
					,ProtectTypeName
					,OwnerName
					,ObjectName
					,GranteeName
					,GrantorName
					,null
					,val1.number
				from	#t1_Prots              prot1
					,master.dbo.spt_values  val1
					,[master].sys.columns sysc
				where	prot1.ObjType    IN (''S '' ,''U '' ,''V '')
				and prot1.Id	= sysc.object_id
				and	val1.type   = ''P''
				and	val1.number = sysc.column_id
				and	case convert(int,substring(prot1.Columns_Orig, 1, 1)) & 1
						when 0 then convert(tinyint, substring(prot1.Columns_Orig, val1.low, 1))
						else (~convert(tinyint, isnull(substring(prot1.Columns_Orig, val1.low, 1),0)))
						end & val1.high <> 0
				and prot1.All_Col_Bits_On <> 1')
		
			--  set column names
			Exec('UPDATE #t1_Prots 
			set ColumnName = c.name
			FROM [master].sys.columns c
			WHERE c.object_id = #t1_Prots.Id
			and   c.column_id = #t1_Prots.ColId')


			delete from #t1_Prots
			where ObjType IN ('S ' ,'U ' ,'V ')
			  and All_Col_Bits_On = 0
			  and new_Bit_On = 0
		
		   end
		
		--------------------  Cursor for DB names  -------------------
		EXECUTE('DECLARE cursor_56b Insensitive Cursor For ' + 
		  'SELECT t.ActionName, t.ProtectTypeName, t.OwnerName, t.ObjectName, t.GranteeName, t.ColumnName, t.All_Col_Bits_On
		   From #t1_Prots   t ' + 
		  'Order By t.GranteeName For Read Only')

		
		OPEN cursor_56b
		
		WHILE (56=56)
		   Begin
			FETCH Next From cursor_56b Into @cu56ActionName, @cu56ProtectTypeName, @cu56OwnerName, @cu56ObjectName, @cu56GranteeName, @cu56ColumnName, @cu56All_Col_Bits_On
			IF (@@fetch_status < 0)
				   begin
					  CLOSE cursor_56b
				  BREAK
				   end
		

			If @cu56All_Col_Bits_On is not null or @cu56ColumnName = '.'
			   begin
				Print  ' '

				Select @miscprint = rtrim(upper(@cu56ProtectTypeName)) + ' ' + rtrim(upper(@cu56ActionName)) + ' ON OBJECT::[' + rtrim(@cu56OwnerName) + '].[' + @cu56ObjectName + '] To [' + @cu56GranteeName + '] CASCADE' 
				Print  @miscprint

				Print  @G_O
			   end
			Else
			   begin
				Print  ' '

				Select @miscprint = rtrim(upper(@cu56ProtectTypeName)) + ' ' + rtrim(upper(@cu56ActionName)) + ' ON OBJECT::[' + rtrim(@cu56OwnerName) + '].[' + @cu56ObjectName + '] ([' + @cu56ColumnName + ']) To [' + @cu56GranteeName + '] CASCADE' 
				Print  @miscprint

				Print  @G_O
			   end
		
		   End  -- loop 56b	
		DEALLOCATE cursor_56b
	   end
	ELSE
	   begin
		Print  ' '

		Select @miscprint = '-- Error on OBJECT::[' + @cu24Schemaname + '].[' + @cu24OBJname + '] for user [' + @cu24grantee + ']'
		Print  @miscprint
	   end

	Select @output_flag	= 'y' 

 
   skip24b:

   End  -- loop 24b
   DEALLOCATE cursor_24outb


-----------------------------------------------------------------------------------
--  END SYSgrantobjectprivileges for Master Section ------------------------------------------
-----------------------------------------------------------------------------------


Print  ' '
Print  ' '



-----------------------------------------------------------------------------------
--  START SYScreateMSDBusers Section ------------------------------------------------
-----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Create Users for MSDB'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [msdb]'
Print  @miscprint

Print  @G_O

Print  ' '



--------------------  Cursor for 26DB  -----------------------
EXECUTE('DECLARE cu26_DBAccessc Insensitive Cursor For ' + 
  'SELECT dp.name, dp.type, dp.default_schema_name
   From [msdb].sys.database_principals  dp ' + 
  'Where dp.type <> ''R''
	 and dp.name in (select name from #temp_dbusers)
   Order By dp.type, dp.name For Read Only')


OPEN cu26_DBAccessc

WHILE (26=26)
   Begin
	FETCH Next From cu26_DBAccessc Into @cu26name, @cu26type, @cu26default_schema_name 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu26_DBAccessc
		  BREAK
		   end

	If @cu26default_schema_name is null or @cu26default_schema_name = 'dbo'
	   begin
		Select @miscprint = 'If not exists (select 1 from [msdb].sys.database_principals where name = ''' + @cu26name + ''' and type = ''' + @cu26type + ''')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      CREATE USER [' + @cu26name + '];'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end
	Else
	   begin
		Select @miscprint = 'CREATE USER [' + @cu26name + '] WITH DEFAULT_SCHEMA = ' + @cu26default_schema_name + ';'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end

	--  This code will fix the schema ownership for users that may have been previously removed from the database
	Select @miscprint = 'If exists (select 1 from [msdb].sys.schemas where name = ''' + @cu26name + ''' and principal_id = 1)'
	Print  @miscprint

	Select @miscprint = '   begin'
	Print  @miscprint

	Select @miscprint = '      ALTER AUTHORIZATION ON SCHEMA::[' + @cu26name + '] TO [' + @cu26name + '];'
	Print  @miscprint

	Select @miscprint = '   end'
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Print  ' '


	Select @output_flag	= 'y' 

   End  -- loop 26
   DEALLOCATE cu26_DBAccessc


-----------------------------------------------------------------------------------
--  END SYScreateMSDBusers Section --------------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
--  START SYSaddMSDBroles Section ---------------------------------------------------
-----------------------------------------------------------------------------------

Select @output_flag02 = 'n' 

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Add Roles for MSDB'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [msdb]'
Print  @miscprint

Print  @G_O

Print  ' '


--------------------  Cursor for 28DB  -----------------------
EXECUTE('DECLARE cu28_DBRolec Insensitive Cursor For ' + 
  'SELECT r.name, r.altuid, r.issqlrole, r.isapprole
   From [msdb].sys.sysusers  u, [msdb].sys.sysusers  r, [msdb].sys.sysmembers  m ' + 
  'Where (r.issqlrole = 1 or r.isapprole = 1)
	 and (r.uid < 16380 or r.name = ''RSExecRole'')
	 and r.name <> ''public''
         and u.uid > 4
	 and u.uid = m.memberuid
	 and m.groupuid = r.uid
         and u.name in (select name from #temp_dbusers)
   Order By r.uid For Read Only')


OPEN cu28_DBRolec

WHILE (28=28)
   Begin
	FETCH Next From cu28_DBRolec Into @cu28Uname, @cu28Ualtuid, @cu28Uissqlrole, @cu28Uisapprole 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu28_DBRolec
		  BREAK
		   end


	If @cu28Uissqlrole = 1
	   begin

		Select @cmd = 'USE msdb' 
				+ ' SELECT @save_altname = (select name from sys.sysusers where uid = ' + convert(varchar(10), @cu28Ualtuid) + ')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_altname sysname output', @save_altname output
		--print @save_altname

		Select @miscprint = 'If not exists (select 1 from msdb.sys.database_principals where name = ''' + @cu28Uname + ''' and type = ''R'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      CREATE ROLE [' + @cu28Uname + '] AUTHORIZATION [' + @save_altname + '];'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Print  @G_O

		Print  ' '

		goto end_01c
	   end


	If @cu28Uisapprole = 1
	   begin
		Select @cmd = 'USE msdb' 
				+ ' SELECT @save_schemaname = (select default_schema_name from sys.database_principals where name = ''' + @cu28Uname + ''')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_schemaname sysname output', @save_schemaname output
		--print @save_schemaname

		Select @miscprint = '/* CREATE APPLICATION ROLE ---------------------------------------------  */'
		Print  @miscprint

		Select @miscprint = '/* To avoid disclosure of passwords, the password is generated in script. */'
		Print  @miscprint

		Select @miscprint = 'declare @idx as int'
		Print  @miscprint

		Select @miscprint = 'declare @randomPwd as nvarchar(64)'
		Print  @miscprint

		Select @miscprint = 'declare @rnd as float'
		Print  @miscprint

		Select @miscprint = 'declare @cmd nvarchar(4000)'
		Print  @miscprint

		Select @miscprint = 'select @idx = 0'
		Print  @miscprint

		Select @miscprint = 'select @randomPwd = N'''
		Print  @miscprint

		Select @miscprint = 'select @rnd = rand((@@CPU_BUSY % 100) + ((@@IDLE % 100) * 100) +'
		Print  @miscprint

		Select @miscprint = '       (DATEPART(ss, GETDATE()) * 10000) + ((cast(DATEPART(ms, GETDATE()) as int) % 100) * 1000000))'
		Print  @miscprint

		Select @miscprint = 'while @idx < 64'
		Print  @miscprint

		Select @miscprint = 'begin'
		Print  @miscprint

		Select @miscprint = '   select @randomPwd = @randomPwd + char((cast((@rnd * 83) as int) + 43))'
		Print  @miscprint

		Select @miscprint = '   select @idx = @idx + 1'
		Print  @miscprint

		Select @miscprint = '   select @rnd = rand()'
		Print  @miscprint

		Select @miscprint = 'end'
		Print  @miscprint

		Select @miscprint = 'select @cmd = N''CREATE APPLICATION ROLE [' + @cu28Uname + '] WITH DEFAULT_SCHEMA = [' + @save_schemaname + '], '' + N''PASSWORD = N'' + QUOTENAME(@randomPwd,'''''''')'
		Print  @miscprint

		Select @miscprint = 'EXEC dbo.sp_executesql @cmd'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end

	end_01c:

	Select @output_flag02 = 'y'

   End  -- loop 28
   DEALLOCATE cu28_DBRolec

If @output_flag02 = 'n'
   begin
	Select @miscprint = '-- No output for msdb.'
	Print  @miscprint

	Print  ' '
   end


-----------------------------------------------------------------------------------
--  END SYSaddMSDBroles Section -----------------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
--  START SYSaddMSDBrolemembers Section ---------------------------------------------
-----------------------------------------------------------------------------------

Select @output_flag02 = 'n' 

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Add Role Members for MSDB'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [msdb]'
Print  @miscprint

Print  @G_O

Print  ' '


--------------------  Cursor for 30DB  -----------------------
EXECUTE('DECLARE cu30_DBRolec Insensitive Cursor For ' + 
  'SELECT r.name, u.name
   From [msdb].sys.sysusers  u, [msdb].sys.sysusers  r, [msdb].sys.sysmembers  m ' + 
  'Where u.uid > 4
	 and u.uid = m.memberuid
	 and m.groupuid = r.uid
         and u.name in (select name from #temp_dbusers)
   Order By r.name, u.uid For Read Only')

OPEN cu30_DBRolec

WHILE (30=30)
   Begin
	FETCH Next From cu30_DBRolec Into @cu30Urole, @cu30Uname 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu30_DBRolec
		  BREAK
		   end

	 
	Select @miscprint = 'sp_addrolemember ''' + @cu30Urole + ''', '''  + @cu30Uname + ''''
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Select @output_flag02 = 'y'

   End  -- loop 30
   DEALLOCATE cu30_DBRolec


If @output_flag02 = 'n'
   begin
	Print ''

	Select @miscprint = '-- No output for msdb.'
	Print  @miscprint

	Print ''
   end
Else
   begin
	Select @output_flag02 = 'n' 
   end


-----------------------------------------------------------------------------------
--  END SYSaddMSDBrolemembers Section -----------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
--  START SYSgrantobjectprivileges (MSDB) Section -------------------------------
-----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'GRANT OBJECT PRIVILEGES for Msdb'
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [msdb]'
Print  @miscprint

Print  @G_O

Print  ' '


--  Create the temp table for sysprotects
If (object_id('tempdb..##tempprotects') is not null)
			drop table ##tempprotects

Exec('select * into ##tempprotects from [msdb].sys.sysprotects')

--------------------  Cursor for 32out  -----------------------
 EXECUTE('DECLARE cursor_32outc Insensitive Cursor For ' + 
		'SELECT distinct CONVERT(int,p.action), p.protecttype, p.uid, o.type, x.name, o.name, u.name, u.uid, p.id, o.is_ms_shipped
		 From ##tempprotects  p
			 , [msdb].sys.all_objects  o
			 , [msdb].sys.sysusers  u
			 , [msdb].sys.schemas  x
	  Where  p.id = o.object_id
	  And    u.uid = p.uid
	  And    o.schema_id = x.schema_id
	  And    p.action in (193, 195, 196, 197, 224, 26) 
	  And    p.uid not in (16382, 16383)
	  And    u.name in (select name from #temp_dbusers)
	  Order By p.uid, o.name, p.protecttype, CONVERT(int,p.action)
   For Read Only')


OPEN cursor_32outc

WHILE (32=32)
   Begin
	FETCH Next From cursor_32outc Into @cu32action, @cu32protecttype, @cu32puid, @cu32objtype, @cu32Schemaname, @cu32OBJname, @cu32grantee, @cu32uid, @cu32id, @cu32is_ms_shipped

	IF (@@fetch_status < 0)
		   begin
			  CLOSE cursor_32outc
		  BREAK
		   end


	If @cu32is_ms_shipped = 1 and @cu32uid < 5
	   begin
		goto skip32c
	   end

	If @cu32is_ms_shipped = 1 and @cu32grantee in ('TargetServersRole'
						    , 'SQLAgentUserRole'
						    , 'SQLAgentReaderRole'
						    , 'SQLAgentOperatorRole'
						    , 'DatabaseMailUserRole'
						    , 'db_dtsadmin'
						    , 'db_dtsltduser'
						    , 'db_dtsoperator')
	   begin
		goto skip32c
	   end

	If @cu32protecttype = 204
	   begin
		select @grantoption = 'WITH GRANT OPTION'
	   end
	Else
	   begin
		select @grantoption = ''
	   end


	IF @cu32action = 224 and @cu32protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT EXECUTE ON OBJECT::[' + @cu32Schemaname + '].[' + @cu32OBJname + '] to [' + @cu32grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu32action = 26 and @cu32protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT REFERENCES ON [' + @cu32Schemaname + '].[' + @cu32OBJname + '] to [' + @cu32grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu32action = 193 and @cu32protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT SELECT ON OBJECT::[' + @cu32Schemaname + '].[' + @cu32OBJname + '] to [' + @cu32grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu32action = 195 and @cu32protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT INSERT ON OBJECT::[' + @cu32Schemaname + '].[' + @cu32OBJname + '] to [' + @cu32grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu32action = 196 and @cu32protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT DELETE ON OBJECT::[' + @cu32Schemaname + '].[' + @cu32OBJname + '] to [' + @cu32grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu32action = 197 and @cu32protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT UPDATE ON OBJECT::[' + @cu32Schemaname + '].[' + @cu32OBJname + '] to [' + @cu32grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu32protecttype = 206 
	   begin 
		delete from #t1_Prots

		--  Insert data into the temp table
		INSERT	#t1_Prots
				(Id
			,Type1Code
			,ObjType
			,ActionName
			,ActionCategory
			,ProtectTypeName
			,Columns_Orig
			,OwnerName
			,ObjectName
			,GranteeName
			,GrantorName
			,ColumnName
			,ColId
			,Max_ColId
			,All_Col_Bits_On
			,new_Bit_On
			)
			/*	1Regul indicates action can be at column level,
				2Simpl indicates action is at the object level */
			SELECT	sysp.id
				,case
					when sysp.columns is null then '2Simpl'
					else '1Regul'
					end
				,Null
				,val1.name
				,'Ob'
				,val2.name
				,sysp.columns
				,null
				,null
				,null
				,null
				,case
					when sysp.columns is null then '.'
					else Null
					end
				,-123
				,Null
				,Null
				,Null
			FROM	##tempprotects sysp
				,master.dbo.spt_values  val1
				,master.dbo.spt_values  val2
			where	sysp.id  = @cu32id
			and	val1.type     = 'T'
			and	val1.number   = sysp.action
			and	val2.type     = 'T' --T is overloaded.
			and	val2.number   = sysp.protecttype
			and	sysp.protecttype = 206
			and 	sysp.id != 0
			and	sysp.uid = @cu32uid


		IF EXISTS (SELECT * From #t1_Prots)
		   begin
			--  set owner name
			select @cmd = 'UPDATE #t1_Prots set OwnerName = ''' + @cu32Schemaname + ''' WHERE id = ' + convert(varchar(20), @cu32id)
			exec(@cmd)

			--  set object name
			select @cmd = 'UPDATE #t1_Prots set ObjectName = ''' + @cu32OBJname + ''' WHERE id = ' + convert(varchar(20), @cu32id)
			exec(@cmd)

			--  set grantee name
			select @cmd = 'UPDATE #t1_Prots set GranteeName = ''' + @cu32grantee + ''' WHERE id = ' + convert(varchar(20), @cu32id)
			exec(@cmd)

			--  set object type
			Exec('UPDATE #t1_Prots 
			set ObjType = ob.type
			FROM [msdb].sys.objects ob
			WHERE ob.object_id = #t1_Prots.Id')
		
			--  set Max_ColId
			Exec('UPDATE #t1_Prots
			set Max_ColId = (select max(colid) From [msdb].sys.columns sysc where #t1_Prots.Id = sysc.object_id)	-- colid may not consecutive if column dropped
			where Type1Code = ''1Regul''')
		
		
			-- First bit set indicates actions pretains to new columns. (i.e. table-level permission)
			-- Set new_Bit_On accordinglly
			UPDATE	#t1_Prots 
			SET new_Bit_On = CASE convert(int,substring(Columns_Orig,1,1)) & 1
						WHEN	1 then	1
						ELSE	0
						END
			WHERE	ObjType	<> 'V'	and	 Type1Code = '1Regul'
		
			-- Views don't get new columns
			UPDATE #t1_Prots 
			set new_Bit_On = 0
			WHERE  ObjType = 'V'

			-- Indicate enties where column level action pretains to all columns in table All_Col_Bits_On = 1					*/
			Exec('UPDATE #t1_Prots
			set All_Col_Bits_On = 1
			where #t1_Prots.Type1Code = ''1Regul''
			  and not exists (select * from [msdb].sys.columns sysc, master.dbo.spt_values v
						where #t1_Prots.Id = sysc.object_id and sysc.column_id = v.number
						and v.number <= Max_ColId		-- column may be dropped/added after Max_ColId snap-shot 
						and v.type = ''P'' and
						-- Columns_Orig where first byte is 1 means off means on and on means off
						-- where first byte is 0 means off means off and on means on
							case convert(int,substring(#t1_Prots.Columns_Orig, 1, 1)) & 1
								when 0 then convert(tinyint, substring(#t1_Prots.Columns_Orig, v.low, 1))
								else (~convert(tinyint, isnull(substring(#t1_Prots.Columns_Orig, v.low, 1),0)))
							end & v.high = 0)')
			
			-- Indicate entries where column level action pretains to only some of columns in table All_Col_Bits_On = 0
			UPDATE	#t1_Prots	
			set All_Col_Bits_On = 0
			WHERE #t1_Prots.Type1Code = '1Regul'
			  and All_Col_Bits_On is null

			Update #t1_Prots
			set ColumnName = case
						when All_Col_Bits_On = 1 and new_Bit_On = 1 then '(All+New)'
						when All_Col_Bits_On = 1 and new_Bit_On = 0 then '(All)'
						when All_Col_Bits_On = 0 and new_Bit_On = 1 then '(New)'
						end
			from #t1_Prots
			where ObjType IN ('S ' ,'U ', 'V ')
			  and Type1Code = '1Regul'
			  and NOT (All_Col_Bits_On = 0 and new_Bit_On = 0)
		
			-- Expand and Insert individual column permission rows
			Exec('INSERT	into   #t1_Prots
				(Id
				,Type1Code
				,ObjType
				,ActionName
				,ActionCategory
				,ProtectTypeName
				,OwnerName
				,ObjectName
				,GranteeName
				,GrantorName
				,ColumnName
				,ColId	)
			   SELECT	prot1.Id
					,''1Regul''
					,ObjType
					,ActionName
					,ActionCategory
					,ProtectTypeName
					,OwnerName
					,ObjectName
					,GranteeName
					,GrantorName
					,null
					,val1.number
				from	#t1_Prots              prot1
					,master.dbo.spt_values  val1
					,[msdb].sys.columns sysc
				where	prot1.ObjType    IN (''S '' ,''U '' ,''V '')
				and prot1.Id	= sysc.object_id
				and	val1.type   = ''P''
				and	val1.number = sysc.column_id
				and	case convert(int,substring(prot1.Columns_Orig, 1, 1)) & 1
						when 0 then convert(tinyint, substring(prot1.Columns_Orig, val1.low, 1))
						else (~convert(tinyint, isnull(substring(prot1.Columns_Orig, val1.low, 1),0)))
						end & val1.high <> 0
				and prot1.All_Col_Bits_On <> 1')
		
			--  set column names
			Exec('UPDATE #t1_Prots 
			set ColumnName = c.name
			FROM [msdb].sys.columns c
			WHERE c.object_id = #t1_Prots.Id
			and   c.column_id = #t1_Prots.ColId')


			delete from #t1_Prots
			where ObjType IN ('S ' ,'U ' ,'V ')
			  and All_Col_Bits_On = 0
			  and new_Bit_On = 0
		
		   end
		
		--------------------  Cursor for DB names  -------------------
		EXECUTE('DECLARE cursor_56c Insensitive Cursor For ' + 
		  'SELECT t.ActionName, t.ProtectTypeName, t.OwnerName, t.ObjectName, t.GranteeName, t.ColumnName, t.All_Col_Bits_On
		   From #t1_Prots   t ' + 
		  'Order By t.GranteeName For Read Only')

		
		OPEN cursor_56c
		
		WHILE (56=56)
		   Begin
			FETCH Next From cursor_56c Into @cu56ActionName, @cu56ProtectTypeName, @cu56OwnerName, @cu56ObjectName, @cu56GranteeName, @cu56ColumnName, @cu56All_Col_Bits_On
			IF (@@fetch_status < 0)
				   begin
					  CLOSE cursor_56c
				  BREAK
				   end
		

			If @cu56All_Col_Bits_On is not null or @cu56ColumnName = '.'
			   begin
				Print  ' '

				Select @miscprint = rtrim(upper(@cu56ProtectTypeName)) + ' ' + rtrim(upper(@cu56ActionName)) + ' ON OBJECT::[' + rtrim(@cu56OwnerName) + '].[' + @cu56ObjectName + '] To [' + @cu56GranteeName + '] CASCADE' 
				Print  @miscprint

				Print  @G_O
			   end
			Else
			   begin
				Print  ' '

				Select @miscprint = rtrim(upper(@cu56ProtectTypeName)) + ' ' + rtrim(upper(@cu56ActionName)) + ' ON OBJECT::[' + rtrim(@cu56OwnerName) + '].[' + @cu56ObjectName + '] ([' + @cu56ColumnName + ']) To [' + @cu56GranteeName + '] CASCADE' 
				Print  @miscprint

				Print  @G_O
			   end
		
		   End  -- loop 56c	
		DEALLOCATE cursor_56c
	   end
	ELSE
	   begin
		Print  ' '

		Select @miscprint = '-- Error on OBJECT::[' + @cu32Schemaname + '].[' + @cu32OBJname + '] for user [' + @cu32grantee + ']'
		Print  @miscprint
	   end

	Select @output_flag	= 'y' 

 
   skip32c:

   End  -- loop 32c
   DEALLOCATE cursor_32outc


-----------------------------------------------------------------------------------
--  END SYSgrantobjectprivileges for MSDB Section ------------------------------------------
-----------------------------------------------------------------------------------


Print  ' '
Print  ' '



-----------------------------------------------------------------------------------
--  START SYSaddmessages Section --------------------------------------------------
-----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'ADD MESSAGES for master'  
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE master'
Print  @miscprint

Print  @G_O

Print  ' '



--------------------  Cursor 34  -----------------------

EXECUTE('DECLARE cursor_34 Insensitive Cursor For ' + 
  'SELECT convert(varchar(10),m.message_id), convert(sysname,l.name), convert(varchar(10),m.severity), m.is_event_logged, convert(varchar(255),m.text)
   From master.sys.messages  m , master.sys.syslanguages  l ' + 
  'Where m.message_id > 49999
     and m.language_id = l.lcid
   Order By m.message_id For Read Only')



OPEN cursor_34

WHILE (34=34)
   Begin
	FETCH Next From cursor_34 Into @cu34Mmessage_id, @cu34Mlanguage_id, @cu34Mseverity, @cu34Mis_event_logged, @cu34Mtext
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_34
	      BREAK
           end


	--  Fix single quote problem in @cu34name
	Select @startpos = 1
	label01:
	select @charpos = charindex('''', @cu34Mtext, @startpos)
	IF @charpos <> 0
	   begin
		select @cu34Mtext = stuff(@cu34Mtext, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @cu34Mtext, @startpos)
	IF @charpos <> 0
	   begin
		goto label01
	   end	

	IF @cu34Mis_event_logged = 1
	   begin
		select @save_log = 'True'
	   end
	Else
	   begin
		select @save_log = 'False'
	   end


	Print  ' '

	Select @miscprint = 'if not exists (select 1 from master.sys.messages where message_id = ' + @cu34Mmessage_id + ')'                                                                                                                                                                                           
	Print  @miscprint

	Select @miscprint = '   begin'                                                                                                                                                                                                                                                        
	Print  @miscprint

	Select @miscprint = '      exec sp_addmessage @msgnum = ' +@cu34Mmessage_id 
	Print  @miscprint

	Select @miscprint = '                  ,@severity = ' +@cu34Mseverity 
	Print  @miscprint

	Select @miscprint = '                  ,@lang = ''' +@cu34Mlanguage_id+ '''' 
	Print  @miscprint

	Select @miscprint = '                  ,@msgtext = N''' +@cu34Mtext+ '''' 
	Print  @miscprint

	Select @miscprint = '                  ,@with_log = ''' +@save_log+ '''' 
	Print  @miscprint

	Select @miscprint = '                  ,@replace = ''replace''' 
	Print  @miscprint

	Select @miscprint = '   end'                                                                                                                                                                                                                                                        
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Select @output_flag	= 'y' 
 
   End  -- loop 34
   DEALLOCATE cursor_34


-----------------------------------------------------------------------------------
--  END SYSaddmessages Section ----------------------------------------------------
-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
--  START SYSchangedbowner Section ------------------------------------------------
-----------------------------------------------------------------------------------

Select @save_sidname = ''
Select @save_sidname = (select name from master.sys.server_principals where sid = @cu11DBsid)

If @save_sidname = '' or @save_sidname is null
   begin
    SELECT @save_sidname = SUSER_SNAME(@cu11DBsid)
   end


----------------------  Output for database owner change  ----------------------

Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'CHANGE DATABASE OWNER for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE master'
Print  @miscprint

Print  @G_O

Print  ' '


If @save_sidname = 'sa'
   begin
	Select @miscprint = 'ALTER AUTHORIZATION ON DATABASE::' + @cu11DBName + ' TO sa;' 
	Print  @miscprint

	Print  @G_O

	Print  ' '
   end
Else
   begin
	Select @miscprint = 'If (suser_sid(''' + @save_sidname + ''')) is null' 
	Print  @miscprint

	Select @miscprint = '   begin' 
	Print  @miscprint

	Select @miscprint = '      ALTER AUTHORIZATION ON DATABASE::' + @cu11DBName + ' TO sa;' 
	Print  @miscprint

	Select @miscprint = '   end' 
	Print  @miscprint

	Select @miscprint = 'Else' 
	Print  @miscprint

	Select @miscprint = '   begin' 
	Print  @miscprint

	Select @miscprint = '      ALTER AUTHORIZATION ON DATABASE::' + @cu11DBName + ' TO ' + QUOTENAME(@save_sidname) + ';' 
	Print  @miscprint

	Select @miscprint = '   end' 
	Print  @miscprint

	Print  @G_O

	Print  ' '
   end

Select @output_flag	= 'y' 


----------------------------------------------------------------------------------
--  END SYSchangedbowner Section -------------------------------------------------
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--  START SYSsetDBoptions Section ------------------------------------------------
----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Set database options for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Print  ' '


--  Print comatibility change command syntax  ----------------------
Print  ' '

Select @miscprint = '/*** Setting Database Compatibility Level ***/'
Print  @miscprint

Print  ' '

Select @miscprint = '/***' 
Print  @miscprint

Select @miscprint = 'EXEC master.sys.sp_dbcmptlevel ''' + @cu11DBName + ''', ''' + convert(varchar(2), @cu11DBcmptlevel) + ''';'
Print  @miscprint

Select @miscprint = 'GO'
Print  @miscprint

Select @miscprint = '***/' 
Print  @miscprint

Print  ' '

Print  ' '



Select @cmd = 'select v.name
   from master.dbo.spt_values v, master.sys.sysdatabases d
	where d.name=''' + @cu11DBname + '''
	  and ((number & ' + convert(varchar(10), @allstatopts) + ' <> 0
		and number not in (-1,' + convert(varchar(10), @allstatopts) + ')
		and v.type = ''D''
		and (v.number & d.status)=v.number)
	   or (number & ' + convert(varchar(10), @allcatopts) + ' <> 0
		and number not in (-1,' + convert(varchar(10), @allcatopts) + ')
		and v.type = ''DC''
		and d.category & v.number <> 0)
	   or (number & ' + convert(varchar(10), @alloptopts) + ' <> 0
		and number not in (-1,' + convert(varchar(10), @alloptopts) + ')
		and v.type = ''D2''
		and d.status2 & v.number <> 0))'


delete from @temp_options

insert into @temp_options (name) exec (@cmd)

delete from @temp_options where name is null or name = ''
--select * from @temp_options


--  Start the main process for this database
If (select count(*) from @tblvar_spt_values) > 0
   begin
	Update @tblvar_spt_values set process_flag = 'n'
	Select @recovery_flag = 'n'
	Select @restrict_flag = 'n'
	
	delete from @repl_options

	start_mainloop:

	Select @fulloptname = (select top 1 name from @tblvar_spt_values where process_flag = 'n')


    IF (@fulloptname IN ('ANSI null default'
        			,'dbo use only'
        			,'no chkpt on recovery'
        			,'read only'
        			,'select into/bulkcopy'
        			,'single user'
        			,'trunc. log on chkpt.'))
	   begin
		Select @CommentThisDBOption = 'N'
	   end
	ELSE
	   begin
		Select @CommentThisDBOption = 'Y'
	   end


	If @fulloptname in (select name from @temp_options)
	   begin
		Select @optvalue = 'true'
	   end
	Else
	   begin
		Select @optvalue = 'false'
	   end


	select @catvalue = 0
	select @catvalue = number
	  from master.dbo.spt_values
	  where lower(name) = lower(@fulloptname)
	  and type = 'DC'

	-- if replication options, format using sproc sp_replicationdboption
	If (@catvalue <> 0)
	   begin
		select @alt_optvalue = (case lower(@optvalue)
				when 'true' then 'true'
				when 'on' then 'true'
				else 'false'
			end)

		select @alt_optname = (case @catvalue
				when 1 then 'publish'
				when 2 then 'subscribe'
				when 4 then 'merge publish'
				else quotename(@fulloptname, '''')
			end)

		select @exec_stmt = quotename(@cu11DBName, '[')   + '.dbo.sp_replicationdboption'
		--print @exec_stmt

		select @cmd = 'EXEC ' + @exec_stmt + ' ' +  @cu11DBName + ', ' + @alt_optname + ', ' + @alt_optvalue
		Insert into @repl_options values (@cmd)

		goto get_next
	   end


	-- set option value in alter database
	select @alt_optvalue = (case lower(@optvalue)
			when 'true'	then 'ON'
			when 'on'	then 'ON'
			else 'OFF'
			end)

	-- set option name in alter database
	select @fulloptname = lower(@fulloptname)
	select @alt_optname = (case @fulloptname
			when 'auto create statistics' then 'AUTO_CREATE_STATISTICS'
			when 'auto update statistics' then 'AUTO_UPDATE_STATISTICS'
			when 'autoclose' then 'AUTO_CLOSE'
			when 'autoshrink' then 'AUTO_SHRINK'
			when 'ansi padding' then 'ANSI_PADDING'
			when 'arithabort' then 'ARITHABORT'
			when 'numeric roundabort' then 'NUMERIC_ROUNDABORT'
			when 'ansi null default' then 'ANSI_NULL_DEFAULT'
			when 'ansi nulls' then 'ANSI_NULLS'
			when 'ansi warnings' then 'ANSI_WARNINGS'
			when 'concat null yields null' then 'CONCAT_NULL_YIELDS_NULL'
			when 'cursor close on commit' then 'CURSOR_CLOSE_ON_COMMIT'
			when 'torn page detection' then 'TORN_PAGE_DETECTION'
			when 'quoted identifier' then 'QUOTED_IDENTIFIER'
			when 'recursive triggers' then 'RECURSIVE_TRIGGERS'
			when 'default to local cursor' then 'CURSOR_DEFAULT'
			when 'offline' then (case @alt_optvalue when 'ON' then 'OFFLINE' else 'ONLINE' end)
			when 'read only' then (case @alt_optvalue when 'ON' then 'READ_ONLY' else 'READ_WRITE' end)
			when 'dbo use only' then (case @alt_optvalue when 'ON' then 'RESTRICTED_USER' else 'MULTI_USER' end)
			when 'single user' then (case @alt_optvalue when 'ON' then 'SINGLE_USER' else 'MULTI_USER' end)
			when 'select into/bulkcopy' then 'RECOVERY'
			when 'trunc. log on chkpt.' then 'RECOVERY'
			when 'db chaining' then 'DB_CHAINING'
			else @alt_optname
			end)


	select @alt_optvalue = (case @fulloptname
			when 'default to local cursor' then (case @alt_optvalue when 'ON' then 'LOCAL' else 'GLOBAL' end)
			when 'offline' then ''
			when 'read only' then ''
			when 'dbo use only' then ''
			when 'single user' then ''
			else  @alt_optvalue
			end)


	--  Special set up for recovery option
	if lower(@fulloptname) = 'select into/bulkcopy' and @recovery_flag = 'n'
	   begin
		if @alt_optvalue = 'ON'
		   begin
			if databaseproperty(@cu11DBName, 'IsTrunclog') = 1
			   begin
				select @alt_optvalue = 'RECMODEL_70BACKCOMP'
				Select @recovery_flag = 'y'
			   end
			else
			   begin
				select @alt_optvalue = 'BULK_LOGGED'
				Select @recovery_flag = 'y'
			   end
		   end
		else
		   begin
			if databaseproperty(@cu11DBName, 'IsTrunclog') = 1
			   begin
				select @alt_optvalue = 'SIMPLE'
				Select @recovery_flag = 'y'
			   end
			else
			   begin
				select @alt_optvalue = 'FULL'
				Select @recovery_flag = 'y'
			   end
		   end
	   end
	Else if lower(@fulloptname) = 'select into/bulkcopy' and @recovery_flag = 'y'
	   begin
		goto get_next
	   end



	if lower(@fulloptname) = 'trunc. log on chkpt.' and @recovery_flag = 'n'
	   begin
		if @alt_optvalue = 'ON'
		   begin
			if databaseproperty(@cu11DBName, 'IsBulkCopy') = 1
			   begin
				select @alt_optvalue = 'RECMODEL_70BACKCOMP'
				Select @recovery_flag = 'y'
			   end
			else
			   begin
				select @alt_optvalue = 'SIMPLE'
				Select @recovery_flag = 'y'
			   end
		   end
		else
		   begin
			if databaseproperty(@cu11DBName, 'IsBulkCopy') = 1
			   begin
				select @alt_optvalue = 'BULK_LOGGED'
				Select @recovery_flag = 'y'
			   end
			else
			   begin
				select @alt_optvalue = 'FULL'
				Select @recovery_flag = 'y'
			   end
		   end
	   end
	Else if lower(@fulloptname) = 'trunc. log on chkpt.' and @recovery_flag = 'y'
	   begin
		goto get_next
	   end


	--  Special set up for restrict option
	if lower(@fulloptname) = 'dbo use only' and @restrict_flag = 'n'
	   begin
		if databaseproperty(@cu11DBName, 'IsDboOnly') = 1
		   begin
			select @alt_optname = 'RESTRICTED_USER'
			Select @restrict_flag = 'y'
		   end
		Else If databaseproperty(@cu11DBName, 'IsSingleUser') = 1
		   begin
			select @alt_optname = 'SINGLE_USER'
			Select @restrict_flag = 'y'
		   end
		Else
		   begin
			select @alt_optname = 'MULTI_USER'
			Select @restrict_flag = 'y'
		   end
	   end
	Else if lower(@fulloptname) = 'dbo use only' and @restrict_flag = 'y'
	   begin
		goto get_next
	   end


	if lower(@fulloptname) = 'single user' and @restrict_flag = 'n'
	   begin
		if databaseproperty(@cu11DBName, 'IsDboOnly') = 1
		   begin
			select @alt_optname = 'RESTRICTED_USER'
			Select @restrict_flag = 'y'
		   end
		Else If databaseproperty(@cu11DBName, 'IsSingleUser') = 1
		   begin
			select @alt_optname = 'SINGLE_USER'
			Select @restrict_flag = 'y'
		   end
		Else
		   begin
			select @alt_optname = 'MULTI_USER'
			Select @restrict_flag = 'y'
		   end
	   end
	Else if lower(@fulloptname) = 'single user' and @restrict_flag = 'y'
	   begin
		goto get_next
	   end



	-- construct the ALTER DATABASE command string
	IF (@CommentThisDBOption = 'Y')
	   begin
		Raiserror('%s%s',0,1,'/','***')
	   end

	select @exec_stmt = 'ALTER DATABASE ' + quotename(@cu11DBName) + ' SET ' + @alt_optname + ' ' + @alt_optvalue + ' WITH NO_WAIT'
	print @exec_stmt


	IF (@CommentThisDBOption = 'Y')
	   begin
		Raiserror('%s%s',0,1,'***','/')
	   end

	print ' '

	get_next:

	--  Check for more rows to process
		Update @tblvar_spt_values set process_flag = 'y' where name = @fulloptname
	If (select count(*) from @tblvar_spt_values where process_flag = 'n') > 0
	   begin
		goto start_mainloop
	  end

   end


--  Print out the replication options here
If (select count(*) from @repl_options) > 0
   begin
	start_repl_options:

	Select @miscprint = '/***'
	Print @miscprint

	Select @save_repl_options = (select top 1 output from @repl_options)
	Print @save_repl_options

	Select @miscprint = '***/'
	Print @miscprint

	Print ' '
   end


--  Check for more rows to process
Delete from @repl_options where output = @save_repl_options
If (select count(*) from @repl_options) > 0
   begin
	goto start_repl_options
  end


-----------------------------------------------------------------------------------
--  END SYSsetDBoptions Section ---------------------------------------------------
-----------------------------------------------------------------------------------


-----------------------------------------------------------------------------------
--  START SYSdropDBusers Section --------------------------------------------------
-----------------------------------------------------------------------------------


----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Drop Users for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [' + @cu11DBName + ']'
Print  @miscprint

Print  @G_O

Print  ' '


Select @miscprint = '---------------------------------------------------------------------------------------------------------------------------'
Print  @miscprint

Select @miscprint = '--  Use the Following code to DROP all Users from ''' + @cu11DBName + ''''
Print  @miscprint

Select @miscprint = '---------------------------------------------------------------------------------------------------------------------------'
Print  @miscprint

Select @miscprint = 'If exists (select 1 from [' + @cu11DBName + '].sys.assemblies where principal_id > 4 and principal_id < 16384)'
Print  @miscprint

Select @miscprint = '   begin'
Print  @miscprint

Select @miscprint = '      Declare @save_aname sysname'
Print  @miscprint

Select @miscprint = '      Declare @cmd nvarchar(500)'
Print  @miscprint

Select @miscprint = '      drop_user01:'
Print  @miscprint

Select @miscprint = '      Select @save_aname = (select top 1 name from [' + @cu11DBName + '].sys.assemblies where principal_id > 4 and principal_id < 16384)'
Print  @miscprint

Select @miscprint = '      Select @cmd = ''ALTER AUTHORIZATION ON Assembly::['' + @save_aname + ''] TO dbo;'''
Print  @miscprint

Select @miscprint = '      Print @cmd'
Print  @miscprint

Select @miscprint = '      Exec (@cmd)'
Print  @miscprint

Select @miscprint = '      If exists (select 1 from [' + @cu11DBName + '].sys.assemblies where principal_id > 4 and principal_id < 16384)'
Print  @miscprint

Select @miscprint = '         begin'
Print  @miscprint

Select @miscprint = '            goto drop_user01'
Print  @miscprint

Select @miscprint = '         end'
Print  @miscprint

Select @miscprint = '   end'
Print  @miscprint

Print  @G_O

Print  ' '


Select @miscprint = 'If exists (select 1 from [' + @cu11DBName + '].sys.schemas where principal_id > 4 and principal_id < 16384)'
Print  @miscprint

Select @miscprint = '   begin'
Print  @miscprint

Select @miscprint = '      Declare @save_sname sysname'
Print  @miscprint

Select @miscprint = '      Declare @cmd nvarchar(500)'
Print  @miscprint

Select @miscprint = '      drop_user02:'
Print  @miscprint

Select @miscprint = '      Select @save_sname = (select top 1 name from [' + @cu11DBName + '].sys.schemas where principal_id > 4 and principal_id < 16384)'
Print  @miscprint

Select @miscprint = '      Select @cmd = ''ALTER AUTHORIZATION ON SCHEMA::['' + @save_sname + ''] TO dbo;'''
Print  @miscprint

Select @miscprint = '      Print @cmd'
Print  @miscprint

Select @miscprint = '      Exec (@cmd)'
Print  @miscprint

Select @miscprint = '      If exists (select 1 from [' + @cu11DBName + '].sys.schemas where principal_id > 4 and principal_id < 16384)'
Print  @miscprint

Select @miscprint = '         begin'
Print  @miscprint

Select @miscprint = '            goto drop_user02'
Print  @miscprint

Select @miscprint = '         end'
Print  @miscprint

Select @miscprint = '   end'
Print  @miscprint

Print  @G_O

Print  ' '


Select @miscprint = 'If exists (select 1 from [' + @cu11DBName + '].sys.database_principals where principal_id > 4 and type <> ''R'')'
Print  @miscprint

Select @miscprint = '   begin'
Print  @miscprint

Select @miscprint = '      Declare @save_uname sysname'
Print  @miscprint

Select @miscprint = '      Declare @cmd nvarchar(500)'
Print  @miscprint

Select @miscprint = '      drop_user03:'
Print  @miscprint

Select @miscprint = '      Select @save_uname = (select top 1 name from [' + @cu11DBName + '].sys.database_principals where principal_id > 4 and type <> ''R'')'
Print  @miscprint

Select @miscprint = '      Select @cmd = ''DROP USER ['' + @save_uname + ''];'''
Print  @miscprint

Select @miscprint = '      Print @cmd'
Print  @miscprint

Select @miscprint = '      Exec (@cmd)'
Print  @miscprint

Select @miscprint = '      If exists (select 1 from [' + @cu11DBName + '].sys.database_principals where principal_id > 4 and type <> ''R'')'
Print  @miscprint

Select @miscprint = '         begin'
Print  @miscprint

Select @miscprint = '            goto drop_user03'
Print  @miscprint

Select @miscprint = '         end'
Print  @miscprint

Select @miscprint = '   end'
Print  @miscprint

Print  @G_O

Print  ' '



Select @miscprint = 'If exists (select 1 from [' + @cu11DBName + '].sys.schemas where principal_id > 4 and principal_id < 16384)'
Print  @miscprint

Select @miscprint = '   begin'
Print  @miscprint

Select @miscprint = '      Declare @save_uname sysname'
Print  @miscprint

Select @miscprint = '      Declare @save_schema_id int'
Print  @miscprint

Select @miscprint = '      Declare @cmd nvarchar(500)'
Print  @miscprint

Select @miscprint = '      Select @save_schema_id = 4'
Print  @miscprint

Select @miscprint = '      drop_schema04:'
Print  @miscprint

Select @miscprint = '      Select @save_schema_id = (select top 1 schema_id from [' + @cu11DBName + '].sys.schemas where schema_id > @save_schema_id and schema_id < 16380 order by schema_id)'
Print  @miscprint

Select @miscprint = '      Select @save_uname = (select name from [' + @cu11DBName + '].sys.schemas where schema_id = @save_schema_id)'
Print  @miscprint

Select @miscprint = '      If (select count(*) from [' + @cu11DBName + '].sys.objects where schema_id = @save_schema_id) = 0'
Print  @miscprint

Select @miscprint = '         begin'
Print  @miscprint

Select @miscprint = '            Select @cmd = ''DROP SCHEMA ['' + @save_uname + ''];'''
Print  @miscprint

Select @miscprint = '            Print @cmd'
Print  @miscprint

Select @miscprint = '            Exec (@cmd)'
Print  @miscprint

Select @miscprint = '         end'
Print  @miscprint

Select @miscprint = '      If (select count(*) from [' + @cu11DBName + '].sys.schemas where schema_id > @save_schema_id and schema_id < 16380) > 0'
Print  @miscprint

Select @miscprint = '         begin'
Print  @miscprint

Select @miscprint = '            goto drop_schema04'
Print  @miscprint

Select @miscprint = '         end'
Print  @miscprint

Select @miscprint = '   end'
Print  @miscprint

Print  @G_O

Print  ' '


Print  ' '

        
Select @output_flag2 = 'y' 


-----------------------------------------------------------------------------------
--  END SYSdropDBusers Section ----------------------------------------------------
-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
--  START SYScreateDBusers Section ------------------------------------------------
-----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Create Users for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [' + @cu11DBName + ']'
Print  @miscprint

Print  @G_O

Print  ' '



--------------------  Cursor for 36DB  -----------------------

EXECUTE('DECLARE cu36_DBAccess Insensitive Cursor For ' + 
  'SELECT dp.name, dp.type, dp.default_schema_name
   From [' + @cu11DBName + '].sys.database_principals  dp ' + 
  'Where dp.type <> ''R''
	 and dp.principal_id > 4
   Order By dp.type, dp.name For Read Only')

OPEN cu36_DBAccess

WHILE (36=36)
   Begin
	FETCH Next From cu36_DBAccess Into @cu36name, @cu36type, @cu36default_schema_name 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu36_DBAccess
		  BREAK
		   end

	If @cu36default_schema_name is null or @cu36default_schema_name = 'dbo'
	   begin
		Select @miscprint = 'CREATE USER [' + @cu36name + '];'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end
	Else
	   begin
		Select @miscprint = 'CREATE USER [' + @cu36name + '] WITH DEFAULT_SCHEMA = [' + @cu36default_schema_name + '];'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end

	--  This code will fix the schema ownership for users that may have been previously removed from the database
	Select @miscprint = 'If exists (select 1 from [' + @cu11DBName + '].sys.schemas where name = ''' + @cu36name + ''' and principal_id = 1)'
	Print  @miscprint

	Select @miscprint = '   begin'
	Print  @miscprint

	Select @miscprint = '      ALTER AUTHORIZATION ON SCHEMA::[' + @cu36name + '] TO [' + @cu36name + '];'
	Print  @miscprint

	Select @miscprint = '   end'
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Print  ' '


	Select @output_flag	= 'y' 

   End  -- loop 36
   DEALLOCATE cu36_DBAccess


-----------------------------------------------------------------------------------
--  END SYScreateDBusers Section --------------------------------------------------
-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
--  START ALTER AUTHORIZATION ON Assembly Section ---------------------------------
-----------------------------------------------------------------------------------

Select @output_flag02 = 'n' 

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'ALTER AUTHORIZATION ON Assembly (if any exist) for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [' + @cu11DBName + ']'
Print  @miscprint

Print  @G_O

Print  ' '


--------------------  Cursor for 41DB  -----------------------
EXECUTE('DECLARE cu38_Assembly Insensitive Cursor For ' + 
  'SELECT a.name, p.name
   From [' + @cu11DBName + '].sys.assemblies  a, [' + @cu11DBName + '].sys.database_principals  p ' + 
  'Where a.principal_id > 4 
    and  a.principal_id < 16384
    and  a.principal_id = p.principal_id
   Order By p.name, a.name For Read Only')

OPEN cu38_Assembly

WHILE (38=38)
   Begin
	FETCH Next From cu38_Assembly Into @cu38Aname, @cu38Pname 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu38_Assembly
		  BREAK
		   end


	Select @miscprint = 'ALTER AUTHORIZATION ON Assembly::' + @cu38Aname + ' TO ' + @cu38Pname + ';'
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Select @output_flag02 = 'y'

   End  -- loop 38
   DEALLOCATE cu38_Assembly

If @output_flag02 = 'n'
   begin
	Select @miscprint = '-- No output for this database.'
	Print  @miscprint

	Print  ' '
   end


-----------------------------------------------------------------------------------
--  END ALTER AUTHORIZATION ON Assembly Section -----------------------------------
-----------------------------------------------------------------------------------


-----------------------------------------------------------------------------------
--  START SYSaddDBroles Section ---------------------------------------------------
-----------------------------------------------------------------------------------

Select @output_flag02 = 'n' 

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Add Roles for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [' + @cu11DBName + ']'
Print  @miscprint

Print  @G_O

Print  ' '


--------------------  Cursor for 41DB  -----------------------
EXECUTE('DECLARE cu41_DBRole Insensitive Cursor For ' + 
  'SELECT u.name, u.altuid, u.issqlrole, u.isapprole
   From [' + @cu11DBName + '].sys.sysusers  u ' + 
  'Where (u.issqlrole = 1 or u.isapprole = 1)
	 and (u.uid < 16380 or u.name = ''RSExecRole'' or u.uid > 16399)
	 and u.name <> ''public''
   Order By u.uid For Read Only')


OPEN cu41_DBRole

WHILE (41=41)
   Begin
	FETCH Next From cu41_DBRole Into @cu41Uname, @cu41Ualtuid, @cu41Uissqlrole, @cu41Uisapprole 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu41_DBRole
		  BREAK
		   end


	 
	If @cu41Uissqlrole = 1
	   begin

		Select @cmd = 'USE ' + quotename(@cu11DBName) 
				+ ' SELECT @save_altname = (select name from sys.sysusers where uid = ' + convert(varchar(10), @cu41Ualtuid) + ')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_altname sysname output', @save_altname output
		--print @save_altname

		Select @miscprint = 'If not exists (select 1 from ' + quotename(@cu11DBName) + '.sys.database_principals where name = ''' + @cu41Uname + ''' and type = ''R'')'
		Print  @miscprint

		Select @miscprint = '   begin'
		Print  @miscprint

		Select @miscprint = '      CREATE ROLE [' + @cu41Uname + '] AUTHORIZATION [' + @save_altname + '];'
		Print  @miscprint

		Select @miscprint = '   end'
		Print  @miscprint

		Print  @G_O

		Print  ' '

		goto end_01
	   end


	If @cu41Uisapprole = 1
	   begin
		Select @cmd = 'USE ' + quotename(@cu11DBName) 
				+ ' SELECT @save_schemaname = (select default_schema_name from sys.database_principals where name = ''' + @cu41Uname + ''')'
		--Print @cmd

		EXEC sp_executesql @cmd, N'@save_schemaname sysname output', @save_schemaname output
		--print @save_schemaname

		Select @miscprint = '/* CREATE APPLICATION ROLE ---------------------------------------------  */'
		Print  @miscprint

		Select @miscprint = '/* To avoid disclosure of passwords, the password is generated in script. */'
		Print  @miscprint

		Select @miscprint = 'declare @idx as int'
		Print  @miscprint

		Select @miscprint = 'declare @randomPwd as nvarchar(64)'
		Print  @miscprint

		Select @miscprint = 'declare @rnd as float'
		Print  @miscprint

		Select @miscprint = 'declare @cmd nvarchar(4000)'
		Print  @miscprint

		Select @miscprint = 'select @idx = 0'
		Print  @miscprint

		Select @miscprint = 'select @randomPwd = N'''
		Print  @miscprint

		Select @miscprint = 'select @rnd = rand((@@CPU_BUSY % 100) + ((@@IDLE % 100) * 100) +'
		Print  @miscprint

		Select @miscprint = '       (DATEPART(ss, GETDATE()) * 10000) + ((cast(DATEPART(ms, GETDATE()) as int) % 100) * 1000000))'
		Print  @miscprint

		Select @miscprint = 'while @idx < 64'
		Print  @miscprint

		Select @miscprint = 'begin'
		Print  @miscprint

		Select @miscprint = '   select @randomPwd = @randomPwd + char((cast((@rnd * 83) as int) + 43))'
		Print  @miscprint

		Select @miscprint = '   select @idx = @idx + 1'
		Print  @miscprint

		Select @miscprint = '   select @rnd = rand()'
		Print  @miscprint

		Select @miscprint = 'end'
		Print  @miscprint

		Select @miscprint = 'select @cmd = N''CREATE APPLICATION ROLE [' + @cu41Uname + '] WITH DEFAULT_SCHEMA = [' + @save_schemaname + '], '' + N''PASSWORD = N'' + QUOTENAME(@randomPwd,'''''''')'
		Print  @miscprint

		Select @miscprint = 'EXEC dbo.sp_executesql @cmd'
		Print  @miscprint

		Print  @G_O

		Print  ' '
	   end

	end_01:

	Select @output_flag02 = 'y'

   End  -- loop 41
   DEALLOCATE cu41_DBRole

If @output_flag02 = 'n'
   begin
	Select @miscprint = '-- No output for this database.'
	Print  @miscprint

	Print  ' '
   end


-----------------------------------------------------------------------------------
--  END SYSaddDBroles Section -----------------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
--  START SYSaddDBrolemembers Section ---------------------------------------------
-----------------------------------------------------------------------------------

Select @output_flag02 = 'n' 

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'Add Role Members for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [' + @cu11DBName + ']'
Print  @miscprint

Print  @G_O

Print  ' '


--------------------  Cursor for 46DB  -----------------------
EXECUTE('DECLARE cu46_DBRole Insensitive Cursor For ' + 
  'SELECT r.name, u.name
   From [' + @cu11DBName + '].sys.sysusers  u, [' + @cu11DBName + '].sys.sysusers  r, [' + @cu11DBName + '].sys.sysmembers  m ' + 
  'Where u.uid > 3
	 and u.uid = m.memberuid
	 and m.groupuid = r.uid
   Order By r.name, u.uid For Read Only')

OPEN cu46_DBRole

WHILE (46=46)
   Begin
	FETCH Next From cu46_DBRole Into @cu46Urole, @cu46Uname 
	IF (@@fetch_status < 0)
		   begin
			  CLOSE cu46_DBRole
		  BREAK
		   end

	 
	Select @miscprint = 'sp_addrolemember ''' + @cu46Urole + ''', '''  + @cu46Uname + ''''
	Print  @miscprint

	Print  @G_O

	Print  ' '

	Select @output_flag02 = 'y'

   End  -- loop 46
   DEALLOCATE cu46_DBRole


If @output_flag02 = 'n'
   begin
	Print ''

	Select @miscprint = '-- No output for this database.'
	Print  @miscprint

	Print ''
   end
Else
   begin
	Select @output_flag02 = 'n' 
   end


-----------------------------------------------------------------------------------
--  END SYSaddDBrolemembers Section -----------------------------------------------
-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
--  START SYSgrantobjectprivileges Section ----------------------------------------
-----------------------------------------------------------------------------------

----------------------  Print the headers  ----------------------
Print  ' '

Select @miscprint = '/***************************************************************************************'
Print  @miscprint

Select @miscprint = 'GRANT OBJECT PRIVILEGES for Database: ' + @cu11DBName
Print  @miscprint

Select @miscprint = '***************************************************************************************/'
Print  @miscprint

Select @miscprint = 'USE [' + @cu11DBName + ']'
Print  @miscprint

Print  @G_O

Print  ' '


--  Create the temp table for sysprotects
If (object_id('tempdb..##tempprotects') is not null)
			drop table ##tempprotects

Exec('select * into ##tempprotects from ['+ @cu11DBName + '].sys.sysprotects')

--------------------  Cursor for 51out  -----------------------
 EXECUTE('DECLARE cursor_51out Insensitive Cursor For ' + 
		'SELECT distinct CONVERT(int,p.action), p.protecttype, p.uid, o.type, x.name, o.name, u.name, u.uid, p.id, o.is_ms_shipped
		 From ##tempprotects  p
			 , [' + @cu11DBName + '].sys.all_objects  o
			 , [' + @cu11DBName + '].sys.sysusers  u
			 , [' + @cu11DBName + '].sys.schemas  x
	  Where  p.id = o.object_id
	  And    u.uid = p.uid
	  And    o.schema_id = x.schema_id
	  And    p.action in (193, 195, 196, 197, 224, 26) 
	  And    p.uid not in (16382, 16383)
	  Order By p.uid, o.name, p.protecttype, CONVERT(int,p.action)
   For Read Only')


OPEN cursor_51out

WHILE (51=51)
   Begin
	FETCH Next From cursor_51out Into @cu51action, @cu51protecttype, @cu51puid, @cu51objtype, @cu51Schemaname, @cu51OBJname, @cu51grantee, @cu51uid, @cu51id, @cu51is_ms_shipped

	IF (@@fetch_status < 0)
		   begin
			  CLOSE cursor_51out
		  BREAK
		   end


	If @cu51is_ms_shipped = 1 and @cu51uid < 5
	   begin
		goto skip51
	   end

	If @cu51is_ms_shipped = 1 and @cu51grantee in ('TargetServersRole'
						    , 'SQLAgentUserRole'
						    , 'SQLAgentReaderRole'
						    , 'SQLAgentOperatorRole'
						    , 'DatabaseMailUserRole'
						    , 'db_dtsadmin'
						    , 'db_dtsltduser'
						    , 'db_dtsoperator')
	   begin
		goto skip51
	   end

	If @cu51protecttype = 204
	   begin
		select @grantoption = 'WITH GRANT OPTION'
	   end
	Else
	   begin
		select @grantoption = ''
	   end


	IF @cu51action = 224 and @cu51protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT EXECUTE ON OBJECT::[' + @cu51Schemaname + '].[' + @cu51OBJname + '] to [' + @cu51grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu51action = 26 and @cu51protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT REFERENCES ON [' + @cu51Schemaname + '].[' + @cu51OBJname + '] to [' + @cu51grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu51action = 193 and @cu51protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT SELECT ON OBJECT::[' + @cu51Schemaname + '].[' + @cu51OBJname + '] to [' + @cu51grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu51action = 195 and @cu51protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT INSERT ON OBJECT::[' + @cu51Schemaname + '].[' + @cu51OBJname + '] to [' + @cu51grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu51action = 196 and @cu51protecttype in (204, 205)
	   begin
		Print  ' '

		Select @miscprint = 'GRANT DELETE ON OBJECT::[' + @cu51Schemaname + '].[' + @cu51OBJname + '] to [' + @cu51grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu51action = 197 and @cu51protecttype in (204, 205) 
	   begin
		Print  ' '

		Select @miscprint = 'GRANT UPDATE ON OBJECT::[' + @cu51Schemaname + '].[' + @cu51OBJname + '] to [' + @cu51grantee + '] ' + @grantoption
		Print  @miscprint

		Print  @G_O
	   end
	ELSE
	IF @cu51protecttype = 206 
	   begin 
		delete from #t1_Prots

		--  Insert data into the temp table
		INSERT	#t1_Prots
				(Id
			,Type1Code
			,ObjType
			,ActionName
			,ActionCategory
			,ProtectTypeName
			,Columns_Orig
			,OwnerName
			,ObjectName
			,GranteeName
			,GrantorName
			,ColumnName
			,ColId
			,Max_ColId
			,All_Col_Bits_On
			,new_Bit_On
			)
			/*	1Regul indicates action can be at column level,
				2Simpl indicates action is at the object level */
			SELECT	sysp.id
				,case
					when sysp.columns is null then '2Simpl'
					else '1Regul'
					end
				,Null
				,val1.name
				,'Ob'
				,val2.name
				,sysp.columns
				,null
				,null
				,null
				,null
				,case
					when sysp.columns is null then '.'
					else Null
					end
				,-123
				,Null
				,Null
				,Null
			FROM	##tempprotects sysp
				,master.dbo.spt_values  val1
				,master.dbo.spt_values  val2
			where	sysp.id  = @cu51id
			and	val1.type     = 'T'
			and	val1.number   = sysp.action
			and	val2.type     = 'T' --T is overloaded.
			and	val2.number   = sysp.protecttype
			and	sysp.protecttype = 206
			and 	sysp.id != 0
			and	sysp.uid = @cu51uid


		IF EXISTS (SELECT * From #t1_Prots)
		   begin
			--  set owner name
			select @cmd = 'UPDATE #t1_Prots set OwnerName = ''' + @cu51Schemaname + ''' WHERE id = ' + convert(varchar(20), @cu51id)
			exec(@cmd)

			--  set object name
			select @cmd = 'UPDATE #t1_Prots set ObjectName = ''' + @cu51OBJname + ''' WHERE id = ' + convert(varchar(20), @cu51id)
			exec(@cmd)

			--  set grantee name
			select @cmd = 'UPDATE #t1_Prots set GranteeName = ''' + @cu51grantee + ''' WHERE id = ' + convert(varchar(20), @cu51id)
			exec(@cmd)

			--  set object type
			Exec('UPDATE #t1_Prots 
			set ObjType = ob.type
			FROM ['+ @cu11DBName + '].sys.objects ob
			WHERE ob.object_id = #t1_Prots.Id')
		
			--  set Max_ColId
			Exec('UPDATE #t1_Prots
			set Max_ColId = (select max(colid) From ['+ @cu11DBName + '].sys.columns sysc where #t1_Prots.Id = sysc.object_id)	-- colid may not consecutive if column dropped
			where Type1Code = ''1Regul''')
		
		
			-- First bit set indicates actions pretains to new columns. (i.e. table-level permission)
			-- Set new_Bit_On accordinglly
			UPDATE	#t1_Prots 
			SET new_Bit_On = CASE convert(int,substring(Columns_Orig,1,1)) & 1
						WHEN	1 then	1
						ELSE	0
						END
			WHERE	ObjType	<> 'V'	and	 Type1Code = '1Regul'
		
			-- Views don't get new columns
			UPDATE #t1_Prots 
			set new_Bit_On = 0
			WHERE  ObjType = 'V'

			-- Indicate enties where column level action pretains to all columns in table All_Col_Bits_On = 1					*/
			Exec('UPDATE #t1_Prots
			set All_Col_Bits_On = 1
			where #t1_Prots.Type1Code = ''1Regul''
			  and not exists (select * from ['+ @cu11DBName + '].sys.columns sysc, master.dbo.spt_values v
						where #t1_Prots.Id = sysc.object_id and sysc.column_id = v.number
						and v.number <= Max_ColId		-- column may be dropped/added after Max_ColId snap-shot 
						and v.type = ''P'' and
						-- Columns_Orig where first byte is 1 means off means on and on means off
						-- where first byte is 0 means off means off and on means on
							case convert(int,substring(#t1_Prots.Columns_Orig, 1, 1)) & 1
								when 0 then convert(tinyint, substring(#t1_Prots.Columns_Orig, v.low, 1))
								else (~convert(tinyint, isnull(substring(#t1_Prots.Columns_Orig, v.low, 1),0)))
							end & v.high = 0)')
			
			-- Indicate entries where column level action pretains to only some of columns in table All_Col_Bits_On = 0
			UPDATE	#t1_Prots	
			set All_Col_Bits_On = 0
			WHERE #t1_Prots.Type1Code = '1Regul'
			  and All_Col_Bits_On is null

			Update #t1_Prots
			set ColumnName = case
						when All_Col_Bits_On = 1 and new_Bit_On = 1 then '(All+New)'
						when All_Col_Bits_On = 1 and new_Bit_On = 0 then '(All)'
						when All_Col_Bits_On = 0 and new_Bit_On = 1 then '(New)'
						end
			from #t1_Prots
			where ObjType IN ('S ' ,'U ', 'V ')
			  and Type1Code = '1Regul'
			  and NOT (All_Col_Bits_On = 0 and new_Bit_On = 0)
		
			-- Expand and Insert individual column permission rows
			Exec('INSERT	into   #t1_Prots
				(Id
				,Type1Code
				,ObjType
				,ActionName
				,ActionCategory
				,ProtectTypeName
				,OwnerName
				,ObjectName
				,GranteeName
				,GrantorName
				,ColumnName
				,ColId	)
			   SELECT	prot1.Id
					,''1Regul''
					,ObjType
					,ActionName
					,ActionCategory
					,ProtectTypeName
					,OwnerName
					,ObjectName
					,GranteeName
					,GrantorName
					,null
					,val1.number
				from	#t1_Prots              prot1
					,master.dbo.spt_values  val1
					,['+ @cu11DBName + '].sys.columns sysc
				where	prot1.ObjType    IN (''S '' ,''U '' ,''V '')
				and prot1.Id	= sysc.object_id
				and	val1.type   = ''P''
				and	val1.number = sysc.column_id
				and	case convert(int,substring(prot1.Columns_Orig, 1, 1)) & 1
						when 0 then convert(tinyint, substring(prot1.Columns_Orig, val1.low, 1))
						else (~convert(tinyint, isnull(substring(prot1.Columns_Orig, val1.low, 1),0)))
						end & val1.high <> 0
				and prot1.All_Col_Bits_On <> 1')
		
			--  set column names
			Exec('UPDATE #t1_Prots 
			set ColumnName = c.name
			FROM ['+ @cu11DBName + '].sys.columns c
			WHERE c.object_id = #t1_Prots.Id
			and   c.column_id = #t1_Prots.ColId')


			delete from #t1_Prots
			where ObjType IN ('S ' ,'U ' ,'V ')
			  and All_Col_Bits_On = 0
			  and new_Bit_On = 0
		
		   end
		
		--------------------  Cursor for DB names  -------------------
		EXECUTE('DECLARE cursor_56 Insensitive Cursor For ' + 
		  'SELECT t.ActionName, t.ProtectTypeName, t.OwnerName, t.ObjectName, t.GranteeName, t.ColumnName, t.All_Col_Bits_On
		   From #t1_Prots   t ' + 
		  'Order By t.GranteeName For Read Only')

		
		OPEN cursor_56
		
		WHILE (56=56)
		   Begin
			FETCH Next From cursor_56 Into @cu56ActionName, @cu56ProtectTypeName, @cu56OwnerName, @cu56ObjectName, @cu56GranteeName, @cu56ColumnName, @cu56All_Col_Bits_On
			IF (@@fetch_status < 0)
				   begin
					  CLOSE cursor_56
				  BREAK
				   end
		

			If @cu56All_Col_Bits_On is not null or @cu56ColumnName = '.'
			   begin
				Print  ' '

				Select @miscprint = rtrim(upper(@cu56ProtectTypeName)) + ' ' + rtrim(upper(@cu56ActionName)) + ' ON OBJECT::[' + rtrim(@cu56OwnerName) + '].[' + @cu56ObjectName + '] To [' + @cu56GranteeName + '] CASCADE' 
				Print  @miscprint

				Print  @G_O
			   end
			Else
			   begin
				Print  ' '

				Select @miscprint = rtrim(upper(@cu56ProtectTypeName)) + ' ' + rtrim(upper(@cu56ActionName)) + ' ON OBJECT::[' + rtrim(@cu56OwnerName) + '].[' + @cu56ObjectName + '] ([' + @cu56ColumnName + ']) To [' + @cu56GranteeName + '] CASCADE' 
				Print  @miscprint

				Print  @G_O
			   end
		
		   End  -- loop 56	
		DEALLOCATE cursor_56
	   end
	ELSE
	   begin
		Print  ' '

		Select @miscprint = '-- Error on OBJECT::[' + @cu51Schemaname + '].[' + @cu51OBJname + '] for user [' + @cu51grantee + ']'
		Print  @miscprint
	   end

	Select @output_flag	= 'y' 

 
   skip51:

   End  -- loop 51
   DEALLOCATE cursor_51out


-----------------------------------------------------------------------------------
--  END SYSgrantobjectprivileges Section ------------------------------------------
-----------------------------------------------------------------------------------


Print  ' '
Print  ' '





---------------------------  Finalization  -----------------------
label99:

drop table #filenames
drop table #holdbackupnames
drop table #temp_dbusers


If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSsetDBoptions
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSsetDBoptions]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSsetDBoptions]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_SYSsetDBoptions

/*********************************************************
 **  Stored Procedure dbasp_SYSsetDBoptions                  
 **  Written by Jim Wilson, Getty Images                
 **  October 10, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  Set DB Options  
 **        
 **  Output member is SYSsetDBoptions.gsql
 ***************************************************************/
  as

set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     				Desc
--	==========	====================	=============================================
--	02/27/2002	Jim Wilson				Added a 'select into' temp table for all options
--										currently true.  Then I added the 'If In' clause
--										to the three If statments that determine if an
--										option should be true or false.
--	06/12/2002	Jim Wilson				Added DB compatibility level command and added
--										formatting for DB option cmds.
--	06/21/2002	Jim Wilson				Removed bracket formatting for database name.
--	02/04/2003	Jim Wilson				Uncommented db chaining commands.
--	03/03/2006	Jim Wilson				Modified for sql 2005.
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint				nvarchar(255)
	,@cmd					nvarchar(2000)
	,@optvalue				nvarchar(5)
	,@CommentThisDBOption	char(1)
	,@output_flag			char(1)
	,@recovery_flag			char(1)
	,@restrict_flag			char(1) 
	,@fulloptname			sysname
	,@alt_optname			sysname
	,@alt_optvalue			sysname	
	,@exec_stmt				nvarchar(2000)
	,@catvalue				int			

DECLARE
	 @allstatopts		int
	,@alloptopts		int
	,@allcatopts		int


DECLARE
	 @cu11DBname		sysname
	,@cu11DBid			int
	,@cu11DBcmptlevel	tinyint

----------------  initial values  -------------------

Select @output_flag	= 'n'

--  Create table variable
declare @dbnames table	
			(name		sysname
			,dbid		smallint
			,cmptlevel	smallint
			)

declare @tblvar_spt_values table 
			(name			sysname
			,process_flag	char(1)
			)

declare @temp_options table (name		sysname)

declare @repl_options table (output		nvarchar(1000))


/*
** Get bitmap of all options that can be set by sp_dboption.
*/
select @allstatopts=number from master.dbo.spt_values where type = 'D'
   and name = 'ALL SETTABLE OPTIONS'

select @allcatopts=number from master.dbo.spt_values where type = 'DC'
   and name = 'ALL SETTABLE OPTIONS'

select @alloptopts=number from master.dbo.spt_values where type = 'D2'
   and name = 'ALL SETTABLE OPTIONS'


		
--  Load the temp table for spt_values
Select @cmd = 'select name
			from master.dbo.spt_values
			where (type = ''D''
				and number & ' + convert(varchar(10), @allstatopts) + ' <> 0
				and number not in (0,' + convert(varchar(10), @allstatopts) + '))	-- Eliminate non-option entries
			 or (type = ''DC''
				and number & ' + convert(varchar(10), @allcatopts) + ' <> 0
				and number not in (0,' + convert(varchar(10), @allcatopts) + '))
			 or (type = ''D2''
				and number & ' + convert(varchar(10), @alloptopts) + ' <> 0
				and number not in (0,' + convert(varchar(10), @alloptopts) + '))
			order by name'

delete from @tblvar_spt_values

insert into @tblvar_spt_values (name) exec (@cmd)

delete from @tblvar_spt_values where name is null or name = ''
--select * from @tblvar_spt_values



/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------

Print  ' '
Print  '/*******************************************************************'
Select @miscprint = 'Generated SQL - SYSsetdboptions'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '



/****************************************************************
 *                MainLine
 ***************************************************************/

Select @cmd = 'SELECT d.name, d.dbid, d.cmptlevel
   From master.sys.sysdatabases   d ' + 
  'Where d.name not in (''master'', ''model'', ''msdb'', ''tempdb'')'

delete from @DBnames

insert into @DBnames (name, dbid, cmptlevel) exec (@cmd)

delete from @DBnames where name is null or name = ''
--select * from @DBnames


If (select count(*) from @DBnames) > 0
   begin
	start_dbnames:

	Select @cu11DBId = (select top 1 dbid from @DBnames order by dbid)
	Select @cu11DBName = (select name from @DBnames where dbid = @cu11DBId)
	Select @cu11DBcmptlevel = (select cmptlevel from @DBnames where dbid = @cu11DBId)


	----------------------  Print the headers  ----------------------
	Print  '/*********************************************************'
	Select @miscprint = 'Set database options for database ' + @cu11DBName 
	Print  @miscprint
	Print  '*********************************************************/'
	Print  ' '

	--  Print comatibility change command syntax  ----------------------
	Print  ' '
	Print  '/*** Setting Database Compatibility Level ***/'
	Print  ' '

	Select @miscprint = '/***' 
	Print  @miscprint
	Select @miscprint = 'EXEC master.sys.sp_dbcmptlevel ''' + @cu11DBName + ''', ''' + convert(varchar(2), @cu11DBcmptlevel) + ''';'
	Print  @miscprint
	Select @miscprint = 'GO'
	Print  @miscprint
	Select @miscprint = '***/' 
	Print  @miscprint
	Print  ' '
	Print  ' '


	Select @cmd = 'select v.name
	   from master.dbo.spt_values v, master.sys.sysdatabases d
		where d.name=''' + @cu11DBname + '''
		  and ((number & ' + convert(varchar(10), @allstatopts) + ' <> 0
			and number not in (-1,' + convert(varchar(10), @allstatopts) + ')
			and v.type = ''D''
			and (v.number & d.status)=v.number)
		   or (number & ' + convert(varchar(10), @allcatopts) + ' <> 0
			and number not in (-1,' + convert(varchar(10), @allcatopts) + ')
			and v.type = ''DC''
			and d.category & v.number <> 0)
		   or (number & ' + convert(varchar(10), @alloptopts) + ' <> 0
			and number not in (-1,' + convert(varchar(10), @alloptopts) + ')
			and v.type = ''D2''
			and d.status2 & v.number <> 0))'


	delete from @temp_options

	insert into @temp_options (name) exec (@cmd)

	delete from @temp_options where name is null or name = ''
	--select * from @temp_options


	--  Start the main process for this database
	If (select count(*) from @tblvar_spt_values) > 0
	   begin
		Update @tblvar_spt_values set process_flag = 'n'
		Select @recovery_flag = 'n'
		Select @restrict_flag = 'n'
		
		delete from @repl_options

		start_mainloop:

		Select @fulloptname = (select top 1 name from @tblvar_spt_values where process_flag = 'n')


        IF (@fulloptname IN ('ANSI null default'
            			,'dbo use only'
            			,'no chkpt on recovery'
            			,'read only'
            			,'select into/bulkcopy'
            			,'single user'
            			,'trunc. log on chkpt.'))
		   begin
			Select @CommentThisDBOption = 'N'
		   end
		ELSE
		   begin
			Select @CommentThisDBOption = 'Y'
		   end


		If @fulloptname in (select name from @temp_options)
		   begin
			Select @optvalue = 'true'
		   end
		Else
		   begin
			Select @optvalue = 'false'
		   end


		select @catvalue = 0
		select @catvalue = number
		  from master.dbo.spt_values
		  where lower(name) = lower(@fulloptname)
		  and type = 'DC'

		-- if replication options, format using sproc sp_replicationdboption
		If (@catvalue <> 0)
		   begin
			select @alt_optvalue = (case lower(@optvalue)
					when 'true' then 'true'
					when 'on' then 'true'
					else 'false'
				end)

			select @alt_optname = (case @catvalue
					when 1 then 'publish'
					when 2 then 'subscribe'
					when 4 then 'merge publish'
					else quotename(@fulloptname, '''')
				end)

			select @exec_stmt = quotename(@cu11DBName, '[')   + '.dbo.sp_replicationdboption'
			--print @exec_stmt

			select @cmd = 'EXEC ' + @exec_stmt + ' ' +  @cu11DBName + ', ' + @alt_optname + ', ' + @alt_optvalue
			Insert into @repl_options values (@cmd)
	
			goto get_next
		   end


		-- set option value in alter database
		select @alt_optvalue = (case lower(@optvalue)
				when 'true'	then 'ON'
				when 'on'	then 'ON'
				else 'OFF'
				end)

		-- set option name in alter database
		select @fulloptname = lower(@fulloptname)
		select @alt_optname = (case @fulloptname
				when 'auto create statistics' then 'AUTO_CREATE_STATISTICS'
				when 'auto update statistics' then 'AUTO_UPDATE_STATISTICS'
				when 'autoclose' then 'AUTO_CLOSE'
				when 'autoshrink' then 'AUTO_SHRINK'
				when 'ansi padding' then 'ANSI_PADDING'
				when 'arithabort' then 'ARITHABORT'
				when 'numeric roundabort' then 'NUMERIC_ROUNDABORT'
				when 'ansi null default' then 'ANSI_NULL_DEFAULT'
				when 'ansi nulls' then 'ANSI_NULLS'
				when 'ansi warnings' then 'ANSI_WARNINGS'
				when 'concat null yields null' then 'CONCAT_NULL_YIELDS_NULL'
				when 'cursor close on commit' then 'CURSOR_CLOSE_ON_COMMIT'
				when 'torn page detection' then 'TORN_PAGE_DETECTION'
				when 'quoted identifier' then 'QUOTED_IDENTIFIER'
				when 'recursive triggers' then 'RECURSIVE_TRIGGERS'
				when 'default to local cursor' then 'CURSOR_DEFAULT'
				when 'offline' then (case @alt_optvalue when 'ON' then 'OFFLINE' else 'ONLINE' end)
				when 'read only' then (case @alt_optvalue when 'ON' then 'READ_ONLY' else 'READ_WRITE' end)
				when 'dbo use only' then (case @alt_optvalue when 'ON' then 'RESTRICTED_USER' else 'MULTI_USER' end)
				when 'single user' then (case @alt_optvalue when 'ON' then 'SINGLE_USER' else 'MULTI_USER' end)
				when 'select into/bulkcopy' then 'RECOVERY'
				when 'trunc. log on chkpt.' then 'RECOVERY'
				when 'db chaining' then 'DB_CHAINING'
				else @alt_optname
				end)


		select @alt_optvalue = (case @fulloptname
				when 'default to local cursor' then (case @alt_optvalue when 'ON' then 'LOCAL' else 'GLOBAL' end)
				when 'offline' then ''
				when 'read only' then ''
				when 'dbo use only' then ''
				when 'single user' then ''
				else  @alt_optvalue
				end)


		--  Special set up for recovery option
		if lower(@fulloptname) = 'select into/bulkcopy' and @recovery_flag = 'n'
		   begin
			if @alt_optvalue = 'ON'
			   begin
				if databaseproperty(@cu11DBName, 'IsTrunclog') = 1
				   begin
					select @alt_optvalue = 'RECMODEL_70BACKCOMP'
					Select @recovery_flag = 'y'
				   end
				else
				   begin
					select @alt_optvalue = 'BULK_LOGGED'
					Select @recovery_flag = 'y'
				   end
			   end
			else
			   begin
				if databaseproperty(@cu11DBName, 'IsTrunclog') = 1
				   begin
					select @alt_optvalue = 'SIMPLE'
					Select @recovery_flag = 'y'
				   end
				else
				   begin
					select @alt_optvalue = 'FULL'
					Select @recovery_flag = 'y'
				   end
			   end
		   end
		Else if lower(@fulloptname) = 'select into/bulkcopy' and @recovery_flag = 'y'
		   begin
			goto get_next
		   end



		if lower(@fulloptname) = 'trunc. log on chkpt.' and @recovery_flag = 'n'
		   begin
			if @alt_optvalue = 'ON'
			   begin
				if databaseproperty(@cu11DBName, 'IsBulkCopy') = 1
				   begin
					select @alt_optvalue = 'RECMODEL_70BACKCOMP'
					Select @recovery_flag = 'y'
				   end
				else
				   begin
					select @alt_optvalue = 'SIMPLE'
					Select @recovery_flag = 'y'
				   end
			   end
			else
			   begin
				if databaseproperty(@cu11DBName, 'IsBulkCopy') = 1
				   begin
					select @alt_optvalue = 'BULK_LOGGED'
					Select @recovery_flag = 'y'
				   end
				else
				   begin
					select @alt_optvalue = 'FULL'
					Select @recovery_flag = 'y'
				   end
			   end
		   end
		Else if lower(@fulloptname) = 'trunc. log on chkpt.' and @recovery_flag = 'y'
		   begin
			goto get_next
		   end


		--  Special set up for restrict option
		if lower(@fulloptname) = 'dbo use only' and @restrict_flag = 'n'
		   begin
			if databaseproperty(@cu11DBName, 'IsDboOnly') = 1
			   begin
				select @alt_optname = 'RESTRICTED_USER'
				Select @restrict_flag = 'y'
			   end
			Else If databaseproperty(@cu11DBName, 'IsSingleUser') = 1
			   begin
				select @alt_optname = 'SINGLE_USER'
				Select @restrict_flag = 'y'
			   end
			Else
			   begin
				select @alt_optname = 'MULTI_USER'
				Select @restrict_flag = 'y'
			   end
		   end
		Else if lower(@fulloptname) = 'dbo use only' and @restrict_flag = 'y'
		   begin
			goto get_next
		   end


		if lower(@fulloptname) = 'single user' and @restrict_flag = 'n'
		   begin
			if databaseproperty(@cu11DBName, 'IsDboOnly') = 1
			   begin
				select @alt_optname = 'RESTRICTED_USER'
				Select @restrict_flag = 'y'
			   end
			Else If databaseproperty(@cu11DBName, 'IsSingleUser') = 1
			   begin
				select @alt_optname = 'SINGLE_USER'
				Select @restrict_flag = 'y'
			   end
			Else
			   begin
				select @alt_optname = 'MULTI_USER'
				Select @restrict_flag = 'y'
			   end
		   end
		Else if lower(@fulloptname) = 'single user' and @restrict_flag = 'y'
		   begin
			goto get_next
		   end



		-- construct the ALTER DATABASE command string
		IF (@CommentThisDBOption = 'Y')
		   begin
			Raiserror('%s%s',0,1,'/','***')
		   end

		select @exec_stmt = 'ALTER DATABASE ' + quotename(@cu11DBName) + ' SET ' + @alt_optname + ' ' + @alt_optvalue + ' WITH NO_WAIT'
		print @exec_stmt

		IF (@CommentThisDBOption = 'Y')
		   begin
			Raiserror('%s%s',0,1,'***','/')
		   end

		print ' '


		get_next:


		--  Check for more rows to process
			Update @tblvar_spt_values set process_flag = 'y' where name = @fulloptname
		If (select count(*) from @tblvar_spt_values where process_flag = 'n') > 0
		   begin
			goto start_mainloop
		  end


	   end


	--  Print out the replication options here
	If (select count(*) from @repl_options) > 0
	   begin
		start_repl_options:

		Select @miscprint = (select top 1 output from @repl_options)
		Raiserror('%s%s',0,1,'/','***')
		Print @miscprint
		Raiserror('%s%s',0,1,'***','/')
		Print ' '
	   end


	--  Check for more rows to process
	Delete from @repl_options where output = @miscprint
	If (select count(*) from @repl_options) > 0
	   begin
		goto start_repl_options
	  end




	--  Check for more rows to process
	Delete from @DBnames where dbid = @cu11DBId
	If (select count(*) from @DBnames) > 0
	   begin
		goto start_dbnames
	  end


   end

---------------------------  Finalization  -----------------------

If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSsqlconfig
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSsqlconfig]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSsqlconfig]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_SYSsqlconfig

/*********************************************************
 **  Stored Procedure dbasp_SYSsqlconfig                  
 **  Written by Jim Wilson, Getty Images                
 **  December 1, 2000                                      
 **
 **  Canabalized from:
 **  Stored Procedure sp_help_diskinit                 
 **  Written by Richard Waymire, ARIS Corp.            
 **  September 18, 1997                                
 **  This procedure shows SQL server config info
 **  and scripts the creation of your backup devices.         
 **                                                    
 **  Output member is SYSsqlconfig.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	12/07/2006	Jim Wilson		Updated for SQL 2005
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(4000)
	,@status 		smallint
	,@cntrltype 		smallint
	,@logicalname 		varchar(30)
	,@physicalname 		varchar(127)
	,@buildstring 		varchar(20)
	,@tempdevno 		smallint
	,@proctext 		varchar(255)
	,@cmd			nvarchar(400)

DECLARE 
	 @service01_name	sysname
	,@service01_ID		sysname
	,@service02_name	sysname
	,@service02_ID		sysname




PRINT '/*****'
SELECT '--Report generated on ' + convert(varchar(30),getdate()) + ' For Server ' + @@servername
PRINT ' '
PRINT 'VERSION INFORMATION:'
SELECT @@VERSION
PRINT ' '
PRINT '*****/'

/*************************************************************/
/** this prints the msver info as comments to the result **/
/*************************************************************/
Print ' '
Print '/********* Here is the msver information ********'
exec master.sys.xp_msver
Print '********** End of msver info *******************/'
Print ' '


/*************************************************************/
/** this prints the helpsort info as comments to the result **/
/*************************************************************/
Print ' '
Print '/********* Here is the character set/sort order information ********'
exec sys.sp_helpsort
Print '********** End of Sort order/character set info *******************/'
Print ' '


/*************************************************************************/
/** this prints the server configuration info as comments to the result **/
/*************************************************************************/
Print ' '
Print '/********* Here is the server configuration information ********'
exec sys.sp_configure
Print '********** End of server configuration information *******************/'
Print ' '

/*************************************************************************/
/** this prints the help server info as comments to the result **/
/*************************************************************************/
Print ' '
Print '/********* Here is the help server information ********'
exec sys.sp_helpserver
Print '********** End of help server information *******************/'
Print ' '

/*************************************************************************/
/** this prints the server fixed drive info as comments to the result **/
/*************************************************************************/
Print ' '
Print '/********* Here is the server fixed drive information ********'
exec master.sys.xp_fixeddrives
Print '********** End of server fixed drive information *******************/'
Print ' '

/*************************************************************************/
/** this prints the login configuration info as comments to the result **/
/*************************************************************************/
Print ' '
Print '/********* Here is the login configuration information ********'
exec master.sys.xp_loginconfig
Print '********** End of login configuration information *******************/'
Print ' '



/*************************************************************************/
/** this prints the login info as comments to the result                **/
/*************************************************************************/
Print ' '
Print '/********* Here is the login information ********'
exec master.sys.xp_logininfo
Print '********** End of login information *******************/'
Print ' '



/*************************************************************************/
/** this prints the SQL Server Service Account Information              **/
/*************************************************************************/
create table #reginfo
   (value sysname,
    data sysname
   )

select @service01_name = 'MSSQLServer'

insert #reginfo (value, data) exec master.sys.xp_regread N'HKEY_LOCAL_MACHINE', 'System\CurrentControlSet\Services\MSSQLServer', N'ObjectName'
select @service01_ID = (Select data from #reginfo)

delete from #reginfo

insert #reginfo (value, data) exec master.sys.xp_regread N'HKEY_LOCAL_MACHINE', 'System\CurrentControlSet\Services\SQLServerAgent', N'DisplayName'
select @service02_name = (Select data from #reginfo)

delete from #reginfo

insert #reginfo (value, data) exec master.sys.xp_regread N'HKEY_LOCAL_MACHINE', 'System\CurrentControlSet\Services\SQLServerAgent', N'ObjectName'
select @service02_ID = (Select data from #reginfo)

Print ' '
Print '/********* Here is the SQL Server Service Account Information *************'
Select @miscprint = 'Service                         Account'
Print @miscprint
Select @miscprint = '------------------------------  -----------------------------------'
Print @miscprint
Select @miscprint = convert(char(30), @service01_name) + '  ' + @service01_ID
Print @miscprint
Select @miscprint = convert(char(30), @service02_name) + '  ' + @service02_ID
Print @miscprint
Print ' '
Print ' '
Print '********** End of the SQL Server Service Account Information **************/'
Print ' '

drop table #reginfo


/*************************************************************/
/** this prints the local administrators for the server     **/
/*************************************************************/

Print ' '
Print '/********* Here are the local administrators ********'
Select @cmd = 'local administrators \\' + @@servername
exec master.sys.xp_cmdshell @cmd
Print '********** End of local administrators **************/'
Print ' '


---------------------------  Finalization  -----------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_SYSupdatesysmessages
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_SYSupdatesysmessages]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_SYSupdatesysmessages]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_SYSupdatesysmessages

/*********************************************************
 **  Stored Procedure dbasp_SYSupdatesysmessages                  
 **  Written by Jim Wilson, Getty Images                
 **  May 2, 2000                                      
 **  
 **  This dbasp is set up to create executable sql to;
 ** 
 **  add system messages  
 **        
 **  Output member is SYSupdatesysmessages.gsql
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/26/2002	Jim Wilson		Revision History added
--	04/26/2006	Jim Wilson		Change double quotes to single quotes for message.
--	11/09/2006	Jim Wilson		Modified for SQL 2005
--	======================================================================================


-----------------  declares  ------------------

DECLARE
	 @miscprint		nvarchar(255)
	,@G_O			nvarchar(2)
	,@output_flag		char(1)
	,@startpos		int
	,@charpos		int
	,@save_log		nvarchar(10)

DECLARE
	 @cu11Mmessage_id	nvarchar(10)
	,@cu11Mlanguage_id	nvarchar(50)
	,@cu11Mseverity		nvarchar(10)
	,@cu11Mis_event_logged	bit
	,@cu11Mtext		nvarchar(2048)

----------------  initial values  -------------------
Select @G_O	= 'g' + 'o'
Select @output_flag	= 'n'
     
/*********************************************************************
 *                Initialization
 ********************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/*******************************************************************'
Select @miscprint = 'Generated SQL - SYSupdatesysmessages'  
Print  @miscprint
Select @miscprint = 'For Server: ' + @@servername + ' on '  + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  '*******************************************************************/'
Print  ' '


/****************************************************************
 *                MainLine
 ***************************************************************/

	
----------------------  Print the headers  ----------------------

   Print  ' '
   Print  '/***********************************************'
   Select @miscprint = 'ADD MESSAGES for master ' 
   Print  @miscprint
   Print  '***********************************************/'
   Print  ' '
   Select @miscprint = 'USE master'
   Print  @miscprint  
   Print  @G_O
   Print  ' '


--------------------  Cursor 11  -----------------------

EXECUTE('DECLARE cursor_11 Insensitive Cursor For ' + 
  'SELECT convert(varchar(10),m.message_id), convert(sysname,l.name), convert(varchar(10),m.severity), m.is_event_logged, convert(varchar(255),m.text)
   From master.sys.messages  m , master.sys.syslanguages  l ' + 
  'Where m.message_id > 49999
     and m.language_id = l.lcid
   Order By m.message_id For Read Only')


OPEN cursor_11

WHILE (11=11)
   Begin
	FETCH Next From cursor_11 Into @cu11Mmessage_id, @cu11Mlanguage_id, @cu11Mseverity, @cu11Mis_event_logged, @cu11Mtext
	IF (@@fetch_status < 0)
           begin
              CLOSE cursor_11
	      BREAK
           end


	--  Fix single quote problem in @cu11name
	Select @startpos = 1
	label01:
	select @charpos = charindex('''', @cu11Mtext, @startpos)
	IF @charpos <> 0
	   begin
		select @cu11Mtext = stuff(@cu11Mtext, @charpos, 1, '''''')
		select @startpos = @charpos + 2
	   end	

	select @charpos = charindex('''', @cu11Mtext, @startpos)
	IF @charpos <> 0
	   begin
		goto label01
	   end	

	IF @cu11Mis_event_logged = 1
	   begin
		select @save_log = 'True'
	   end
	Else
	   begin
		select @save_log = 'False'
	   end


	Print  ' '
	Select @miscprint = 'exec sp_addmessage @msgnum = ' +@cu11Mmessage_id 
	Print  @miscprint
	Select @miscprint = '                  ,@severity = ' +@cu11Mseverity 
	Print  @miscprint
	Select @miscprint = '                  ,@lang = ''' +@cu11Mlanguage_id+ '''' 
	Print  @miscprint
	Select @miscprint = '                  ,@msgtext = N''' +@cu11Mtext+ '''' 
	Print  @miscprint
	Select @miscprint = '                  ,@with_log = ''' +@save_log+ '''' 
	Print  @miscprint
	Select @miscprint = '                  ,@replace = ''replace''' 
	Print  @miscprint
	Print  @G_O


	Select @output_flag	= 'y' 
 
   End  -- loop 11

---------------------------  Finalization  -----------------------
   DEALLOCATE cursor_11

If @output_flag = 'n'
   begin
	Print '-- No output for this script.'
   end



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_Update_SQLjobs
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_Update_SQLjobs]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_Update_SQLjobs]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO







CREATE PROCEDURE dbo.dbasp_Update_SQLjobs @runtype	varchar(20) = 'report'

/***************************************************************
 **  Stored Procedure dbasp_Update_SQLjobs                  
 **  Written by Jim Wilson, Getty Images                
 **  October 15, 2002                                      
 **  
 **  This dbasp is set up to;
 ** 
 **  Report Current Job status (parm=report)
 **
 **  Disable all enabled local sql jobs (parm=disable)
 **    - as long as no records exist in the dbaadmin.dbo.DisabledJobs table
 **
 **  Disable all enabled sql jobs (parm=disable_force)
 **    - Even if records exist in the dbaadmin.dbo.DisabledJobs table
 **
 **  Re-enable all previously disabled jobs (parm=enable)
 **
 **  Enable all disabled jobs (parm=enable_force)
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	10/15/2002	Jim Wilson		New process
--	05/28/2009	David Spriggs		Convert To 2005
--	======================================================================================

--Declare @runtype varchar(20)
--Select  @runtype = 'report1'

-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar(4000)
	,@sql				varchar(500)
	,@currdate			datetime
	,@report_flag			char(1)
	,@disable_flag			char(1)
	,@enable_flag			char(1)
	,@Dforce_flag			char(1)
	,@Eforce_flag			char(1)
	,@output_flag			char(1)
	,@cursor11_text			nvarchar(1024)
	,@cursor12_text			nvarchar(1024)
	,@cursor13_text			nvarchar(1024)
	,@cursor21_text			nvarchar(1024)
	,@cursor22_text			nvarchar(1024)
	,@cursor23_text			nvarchar(1024)
	,@cursor31_text			nvarchar(1024)
	,@cursor32_text			nvarchar(1024)

DECLARE
	 @cu11name			sysname
	,@cu11originating_server	sysname

DECLARE
	 @cu12name			sysname
	,@cu12originating_server	sysname

DECLARE
	 @cu13jobname			sysname
	,@cu13disable_date		datetime

DECLARE
	 @cu21jobname			sysname
	,@cu21disable_date		datetime

DECLARE
	 @cu22job_id			varchar(50)
	,@cu22name			sysname
	,@cu22originating_server	sysname

DECLARE
	 @cu23name			sysname
	,@cu23originating_server	sysname

DECLARE
	 @cu31job_id			varchar(40)
	,@cu31jobname			sysname
	,@cu31disable_date		datetime

DECLARE
	 @cu32job_id			varchar(50)
	,@cu32name			sysname
	,@cu32originating_server	sysname


/*********************************************************************
 *                Initialization
 ********************************************************************/
Select @report_flag = 'n'
Select @disable_flag = 'n'
Select @Dforce_flag = 'n'
Select @enable_flag = 'n'
Select @Eforce_flag = 'n'
Select @currdate = getdate()


--  Check input parm
If @runtype = 'report'
   begin
	Select @report_flag = 'y'
   end
Else If @runtype = 'disable'
   begin
	Select @disable_flag = 'y'
   end
Else If @runtype = 'disable_force'
   begin
	Select @Dforce_flag = 'y'
   end
Else If @runtype = 'enable'
   begin
	Select @enable_flag = 'y'
   end
Else If @runtype = 'enable_force'
   begin
	Select @Eforce_flag = 'y'
   end
Else
   begin
	Select @miscprint = 'ERROR for sproc dbasp_Update_SQLjobs:  Invalid parameter used.  Must be ''report'', ''disable'', ''disable_force'', ''enable'', or ''enable_force''.'
	Print  @miscprint
	goto label99
   end


If @report_flag = 'y'
   begin
	--  Print the headers
	Print  ' '
	Print  '/********************************************************************'
	Select @miscprint = '   dbasp_Update_SQLjobs:  Flag = ' + @runtype
	Print  @miscprint
	Print  ' '
	Select @miscprint = '-- Executed on ' + convert(varchar(30),getdate()) + '  For Server ' + @@servername
	Print  @miscprint
	Print  '********************************************************************/'
	Print  ' '
	Select @miscprint = 'The following SQL jobs are currently enabled'
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Local Job Name'
	Print  @miscprint
	Select @miscprint = '----------------------------------------------------------'
	Print  @miscprint
	Select @output_flag = 'n'

	Select @cursor11_text = 'DECLARE cu11_cursor Insensitive Cursor For ' + 
	  'SELECT j.name, m.srvname
	   From msdb.dbo.sysjobs j 
	   join master.sys.sysservers as m on j.originating_server_id = m.srvid ' + 
	  'Where j.enabled = 1
	     and (m.srvname = ''(local)'' or UPPER(m.srvname) = UPPER(CONVERT(NVARCHAR(30), @@servername)))
	   Order by m.srvname, j.name For Read Only'


	EXECUTE (@cursor11_text)

	OPEN cu11_cursor

	WHILE (11=11)
	 Begin
		FETCH Next From cu11_cursor Into @cu11name, @cu11originating_server
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu11_cursor
		      BREAK
	           end


		Select @miscprint = @cu11name
		Print  @miscprint
		Select @output_flag = 'y'


	 End  -- loop 11

	DEALLOCATE cu11_cursor

	If @output_flag = 'n'
	   begin
		Select @miscprint = 'No local enabled jobs to report'
		Print  @miscprint
	   end


	Print  ' '
	Select @miscprint = 'MultiServer Job Name                                          Originating Server'
	Print  @miscprint
	Select @miscprint = '----------------------------------------------------------    -------------------------'
	Print  @miscprint
	Select @output_flag = 'n'

	Select @cursor12_text = 'DECLARE cu12_cursor Insensitive Cursor For ' + 
	  'SELECT j.name, m.srvname
	   From msdb.dbo.sysjobs j ' + 
	  ' join master.sys.sysservers as m on j.originating_server_id = m.srvid  ' +
	  'Where j.enabled = 1
	     and (m.srvname <> ''(local)'' and UPPER(m.srvname) <> UPPER(CONVERT(NVARCHAR(30), @@servername)))
	   Order by m.srvname, j.name For Read Only'


	EXECUTE (@cursor12_text)

	OPEN cu12_cursor

	WHILE (12=12)
	 Begin
		FETCH Next From cu12_cursor Into @cu12name, @cu12originating_server
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu12_cursor
		      BREAK
	           end


		Select @miscprint = convert(char(60), @cu12name) + '  ' + convert(char(27), @cu12originating_server)
		Print  @miscprint
		Select @output_flag = 'y'


	 End  -- loop 12

	DEALLOCATE cu12_cursor

	If @output_flag = 'n'
	   begin
		Select @miscprint = 'No MultiServer enabled jobs to report'
		Print  @miscprint
	   end


	Print  ' '
	Print  ' '
	Print  ' '
	Select @miscprint = 'The following SQL jobs were previously disabled by this process'
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Disabled Job Name                                             Disable Date'
	Print  @miscprint
	Select @miscprint = '----------------------------------------------------------    -------------------------'
	Print  @miscprint
	Select @output_flag = 'n'

	Select @cursor13_text = 'DECLARE cu13_cursor Insensitive Cursor For ' + 
	  'SELECT d.jobname, d.disable_date
	   From dbaadmin.dbo.DisabledJobs d ' + 
	  'Order by d.jobname For Read Only'

	EXECUTE (@cursor13_text)

	OPEN cu13_cursor

	WHILE (13=13)
	 Begin
		FETCH Next From cu13_cursor Into @cu13jobname, @cu13disable_date
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu13_cursor
		      BREAK
	           end


		Select @miscprint = convert(char(60), @cu13jobname) + '   ' + convert(varchar(20), @cu13disable_date, 120)
		Print  @miscprint
		Select @output_flag = 'y'


	 End  -- loop 13

	DEALLOCATE cu13_cursor

	If @output_flag = 'n'
	   begin
		Select @miscprint = 'No previously disabled jobs to report'
		Print  @miscprint
	   end

   end



--  Disable process
If @disable_flag = 'y' or @Dforce_flag = 'y'
   begin
	--  Print the headers
	Print  ' '
	Print  '/********************************************************************'
	Select @miscprint = '   dbasp_Update_SQLjobs:  Flag = ' + @runtype
	Print  @miscprint
	Print  ' '
	Select @miscprint = '-- Executed on ' + convert(varchar(30),getdate()) + '  For Server ' + @@servername
	Print  @miscprint
	Print  '********************************************************************/'
	Print  ' '

	If @Dforce_flag = 'y'
	   begin
		Delete from dbaadmin.dbo.DisabledJobs
	   end

	If (select count(*) from dbaadmin.dbo.DisabledJobs) > 0
	   begin
		Select @miscprint = 'Warning:  Unable to disable jobs with this parameter.'
		Print  @miscprint
		Select @miscprint = '          To force the disable, use ''disable_force''.'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'The following SQL jobs were previously disabled by this process'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'Disabled Job Name                                             Disable Date'
		Print  @miscprint
		Select @miscprint = '----------------------------------------------------------    -------------------------'
		Print  @miscprint

		Select @cursor21_text = 'DECLARE cu21_cursor Insensitive Cursor For ' + 
		  'SELECT d.jobname, d.disable_date
		   From dbaadmin.dbo.DisabledJobs d ' + 
		  'Order by d.jobname For Read Only'

		EXECUTE (@cursor21_text)

		OPEN cu21_cursor

		WHILE (21=21)
		 Begin
			FETCH Next From cu21_cursor Into @cu21jobname, @cu21disable_date
			IF (@@fetch_status < 0)
		           begin
		              CLOSE cu21_cursor
			      BREAK
		           end


			Select @miscprint = convert(char(60), @cu21jobname) + '  ' + convert(varchar(20), @cu21disable_date, 120)
			Print  @miscprint


		 End  -- loop 21

		DEALLOCATE cu21_cursor
	   end	
	Else
	   begin
		Select @miscprint = 'The following SQL jobs have now been disabled'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'Local Job Name'
		Print  @miscprint
		Select @miscprint = '----------------------------------------------------------'
		Print  @miscprint
		Select @output_flag = 'n'

		Select @cursor22_text = 'DECLARE cu22_cursor Insensitive Cursor For ' + 
		  'SELECT convert(varchar(50), j.job_id), j.name, m.srvname
		   From msdb.dbo.sysjobs j ' + 
		  'join master.sys.sysservers as m on j.originating_server_id = m.srvid '+
		  'Where j.enabled = 1
		     and (m.srvname = ''(local)'' or UPPER(m.srvname) = UPPER(CONVERT(NVARCHAR(30), @@servername)))
		   Order by m.srvname, j.name For Read Only'

		EXECUTE (@cursor22_text)

		OPEN cu22_cursor

		WHILE (22=22)
		 Begin
			FETCH Next From cu22_cursor Into @cu22job_id, @cu22name, @cu22originating_server
			IF (@@fetch_status < 0)
		           begin
		              CLOSE cu22_cursor
			      BREAK
		           end

			Select @sql = 'msdb.dbo.sp_update_job @job_id = ''' + @cu22job_id + ''', @enabled = 0'
			exec (@sql)
			
			Insert into dbaadmin.dbo.DisabledJobs(Job_ID, JobName, Disable_date) values (@cu22job_id, @cu22name, @currdate)

			Select @miscprint = @cu22name
			Print  @miscprint
			Select @output_flag = 'y'


		 End  -- loop 22
	
		DEALLOCATE cu22_cursor

		If @output_flag = 'n'
		   begin
			Select @miscprint = 'No local enabled jobs to disable'
			Print  @miscprint
		   end


		Print  ' '
		Print  ' '
		Print  ' '
		Select @miscprint = 'The following MultiServer SQL jobs cannot be disabled locally'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'MultiServer Job Name                                          Originating Server'
		Print  @miscprint
		Select @miscprint = '----------------------------------------------------------    -------------------------'
		Print  @miscprint
		Select @output_flag = 'n'

		Select @cursor23_text = 'DECLARE cu23_cursor Insensitive Cursor For ' + 
		  'SELECT j.name, m.srvname
		   From msdb.dbo.sysjobs j ' + 
		  'join master.sys.sysservers as m on j.originating_server_id = m.srvid '+
		  'Where j.enabled = 1
		     and (m.srvname <> ''(local)'' and UPPER(m.srvname) <> UPPER(CONVERT(NVARCHAR(30), @@servername)))
		   Order by m.srvname, j.name For Read Only'

		EXECUTE (@cursor23_text)
	
		OPEN cu23_cursor

		WHILE (23=23)
		 Begin
			FETCH Next From cu23_cursor Into @cu23name, @cu23originating_server
			IF (@@fetch_status < 0)
		           begin
		              CLOSE cu23_cursor
			      BREAK
		           end


			Select @miscprint = convert(char(60), @cu23name) + '  ' + convert(char(27), @cu23originating_server)
			Print  @miscprint
			Select @output_flag = 'y'


		 End  -- loop 23

		DEALLOCATE cu23_cursor

		If @output_flag = 'n'
		   begin
			Select @miscprint = 'No MultiServer enabled jobs to report'
			Print  @miscprint
		   end

	   end

   end



--  Enable process
If @enable_flag = 'y'
   begin
	--  Print the headers
	Print  ' '
	Print  '/********************************************************************'
	Select @miscprint = '   dbasp_Update_SQLjobs:  Flag = ' + @runtype
	Print  @miscprint
	Print  ' '
	Select @miscprint = '-- Executed on ' + convert(varchar(30),getdate()) + '  For Server ' + @@servername
	Print  @miscprint
	Print  '********************************************************************/'
	Print  ' '


	If (select count(*) from dbaadmin.dbo.DisabledJobs) = 0
	   begin
		Select @miscprint = 'No previously disabled jobs were found.'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'To enable all SQL jobs on this server, use the ''enable_force'' parameter.'
		Print  @miscprint

	   end
	Else
	   begin
		Select @miscprint = 'The following SQL jobs have now been enabled'
		Print  @miscprint
		Print  ' '
		Select @miscprint = 'Local Job Name'
		Print  @miscprint
		Select @miscprint = '----------------------------------------------------------'
		Print  @miscprint

		Select @cursor31_text = 'DECLARE cu31_cursor Insensitive Cursor For ' + 
		  'SELECT d.job_id, d.jobname, d.disable_date
		   From dbaadmin.dbo.DisabledJobs d ' + 
		  'Order by d.jobname For Read Only'

		EXECUTE (@cursor31_text)

		OPEN cu31_cursor

		WHILE (31=31)
		 Begin
			FETCH Next From cu31_cursor Into @cu31job_id, @cu31jobname, @cu31disable_date
			IF (@@fetch_status < 0)
		           begin
		              CLOSE cu31_cursor
			      BREAK
		           end


			If exists(select 1 from msdb.dbo.sysjobs where name = @cu31jobname)
			   begin
				Select @sql = 'msdb.dbo.sp_update_job @job_name = ''' + @cu31jobname + ''', @enabled = 1'
				exec (@sql)
				
				Select @miscprint = @cu31jobname
				Print  @miscprint
			   end
			Else
			   begin
				Select @miscprint = convert(varchar(60), @cu31jobname) + '   ' + '(This job no longer exists'
				Print  @miscprint
			   end


			delete from dbaadmin.dbo.DisabledJobs where job_id = @cu31job_id


		 End  -- loop 31

		DEALLOCATE cu31_cursor

	   end	
   end


If @Eforce_flag = 'y'
   begin
	--  Print the headers
	Print  ' '
	Print  '/********************************************************************'
	Select @miscprint = '   dbasp_Update_SQLjobs:  Flag = ' + @runtype
	Print  @miscprint
	Print  ' '
	Select @miscprint = '-- Executed on ' + convert(varchar(30),getdate()) + '  For Server ' + @@servername
	Print  @miscprint
	Print  '********************************************************************/'
	Print  ' '

	Delete from dbaadmin.dbo.DisabledJobs

	Select @miscprint = 'The following local SQL jobs have now been enabled'
	Print  @miscprint
	Print  ' '
	Select @miscprint = 'Local Job Name'
	Print  @miscprint
	Select @miscprint = '----------------------------------------------------------'
	Print  @miscprint
	Select @output_flag = 'n'

	Select @cursor32_text = 'DECLARE cu32_cursor Insensitive Cursor For ' + 
	  'SELECT convert(varchar(50), j.job_id), j.name, m.srvname
	   From msdb.dbo.sysjobs j ' + 
	  'join master.sys.sysservers as m on j.originating_server_id = m.srvid '+
	  'Where j.enabled = 0
	     and (m.srvname = ''(local)'' or UPPER(m.srvname) = UPPER(CONVERT(NVARCHAR(30), @@servername)))
	   Order by m.srvname, j.name For Read Only'

	EXECUTE (@cursor32_text)
	
	OPEN cu32_cursor

	WHILE (32=32)
	 Begin
		FETCH Next From cu32_cursor Into @cu32job_id, @cu32name, @cu32originating_server
		IF (@@fetch_status < 0)
	           begin
	              CLOSE cu32_cursor
		      BREAK
	           end

		Select @sql = 'msdb.dbo.sp_update_job @job_id = ''' + @cu32job_id + ''', @enabled = 1'
		exec (@sql)

		Select @miscprint = @cu32name
		Print  @miscprint
		Select @output_flag = 'y'


	 End  -- loop 32

	DEALLOCATE cu32_cursor

	If @output_flag = 'n'
	   begin
		Select @miscprint = 'No local disabled jobs found'
		Print  @miscprint
	   end
   end



---------------------------  Finalization  -----------------------
Label99:

Select @miscprint = ' '
Print  @miscprint

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_UpdateBuild
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_UpdateBuild]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_UpdateBuild]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.dbasp_UpdateBuild
	@DatabaseName 	varchar(30),
	@vchLabel 	varchar(100),
        @vchNotes       varchar(255) = NULL
AS
/* ---------------------------------------------------------------------------
---------------------------------------------------------------------------
-- Procedure: dbasp_UpdateBuild
-- 
-- For: Getty Images
--
-- Revision History
--      Modified 3/20/2001 - Modified sproc to accept the parameter of 
--                           @vchNotes and changed the parameter of
--                           iBuildNumber to vchLabel.
--
-- Purpose
--  Inserts a record into dbo.Build.
--
--
---------------------------------------------------------------------------
--------------------------------------------------------------------------- */
INSERT INTO Build
 (
	vchName,
 	vchLabel,
 	dtBuildDate,
        vchNotes
 )
VALUES 
 (
 	@DatabaseName,
 	@vchLabel,
 	GETDATE(),
        @vchNotes
 )

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- dbasp_updatestats
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbasp_updatestats]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[dbasp_updatestats]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE dbo.dbasp_updatestats (@Large_count int = 100000
					,@med_count int = 10000
					,@Small_count int = 1000
					,@Large_pct dec(10,5) = 0.01000
					,@Med_pct dec(10,5) = 0.05000
					,@Small_pct dec(10,5) = 0.10000
					,@PlanName varchar(500) = 'mplan_user_defrag'
					)

/***************************************************************
 **  Stored Procedure dbasp_updatestats                  
 **  Written by Jim Wilson, Getty Images                
 **  February 08, 2006                                      
 **
 **  This procedure creates a file to run the update stats process.
 **  Commands to update stats are based on a percentage of rows modified
 **  compared to the row count (both found in sysindexes).  Using the 
 **  input parms, you can specifiy different percentages for large, medium
 **  and small row counts.  You can also set the values to define what a 
 **  large, medium and small row count is.
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	02/08/2006	Jim Wilson		New process
--	02/17/2006	Jim Wilson		Modified for sql 2005
--	======================================================================================

/***
declare @Large_count int
declare @med_count int
declare @Small_count int
declare @Large_pct float
declare @Med_pct float
declare @Small_pct float
declare @PlanName varchar(500)

select @Large_count = 100000
select @med_count = 1000
select @Small_count = 100
select @Large_pct = 0.01000
select @Med_pct = 0.05000
select @Small_pct = 0.10000
select @PlanName = 'mplan_user_defrag'
--***/

Declare
	 @miscprint			nvarchar(4000)
	,@save_DBname		sysname
	,@error_count		int
	,@cmd				nvarchar(500)
	,@query				nvarchar(3000)
	,@owner				sysname
	,@rowmodctr_limit	int
	,@save_ObjectName	sysname
	,@save_rowcnt		bigint
	,@save_rowmodctr	int
	,@save_objid		int
	,@save_pct			float


DECLARE
	 @cu11DBName		sysname
	,@cu11DBId			smallint
	,@cu11DBStatus		int


----------------  initial values  -------------------
Select @error_count = 0
Select @save_DBname = ''
Select @rowmodctr_limit = 0


--  Create table variable
declare @dbnames table	(name		sysname
			,dbid		smallint
			,status		int
			)

Create table #temp_upstat (
		objid int,
		owner nvarchar(255),
		objname sysname,
		rowcnt bigint,
		rowmodctr int
		)



/****************************************************************
*                MainLine
***************************************************************/

----------------------  Main header  ----------------------
Print  ' '
Print  '/************************************************************************'
Select @miscprint = 'SQL Update Statistics Process'
Print  @miscprint
Select @miscprint = 'Created For Server: ' + @@servername + ' on ' + convert(varchar(30),getdate(),9)
Print  @miscprint
Print  ' '
Print  '************************************************************************/'

Insert into @dbnames (name, dbid, status)
Select distinct(d.database_name), db.dbid, db.status 
From msdb.dbo.sysdbmaintplan_databases  d with (NOLOCK), msdb.dbo.sysdbmaintplans  s with (NOLOCK), master.sys.sysdatabases db with (NOLOCK)
Where d.plan_id = s.plan_id
  and s.plan_name = @PlanName
  and db.name = d.database_name


delete from @dbnames where name is null or name = ''
--select * from @dbnames


If (select count(*) from @dbnames) > 0
   begin
	start_dbnames:

	Select @cu11DBName = (select top 1 name from @dbnames)
	Select @cu11DBId = dbid from @dbnames where name = @cu11DBName
	Select @cu11DBStatus = status from @dbnames where name = @cu11DBName
	Print ' '
	Print ' '

	Print '---------------------------------------------------------------------------'
	Print '--  Start process for database ' + @cu11DBName
	Print '---------------------------------------------------------------------------'
	Select @miscprint = 'Use ' + @cu11DBName
	Print @miscprint
	Print 'go'
	Print ' '


	Print  ' '
	Select @miscprint = '-- UPDATING USAGE for database ' + (rtrim(@cu11DBName))
	Print  @miscprint
	Select @miscprint = 'Print ''Start Update Usage for database ' + rtrim(@cu11DBName) + ''''
	Print @miscprint
	Print 'Select getdate()'
	Print  ' '
	Select @cmd = 'dbcc updateusage(' + rtrim(@cu11DBName) + ') with no_infomsgs'
	Print @cmd
	Print  ' '
	Print  ' '


	Delete from #temp_upstat
	Select @query = 'select so.object_id, sc.name, so.name, si.rowcnt, si.rowmodctr  
	from ' + @cu11DBName + '.sys.sysindexes  si, ' + @cu11DBName + '.sys.objects so, ' + @cu11DBName + '.sys.schemas  sc
	where si.id = so.object_id
	and so.type = ''u''
	and si.rowmodctr > ' + convert(varchar(20), @rowmodctr_limit) + '
	and si.rowcnt > 0
    and sc.schema_id = so.schema_id
	order by so.name'

	Insert into #temp_upstat exec (@query)
	--select * from #temp_upstat


	If (select count(*) from #temp_upstat) > 0
	   begin
		Select @miscprint = 'Print ''Start Update Stats Processing for database ' + @cu11DBName + ''''
		Print @miscprint
		Print 'Select getdate()'
		Print 'go'
		Print ' '

		start_loop:

		Select @save_objid = (select top 1 objid from #temp_upstat)
		Select @save_rowcnt = (select rowcnt from #temp_upstat where objid = @save_objid)
		Select @save_rowmodctr = (select rowmodctr from #temp_upstat where objid = @save_objid)
		Select @save_ObjectName = (select top 1 objname from #temp_upstat where objid = @save_objid)
		Select @owner = (select owner from #temp_upstat where objid = @save_objid and objname = @save_ObjectName)

	--print @save_ObjectName
	--select @save_rowmodctr
	--select @save_rowcnt
	--print @owner

		Select @save_pct = CONVERT(float, @save_rowmodctr) / CONVERT(float, @save_rowcnt)

		If (@save_pct > @Large_pct and @save_rowcnt > @Large_count)
		  or (@save_pct > @Med_pct and @save_rowcnt > @med_count)
		  or (@save_pct > @Small_pct and @save_rowcnt < @med_count)
		   begin
	--print @save_ObjectName
	--select @save_rowmodctr
	--select @save_rowcnt


			Print  ' '
			Print  ' '
			Select @miscprint = '-- UPDATING STATISTICS for table ' + (rtrim(@save_ObjectName)) + ' (rowcnt = ' + convert(varchar(20), @save_rowcnt) + ', rowmodcnt = ' + convert(varchar(20), @save_rowmodctr) + ')'
			Print  @miscprint
			Select @miscprint = 'Print ''Start Update Stats on table ' + rtrim(@save_ObjectName) + ''''
			Print @miscprint
			Print 'Select getdate()'
			Print  ' '


			If @save_rowcnt > @Large_count
			   begin
				Select @cmd = 'UPDATE STATISTICS [' + @owner + '].[' + rtrim(@save_ObjectName) + '] WITH SAMPLE 10 PERCENT'
				Print @cmd
			   end
			Else
			   begin
				Select @cmd = 'UPDATE STATISTICS [' + @owner + '].[' + rtrim(@save_ObjectName) + '] WITH SAMPLE 20 PERCENT'
				Print @cmd
			   end

		   end

		Delete from #temp_upstat where objname = @save_ObjectName and objid = @save_objid

		If (select count(*) from #temp_upstat) > 0
		   begin
			goto start_loop
		   end


	   end


	--  Remove this record from @dbname and go to the next
	delete from @dbnames where name = @cu11DBName
	If (select count(*) from @dbnames) > 0
	   begin
		goto start_dbnames
	   end

   end



--  Finalization  
--------------------------------------------------------------------
Print ' '
Select @miscprint = 'Print ''End Update Stats on database ' + @cu11DBName + ''''
Print @miscprint
Print 'Select getdate()'
Print 'go'
Print ' '

Print  ' '
Print  
'/************************************************************************'
Select @miscprint = 'SQL Update Stats Process Complete '
Print  @miscprint
Print  
'************************************************************************/'



drop table #temp_upstat



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- getUIREPORTcomp_backup
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[getUIREPORTcomp_backup]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[getUIREPORTcomp_backup]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE dbo.getUIREPORTcomp_backup

/*********************************************************
 **  Stored Procedure getUIDeplServersbyGearsID                
 **  Written by David Spriggs, Getty Images                
 **  August 27, 2009                                     
 **  
 **  This stored procedure is the Web UI version of 
 **  dbo.dbasp_REPORTcomp_backup
 **  
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	08/27/2009	David Spriggs		New report
--	======================================================================================

-----------------  declares  ------------------

declare @tblCount table(rnk int, svrname sysname, sqlname sysname, lic sysname)
declare @tbllicenseVerInfo table (lic sysname, ver sysname)


/****************************************************************
 *                Initialization
 ***************************************************************/
insert into @tbllicenseVerInfo
select
	distinct
	license,
	version
from dbo.Compress_BackupInfo

insert into @tblCount
select
	rank() over(partition by servername order by sqlname, servername),
	servername,
	sqlname,
	license
from dbo.Compress_BackupInfo
order by servername

/****************************************************************
 *                MainLine
 ***************************************************************/

select
	li.VendorName,
	li.Type 'Version',
	vi.ver 'Product Version',
	tc.lic 'License Key',
	LicStatus =	case li.Active 
					when 'y' then 'Active'
					when 'n' then 'In Active'
				end,
	li.LicenseNum 'License Allocated',
	count(*)'Licenses Used',
	(li.LicenseNum - count(*)) 'License Avaliable'
from @tblCount as tc
join dbo.licenseInfo as li on tc.lic = li.LicenseKey
join @tbllicenseVerInfo as vi on vi.Lic = tc.lic
where rnk = 1
group by 
	tc.lic,
	li.VendorName,
	vi.ver,
	li.Type,
	li.LicenseNum,
	li.Active
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- sp_alterdiagram
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[sp_alterdiagram]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_alterdiagram]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

	CREATE PROCEDURE dbo.sp_alterdiagram
	(
		@diagramname 	sysname,
		@owner_id	int	= null,
		@version 	int,
		@definition 	varbinary(max)
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
	
		declare @theId 			int
		declare @retval 		int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
		declare @ShouldChangeUID	int
	
		if(@diagramname is null)
		begin
			RAISERROR ('Invalid ARG', 16, 1)
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID();	 
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		revert;
	
		select @ShouldChangeUID = 0
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		
		if(@DiagId IS NULL or (@IsDbo = 0 and @theId <> @UIDFound))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1);
			return -3
		end
	
		if(@IsDbo <> 0)
		begin
			if(@UIDFound is null or USER_NAME(@UIDFound) is null) -- invalid principal_id
			begin
				select @ShouldChangeUID = 1 ;
			end
		end

		-- update dds data			
		update dbo.sysdiagrams set definition = @definition where diagram_id = @DiagId ;

		-- change owner
		if(@ShouldChangeUID = 1)
			update dbo.sysdiagrams set principal_id = @theId where diagram_id = @DiagId ;

		-- update dds version
		if(@version is not null)
			update dbo.sysdiagrams set version = @version where diagram_id = @DiagId ;

		return 0
	END
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- sp_creatediagram
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[sp_creatediagram]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_creatediagram]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

	CREATE PROCEDURE dbo.sp_creatediagram
	(
		@diagramname 	sysname,
		@owner_id		int	= null, 	
		@version 		int,
		@definition 	varbinary(max)
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
	
		declare @theId int
		declare @retval int
		declare @IsDbo	int
		declare @userName sysname
		if(@version is null or @diagramname is null)
		begin
			RAISERROR (N'E_INVALIDARG', 16, 1);
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID(); 
		select @IsDbo = IS_MEMBER(N'db_owner');
		revert; 
		
		if @owner_id is null
		begin
			select @owner_id = @theId;
		end
		else
		begin
			if @theId <> @owner_id
			begin
				if @IsDbo = 0
				begin
					RAISERROR (N'E_INVALIDARG', 16, 1);
					return -1
				end
				select @theId = @owner_id
			end
		end
		-- next 2 line only for test, will be removed after define name unique
		if EXISTS(select diagram_id from dbo.sysdiagrams where principal_id = @theId and name = @diagramname)
		begin
			RAISERROR ('The name is already used.', 16, 1);
			return -2
		end
	
		insert into dbo.sysdiagrams(name, principal_id , version, definition)
				VALUES(@diagramname, @theId, @version, @definition) ;
		
		select @retval = @@IDENTITY 
		return @retval
	END
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- sp_dropdiagram
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[sp_dropdiagram]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_dropdiagram]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

	CREATE PROCEDURE dbo.sp_dropdiagram
	(
		@diagramname 	sysname,
		@owner_id	int	= null
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
		declare @theId 			int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
	
		if(@diagramname is null)
		begin
			RAISERROR ('Invalid value', 16, 1);
			return -1
		end
	
		EXECUTE AS CALLER;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		REVERT; 
		
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1)
			return -3
		end
	
		delete from dbo.sysdiagrams where diagram_id = @DiagId;
	
		return 0;
	END
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- sp_helpdiagramdefinition
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[sp_helpdiagramdefinition]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_helpdiagramdefinition]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

	CREATE PROCEDURE dbo.sp_helpdiagramdefinition
	(
		@diagramname 	sysname,
		@owner_id	int	= null 		
	)
	WITH EXECUTE AS N'dbo'
	AS
	BEGIN
		set nocount on

		declare @theId 		int
		declare @IsDbo 		int
		declare @DiagId		int
		declare @UIDFound	int
	
		if(@diagramname is null)
		begin
			RAISERROR (N'E_INVALIDARG', 16, 1);
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner');
		if(@owner_id is null)
			select @owner_id = @theId;
		revert; 
	
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname;
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId ))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1);
			return -3
		end

		select version, definition FROM dbo.sysdiagrams where diagram_id = @DiagId ; 
		return 0
	END
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- sp_helpdiagrams
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[sp_helpdiagrams]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_helpdiagrams]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

	CREATE PROCEDURE dbo.sp_helpdiagrams
	(
		@diagramname sysname = NULL,
		@owner_id int = NULL
	)
	WITH EXECUTE AS N'dbo'
	AS
	BEGIN
		DECLARE @user sysname
		DECLARE @dboLogin bit
		EXECUTE AS CALLER;
			SET @user = USER_NAME();
			SET @dboLogin = CONVERT(bit,IS_MEMBER('db_owner'));
		REVERT;
		SELECT
			[Database] = DB_NAME(),
			[Name] = name,
			[ID] = diagram_id,
			[Owner] = USER_NAME(principal_id),
			[OwnerID] = principal_id
		FROM
			sysdiagrams
		WHERE
			(@dboLogin = 1 OR USER_NAME(principal_id) = @user) AND
			(@diagramname IS NULL OR name = @diagramname) AND
			(@owner_id IS NULL OR principal_id = @owner_id)
		ORDER BY
			4, 5, 1
	END
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- sp_renamediagram
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[sp_renamediagram]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_renamediagram]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

	CREATE PROCEDURE dbo.sp_renamediagram
	(
		@diagramname 		sysname,
		@owner_id		int	= null,
		@new_diagramname	sysname
	
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
		declare @theId 			int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
		declare @DiagIdTarg		int
		declare @u_name			sysname
		if((@diagramname is null) or (@new_diagramname is null))
		begin
			RAISERROR ('Invalid value', 16, 1);
			return -1
		end
	
		EXECUTE AS CALLER;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		REVERT;
	
		select @u_name = USER_NAME(@owner_id)
	
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1)
			return -3
		end
	
		-- if((@u_name is not null) and (@new_diagramname = @diagramname))	-- nothing will change
		--	return 0;
	
		if(@u_name is null)
			select @DiagIdTarg = diagram_id from dbo.sysdiagrams where principal_id = @theId and name = @new_diagramname
		else
			select @DiagIdTarg = diagram_id from dbo.sysdiagrams where principal_id = @owner_id and name = @new_diagramname
	
		if((@DiagIdTarg is not null) and  @DiagId <> @DiagIdTarg)
		begin
			RAISERROR ('The name is already used.', 16, 1);
			return -2
		end		
	
		if(@u_name is null)
			update dbo.sysdiagrams set [name] = @new_diagramname, principal_id = @theId where diagram_id = @DiagId
		else
			update dbo.sysdiagrams set [name] = @new_diagramname where diagram_id = @DiagId
		return 0
	END
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- sp_upgraddiagrams
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[sp_upgraddiagrams]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[sp_upgraddiagrams]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

	CREATE PROCEDURE dbo.sp_upgraddiagrams
	AS
	BEGIN
		IF OBJECT_ID(N'dbo.sysdiagrams') IS NOT NULL
			return 0;
	
		CREATE TABLE dbo.sysdiagrams
		(
			name sysname NOT NULL,
			principal_id int NOT NULL,	-- we may change it to varbinary(85)
			diagram_id int PRIMARY KEY IDENTITY,
			version int,
	
			definition varbinary(max)
			CONSTRAINT UK_principal_name UNIQUE
			(
				principal_id,
				name
			)
		);


		/* Add this if we need to have some form of extended properties for diagrams */
		/*
		IF OBJECT_ID(N'dbo.sysdiagram_properties') IS NULL
		BEGIN
			CREATE TABLE dbo.sysdiagram_properties
			(
				diagram_id int,
				name sysname,
				value varbinary(max) NOT NULL
			)
		END
		*/

		IF OBJECT_ID(N'dbo.dtproperties') IS NOT NULL
		begin
			insert into dbo.sysdiagrams
			(
				[name],
				[principal_id],
				[version],
				[definition]
			)
			select	 
				convert(sysname, dgnm.[uvalue]),
				DATABASE_PRINCIPAL_ID(N'dbo'),			-- will change to the sid of sa
				0,							-- zero for old format, dgdef.[version],
				dgdef.[lvalue]
			from dbo.[dtproperties] dgnm
				inner join dbo.[dtproperties] dggd on dggd.[property] = 'DtgSchemaGUID' and dggd.[objectid] = dgnm.[objectid]	
				inner join dbo.[dtproperties] dgdef on dgdef.[property] = 'DtgSchemaDATA' and dgdef.[objectid] = dgnm.[objectid]
				
			where dgnm.[property] = 'DtgSchemaNAME' and dggd.[uvalue] like N'_EA3E6268-D998-11CE-9454-00AA00A3F36E_' 
			return 2;
		end
		return 1;
	END
	
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- UpdateDBAaadminBuild
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[UpdateDBAaadminBuild]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[UpdateDBAaadminBuild]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.UpdateDBAaadminBuild
	@DatabaseName 	varchar(30),
	@vchLabel 	varchar(100),
        @vchNotes       varchar(255) = NULL
AS
/* ---------------------------------------------------------------------------
---------------------------------------------------------------------------
-- Procedure: UpdateDBAaadminBuild
-- 
-- For: Getty Images
--
-- Revision History
--      Modified 3/20/2001 - Modified sproc to accept the parameter of 
--                           @vchNotes and changed the parameter of
--                           iBuildNumber to vchLabel.
--
-- Purpose
--  Inserts a record into DBAadmin..Build when the build
--  gets run.
--
--
---------------------------------------------------------------------------
--------------------------------------------------------------------------- */
INSERT INTO dbo.Build
 (
	vchName,
 	vchLabel,
 	dtBuildDate,
        vchNotes
 )
VALUES 
 (
 	@DatabaseName,
 	@vchLabel,
 	GETDATE(),
        @vchNotes
 )

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- UpdateSystemInfoBuild
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[UpdateSystemInfoBuild]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[UpdateSystemInfoBuild]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE dbo.UpdateSystemInfoBuild
	@DatabaseName 	varchar(30),
	@vchLabel 	varchar(100),
        @vchNotes       varchar(255) = NULL
AS
/* ---------------------------------------------------------------------------
---------------------------------------------------------------------------
-- Procedure: UpdateSystemInfoBuild
-- 
-- For: Getty Images
--
-- Revision History
--      Modified 3/20/2001 - Modified sproc to accept the parameter of 
--                           @vchNotes and changed the parameter of
--                           iBuildNumber to vchLabel.
--
-- Purpose
--  Inserts a record into SystemInfo..Build when the build
--  gets run.
--
--
---------------------------------------------------------------------------
--------------------------------------------------------------------------- */
INSERT INTO Build
 (
	vchName,
 	vchLabel,
 	dtBuildDate,
        vchNotes
 )
VALUES 
 (
 	@DatabaseName,
 	@vchLabel,
 	GETDATE(),
        @vchNotes
 )

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go
 
 
------------------------------------------------------------------------------------------------------- 
-- websp_ServerRpt
------------------------------------------------------------------------------------------------------- 
if exists (select * from sys.objects where object_id = object_id(N'[dbo].[websp_ServerRpt]') and OBJECTPROPERTY(object_id, N'IsProcedure') = 1)
drop procedure [dbo].[websp_ServerRpt]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE dbo.websp_ServerRpt (@detail sysname = null
					,@type sysname = 'partial'
					,@report_only char(1) = 'n')

/*********************************************************
 **  Stored Procedure websp_ServerRpt                 
 **  Written by Jim Wilson, Getty Images                
 **  July 23, 2009                                      
 **  
 **  This dbasp is set up to create a report for web servers.
 **        
 ***************************************************************/
  as
set nocount on

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	07/23/2009	Jim Wilson		New report.
--	======================================================================================

/***
Declare @detail sysname
Declare @type sysname
Declare @report_only char(1)
	
--Select @detail = 'dev'
Select @detail = 'cwsdev01'
Select @type = 'full'
Select @report_only = 'n'
--***/

-----------------  declares  ------------------

DECLARE
	 @miscprint			nvarchar(2000)
	,@hold_Gears_id			int
	,@save_gears_id			int
	,@save_projectname		sysname
	,@save_projectnum		sysname
	,@save_Project			sysname
	,@save_startdate		datetime
	,@save_DBname			sysname
	,@save_APPLname			sysname
	,@save_BASEfolder		sysname
	,@save_Process			sysname
	,@save_central_server		sysname
	,@save_servername		sysname
	,@save_active			char(1)
	,@save_envname			sysname
	,@save_OSname			sysname
	,@save_OSver			sysname
	,@save_OSinstallDate		sysname
	,@save_OSuptime			sysname
	,@save_SystemManufacture	sysname
	,@save_SystemModel		sysname
	,@save_SystemType		sysname
	,@save_CPUnumber		sysname
	,@save_CPUtype			sysname
	,@save_Domain			sysname
	,@save_MemoryPhysical_Total	sysname
	,@save_MemoryPhysical_Avail	sysname
	,@save_MemoryVirtual_Total	sysname
	,@save_MemoryVirtual_Avail	sysname
	,@save_Pagefile_path		sysname
	,@save_Pagefile_Maxsize		sysname
	,@save_Pagefile_Avail		sysname
	,@save_Pagefile_InUse		sysname
	,@save_Path			nvarchar(2000)
	,@save_Boot_Loader		sysname
	,@save_Boot_OppSystems		sysname
	,@save_IEver			sysname
	,@save_MDACver			sysname
	,@save_BiosVer			sysname
	,@save_SMBiosVer		sysname
	,@save_IPaddress		sysname
	,@save_IPorder			int
	,@save_MACaddress		sysname
	,@save_hotfix			sysname
	,@save_drive			nvarchar(5)
	,@save_Description		sysname
	,@save_Drive_Size		sysname
	,@save_Drive_Freespace		sysname
	,@save_WebREGID			int
	,@save_KEYpath02		nvarchar(500)
	,@hold_KEYpath02		nvarchar(500)
	,@save_KEYname			sysname
	,@save_KEYdata			sysname

DECLARE
	 @error_count			int
	,@counter			int
	,@detail_report			char(1)
	,@save_Status			sysname
	,@save_ProcessType		sysname
	,@save_ProcessDetail		sysname
	,@save_ModDate			datetime
	,@save_cl_id			int
	,@report_fromdate		datetime
	,@gears_id			int


/*********************************************************************
 *                Initialization
 ********************************************************************/
Select @error_count = 0
Select @detail_report = 'n'

--  Create temp table
CREATE TABLE #temp_server ([ServerName] [sysname] NULL)

CREATE TABLE #temp_envname ([EnvName] [sysname] NULL)

CREATE TABLE #temp_ipconfig ([MACaddress] [sysname] NULL
			    ,[IPtype] [sysname] NULL
			    ,[IPaddress] [sysname] NULL
			    ,[IPorder] [int] null
			    )

CREATE TABLE #temp_hotfix ([hotfix_name] [sysname] NULL)

CREATE TABLE #temp_drive ([Drive_name] [nvarchar] (5) NULL
			,[Drive_Size] [sysname] NULL
			,[Drive_Freespace] [sysname] NULL
			,[File_System] [nvarchar] (10) NULL
			,[Compressed] [nvarchar] (10) NULL
			,[Description] [sysname] NULL
			)


CREATE TABLE #temp_reg ([WebREGID] [int] NULL
			,[KEYpath01] [nvarchar] (500) NULL
			,[KEYpath02] [nvarchar] (500) NULL
			,[KEYname] [sysname] NULL
			,[KEYdata] [sysname] NULL
			)


CREATE TABLE #temp_serverinfo (	[ServerName] [sysname] NOT NULL,
				[ServerType] [sysname] NULL,
				[EnvName] [sysname] NULL,
				[Active] [char] (1) NOT NULL,
				[modDate] [datetime] NOT NULL,
				[OSname] [sysname] NULL,
				[OSver] [sysname] NULL,
				[OSinstallDate] [sysname] NULL,
				[OSuptime] [sysname] NULL,
				[MemoryPhysical_Total] [sysname] NULL,
				[MemoryPhysical_Avail] [sysname] NULL,
				[MemoryVirtual_Total] [sysname] NULL,
				[MemoryVirtual_Avail] [sysname] NULL,
				[Domain] [sysname] NULL,
				[Logon_Server] [sysname] NULL,
				[SAN] [char] (1) NULL,
				[Location] [sysname] NULL,
				[CPUnumber] [sysname] NULL,
				[CPUtype] [sysname] NULL,
				[BiosVer] [sysname] NULL,
				[SMBiosVer] [sysname] NULL,
				[MDACver] [sysname] NULL,
				[IEver] [sysname] NULL,
				[AntiVirus_Type] [sysname] NULL,
				[AntiVirus_Ver] [sysname] NULL,
				[Boot_Loader] [sysname] NULL,
				[Boot_OppSystems] [sysname] NULL,
				[Pagefile_Maxsize] [sysname] NULL,
				[Pagefile_Avail] [sysname] NULL,
				[Pagefile_InUse] [sysname] NULL,
				[Pagefile_path] [sysname] NULL,
				[Path] [nvarchar] (2000) NULL,
				[SystemManufacture] [sysname] NULL,
				[SystemModel] [sysname] NULL,
				[SystemType] [sysname] NULL,
				[MOMverifyDate] [datetime] NULL
				)

CREATE TABLE #temp_cldet ([cl_id] [int] NOT NULL,
			[Gears_id] [int] NOT NULL,
			[ProjectName] [sysname] NULL,
			[ProjectNum] [sysname] NULL,
			[central_server] [sysname] NULL,
			[Status] [sysname] NULL,
			[Process] [sysname] NULL,
			[ProcessType] [sysname] NULL,
			[ProcessDetail] [sysname] NULL,
			[DBname] [sysname] NULL,
			[APPLname] [sysname] NULL,
			[BASEfolder] [sysname] NULL,
			[CreateDate] [datetime] NULL,
			[ModDate] [datetime] NULL
			)



--  Verify input parms
If @type not in ('partial', '1', '2', '3', '4', '5', 'full')
   begin
	Select @miscprint = 'DBA WARNING: Invalid input.  ''@type'' must be either ''full'' or ''partial'' or the numbers 1 thru 5.' 
	raiserror(@miscprint,-1,-1) with log
	Select @error_count = @error_count + 1
	goto label99
   end




----------------------  Print the headers  ----------------------
If @report_only = 'n'
   begin
	Print  '/*******************************************************************'
	If @type = '1'
	   begin
		Select @miscprint = '   WEB Server Report - Partial with IPconfig Info'
		Print  @miscprint
	   end
	Else If @type = '2'
	   begin
		Select @miscprint = '   WEB Server Report - Partial with Hot Fix Info'
		Print  @miscprint
	   end
	Else If @type = '3'
	   begin
		Select @miscprint = '   WEB Server Report - Partial with Drive Info'
		Print  @miscprint
	   end
	Else If @type = '4'
	   begin
		Select @miscprint = '   WEB Server Report - Partial with Registry Info'
		Print  @miscprint
	   end
	Else If @type = '5'
	   begin
		Select @miscprint = '   WEB Server Report - Partial with Deployment Info'
		Print  @miscprint
	   end
	Else If @type = 'Full'
	   begin
		Select @miscprint = '   WEB Server Report - Full'
		Print  @miscprint
	   end
	Else
	   begin
		Select @miscprint = '   WEB Server Report'
		Print  @miscprint
	   end

	Print  ' '
	Select @miscprint = '-- Report Generated on ' + convert(varchar(30),getdate())
	Print  @miscprint
	Print  '*******************************************************************/'
	Print  ' '
   end
	

/****************************************************************
 *                MainLine
 ***************************************************************/

If @detail is null
   begin
	goto catch_all
   end



----------------------------------------------------------------------------------------------------------------------
--  Request Report for "specific server" section  --------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
If exists (select 1 from dbo.web_serverinfo where servername = @detail)
   begin
--	Insert into #temp_serverinfo select ServerName
--					,ServerType
--					,EnvName
--					,Active
--					,modDate
--					,OSname
--					,OSver
--					,OSinstallDate
--					,OSuptime
--					,MemoryPhysical_Total
--					,MemoryPhysical_Avail
--					,MemoryVirtual_Total
--					,MemoryVirtual_Avail
--					,Domain
--					,Logon_Server
--					,SAN
--					,Location
--					,CPUnumber
--					,CPUtype
--					,BiosVer
--					,SMBiosVer
--					,MDACver
--					,IEver
--					,AntiVirus_Type
--					,AntiVirus_Ver
--					,Boot_Loader
--					,Boot_OppSystems
--					,Pagefile_Maxsize
--					,Pagefile_Avail
--					,Pagefile_InUse
--					,Pagefile_path
--					,Path
--					,SystemManufacture
--					,SystemModel
--					,SystemType
--					,MOMverifyDate
--				from dbo.web_serverinfo 
--				where ServerName = @detail
--Select * from #temp_serverinfo



--	If (select count(*) from #temp_serverinfo) = 0
--	   begin
--		Select @miscprint = 'No results found for this report.' 
--		goto label99
--	   end


	--  Print the report headers
	Select @miscprint = 'Server Name: ' + upper(@detail)
	Print @miscprint
	Print ''

	Select @miscprint = 'Environment Name(s): '
	Insert into #temp_envname select EnvName
				from dbo.web_serverinfo
				where servername = @detail
				Union
				select keydata
				from dbo.web_reginfo
				where servername = @detail and keyname = 'Environment'
				--Select * from #temp_envname

	If (select count(*) from #temp_envname) > 0
	   begin
		Select @miscprint = 'Environment Name(s): '

		Start_envname01:

		Select @save_envname = (select top 1 envname from #temp_envname order by envname)
		Select @miscprint = @miscprint + @save_envname


		Delete from #temp_envname where envname = @save_envname
		If (select count(*) from #temp_envname) > 0
		   begin
			Select @miscprint = @miscprint + ', '

			goto Start_envname01
		   end

		Print @miscprint
	   end


	Select @save_Domain = (Select top 1 Domain from dbo.web_serverinfo where ServerName = @detail)
	Select @miscprint = 'Domain: ' + convert(char(60), @save_Domain)
	Print @miscprint

	Select @save_modDate = (Select top 1 modDate from dbo.web_serverinfo where ServerName = @detail)
	Select @miscprint = 'Data Last Updated: ' + convert(nvarchar(30), @save_modDate, 110)
	Print @miscprint


	Select @save_active = (Select top 1 active from dbo.web_serverinfo where ServerName = @detail)
	Select @miscprint = 'Active = ' + @save_active
	Print @miscprint
	Print ''


	Select @save_OSname = (Select top 1 OSname from dbo.web_serverinfo where ServerName = @detail)
	Select @save_OSver = (Select top 1 OSver from dbo.web_serverinfo where ServerName = @detail)
	Select @save_OSinstallDate = (Select top 1 OSinstallDate from dbo.web_serverinfo where ServerName = @detail)
	Select @save_OSuptime = (Select top 1 OSuptime from dbo.web_serverinfo where ServerName = @detail)

	Select @miscprint = 'OS Info'
	Print @miscprint
	Select @miscprint = '======='
	Print @miscprint
	Select @miscprint = 'OS Name:          ' + convert(char(60), @save_OSname)
	Print @miscprint
	Select @miscprint = 'OS Version:       ' + convert(char(60), @save_OSver)
	Print @miscprint
	Select @miscprint = 'OS Install Date:  ' + convert(char(60), @save_OSinstallDate)
	Print @miscprint
	Select @miscprint = 'OS Up Time:       ' + convert(char(60), @save_OSuptime)
	Print @miscprint
	Print''


	Select @save_SystemManufacture = (Select top 1 SystemManufacture from dbo.web_serverinfo where ServerName = @detail)
	Select @save_SystemModel = (Select top 1 SystemModel from dbo.web_serverinfo where ServerName = @detail)
	Select @save_SystemType = (Select top 1 SystemType from dbo.web_serverinfo where ServerName = @detail)
	Select @save_CPUnumber = (Select top 1 CPUnumber from dbo.web_serverinfo where ServerName = @detail)
	Select @save_CPUtype = (Select top 1 CPUtype from dbo.web_serverinfo where ServerName = @detail)

	Select @miscprint = 'Hardware Info'
	Print @miscprint
	Select @miscprint = '============='
	Print @miscprint
	Select @miscprint = 'Manufacture:      ' + convert(char(60), @save_SystemManufacture)
	Print @miscprint
	Select @miscprint = 'Model:            ' + convert(char(60), @save_SystemModel)
	Print @miscprint
	Select @miscprint = 'Type:             ' + convert(char(60), @save_SystemType)
	Print @miscprint
	Select @miscprint = 'CPU Number:       ' + convert(char(60), @save_CPUnumber)
	Print @miscprint
	Select @miscprint = 'CPU Type:         ' + convert(char(60), @save_CPUtype)
	Print @miscprint
	Print''


	Select @save_MemoryPhysical_Total = (Select top 1 MemoryPhysical_Total from dbo.web_serverinfo where ServerName = @detail)
	Select @save_MemoryPhysical_Avail = (Select top 1 MemoryPhysical_Avail from dbo.web_serverinfo where ServerName = @detail)
	Select @save_MemoryVirtual_Total = (Select top 1 MemoryVirtual_Total from dbo.web_serverinfo where ServerName = @detail)
	Select @save_MemoryVirtual_Avail = (Select top 1 MemoryVirtual_Avail from dbo.web_serverinfo where ServerName = @detail)

	Select @save_Pagefile_path = (Select top 1 Pagefile_path from dbo.web_serverinfo where ServerName = @detail)
	Select @save_Pagefile_Maxsize = (Select top 1 Pagefile_Maxsize from dbo.web_serverinfo where ServerName = @detail)
	Select @save_Pagefile_Avail = (Select top 1 Pagefile_Avail from dbo.web_serverinfo where ServerName = @detail)
	Select @save_Pagefile_InUse = (Select top 1 Pagefile_InUse from dbo.web_serverinfo where ServerName = @detail)

	Select @save_Path = (Select top 1 Path from dbo.web_serverinfo where ServerName = @detail)
	Select @save_Boot_Loader = (Select top 1 Boot_Loader from dbo.web_serverinfo where ServerName = @detail)
	Select @save_Boot_OppSystems = (Select top 1 Boot_OppSystems from dbo.web_serverinfo where ServerName = @detail)
	Select @save_IEver = (Select top 1 IEver from dbo.web_serverinfo where ServerName = @detail)
	Select @save_MDACver = (Select top 1 MDACver from dbo.web_serverinfo where ServerName = @detail)
	Select @save_BiosVer = (Select top 1 BiosVer from dbo.web_serverinfo where ServerName = @detail)
	Select @save_SMBiosVer = (Select top 1 SMBiosVer from dbo.web_serverinfo where ServerName = @detail)

	Select @miscprint = 'Configuration Info'
	Print @miscprint
	Select @miscprint = '=================='
	Print @miscprint

	Select @miscprint = 'Memory Physical_Total: ' + convert(char(60), @save_MemoryPhysical_Total)
	Print @miscprint
	Select @miscprint = 'Memory Physical_Avail: ' + convert(char(60), @save_MemoryPhysical_Avail)
	Print @miscprint
	Select @miscprint = 'Memory Virtual_Total:  ' + convert(char(60), @save_MemoryVirtual_Total)
	Print @miscprint
	Select @miscprint = 'Memory Virtual_Avail:  ' + convert(char(60), @save_MemoryVirtual_Avail)
	Print @miscprint
	Select @miscprint = 'Pagefile Path:         ' + convert(char(60), @save_Pagefile_path)
	Print @miscprint
	Select @miscprint = 'Pagefile Maxsize:      ' + convert(char(60), @save_Pagefile_Maxsize)
	Print @miscprint
	Select @miscprint = 'Pagefile Available:    ' + convert(char(60), @save_Pagefile_Avail)
	Print @miscprint
	Select @miscprint = 'Pagefile In Use:       ' + convert(char(60), @save_Pagefile_InUse)
	Print @miscprint
	Select @miscprint = 'System Path:           ' + @save_Path
	Print @miscprint
	Select @miscprint = 'Boot.ini Loader:       ' + @save_Boot_Loader
	Print @miscprint
	Select @miscprint = 'Boot.ini OppSystems:   ' + @save_Boot_OppSystems
	Print @miscprint
	Select @miscprint = 'IE Version:            ' + @save_IEver
	Print @miscprint
	Select @miscprint = 'MDAC Version:          ' + @save_MDACver
	Print @miscprint
	Select @miscprint = 'Bios Version:          ' + @save_BiosVer
	Print @miscprint
	Select @miscprint = 'SM Bios Version:       ' + @save_SMBiosVer
	Print @miscprint
	Print''



	If @type in ('1', 'full')
	   begin
		Delete from #temp_ipconfig
		Insert into #temp_ipconfig select MACaddress
						,IPtype
						,IPaddress
						,IPorder	
					from dbo.WEB_IPconfig
					where ServerName = @detail
					and active = 'y'
		--Select * from #temp_ipconfig


		Select @miscprint = 'IP Config Info'
		Print @miscprint
		Select @miscprint = '=============='
		Print @miscprint

		If (select count(*) from #temp_ipconfig) = 0
		   begin
			Select @miscprint = 'No IPconfig results found for this report.' 
			Print @miscprint
			Print ''
			goto skip_ipconfig
		   end


		If (select count(*) from #temp_ipconfig where IPtype = 'IP') > 0
		   begin
			Select @miscprint = 'IP Address(es):  '
			start_ipconfig01:
			Select @save_IPaddress = (select top 1 IPaddress from #temp_ipconfig where IPtype = 'IP' order by IPorder)
			Select @save_IPorder = (select top 1 IPorder from #temp_ipconfig where IPtype = 'IP' and IPaddress = @save_IPaddress order by IPorder)

			Select @miscprint = @miscprint + @save_IPaddress 
			Print @miscprint

			delete from #temp_ipconfig where IPtype = 'IP' and IPaddress = @save_IPaddress and IPorder = @save_IPorder
			If (select count(*) from #temp_ipconfig where IPtype = 'IP') > 0
			   begin
				Select @miscprint = '                 '
				goto start_ipconfig01
			   end
		   end


		If (select count(*) from #temp_ipconfig where IPtype = 'DFLT_Gateway') > 0
		   begin
			Select @miscprint = 'Default Gateway: '
			start_DFLT_Gateway01:
			Select @save_IPaddress = (select top 1 IPaddress from #temp_ipconfig where IPtype = 'DFLT_Gateway' order by IPorder)
			Select @save_IPorder = (select top 1 IPorder from #temp_ipconfig where IPtype = 'DFLT_Gateway' and IPaddress = @save_IPaddress order by IPorder)

			Select @miscprint = @miscprint + @save_IPaddress 
			Print @miscprint

			delete from #temp_ipconfig where IPtype = 'DFLT_Gateway' and IPaddress = @save_IPaddress and IPorder = @save_IPorder
			If (select count(*) from #temp_ipconfig where IPtype = 'DFLT_Gateway') > 0
			   begin
				Select @miscprint = '                '
				goto start_DFLT_Gateway01
			   end
		   end


		If (select count(*) from #temp_ipconfig where IPtype = 'DNS') > 0
		   begin
			Select @miscprint = 'DNS:             '
			start_DNS01:
			Select @save_IPaddress = (select top 1 IPaddress from #temp_ipconfig where IPtype = 'DNS' order by IPorder)
			Select @save_IPorder = (select top 1 IPorder from #temp_ipconfig where IPtype = 'DNS' and IPaddress = @save_IPaddress order by IPorder)

			Select @miscprint = @miscprint + @save_IPaddress 
			Print @miscprint

			delete from #temp_ipconfig where IPtype = 'DNS' and IPaddress = @save_IPaddress and IPorder = @save_IPorder
			If (select count(*) from #temp_ipconfig where IPtype = 'DNS') > 0
			   begin
				Select @miscprint = '                 '
				goto start_DNS01
			   end
		   end


		If (select count(*) from #temp_ipconfig where IPtype = 'WinsPrimary') > 0
		   begin
			Select @miscprint = 'WinsPrimary:     '
			start_WinsPrimary01:
			Select @save_IPaddress = (select top 1 IPaddress from #temp_ipconfig where IPtype = 'WinsPrimary' order by IPorder)
			Select @save_IPorder = (select top 1 IPorder from #temp_ipconfig where IPtype = 'WinsPrimary' and IPaddress = @save_IPaddress order by IPorder)

			Select @miscprint = @miscprint + @save_IPaddress 
			Print @miscprint

			delete from #temp_ipconfig where IPtype = 'WinsPrimary' and IPaddress = @save_IPaddress and IPorder = @save_IPorder
			If (select count(*) from #temp_ipconfig where IPtype = 'WinsPrimary') > 0
			   begin
				Select @miscprint = '                 '
				goto start_WinsPrimary01
			   end
		   end


		If (select count(*) from #temp_ipconfig where IPtype = 'WinsSecondary') > 0
		   begin
			Select @miscprint = 'WinsSecondary:   '
			start_WinsSecondary01:
			Select @save_IPaddress = (select top 1 IPaddress from #temp_ipconfig where IPtype = 'WinsSecondary' order by IPorder)
			Select @save_IPorder = (select top 1 IPorder from #temp_ipconfig where IPtype = 'WinsSecondary' and IPaddress = @save_IPaddress order by IPorder)

			Select @miscprint = @miscprint + @save_IPaddress 
			Print @miscprint

			delete from #temp_ipconfig where IPtype = 'WinsSecondary' and IPaddress = @save_IPaddress and IPorder = @save_IPorder
			If (select count(*) from #temp_ipconfig where IPtype = 'WinsSecondary') > 0
			   begin
				Select @miscprint = '                 '
				goto start_WinsSecondary01
			   end
		   end


		If (select count(*) from #temp_ipconfig where IPtype = 'Subnet') > 0
		   begin
			Select @miscprint = 'Subnet:          '
			start_Subnet01:
			Select @save_IPaddress = (select top 1 IPaddress from #temp_ipconfig where IPtype = 'Subnet' order by IPorder)
			Select @save_IPorder = (select top 1 IPorder from #temp_ipconfig where IPtype = 'Subnet' and IPaddress = @save_IPaddress order by IPorder)

			Select @miscprint = @miscprint + @save_IPaddress 
			Print @miscprint

			delete from #temp_ipconfig where IPtype = 'Subnet' and IPaddress = @save_IPaddress and IPorder = @save_IPorder
			If (select count(*) from #temp_ipconfig where IPtype = 'Subnet') > 0
			   begin
				Select @miscprint = '                 '
				goto start_Subnet01
			   end
		   end



		Delete from #temp_ipconfig
		Insert into #temp_ipconfig select MACaddress
						,IPtype
						,IPaddress
						,IPorder	
					from dbo.WEB_IPconfig
					where ServerName = @detail
					and active = 'y'
		--Select * from #temp_ipconfig


		If (select count(*) from #temp_ipconfig) > 0
		   begin
			Select @miscprint = 'MAC Address:     '
			start_MACaddress01:
			Select @save_MACaddress = (select top 1 MACaddress from #temp_ipconfig order by MACaddress)

			Select @miscprint = @miscprint + @save_MACaddress 
			Print @miscprint

			delete from #temp_ipconfig where MACaddress = @save_MACaddress
			If (select count(*) from #temp_ipconfig) > 0
			   begin
				Select @miscprint = '                 '
				goto start_MACaddress01
			   end
		   end


		print ''

		skip_ipconfig:

	   end



	--  Hotfix report section
	If @type in ('2', 'full')
	   begin
		Delete from #temp_hotfix
		Insert into #temp_hotfix select hotfix_name
					from dbo.WEB_HOTfix
					where ServerName = @detail
					and active = 'y'
		--Select * from #temp_hotfix

		Select @miscprint = 'HotFix Info'
		Print @miscprint
		Select @miscprint = '==========='
		Print @miscprint

		If (select count(*) from #temp_hotfix) = 0
		   begin
			Select @miscprint = 'No HotFix results found for this report.' 
			Print @miscprint
			Print ''
			goto skip_hotfix
		   end



		If (select count(*) from #temp_hotfix) > 0
		   begin
			start_hotfix01:
			Select @save_hotfix = (select top 1 hotfix_name from #temp_hotfix order by hotfix_name)

			Print @save_hotfix

			delete from #temp_hotfix where hotfix_name = @save_hotfix
			If (select count(*) from #temp_hotfix) > 0
			   begin
				Select @miscprint = '                 '
				goto start_hotfix01
			   end
		   end


		print ''

		skip_hotfix:

	   end




	--  Drive report section
	If @type in ('3', 'full')
	   begin
		Delete from #temp_drive
		Insert into #temp_drive select Drive_name
						,Drive_Size
						,Drive_Freespace
						,File_System
						,Compressed
						,Description
					from dbo.WEB_Driveinfo
					where ServerName = @detail
					and active = 'y'
		--Select * from #temp_drive

		Select @miscprint = 'Drive Info                         Drive Size                         Drive Freespace'
		Print @miscprint
		Select @miscprint = '================================== ================================== ================================'
		Print @miscprint

		If (select count(*) from #temp_drive) = 0
		   begin
			Select @miscprint = 'No Drive results found for this report.' 
			Print @miscprint
			Print ''
			goto skip_drive
		   end



		If (select count(*) from #temp_drive) > 0
		   begin
			start_drive01:
			Select @save_drive = (select top 1 drive_name from #temp_drive order by drive_name)
			Select @save_Description = (select top 1 Description from #temp_drive where drive_name = @save_drive)
			Select @save_Drive_Size = (select top 1 Drive_Size from #temp_drive where drive_name = @save_drive)
			Select @save_Drive_Freespace = (select top 1 Drive_Freespace from #temp_drive where drive_name = @save_drive)

			Select @miscprint = convert(nchar(5), @save_drive)

			If @save_Description is not null
			   begin
				Select @miscprint = @miscprint + convert(nchar(30), @save_Description)
			   end
			Else
			   begin
				Select @miscprint = @miscprint + '                    '
			   end

			If @save_Drive_Size is not null
			   begin
				Select @miscprint = @miscprint + convert(nchar(35), @save_Drive_Size)
			   end
			Else
			   begin
				Select @miscprint = @miscprint + '                    '
			   end

			If @save_Drive_Freespace is not null
			   begin
				Select @miscprint = @miscprint + convert(nchar(35), @save_Drive_Freespace)
			   end
			Else
			   begin
				Select @miscprint = @miscprint + '                    '
			   end

			Print @miscprint



			delete from #temp_drive where drive_name = @save_drive
			If (select count(*) from #temp_drive) > 0
			   begin
				goto start_drive01
			   end
		   end


		print ''

		skip_drive:

	   end



	--  Reg report section
	If @type in ('4', 'full')
	   begin
		Delete from #temp_reg
		Insert into #temp_reg select WebREGID
						,KEYpath01
						,KEYpath02
						,KEYname
						,KEYdata
					from dbo.WEB_REGinfo
					where ServerName = @detail
					and active = 'y'

		Delete from #temp_reg where KEYpath02 like 'DeploymentInfo\%'

		--Select * from #temp_reg

		Select @miscprint = 'Registry Info                                                                   Key Name                           Key Data'
		Print @miscprint
		Select @miscprint = '==============================================================================  =================================  ================================='
		Print @miscprint

		If (select count(*) from #temp_reg) = 0
		   begin
			Select @miscprint = 'No Registry results found for this report.' 
			Print @miscprint
			Print ''
			goto skip_reg01
		   end


		If (select count(*) from #temp_reg) > 0
		   begin
			start_reg01:
			Select @save_WebREGID = (select top 1 WebREGID from #temp_reg order by KEYpath02, WebREGID)
			Select @save_KEYpath02 = (select top 1 KEYpath02 from #temp_reg where WebREGID = @save_WebREGID)
			Select @save_KEYname = (select top 1 KEYname from #temp_reg where WebREGID = @save_WebREGID)
			Select @save_KEYdata = (select top 1 KEYdata from #temp_reg where WebREGID = @save_WebREGID)

			Select @miscprint = convert(nchar(80), @save_KEYpath02)

			If @save_KEYname is not null
			   begin
				Select @miscprint = @miscprint + convert(nchar(35), @save_KEYname)
			   end
			Else
			   begin
				Select @miscprint = @miscprint + '                    '
			   end

			If @save_KEYdata is not null
			   begin
				Select @miscprint = @miscprint + convert(nchar(35), @save_KEYdata)
			   end
			Else
			   begin
				Select @miscprint = @miscprint + '                    '
			   end


			Print @miscprint


			delete from #temp_reg where WebREGID = @save_WebREGID
			If (select count(*) from #temp_reg) > 0
			   begin
				goto start_reg01
			   end
		   end


		print ''

		skip_reg01:

	   end





	--  DEPL report section
	If @type in ('5', 'full')
	   begin
		Delete from #temp_reg
		Insert into #temp_reg select WebREGID
						,KEYpath01
						,KEYpath02
						,KEYname
						,KEYdata
					from dbo.WEB_REGinfo
					where ServerName = @detail
					and active = 'y'

		Delete from #temp_reg where KEYpath02 not like 'DeploymentInfo\%'

		--Select * from #temp_reg

		Select @miscprint = 'Deployment Info                                   Attribute                          Detail'
		Print @miscprint
		Select @miscprint = '================================================  =================================  ================================='
		Print @miscprint

		If (select count(*) from #temp_reg) = 0
		   begin
			Select @miscprint = 'No DEPL Registry results found for this report.' 
			Print @miscprint
			Print ''
			goto skip_reg02
		   end


		If (select count(*) from #temp_reg) > 0
		   begin
			select @hold_KEYpath02 = ''
			start_reg02:
			Select @save_WebREGID = (select top 1 WebREGID from #temp_reg order by KEYpath02, WebREGID)
			Select @save_KEYpath02 = (select top 1 KEYpath02 from #temp_reg where WebREGID = @save_WebREGID)
			Select @save_KEYname = (select top 1 KEYname from #temp_reg where WebREGID = @save_WebREGID)
			Select @save_KEYdata = (select top 1 KEYdata from #temp_reg where WebREGID = @save_WebREGID)

			If @save_KEYpath02 = @hold_KEYpath02
			   begin
				Select @miscprint = '                                                  '
			   end
			Else
			   begin
				Select @miscprint = convert(nchar(50), @save_KEYpath02)
			   end

			If @save_KEYname is not null
			   begin
				Select @miscprint = @miscprint + convert(nchar(35), @save_KEYname)
			   end
			Else
			   begin
				Select @miscprint = @miscprint + '                    '
			   end

			If @save_KEYdata is not null
			   begin
				Select @miscprint = @miscprint + convert(nchar(35), @save_KEYdata)
			   end
			Else
			   begin
				Select @miscprint = @miscprint + '                    '
			   end

			Print @miscprint

			delete from #temp_reg where WebREGID = @save_WebREGID
			If (select count(*) from #temp_reg) > 0
			   begin
				Select @hold_KEYpath02 = @save_KEYpath02
				goto start_reg02
			   end
		   end


		print ''

		skip_reg02:

	   end








	--  Print out sample exection for this sproc
	If @report_only = 'n'
	   begin
		Print  ' '
		Select @miscprint = '--  Example execute command for this sproc: (Full Report)'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_ServerRpt ''' + upper(@detail) + ''', ''Full'''
		Print  @miscprint
		Print  ' '
		Select @miscprint = '--  Example execute command for this sproc: (Enhanced Partial Report)'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_ServerRpt ''' + upper(@detail) + ''', ''1'' -- Partial with IPconfig Info'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_ServerRpt ''' + upper(@detail) + ''', ''2'' -- Partial with Hot Fix Info'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_ServerRpt ''' + upper(@detail) + ''', ''3'' -- Partial with Drive Info'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_ServerRpt ''' + upper(@detail) + ''', ''4'' -- Partial with Registry Info'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_ServerRpt ''' + upper(@detail) + ''', ''5'' -- Partial with Deployment Info'
		Print  @miscprint
		Print  ' '
	   end


	goto label99

   end




----------------------------------------------------------------------------------------------------------------------
--  Request Report "DEV" section  --------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
If @detail like '%dev%'
   begin

	Insert into #temp_server select servername
				from dbo.web_serverinfo
				where envname like 'dev%' or servername like '%dev%' or servername like 'fred%'
				Union
				select servername
				from dbo.web_reginfo
				where keyname = 'Environment' and keydata like 'dev%'


	--  Print out sample exection for this sproc
	If @report_only = 'n'
	   begin
		Select @miscprint = '--  Example execute command for this sproc:'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_serverrpt ''servername'', --''Full'' (''Partial'' is the default)'
		Print  @miscprint
		Print  ' '
	   end


	If (select count(*) from #temp_server) = 0
	   begin
		Select @miscprint = 'No DEV servers found for this report.' 
		Print  @miscprint
		Print  ' '
		goto label99
	   end


	--  Print the dev servers
	Select @miscprint = 'Dev Servers:'
	Print @miscprint

	start_dev01:

	Select @save_servername = (select top 1 servername from #temp_server order by servername)


	Select @miscprint = @save_servername
	Print @miscprint


	--  Check to see if there are more row to process
	delete from #temp_server where servername = @save_servername
	If (select count(*) from #temp_server) > 0
	   begin
		goto start_dev01
	   end

	goto label99

   end


----------------------------------------------------------------------------------------------------------------------
--  Request Report "TEST" section  --------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
If @detail like '%test%' or @detail like '%tst%'
   begin

	Insert into #temp_server select servername
				from dbo.web_serverinfo
				where envname like 'test%' or servername like '%test%' or servername like '%tst%' or servername like 'fret%'
				Union
				select servername
				from dbo.web_reginfo
				where keyname = 'Environment' and keydata like 'test%'


	--  Print out sample exection for this sproc
	If @report_only = 'n'
	   begin
		Select @miscprint = '--  Example execute command for this sproc:'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_serverrpt ''servername'', --''Full'' (''Partial'' is the default)'
		Print  @miscprint
		Print  ' '
	   end


	If (select count(*) from #temp_server) = 0
	   begin
		Select @miscprint = 'No TEST servers found for this report.' 
		Print  @miscprint
		Print  ' '
		goto label99
	   end


	--  Print the test servers
	Select @miscprint = 'Test Servers:'
	Print @miscprint

	start_test01:

	Select @save_servername = (select top 1 servername from #temp_server order by servername)


	Select @miscprint = @save_servername
	Print @miscprint


	--  Check to see if there are more row to process
	delete from #temp_server where servername = @save_servername
	If (select count(*) from #temp_server) > 0
	   begin
		goto start_test01
	   end

	goto label99

   end



----------------------------------------------------------------------------------------------------------------------
--  Request Report "LOAD" section  --------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
If @detail like '%load%'
   begin

	Insert into #temp_server select servername
				from dbo.web_serverinfo
				where envname like 'load%' or servername like '%load%' or servername like 'frel%'
				Union
				select servername
				from dbo.web_reginfo
				where keyname = 'Environment' and keydata like 'load%'


	--  Print out sample exection for this sproc
	If @report_only = 'n'
	   begin
		Select @miscprint = '--  Example execute command for this sproc:'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_serverrpt ''servername'', --''Full'' (''Partial'' is the default)'
		Print  @miscprint
		Print  ' '
	   end


	If (select count(*) from #temp_server) = 0
	   begin
		Select @miscprint = 'No LOAD servers found for this report.' 
		Print  @miscprint
		Print  ' '
		goto label99
	   end


	--  Print the test servers
	Select @miscprint = 'Load Servers:'
	Print @miscprint

	start_load01:

	Select @save_servername = (select top 1 servername from #temp_server order by servername)


	Select @miscprint = @save_servername
	Print @miscprint


	--  Check to see if there are more row to process
	delete from #temp_server where servername = @save_servername
	If (select count(*) from #temp_server) > 0
	   begin
		goto start_load01
	   end

	goto label99

   end


----------------------------------------------------------------------------------------------------------------------
--  Request Report "STAGE" section  --------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
If @detail like '%stag%'
   begin

	Insert into #temp_server select servername
				from dbo.web_serverinfo
				where envname like 'stag%' or servername like '%stag%' or servername like 'fres%'
				Union
				select servername
				from dbo.web_reginfo
				where keyname = 'Environment' and keydata like 'stag%'


	--  Print out sample exection for this sproc
	If @report_only = 'n'
	   begin
		Select @miscprint = '--  Example execute command for this sproc:'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_serverrpt ''servername'', --''Full'' (''Partial'' is the default)'
		Print  @miscprint
		Print  ' '
	   end

	If (select count(*) from #temp_server) = 0
	   begin
		Select @miscprint = 'No STAGE servers found for this report.' 
		Print  @miscprint
		Print  ' '
		goto label99
	   end


	--  Print the test servers
	Select @miscprint = 'Stage Servers:'
	Print @miscprint

	start_stage01:

	Select @save_servername = (select top 1 servername from #temp_server order by servername)


	Select @miscprint = @save_servername
	Print @miscprint


	--  Check to see if there are more row to process
	delete from #temp_server where servername = @save_servername
	If (select count(*) from #temp_server) > 0
	   begin
		goto start_stage01
	   end

	goto label99

   end


----------------------------------------------------------------------------------------------------------------------
--  Request Report "PROD" section  --------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
If @detail like '%prod%'
   begin

	Insert into #temp_server select servername
				from dbo.web_serverinfo
				where envname not like 'dev%'
				and envname not like 'test%'
				and envname not like 'tst%'
				and envname not like 'load%'
				and envname not like 'stag%'
				and servername not like '%dev%'
				and servername not like '%test%'
				and servername not like '%tst%'
				and servername not like '%load%'
				and servername not like '%stag%'
				and servername not like 'fred%'
				and servername not like 'fret%'
				and servername not like 'frel%'
				and servername not like 'fres%'
				Union
				select servername
				from dbo.web_reginfo
				where keyname = 'Environment' and keydata like 'prod%'


	--  Print out sample exection for this sproc
	If @report_only = 'n'
	   begin
		Select @miscprint = '--  Example execute command for this sproc:'
		Print  @miscprint
		Select @miscprint = 'exec dbaadmin.dbo.websp_serverrpt ''servername'', --''Full'' (''Partial'' is the default)'
		Print  @miscprint
		Print  ' '
	   end


	If (select count(*) from #temp_server) = 0
	   begin
		Select @miscprint = 'No PRODUCTION servers found for this report.' 
		Print  @miscprint
		Print  ' '
		goto label99
	   end


	--  Print the test servers
	Select @miscprint = 'Production Servers:'
	Print @miscprint

	start_prod01:

	Select @save_servername = (select top 1 servername from #temp_server order by servername)


	Select @miscprint = @save_servername
	Print @miscprint


	--  Check to see if there are more row to process
	delete from #temp_server where servername = @save_servername
	If (select count(*) from #temp_server) > 0
	   begin
		goto start_prod01
	   end

	goto label99

   end





catch_all:

----------------------------------------------------------------------------------------------------------------------
--  Request Report "Catch All" section  --------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Insert into #temp_server select servername
			from dbo.web_serverinfo
			Union
			select servername
			from dbo.web_reginfo


--  Print out sample exection for this sproc
If @report_only = 'n'
   begin
	Select @miscprint = '--  Example execute command for this sproc:'
	Print  @miscprint
	Select @miscprint = 'exec dbaadmin.dbo.websp_serverrpt ''servername'', --''Full'' (''Partial'' is the default)'
	Print  @miscprint
	Print  ' '
   end

If (select count(*) from #temp_server) = 0
   begin
	Select @miscprint = 'No servers found for this report.' 
	Print  @miscprint
	Print  ' '
	goto label99
   end


--  Print the test servers
Select @miscprint = 'Servers:'
Print @miscprint

start_catch01:

Select @save_servername = (select top 1 servername from #temp_server order by servername)


Select @miscprint = @save_servername
Print @miscprint


--  Check to see if there are more row to process
delete from #temp_server where servername = @save_servername
If (select count(*) from #temp_server) > 0
   begin
	goto start_catch01
   end







-----------------  Finalizations  ------------------

label99:

drop table #temp_cldet

drop table #temp_server
drop table #temp_serverinfo
drop table #temp_envname
drop table #temp_ipconfig
drop table #temp_hotfix
drop table #temp_drive
drop table #temp_reg




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
go















































/**************************************************************
UDF Section: dbaadmin
**************************************************************/
use dbaadmin
go




if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbaudf_CheckFileStatus]'))
drop function [dbo].[dbaudf_CheckFileStatus]
GO



Create function dbo.dbaudf_CheckFileStatus (@filename nvarchar(1000))
returns bit

/**************************************************************
 **  User Defined Function dbaudf_CheckFileStatus                  
 **  Written by Jim Wilson, Getty Images                
 **  November 28, 2005                                      
 **  
 **  This dbaudf is set up to check the file status.
 **  In Use 		= 1
 **  Ready 		= 0
 ***************************************************************/
as

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	11/28/2005	Jim Wilson		New process
--	06/02/2006	Jim Wilson		Updated for SQL 2005.
--	======================================================================================

/***
declare  @filename varchar(1000)

set @filename = '\\SEADCSQLWVA\SEADCSQLWVA_builds\deployment_logs\SQLDEPL_SEADCSQLWVA_AssetKeyword_F_20060602_1627.log'
--set @filename = 'D:\sqldumps\etst.bak'
--***/

BEGIN
DECLARE @FS				int
DECLARE @OLEResult		int
DECLARE @FileID			int
DECLARE @source			NVARCHAR(255)
DECLARE @description	NVARCHAR(255)
DECLARE @flag			bit

set @source ='Exist'
set @description='Exist'
EXECUTE @OLEResult = master.sys.sp_OACreate 'Scripting.FileSystemObject', @FS OUT
IF @OLEResult <> 0  
   begin
	EXEC master.sys.sp_OAGetErrorInfo NULL, @source OUTPUT, @description OUTPUT 
	goto displayerror
   end

--Open a file
execute @OLEResult = master.sys.sp_OAMethod @FS, 'OpenTextFile', @FileID OUT,@filename , 1
IF @OLEResult <> 0  
   begin
	EXEC master.sys.sp_OAGetErrorInfo NULL, @source OUTPUT, @description OUTPUT 
	goto displayerror
   end

EXECUTE @OLEResult = master.sys.sp_OADestroy @FileID
EXECUTE @OLEResult = master.sys.sp_OADestroy @FS

DisplayError:
if @source is NULL and @description is NULL
   begin
	--print @filename + '  in Use'
	set @flag = 1
   end
else
   begin
	--print @filename + '  is ready'
	set @flag = 0
   end

return @flag
END


GO













if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbaudf_xpExec]'))
drop function [dbo].[dbaudf_xpExec]

GO


create function dbo.dbaudf_xpExec(@cmd nvarchar(4000))
returns nvarchar(4000)

/**************************************************************
 **  User Defined Function dbaudf_xpExec                 
 **  Written by David Spriggs, Getty Images                
 **  December 10, 2008                                     
 **  
 **  This dbaudf is set up to execute a shell command utilizing
 **  xp_cmdshell. This especially useful when used in table 
 **  processing; thus eliminating the need for those nasty little cursors.
 **  
 **  For Example:
 **
 **	SELECT dbaadmin.dbo.dbaudf_xpExec('del '+columnvalue) from #cmdtable
 **
 **  Returns the submitted command.
 ***************************************************************/
as


--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	12/10/2008	David Spriggs		New process
--	
--	======================================================================================

/**
    declare @cmd nvarchar(4000)
    set @cmd = 'dir c:\'
**/


begin
    -----------------  declares  ------------------
    declare @ret nvarchar(4000)


    /****************************************************************
     *                MainLine
     ***************************************************************/
    exec master.sys.xp_cmdShell @cmd
    set @ret = 'exec master.sys.xp_cmdshell '''+@cmd+''''
    return @ret
END
go









if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbaudf_split]'))
drop function [dbo].[dbaudf_split]
GO


Create function dbo.dbaudf_split ( @String VARCHAR(200), @Delimiter VARCHAR(5))
returns @SplittedValues TABLE
(
    OccurenceId SMALLINT IDENTITY(1,1),
    SplitValue VARCHAR(200)
)
/**************************************************************
 **  User Defined Function dbaudf_split                 
 **  Written by David Spriggs, Getty Images                
 **  May 12, 2009                                     
 **  
 **  This dbaudf is set up parse a delimited string return values
 **  in tabular format.
 **  
 ***************************************************************/
as

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	05/13/2009	David Spriggs		New process
--	
--	======================================================================================

/***
declare @String VARCHAR(200)
declare @Delimiter VARCHAR(5)

set @String = 'abc def ghi'
set @Delimiter = ' '

--***/

BEGIN

    DECLARE @SplitLength INT

    WHILE LEN(@String) > 0

	BEGIN

	    SELECT @SplitLength = (CASE CHARINDEX(@Delimiter,@String) WHEN 0 THEN
			           LEN(@String) ELSE CHARINDEX(@Delimiter,@String) -1 END)

	    INSERT INTO @SplittedValues
	    SELECT SUBSTRING(@String,1,@SplitLength)

	    SELECT @String = (CASE (LEN(@String) - @SplitLength) WHEN 0 THEN ''
			      ELSE RIGHT(@String, LEN(@String) - @SplitLength - 1) END)
	END

    RETURN

END

go







use dbaadmin
go


if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbaudf_getdefaultFilePath]'))
drop function [dbo].[dbaudf_getdefaultFilePath]
GO
create function [dbo].[dbaudf_getdefaultFilePath](@gfpType char(2))
returns nvarchar(500)
as

/**************************************************************
 **  User Defined Function dbaudf_getdefaultFilePath                  
 **  Written by David Spriggs, Getty Images                
 **  July 08/2009                                      
 **  
 **  This dbaudf is set up to check the the default path 
 **  for the physical Data and Log File.
 **  Returns:
 **      path:    Which indicates the database default path is set.
 **	 Not Set: Which indicates the database default path is 
 **		  the same as where SQL is installed.
 **  
 ***************************************************************/


--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	07/08/2009	David Spriggs		New process
--	
--	======================================================================================
begin


      DECLARE
		 @in_key			sysname
		,@in_path			sysname
		,@in_value			sysname
		,@in_value2			sysname
		,@result_value		        nvarchar(500)
		,@retVal			nvarchar(500)
		,@cmd			        nvarchar(4000)
		,@save_servername		sysname
		,@save_servername2		sysname
		,@save_ServerType		sysname
		,@save_sqlinstance		sysname
		,@charpos			int
		,@isNMinstance			char(1)
		,@save_install_folder		sysname
		,@save_whatwearelookingfor	nvarchar(20)
		,@save_regresult		sysname
		,@interimResult			nvarchar(4000)



	   /**
		  declare @gfpType char(2)
     		   set @gfpType = 'L'
	    --**/
     

       --Parameter check--

       if (@gfpType not like 'D' and  @gfpType  not like 'L')
	    begin 
		    select @retval='invalid parameter passed'
		   --print @retval
		    return @retval
		    goto label99
	    end 
        else
	    begin
		set @in_value =
		    case 
			when @gfpType like '%D%'  then  'DefaultData' 
			when @gfpType like '%L%'  then  'DefaultLog'
		    end
            end

	Select @save_whatwearelookingfor = @in_value

	declare @regresults table (results nvarchar(1500) null)


	Select @save_sqlinstance = 'mssqlserver'
	Select @save_servername = @@servername
	Select @save_servername2 = @@servername

	Select @charpos = charindex('\', @save_servername)
	IF @charpos <> 0
	   begin
		Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	
		Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
	
		Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
		Select @isNMinstance = 'y'
	   end


	--  Get the instalation directory folder name
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'
	select @in_value2 = @save_sqlinstance
	exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value2, @result_value output

	If @result_value is null or @result_value = ''
	   begin
		goto label99
	   end

	--  Now ...
	select @save_install_folder = @result_value
	select @in_key = 'HKEY_LOCAL_MACHINE'
	select @in_path = 'SOFTWARE\Microsoft\Microsoft SQL Server\' + @save_install_folder + '\MSSQLServer'
	EXEC master..xp_regread @rootkey = @in_key , @key = @in_path, @value_name = @in_value, @value = @save_regresult OUTPUT


	If @save_regresult is not null and @save_regresult <> ''
	   begin
		select @retVal = @save_regresult
	   end

           
	If(@retVal is null)
	     begin
		    set @retVal = 'Not Set'
	     end

	--print @retVal   


	----------finalization----------

	label99:

	return @retVal

end





go



use dbaadmin
go


if exists (select * from sys.objects where object_id = object_id(N'[dbo].[dbaudf_FileAccess_Read]'))
drop function [dbo].[dbaudf_FileAccess_Read]
GO



CREATE FUNCTION [dbo].[dbaudf_FileAccess_Read] (@Path VARCHAR(255),
						@Filename VARCHAR(100)
						)
						RETURNS @File TABLE
						([LineNo] int identity(1,1), 
						line varchar(8000)) 

/**************************************************************
 **  User Defined Function dbaudf_CheckFileStatus                  
 **  Written by Steve Ledridge, Getty Images                
 **  April 01, 2005                                      
 **  
 **  This dbaudf is set up to read a file into a table.
 ***************************************************************/
as

--	======================================================================================
--	Revision History
--	Date		Author     		Desc
--	==========	====================	=============================================
--	04/01/2010	Steve Ledridge		New process
--	======================================================================================

BEGIN

DECLARE  @objFileSystem int
        ,@objTextStream int
	,@objErrorObject int
	,@strErrorMessage Varchar(1000)
	,@Command varchar(1000)
	,@hr int
	,@String VARCHAR(8000)
	,@YesOrNo INT

select @strErrorMessage='opening the File System Object'
EXECUTE @hr = sp_OACreate  'Scripting.FileSystemObject' , @objFileSystem OUT


if @HR=0 Select @objErrorObject=@objFileSystem, @strErrorMessage='Opening file "'+@path+'\'+@filename+'"',@command=@path+'\'+@filename

if @HR=0 execute @hr = sp_OAMethod   @objFileSystem  , 'OpenTextFile'
	, @objTextStream OUT, @command,1,false,0--for reading, FormatASCII

WHILE @hr=0
	BEGIN
	if @HR=0 Select @objErrorObject=@objTextStream, 
		@strErrorMessage='finding out if there is more to read in "'+@filename+'"'
	if @HR=0 execute @hr = sp_OAGetProperty @objTextStream, 'AtEndOfStream', @YesOrNo OUTPUT

	IF @YesOrNo<>0  break
	if @HR=0 Select @objErrorObject=@objTextStream, 
		@strErrorMessage='reading from the output file "'+@filename+'"'
	if @HR=0 execute @hr = sp_OAMethod  @objTextStream, 'Readline', @String OUTPUT
	INSERT INTO @file(line) SELECT @String
	END

if @HR=0 Select @objErrorObject=@objTextStream, 
	@strErrorMessage='closing the output file "'+@filename+'"'
if @HR=0 execute @hr = sp_OAMethod  @objTextStream, 'Close'


if @hr<>0
	begin
	Declare 
		@Source varchar(255),
		@Description Varchar(255),
		@Helpfile Varchar(255),
		@HelpID int
	
	EXECUTE sp_OAGetErrorInfo  @objErrorObject, 
		@source output,@Description output,@Helpfile output,@HelpID output
	Select @strErrorMessage='Error whilst '
			+coalesce(@strErrorMessage,'doing something')
			+', '+coalesce(@Description,'')
	insert into @File(line) select @strErrorMessage
	end
EXECUTE  sp_OADestroy @objTextStream
	-- Fill the table variable with the rows for your result set
	
	RETURN 
END



GO










































-----------------------------------
--  Other dependent Objects section
-----------------------------------
use msdb
go

if OBJECTPROPERTY(object_id('dbo.fn_QueryTextFromHandle'), 'IsTableFunction') = 1
	drop function dbo.fn_QueryTextFromHandle
go


CREATE function dbo.fn_QueryTextFromHandle(@handle varbinary(64), @statement_start_offset int, @statement_end_offset int)
RETURNS @query_text TABLE (database_id smallint, object_id int, encrypted bit, query_text nvarchar(max))
begin
	if @handle is not null
	begin
		declare @start int, @end int
		declare @dbid smallint, @objectid int, @encrypted bit
		declare @batch nvarchar(max), @query nvarchar(max)

		-- statement_end_offset is zero prior to beginning query execution (e.g., compilation)
		select 
			@start = isnull(@statement_start_offset, 0), 
			@end = case when @statement_end_offset is null or @statement_end_offset = 0 then -1
						else @statement_end_offset 
					end

		select @dbid = t.dbid, 
			@objectid = t.objectid, 
			@encrypted = t.encrypted, 
			@batch = t.text 
		from sys.dm_exec_sql_text(@handle) as t

		select @query = case 
				when @encrypted = cast(1 as bit) then N'encrypted text' 
				else ltrim(substring(@batch, @start / 2 + 1, ((case when @end = -1 then datalength(@batch) 
							else @end end) - @start) / 2))
			end

		-- Found internal queries (e.g., CREATE INDEX) with end offset of original batch that is 
		-- greater than the length of the internal query and thus returns nothing if we don't do this
		if datalength(@query) = 0
		begin
			select @query = @batch
		end

		insert into @query_text (database_id, object_id, encrypted, query_text) 
		values (@dbid, @objectid, @encrypted, @query)
	end

	return
end

go

GRANT SELECT ON dbo.fn_QueryTextFromHandle TO public
go




































--------------------------------------------
--  Performance Dashboard Updates
--------------------------------------------
--  Updates for Performance Dashboard (2005)


-- Script must not be run in a transaction
SET IMPLICIT_TRANSACTIONS OFF
IF @@TRANCOUNT > 0 ROLLBACK TRAN
GO

-- Options that are saved with object definition
SET QUOTED_IDENTIFIER ON		-- Required to call methods on XML type
SET ANSI_NULLS ON				-- All queries use IS NULL check
go

use msdb
go

if not exists (select * from sys.schemas where name = 'MS_PerfDashboard')
	exec('create schema MS_PerfDashboard')
go

if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_WaitTypeCategory'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_WaitTypeCategory
go

create function MS_PerfDashboard.fn_WaitTypeCategory(@wait_type nvarchar(60)) 
returns varchar(60)
as
begin
	declare @category nvarchar(60)
	select @category = 
		case 
			when @wait_type like N'LCK_M_%' then N'Lock'
			when @wait_type like N'LATCH_%' then N'Latch'
			when @wait_type like N'PAGELATCH_%' then N'Buffer Latch'
			when @wait_type like N'PAGEIOLATCH_%' then N'Buffer IO'
			when @wait_type like N'RESOURCE_SEMAPHORE_%' then N'Compilation'
			when @wait_type = N'SOS_SCHEDULER_YIELD' then N'Scheduler Yield'
			when @wait_type in (N'LOGMGR', N'LOGBUFFER', N'LOGMGR_RESERVE_APPEND', N'LOGMGR_FLUSH', N'WRITELOG') then N'Logging'
			when @wait_type in (N'ASYNC_NETWORK_IO', N'NET_WAITFOR_PACKET') then N'Network IO'
			when @wait_type in (N'CXPACKET', N'EXCHANGE') then N'Parallelism'
			when @wait_type in (N'RESOURCE_SEMAPHORE', N'CMEMTHREAD', N'SOS_RESERVEDMEMBLOCKLIST') then N'Memory'
			when @wait_type like N'CLR_%' or @wait_type like N'SQLCLR%' then N'CLR'
			when @wait_type like N'DBMIRROR%' or @wait_type = N'MIRROR_SEND_MESSAGE' then N'Mirroring'
			when @wait_type like N'XACT%' or @wait_type like N'DTC_%' or @wait_type like N'TRAN_MARKLATCH_%' or @wait_type like N'MSQL_XACT_%' or @wait_type = N'TRANSACTION_MUTEX' then N'Transaction'
			when @wait_type like N'SLEEP_%' or @wait_type in(N'LAZYWRITER_SLEEP', N'SQLTRACE_BUFFER_FLUSH', N'WAITFOR', N'WAIT_FOR_RESULTS') then N'Sleep'
			else N'Other'
		end

	return @category
end
go
GRANT EXECUTE ON MS_PerfDashboard.fn_WaitTypeCategory TO public
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_QueryTextFromHandle'), 'IsTableFunction') = 1
	drop function MS_PerfDashboard.fn_QueryTextFromHandle
go

CREATE function MS_PerfDashboard.fn_QueryTextFromHandle(@handle varbinary(64), @statement_start_offset int, @statement_end_offset int)
RETURNS @query_text TABLE (database_id smallint, object_id int, encrypted bit, query_text nvarchar(max))
begin
	if @handle is not null
	begin
		declare @start int, @end int
		declare @dbid smallint, @objectid int, @encrypted bit
		declare @batch nvarchar(max), @query nvarchar(max)

		-- statement_end_offset is zero prior to beginning query execution (e.g., compilation)
		select 
			@start = isnull(@statement_start_offset, 0), 
			@end = case when @statement_end_offset is null or @statement_end_offset = 0 then -1
						else @statement_end_offset 
					end

		select @dbid = t.dbid, 
			@objectid = t.objectid, 
			@encrypted = t.encrypted, 
			@batch = t.text 
		from sys.dm_exec_sql_text(@handle) as t

		select @query = case 
				when @encrypted = cast(1 as bit) then N'encrypted text' 
				else ltrim(substring(@batch, @start / 2 + 1, ((case when @end = -1 then datalength(@batch) 
							else @end end) - @start) / 2))
			end

		-- Found internal queries (e.g., CREATE INDEX) with end offset of original batch that is 
		-- greater than the length of the internal query and thus returns nothing if we don't do this
		if datalength(@query) = 0
		begin
			select @query = @batch
		end

		insert into @query_text (database_id, object_id, encrypted, query_text) 
		values (@dbid, @objectid, @encrypted, @query)
	end

	return
end
go
GRANT SELECT ON MS_PerfDashboard.fn_QueryTextFromHandle TO public
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_hexstrtovarbin'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_hexstrtovarbin
go

create function MS_PerfDashboard.fn_hexstrtovarbin(@input varchar(8000)) 
returns varbinary(8000) 
as 
begin 
	declare @result varbinary(8000)

	if @input is not null
	begin
		declare @i int, @l int 

		select @result = 0x, @l = len(@input) / 2, @i = 2 
	
		while @i <= @l 
		begin 
			set @result = @result + 
			cast(cast(case lower(substring(@input, @i*2-1, 1)) 
				when '0' then 0x00 
				when '1' then 0x10 
				when '2' then 0x20 
				when '3' then 0x30 
				when '4' then 0x40 
				when '5' then 0x50 
				when '6' then 0x60 
				when '7' then 0x70 
				when '8' then 0x80 
				when '9' then 0x90 
				when 'a' then 0xa0 
				when 'b' then 0xb0 
				when 'c' then 0xc0 
				when 'd' then 0xd0 
				when 'e' then 0xe0 
				when 'f' then 0xf0 
				end as tinyint) | 
			cast(case lower(substring(@input, @i*2, 1)) 
				when '0' then 0x00 
				when '1' then 0x01 
				when '2' then 0x02 
				when '3' then 0x03 
				when '4' then 0x04 
				when '5' then 0x05 
				when '6' then 0x06 
				when '7' then 0x07 
				when '8' then 0x08 
				when '9' then 0x09 
				when 'a' then 0x0a 
				when 'b' then 0x0b 
				when 'c' then 0x0c 
				when 'd' then 0x0d 
				when 'e' then 0x0e 
				when 'f' then 0x0f 
				end as tinyint) as binary(1)) 
		set @i = @i + 1 
		end 
	end

	return @result 
end 
go
GRANT EXECUTE ON MS_PerfDashboard.fn_hexstrtovarbin TO public
go


if object_id('MS_PerfDashboard.usp_CheckDependencies', 'P') is not null
	drop procedure MS_PerfDashboard.usp_CheckDependencies
go

create procedure MS_PerfDashboard.usp_CheckDependencies
as
begin
	declare @Version nvarchar(100)
	declare @MajorVer tinyint, @MinorVer tinyint, @BuildNum smallint
	declare @dec1 int, @dec2 int, @dec3 int

	select @Version = convert(nvarchar(100), serverproperty('ProductVersion'))
	select @dec1 = charindex('.', @Version)
	select @dec2 = charindex('.', @Version, @dec1 + 1)
	select @dec3 = case when charindex('.', @Version, @dec2 + 1) = 0 then len(@Version) + 1 else charindex('.', @Version, @dec2 + 1) end

	select @MajorVer = convert(tinyint, substring(@Version, 1, @dec1 - 1)), 
		@MinorVer = convert(tinyint, substring(@Version, @dec1 + 1, @dec2 - @dec1 - 1)),
		@BuildNum = convert(smallint, substring(@Version, @dec2 + 1, @dec3 - @dec2 - 1))
	
	select @MajorVer as major_version, 
		@MinorVer as minor_version, 
		@BuildNum as build_number,
		convert(nvarchar(128), SERVERPROPERTY('MachineName')) + 
			CASE WHEN convert(nvarchar(128), SERVERPROPERTY('InstanceName')) IS NOT NULL THEN N'\' + convert(nvarchar(128), SERVERPROPERTY('InstanceName'))
			ELSE N''
			END as ServerInstance,
		@Version as ProductVersion,
		serverproperty('ProductLevel') as ProductLevel,
		serverproperty('Edition') as Edition

	if not (@MajorVer > 9 or (@MajorVer = 9 and @MinorVer > 0) or (@MajorVer = 9 and @MinorVer = 0 and @BuildNum >= 3026))
	begin
		RAISERROR('The target server being monitored via the Performance Dashboard must be running SQL Server 2005 Service Pack 2 (build 9.00.3026) or later.  This server is running version %s', 18, 1, @Version)
	end
end
go
grant execute on MS_PerfDashboard.usp_CheckDependencies to public
go


if object_id('MS_PerfDashboard.usp_Main_GetCPUHistory', 'P') is not null
	drop procedure MS_PerfDashboard.usp_Main_GetCPUHistory
go

create procedure MS_PerfDashboard.usp_Main_GetCPUHistory
as
begin
	declare @ts_now bigint
	select @ts_now = cpu_ticks / convert(float, ms_ticks) from sys.dm_os_sys_info
	
	select top 15 record_id,
		dateadd(ms, -1 * (@ts_now - [timestamp]), GetDate()) as EventTime, 
		SQLProcessUtilization,
		SystemIdle,
		100 - SystemIdle - SQLProcessUtilization as OtherProcessUtilization
	from (
		select 
			record.value('(./Record/@id)[1]', 'int') as record_id,
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') as SystemIdle,
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') as SQLProcessUtilization,
			timestamp
		from (
			select timestamp, convert(xml, record) as record 
			from sys.dm_os_ring_buffers 
			where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
			and record like '%<SystemHealth>%') as x
		) as y 
	order by record_id desc
end
go
grant execute on MS_PerfDashboard.usp_Main_GetCPUHistory to public
go


if object_id('MS_PerfDashboard.usp_Main_GetMiscInfo', 'P') is not null
	drop procedure MS_PerfDashboard.usp_Main_GetMiscInfo
go

create procedure MS_PerfDashboard.usp_Main_GetMiscInfo
as
begin
	select 
		(select count(*) from sys.traces) as running_traces,
		(select count(*) from sys.databases) as number_of_databases,
		(select count(*) from sys.dm_db_missing_index_group_stats) as missing_index_count,
		(select waiting_tasks_count from sys.dm_os_wait_stats where wait_type = N'SQLCLR_QUANTUM_PUNISHMENT') as clr_quantum_waits,
		(select count(*) from sys.dm_os_ring_buffers where ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' and record like N'%<NonYieldSchedBegin>%') as non_yield_count,
		(select cpu_count from sys.dm_os_sys_info) as number_of_cpus,
		(select scheduler_count from sys.dm_os_sys_info) as number_of_schedulers
	end
go
grant execute on MS_PerfDashboard.usp_Main_GetMiscInfo to public
go


if object_id('MS_PerfDashboard.usp_Main_GetSessionInfo', 'P') is not null
	drop procedure MS_PerfDashboard.usp_Main_GetSessionInfo
go

create procedure MS_PerfDashboard.usp_Main_GetSessionInfo
as
begin
	select count(*) as num_sessions,
		sum(convert(bigint, s.total_elapsed_time)) as total_elapsed_time,
		sum(convert(bigint, s.cpu_time)) as cpu_time, 
		sum(convert(bigint, s.total_elapsed_time)) - sum(convert(bigint, s.cpu_time)) as wait_time,
		sum(convert(bigint, CAST ( DATEDIFF ( minute, login_time, getdate()) AS BIGINT)*60000 + DATEDIFF ( millisecond, DATEADD ( minute, DATEDIFF ( minute, login_time, getdate() ), login_time ),getdate() ))) - sum(convert(bigint, s.total_elapsed_time)) as idle_connection_time,
		case when sum(s.logical_reads) > 0 then (sum(s.logical_reads) - isnull(sum(s.reads), 0)) / convert(float, sum(s.logical_reads))
			else NULL
			end as cache_hit_ratio
	from sys.dm_exec_sessions s
	where s.is_user_process = 0x1
end
go
grant execute on MS_PerfDashboard.usp_Main_GetSessionInfo to public
go



if object_id('MS_PerfDashboard.usp_Main_GetRequestInfo', 'P') is not null
	drop procedure MS_PerfDashboard.usp_Main_GetRequestInfo
go

create procedure MS_PerfDashboard.usp_Main_GetRequestInfo
as
begin
	select count(r.request_id) as num_requests,
		sum(convert(bigint, r.total_elapsed_time)) as total_elapsed_time,
		sum(convert(bigint, r.cpu_time)) as cpu_time,
		sum(convert(bigint, r.total_elapsed_time)) - sum(convert(bigint, r.cpu_time)) as wait_time,
		case when sum(r.logical_reads) > 0 then (sum(r.logical_reads) - isnull(sum(r.reads), 0)) / convert(float, sum(r.logical_reads))
			else NULL
			end as cache_hit_ratio
	from sys.dm_exec_requests r
		join sys.dm_exec_sessions s on r.session_id = s.session_id
	where s.is_user_process = 0x1
end
go
grant execute on MS_PerfDashboard.usp_Main_GetRequestInfo to public
go


if object_id('MS_PerfDashboard.usp_Main_GetRequestWaits', 'P') is not null
	drop procedure MS_PerfDashboard.usp_Main_GetRequestWaits
go

create procedure MS_PerfDashboard.usp_Main_GetRequestWaits
as
begin
	SELECT 
		r.session_id, 
		MS_PerfDashboard.fn_WaitTypeCategory(r.wait_type) AS wait_category, 
		r.wait_type, 
		r.wait_time
	FROM sys.dm_exec_requests AS r 
		INNER JOIN sys.dm_exec_sessions AS s ON r.session_id = s.session_id
	WHERE r.wait_type IS NOT NULL  
		AND s.is_user_process = 0x1
end
go
GRANT EXECUTE ON MS_PerfDashboard.usp_Main_GetRequestWaits TO public
go



if object_id('MS_PerfDashboard.usp_GetPageDetails', 'P') is not null
	drop procedure MS_PerfDashboard.usp_GetPageDetails
go

create procedure MS_PerfDashboard.usp_GetPageDetails @wait_resource varchar(100)
as
begin
	declare @database_id smallint, @file_id smallint, @page_no int
	declare @t TABLE (ParentObject varchar(256), Object varchar(256), Field varchar(256), VALUE sql_variant)

	declare @colon1 int, @colon2 int
	select @colon1 = charindex(':', @wait_resource)
	select @colon2 = charindex(':', @wait_resource, @colon1 + 1)
	select @database_id = substring(@wait_resource, 1, @colon1 - 1)
	select @file_id = substring(@wait_resource, @colon1 + 1, @colon2 - @colon1 - 1)
	select @page_no = substring(@wait_resource, @colon2 + 1, 100)
	
	BEGIN TRY
		insert into @t exec sp_executesql N'dbcc page(@database_id, @file_id, @page_no) with tableresults', N'@database_id smallint, @file_id smallint, @page_no int', @database_id, @file_id, @page_no
	END TRY
	BEGIN CATCH
		--do nothing
	END CATCH
	
	select @database_id as database_id, 
		quotename(db_name(@database_id)) as database_name,
		@file_id as file_id,
		@page_no as page_no,
		convert(int, [Metadata: ObjectId]) as [object_id], 
		quotename(object_schema_name(convert(int, [Metadata: ObjectId]), @database_id)) + N'.' + quotename(object_name(convert(int, [Metadata: ObjectId]), @database_id)) as [object_name],
		convert(smallint, [Metadata: IndexId]) as [index_id],
		convert(int, [m_level]) as page_level,
		case convert(int, [m_type])
			when 1 then N'Data Page'
			when 2 then N'Index Page'
			when 3 then N'Text Mix Page'
			when 4 then N'Text Tree Page'
			when 8 then N'GAM Page'
			when 9 then N'SGAM Page'
			when 10 then N'IAM Page'
			when 11 then N'PFS Page'
			else convert(nvarchar(10), [m_type])	-- other types intentionally omitted
		end as page_type
	from (select * from @t where ParentObject = 'PAGE HEADER:' and 
			Field IN ('Metadata: ObjectId', 'Metadata: IndexId', 'm_objId (AllocUnitId.idObj)', 'm_level', 'm_type')) as x
		pivot (min([VALUE]) for Field in ([Metadata: ObjectId], [Metadata: IndexId], [m_level], [m_type])) as z
end
go
GRANT EXECUTE ON MS_PerfDashboard.usp_GetPageDetails TO public
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.usp_GetPlanGuideDetails'), 'IsProcedure') = 1
	drop procedure MS_PerfDashboard.usp_GetPlanGuideDetails
go

create procedure MS_PerfDashboard.usp_GetPlanGuideDetails @database_name nvarchar(128), @plan_guide_name nvarchar(128)
as
begin
	if (LEFT(@database_name, 1) = N'[' and RIGHT(@database_name, 1) = N']')
	begin
		select @database_name = substring(@database_name, 2, len(@database_name) - 2)
	end

	if (LEFT(@plan_guide_name, 1) = N'[' and RIGHT(@plan_guide_name, 1) = N']')
	begin
		select @plan_guide_name = substring(@plan_guide_name, 2, len(@plan_guide_name) - 2)
	end

	if db_id(@database_name) is not null
	begin
		declare @cmd nvarchar(4000)
		select @cmd = N'select * from [' + @database_name + N'].[sys].[plan_guides] where name = @P1'

		exec sp_executesql @cmd, N'@P1 nvarchar(128)', @plan_guide_name
	end
	else
	begin
		-- return empty result set
		select * from [sys].[plan_guides] where 0 = 1
	end
end
go

grant execute on MS_PerfDashboard.usp_GetPlanGuideDetails to public
go




if OBJECTPROPERTY(object_id('MS_PerfDashboard.usp_TransformShowplanXMLToTable'), 'IsProcedure') = 1
	drop procedure MS_PerfDashboard.usp_TransformShowplanXMLToTable
go

CREATE PROCEDURE MS_PerfDashboard.usp_TransformShowplanXMLToTable @plan_handle nvarchar(256), @stmt_start_offset int, @stmt_end_offset int, @fDebug bit = 0x0
AS
BEGIN
	SET NOCOUNT ON

	declare @plan nvarchar(max)
	declare @dbid int, @objid int
	declare @xml_plan xml
	declare @error int

	declare @output TABLE (
		node_id int, 
		parent_node_id int, 
		relevant_xml_text nvarchar(max), 
		stmt_text nvarchar(max), 
		logical_op nvarchar(128), 
		physical_op nvarchar(128), 
		output_list nvarchar(max), 
		avg_row_size float, 
		est_cpu float, 
		est_io float, 
		est_rows float, 
		est_rewinds float, 
		est_rebinds float, 
		est_subtree_cost float,
		warnings nvarchar(max))

	BEGIN TRY
		-- handle may be invalid now, or XML may be too deep to convert
		select @dbid = p.dbid, @objid = p.objectid, @plan = p.query_plan from sys.dm_exec_text_query_plan(msdb.MS_PerfDashboard.fn_hexstrtovarbin(@plan_handle), @stmt_start_offset, @stmt_end_offset) as p
		select @xml_plan = convert(xml, @plan)

		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		insert into @output 
		select nd.node_id,
			x.parent_node_id,
			case when @fDebug = 0x1 then 
							case 
								when x.parent_node_id is null then @plan 
								else convert(nvarchar(max), x.plan_node) 
							end
					else NULL
					end as relevant_xml_text,
			nd.stmt_text, 
			nd.logical_op, 
			nd.physical_op, 
			nd.output_list, 
			nd.avg_row_size, 
			nd.est_cpu, 
			nd.est_io, 
			nd.est_rows, 
			nd.est_rewinds, 
			nd.est_rebinds, 
			nd.est_subtree_cost,
			nd.warnings
		from (select 
				splan.row.query('.') as plan_node,
				splan.row.value('../../@NodeId', 'int') as parent_node_id
			from (select @xml_plan as query_plan) as p
				cross apply p.query_plan.nodes('//sp:RelOp') as splan (row)) as x
				cross apply MS_PerfDashboard.fn_ShowplanRowDetails(plan_node) as nd
		order by isnull(parent_node_id, -1) asc

		-- Statements such as WAITFOR, etc may not have a RelOp so just show the statement type if available
		if @@rowcount = 0
		begin
			;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
			insert into @output (stmt_text) select isnull(@xml_plan.value('(//@StatementType)[1]', 'nvarchar(max)'), N'Unknown Statement')
		end
	END TRY
	BEGIN CATCH
		select @error = ERROR_NUMBER()
-- 		select 
-- 			cast(NULL as int) as node_id, 
-- 			cast(NULL as int) as parent_node_id,
-- 			cast(NULL as nvarchar(max)) as relevant_xml_text,
-- 			cast(NULL as nvarchar(max)) as stmt_text,
-- 			cast(NULL as nvarchar(128)) as logical_op,
-- 			cast(NULL as nvarchar(128)) as physical_op,
-- 			cast(NULL as nvarchar(max)) as output_list,
-- 			cast(NULL as float) as avg_row_size,
-- 			cast(NULL as float) as est_cpu,
-- 			cast(NULL as float) as est_io,
-- 			cast(NULL as float) as est_rows,
-- 			cast(NULL as float) as est_rewinds,
-- 			cast(NULL as float) as est_rebinds,
-- 			cast(NULL as float) as est_subtree_cost,
-- 			cast(NULL as nvarchar(max)) as warnings
-- 		where 0 = 1
	END CATCH

	-- This may be an empty set if there was an exception caught above
	SELECT
		node_id,
		parent_node_id, 
		relevant_xml_text, 
		stmt_text, 
		logical_op, 
		physical_op, 
		output_list, 
		avg_row_size, 
		est_cpu, 
		est_io, 
		est_rows, 
		est_rewinds, 
		est_rebinds, 
		est_subtree_cost,
		warnings
	FROM @output
END
go

grant execute on MS_PerfDashboard.usp_TransformShowplanXMLToTable to public
go




/* 
 *
 *	Helper procedures for building showplan output.  These are called, indirectly, by MS_PerfDashboard.usp_TransformShowplanXMLToTable and because
 *	they belong to the same schema we do not need to grant EXECUTE permissions to users.  They are not intended to be called directly as they require
 *	proper context within the showplan XML in order to return meaningful output.
 *
 *
 */
if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildColumnReference'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildColumnReference
go

create function MS_PerfDashboard.fn_ShowplanBuildColumnReference(@node_data xml, @include_alias_or_table bit)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)
	declare @table nvarchar(256), @alias nvarchar(256), @column nvarchar(256)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @alias = @node_data.value('(./sp:ColumnReference/@Alias)[1]', 'nvarchar(256)'),
		@table = @node_data.value('(./sp:ColumnReference/@Table)[1]', 'nvarchar(256)'),
		@column = @node_data.value('(./sp:ColumnReference/@Column)[1]', 'nvarchar(256)')

	select @column = case when left(@column, 1) = N'[' and right(@column, 1) = N']' then @column else quotename(@column) end

	if @include_alias_or_table = 0x1 and coalesce(@alias, @table) is not null
	begin
		select @alias = case when left(@alias, 1) = N'[' and right(@alias, 1) = N']' then @alias else quotename(@alias) end
		select @table = case when left(@table, 1) = N'[' and right(@table, 1) = N']' then @table else quotename(@table) end

		select @output = case 
					when @alias is not null then @alias
					else @table
				end + N'.' + @column
	end
	else
	begin
		select @output = @column
	end

	return @output
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList
go

create function MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList (@node_data xml, @include_alias_or_table bit)
returns nvarchar(max)

as
begin
	declare @output nvarchar(max)

	declare @count int, @ctr int

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'', @ctr = 1, @count = @node_data.value('count(./sp:ColumnReference)', 'int')

	-- iterate over each element in the list
	while @ctr <= @count
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + case when @ctr > 1 then N', ' else N'' end + MS_PerfDashboard.fn_ShowplanBuildColumnReference(@node_data.query('./sp:ColumnReference[position() = sql:variable("@ctr")]'), @include_alias_or_table)

		select @ctr = @ctr + 1
	end

	return @output
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildDefinedValuesList'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildDefinedValuesList
go

create function MS_PerfDashboard.fn_ShowplanBuildDefinedValuesList (@node_data xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = convert(nvarchar(max), @node_data.query('for $val in /sp:DefinedValue
				return concat(($val/sp:ColumnReference/@Column)[1], "=", ($val/sp:ScalarOperator/@ScalarString)[1], ",")'))

	declare @len int
	select @len = len(@output)
	if (@len > 0)
	begin
		select @output = left(@output, @len - 1)
	end

	return @output
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildOrderBy'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildOrderBy
go

create function MS_PerfDashboard.fn_ShowplanBuildOrderBy (@node_data xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = convert(nvarchar(max), @node_data.query('for $col in /sp:OrderByColumn
					return concat(if (($col/sp:ColumnReference/@Alias)[1] > "") then concat(($col/sp:ColumnReference/@Alias)[1], ".") else if (($col/sp:ColumnReference/@Table)[1] > "") then concat(($col/sp:ColumnReference/@Table)[1], ".") else "", string(($col/sp:ColumnReference/@Column)[1]), if ($col/@Ascending = 1) then " ASC" else " DESC", ",")'))
	declare @len int
	select @len = len(@output)
	if (@len > 0)
	begin
		select @output = left(@output, @len - 1)
	end

	return @output
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildRowset'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildRowset
go

create function MS_PerfDashboard.fn_ShowplanBuildRowset (@node_data xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = MS_PerfDashboard.fn_ShowplanBuildObject(@node_data.query('./sp:Object'))

	return @output
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildScalarExpression'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildScalarExpression
go

create function MS_PerfDashboard.fn_ShowplanBuildScalarExpression (@node_data xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)

	select @output = N''

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @node_data.value('(./sp:ScalarOperator/@ScalarString)[1]', 'nvarchar(max)')

	return @output
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildScalarExpressionList'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildScalarExpressionList
go

create function MS_PerfDashboard.fn_ShowplanBuildScalarExpressionList (@node_data xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = convert(nvarchar(max), @node_data.query('for $op in ./sp:ScalarOperator
					return concat(string($op/@ScalarString), ",")'))

	declare @len int
	select @len = len(@output)
	if (@len > 0)
	begin
		select @output = left(@output, @len - 1)
	end

	return @output
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildScanRange'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildScanRange
go

create function MS_PerfDashboard.fn_ShowplanBuildScanRange (@node_data xml, @scan_type nvarchar(30))
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)
	set @output = N''

	declare @count int, @ctr int

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @ctr = 1, @count = @node_data.value('count(./sp:RangeColumns/sp:ColumnReference)', 'int')

	while @ctr <= @count
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + 
				case when @ctr > 1 then N' AND ' else '' end + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:RangeColumns/sp:ColumnReference[position() = sql:variable("@ctr")]'), 0x1)
				+ N' ' + 
			case UPPER(@scan_type) 
				when 'BINARY IS' then N'IS'
				when 'EQ' then N'='
				when 'GE' then N'>='
				when 'GT' then N'>'
				when 'IS' then N'IS'
				when 'IS NOT' then N'IS NOT'
				when 'IS NOT NULL' then N'IS NOT NULL'
				when 'IS NULL' then N'IS NULL'
				when 'LE' then N'<='
				when 'LT' then N'<'
				when 'NE' then N'<>'
			end
			 + N' '
			+ MS_PerfDashboard.fn_ShowplanBuildScalarExpressionList(@node_data.query('./sp:RangeExpressions/sp:ScalarOperator[position() = sql:variable("@ctr")]'))

		select @ctr = @ctr + 1
	end

	return @output
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildSeekPredicates'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildSeekPredicates
go

create function MS_PerfDashboard.fn_ShowplanBuildSeekPredicates (@node_data xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)
	declare @count int, @ctr int

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'', @ctr = 1, @count = @node_data.value('count(./sp:SeekPredicates/sp:SeekPredicate)', 'int')

	-- iterate over each element in the list
	while @ctr <= @count
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + case when @ctr > 1 then N' AND ' else N'' end + MS_PerfDashboard.fn_ShowplanBuildSeekPredicate(@node_data.query('./sp:SeekPredicates/sp:SeekPredicate[position() = sql:variable("@ctr")]/*'))

		select @ctr = @ctr + 1
	end

	return @output
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildSeekPredicate'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildSeekPredicate
go

create function MS_PerfDashboard.fn_ShowplanBuildSeekPredicate (@node_data xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)
	set @output = N''

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Prefix') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + MS_PerfDashboard.fn_ShowplanBuildScanRange(@node_data.query('./sp:Prefix/*'), @node_data.value('(./sp:Prefix/@ScanType)[1]', 'nvarchar(100)'))
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:StartRange') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + case when datalength(@output) > 0 then N' AND ' else '' end + MS_PerfDashboard.fn_ShowplanBuildScanRange(@node_data.query('./sp:StartRange/*'), @node_data.value('(./sp:StartRange/@ScanType)[1]', 'nvarchar(100)'))
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:EndRange') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + case when datalength(@output) > 0 then N' AND ' else '' end + MS_PerfDashboard.fn_ShowplanBuildScanRange(@node_data.query('./sp:EndRange/*'), @node_data.value('(./sp:EndRange/@ScanType)[1]', 'nvarchar(100)'))
	end

	return @output
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildObject'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildObject
go

create function MS_PerfDashboard.fn_ShowplanBuildObject (@node_data xml)
returns nvarchar(max)
as
begin
	declare @object nvarchar(max)
	set @object = N''

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Object/@Server') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @object = @object + @node_data.value('(./sp:Object/@Server)[1]', 'nvarchar(128)') + N'.'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Object/@Database') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @object = @object + @node_data.value('(./sp:Object/@Database)[1]', 'nvarchar(128)') + N'.'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Object/@Schema') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @object = @object + @node_data.value('(./sp:Object/@Schema)[1]', 'nvarchar(128)') + N'.'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Object/@Table') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @object = @object + @node_data.value('(./sp:Object/@Table)[1]', 'nvarchar(128)')
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Object/@Index') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @object = @object + N'.' + @node_data.value('(./sp:Object/@Index)[1]', 'nvarchar(128)')
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Object/@Alias') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @object = @object + N' AS ' + @node_data.value('(./sp:Object/@Alias)[1]', 'nvarchar(128)')
	end

	return @object
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanBuildWarnings'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanBuildWarnings
go

create function MS_PerfDashboard.fn_ShowplanBuildWarnings(@relop_node xml)
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)

	if (@relop_node.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RelOp/sp:Warnings') = 1)
	begin
		if (@relop_node.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RelOp/sp:Warnings[@NoJoinPredicate = 1]') = 1)
		begin
			select @output = N'NO JOIN PREDICATE'
		end
		
		if (@relop_node.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RelOp/sp:Warnings/sp:ColumnsWithNoStatistics') = 1)
		begin
			;with xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as sp)
			select @output = case when @output is null then N'' else @output + N', ' end + N'NO STATS: ' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@relop_node.query('./sp:RelOp/sp:Warnings/sp:ColumnsWithNoStatistics/*'), 0x1)
		end
	end

	return @output
end
go




if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatAssert'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatAssert
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatAssert(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'Assert(' + @node_data.value('(./sp:Assert/sp:Predicate/sp:ScalarOperator/@ScalarString)[1]', 'nvarchar(max)') + N'))'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatBitmap'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatBitmap
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatBitmap(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'Bitmap(Hash Keys:(' + MS_PerfDashboard.fn_BuildColumnReferenceList(@node_data.query('./sp:HashKeys/sp:ColumnReference'), 0x1) + N')'

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatCollapse'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatCollapse
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatCollapse(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'Bitmap(GROUP BY:(' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:GroupBy/sp:ColumnReference'), 0x1) + N')'

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatComputeScalar'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatComputeScalar
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatComputeScalar(@node_data xml, @physical_op nvarchar(128))
returns nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @physical_op + N'(DEFINE: (' + MS_PerfDashboard.fn_ShowplanBuildDefinedValuesList(@node_data.query('./sp:DefinedValues/*')) + N'))';

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatConcat'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatConcat
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatConcat(@node_data xml)
RETURNS nvarchar(max)
as
begin
	return N'Concatenation'
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatIndexScan'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatIndexScan
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatIndexScan(@node_data xml, @physical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)


	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @physical_op + N'(OBJECT: (' + MS_PerfDashboard.fn_ShowplanBuildObject(@node_data.query('./sp:IndexScan/sp:Object')) + N')'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:IndexScan/sp:SeekPredicates/sp:SeekPredicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', SEEK: (' + MS_PerfDashboard.fn_ShowplanBuildSeekPredicates(@node_data.query('./sp:IndexScan/sp:SeekPredicates')) + N')'
	end


	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:IndexScan/sp:Predicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', WHERE: (' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:IndexScan/sp:Predicate/*')) + N')'
	end

	select @output = @output + N')'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:IndexScan[@Lookup = 1]') = 1)
	begin
		select @output = @output + N' LOOKUP'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:IndexScan[@Ordered = 1]') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N' ORDERED ' + @node_data.value('(./sp:IndexScan/@ScanDirection)[1]', 'nvarchar(128)')
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:IndexScan[@ForcedIndex = 1]') = 1)
	begin
		select @output = @output + N' FORCEDINDEX'
	end

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatConstantScan'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatConstantScan
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatConstantScan(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Constant Scan'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:ConstantScan/sp:Values') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'(VALUES: (' + MS_PerfDashboard.fn_ShowplanBuildScalarExpressionList(@node_data.query('./sp:ConstantScan/sp:Values/sp:Row/*')) + N'))'
	end

	return @output
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatDeletedInsertedScan'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatDeletedInsertedScan
go

-- Passed the Rowset element of XML showplan and extracts the Object details
CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatDeletedInsertedScan(@node_data xml, @physical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @physical_op + N'(' + MS_PerfDashboard.fn_ShowplanBuildRowset(@node_data) + N')'

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatFilter'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatFilter
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatFilter(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	declare @fStartup tinyint

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @fStartup = case when (@node_data.exist('./sp:Filter[@StartupExpression = 1]') = 1) then 1 else 0 end

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'Filter(WHERE: (' + 
		case when @fStartup = 1 then N'STARTUP EXPRESSION(' else N'' end + 
		MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:Filter/sp:Predicate/*')) +
		case when @fStartup = 1 then N')' else N'' end + 
		N'))'

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatHashMatch'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatHashMatch
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatHashMatch(@node_data xml, @logical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Hash Match(' + @logical_op

	if (@logical_op = N'Aggregate')
	begin
		if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Hash/sp:HashKeysBuild') = 1)
		begin
			;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
			select @output = @output + N', HASH:(' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:Hash/sp:HashKeysBuild/sp:ColumnReference'), 0x1) + N')'
		end
	
		if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Hash/sp:BuildResidual') = 1)
		begin
			;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
			select @output = @output + N', RESIDUAL:(' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:Hash/sp:BuildResidual/*')) + N')'
		end

		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', DEFINE: (' + MS_PerfDashboard.fn_ShowplanBuildDefinedValuesList(@node_data.query('./sp:Hash/sp:DefinedValues/*')) + N')';
	end
	else
	begin
		if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Hash/sp:HashKeysBuild') = 1)
		begin
			;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
			select @output = @output + N', HASH:(' + 
				MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:Hash/sp:HashKeysBuild/sp:ColumnReference'), 0x1) + 
				N')=(' + 
				MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:Hash/sp:HashKeysProbe/sp:ColumnReference'), 0x1) + N')'
		end
	
		if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Hash/sp:BuildResidual') = 1) or
			(@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Hash/sp:ProbeResidual') = 1)
		begin
			declare @build_residual bit
	
			select @build_residual = 0x0, @output = @output + N', RESIDUAL:('
	
			if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Hash/sp:BuildResidual') = 1)
			begin
				;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
				select @output = @output + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:Hash/sp:BuildResidual/*'))
				select @build_residual = 0x1
			end
	
			if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Hash/sp:ProbeResidual') = 1)
			begin
				;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
				select @output = @output + case when @build_residual = 0x1 then N' AND ' else '' end + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:Hash/sp:ProbeResidual/*'))
			end

			select @output = @output + N')'
		end
	end

	select @output = @output + N')'

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatMerge'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatMerge
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatMerge(@node_data xml, @logical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'Merge Join(' + @logical_op + case when @node_data.exist('./sp:Merge[@ManyToMany = 1]') = 1 then N', MANY-TO-MANY'
			else N'' end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Merge/sp:InnerSideJoinColumns') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', MERGE: (' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:Merge/sp:InnerSideJoinColumns/sp:ColumnReference'), 0x1) + N')=(' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:Merge/sp:OuterSideJoinColumns/sp:ColumnReference'), 0x1) + N'))'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Merge/sp:Residual') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', RESIDUAL: (' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:Merge/sp:Residual/*')) + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Merge/sp:PassThru') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', PASSTHRU: (' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:Merge/sp:PassThru/*')) + N')'
	end

	return @output;
end
go




if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatNestedLoops'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatNestedLoops
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatNestedLoops(@node_data xml, @logical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Nested Loops(' + @logical_op

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:NestedLoops/sp:OuterReferences') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', OUTER REFERENCES:' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:NestedLoops/sp:OuterReferences/sp:ColumnReference'), 0x1)
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:NestedLoops/sp:Predicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', WHERE: (' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:NestedLoops/sp:Predicate/*')) + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:NestedLoops/sp:PassThru') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', PASSTHRU:(' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:NestedLoops/sp:PassThru/*')) + N')'
	end

	select @output = @output + N')'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:NestedLoops[@Optimized = 1]') = 1)
	begin
		select @output = @output + N' OPTIMIZED'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:NestedLoops[@WithOrderedPrefetch = 1]') = 1)
	begin
		select @output = @output + N' WITH ORDERED PREFETCH'
	end
	else if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:NestedLoops[@WithUnorderedPrefetch = 1]') = 1)
	begin
		select @output = @output + N' WITH UNORDERED PREFETCH'
	end

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatParallelism'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatParallelism
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatParallelism(@node_data xml, @logical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	select @output = N'Parallelism(' + @logical_op + N')'
	--TODO: Extend to show partitioning information, order by information	

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatSimpleUpdate'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatSimpleUpdate
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatSimpleUpdate(@node_data xml, @physical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @physical_op + N'(' + MS_PerfDashboard.fn_ShowplanBuildObject(@node_data.query('./sp:Object'))

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:SetPredicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', SET: ' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:SetPredicate/*'))
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:SeekPredicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', WHERE: (' + MS_PerfDashboard.fn_ShowplanBuildSeekPredicate(@node_data.query('./sp:SeekPredicate/*')) + N')'
	end

	select @output = @output + N')'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatRemoteQuery'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatRemoteQuery
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatRemoteQuery(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Remote Scan('

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteQuery/@RemoteSource') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'SOURCE: (' + @node_data.value('(./sp:RemoteQuery/@RemoteSource)[1]', 'nvarchar(256)') + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteQuery/@RemoteObject') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'OBJECT: (' + @node_data.value('(./sp:RemoteQuery/@RemoteObject)[1]', 'nvarchar(256)') + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteQuery/@RemoteQuery') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', QUERY: (' + @node_data.value('(./sp:RemoteQuery/@RemoteQuery)[1]', 'nvarchar(max)') + N')'
	end

	select @output = @output + N')'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatRemoteScan'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatRemoteScan
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatRemoteScan(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Remote Scan('

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteScan/@RemoteSource') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'SOURCE: (' + @node_data.value('(./sp:RemoteScan/@RemoteSource)[1]', 'nvarchar(256)') + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteScan/@RemoteObject') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'OBJECT: (' + @node_data.value('(./sp:RemoteScan/@RemoteObject)[1]', 'nvarchar(256)') + N')'
	end

	select @output = @output + N')'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatRemoteModify'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatRemoteModify
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatRemoteModify(@node_data xml, @logical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = @logical_op + N'('

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteModify/@RemoteSource') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'SOURCE: (' + @node_data.value('(./sp:RemoteModify/@RemoteSource)[1]', 'nvarchar(256)') + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteModify/@RemoteObject') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'OBJECT: (' + @node_data.value('(./sp:RemoteModify/@RemoteObject)[1]', 'nvarchar(256)') + N')'
	end


	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:RemoteModify/sp:SetPredicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'WHERE: (' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:RemoteModify/sp:SetPredicate/*')) + N')'
	end

	select @output = @output + N')'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatSort'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatSort
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatSort(@node_data xml, @logical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Sort('

	if @logical_op = N'Sort'
	begin
		if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Sort[@Distinct = 1]') = 1)
		begin
			select @output = @output + N'DISTINCT '
		end

		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'ORDER BY: (' + MS_PerfDashboard.fn_ShowplanBuildOrderBy(@node_data.query('./sp:Sort/sp:OrderBy/sp:OrderByColumn')) + N')'
	end
	else if @logical_op = N'TopN Sort'
	begin
		select @output = @output + N'TOP ' + @node_data.value('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; (./sp:TopSort/@Rows)[1]', 'nvarchar(50)') + N', '

		if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:TopSort[@Distinct = 1]') = 1)
		begin
			select @output = @output + N'DISTINCT '
		end

		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'ORDER BY: (' + MS_PerfDashboard.fn_ShowplanBuildOrderBy(@node_data.query('./sp:TopSort/sp:OrderBy/sp:OrderByColumn')) + N')'
	end

	select @output = @output + N')'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatSplit'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatSplit
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatSplit(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Split'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Split/sp:ActionColumn') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'(' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:Split/sp:ActionColumn/sp:ColumnReference'), 0x1) + N')'
	end

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatStreamAggregate'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatStreamAggregate
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatStreamAggregate(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	declare @need_comma bit

	select @output = N'Stream Aggregate('

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:StreamAggregate/sp:GroupBy') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'GROUP BY: (' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:StreamAggregate/sp:GroupBy/sp:ColumnReference'), 0x1) + N')'
		select @need_comma = 0x1
	end

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @output + 
			case when @need_comma = 0x1 then N', ' else N'' end 
		+ N'DEFINE: (' + MS_PerfDashboard.fn_ShowplanBuildDefinedValuesList(@node_data.query('./sp:StreamAggregate/sp:DefinedValues/sp:DefinedValue')) + N')'

	select @output = @output + N')'

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatSegment'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatSegment
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatSegment(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Segment'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Segment/sp:GroupBy/sp:ColumnReference') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'(GROUP BY: ' + MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@node_data.query('./sp:Segment/sp:GroupBy/sp:ColumnReference'), 0x1) + N')'
	end

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatSpool'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatSpool
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatSpool(@node_data xml, @physical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = @physical_op

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Spool/sp:SeekPredicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'(' + MS_PerfDashboard.fn_ShowplanBuildSeekPredicate(@node_data.query('./sp:Spool/sp:SeekPredicate/*')) + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Spool[@Stack = 1]') = 1)
	begin
		select @output = @output + N' WITH STACK'
	end

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatTableScan'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatTableScan
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatTableScan(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Table Scan('

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @output + MS_PerfDashboard.fn_ShowplanBuildObject(@node_data.query('./sp:TableScan/sp:Object'))

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:TableScan/sp:Predicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', WHERE: (' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:TableScan/sp:Predicate/*')) + N')'
	end
	
	select @output = @output + N')'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:TableScan[@Ordered = 1]') = 1)
	begin
		select @output = @output + N' ORDERED'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:TableScan[@ForcedIndex = 1]') = 1)
	begin
		select @output = @output + N' FORCEDINDEX'
	end


	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatTop'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatTop
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatTop(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Top'

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Top/sp:TopExpression') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'(TOP EXPRESSION: ' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:Top/sp:TopExpression/*')) + N')'
	end

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatTVF'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatTVF
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatTVF(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)
	select @output = N'Table-valued Function('

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:TableValuedFunction/sp:Object') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'OBJECT: (' + MS_PerfDashboard.fn_ShowplanBuildObject(@node_data.query('./sp:TableValuedFunction/sp:Object')) + N')'
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:TableValuedFunction/sp:Predicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N', WHERE: ( ' + MS_PerfDashboard.fn_ShowplanBuildPredicate(@node_data.query('./sp:TableValuedFunction/sp:Predicate')) + N')'
	end

	select @output = @output + N')'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatUDX'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatUDX
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatUDX(@node_data xml)
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = N'UDX(' + @node_data.value('(./sp:Extension/@UDXName)[1]', 'nvarchar(128)') + N')'

	return @output;
end
go


if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatUpdate'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatUpdate
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatUpdate(@node_data xml, @physical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @output = @physical_op + N'(' + MS_PerfDashboard.fn_ShowplanBuildObject(@node_data.query('./sp:Object/*'))

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:SetPredicate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = @output + N'SET: ' + MS_PerfDashboard.fn_ShowplanBuildScalarExpression(@node_data.query('./sp:SetPredicate/*'))
	end

	select @output = @output + N')'

	return @output;
end
go



if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanFormatGenericUpdate'), 'IsScalarFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanFormatGenericUpdate
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanFormatGenericUpdate(@node_data xml, @physical_op nvarchar(128))
RETURNS nvarchar(max)
as
begin
	declare @output nvarchar(max)

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:SimpleUpdate') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = MS_PerfDashboard.fn_ShowplanFormatSimpleUpdate(@node_data.query('./sp:SimpleUpdate/*'), @physical_op)
	end

	if (@node_data.exist('declare namespace sp="http://schemas.microsoft.com/sqlserver/2004/07/showplan"; ./sp:Update') = 1)
	begin
		;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
		select @output = MS_PerfDashboard.fn_ShowplanFormatUpdate(@node_data.query('./sp:Update/*'), @physical_op)
	end

	return @output;
end
go


--
-- Created last since it depends on all the above functions for building/formatting the showplan
--
if OBJECTPROPERTY(object_id('MS_PerfDashboard.fn_ShowplanRowDetails'), 'IsTableFunction') = 1
	drop function MS_PerfDashboard.fn_ShowplanRowDetails
go

CREATE FUNCTION MS_PerfDashboard.fn_ShowplanRowDetails(@relop_node xml)
returns @node TABLE (node_id int, stmt_text nvarchar(max), logical_op nvarchar(128), physical_op nvarchar(128), output_list nvarchar(max), avg_row_size float, est_cpu float, est_io float, est_rows float, est_rewinds float, est_rebinds float, est_subtree_cost float, warnings nvarchar(max))
AS
begin
	declare @node_id int
	declare @output_list nvarchar(max)
	declare @stmt_text nvarchar(max)
	declare @logical_op nvarchar(128), @physical_op nvarchar(128)
	declare @avg_row_size float, @est_cpu float, @est_io float, @est_rows float, @est_rewinds float, @est_rebinds float, @est_subtree_cost float
	declare @relop_children xml

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @logical_op = @relop_node.value('(./sp:RelOp/@LogicalOp)[1]', 'nvarchar(128)'),
		@physical_op = @relop_node.value('(./sp:RelOp/@PhysicalOp)[1]', 'nvarchar(128)'),
		@relop_children = @relop_node.query('./sp:RelOp/*')

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	select @stmt_text =
		case 
			when @physical_op = N'Assert' then MS_PerfDashboard.fn_ShowplanFormatAssert(@relop_children)
			when @physical_op = N'Bitmap' then MS_PerfDashboard.fn_ShowplanFormatBitmap(@relop_children)
			when @physical_op in (N'Clustered Index Delete', N'Clustered Index Insert', N'Clustered Index Update', 
						N'Index Delete', N'Index Insert', N'Index Update', 
						N'Table Delete', N'Table Insert', N'Table Update') then MS_PerfDashboard.fn_ShowplanFormatGenericUpdate(@relop_children, @physical_op)
			when @physical_op in (N'Clustered Index Scan', N'Clustered Index Seek', 
						N'Index Scan', N'Index Seek') then MS_PerfDashboard.fn_ShowplanFormatIndexScan(@relop_children, @physical_op)
--			when @physical_op = N'Clustered Update' then 
			when @physical_op = N'Compute Scalar' then MS_PerfDashboard.fn_ShowplanFormatComputeScalar(@relop_children.query('./sp:ComputeScalar/*'), @physical_op)
			when @physical_op = N'Concatenation' then MS_PerfDashboard.fn_ShowplanFormatConcat(@relop_children)
			when @physical_op = N'Constant Scan' then MS_PerfDashboard.fn_ShowplanFormatConstantScan(@relop_children)
			when @physical_op = N'Deleted Scan' then MS_PerfDashboard.fn_ShowplanFormatDeletedInsertedScan(@relop_children.query('./sp:DeletedScan/*'), @physical_op)
			when @physical_op = N'Filter' then MS_PerfDashboard.fn_ShowplanFormatFilter(@relop_children)
--			when @physical_op = N'Generic' then 
			when @physical_op = N'Hash Match' then MS_PerfDashboard.fn_ShowplanFormatHashMatch(@relop_children, @logical_op)
			when @physical_op = N'Index Spool' then MS_PerfDashboard.fn_ShowplanFormatSpool(@relop_children, @physical_op)
			when @physical_op = N'Inserted Scan' then MS_PerfDashboard.fn_ShowplanFormatDeletedInsertedScan(@relop_children.query('./sp:InsertedScan/*'), @physical_op)
			when @physical_op = N'Log Row Scan' then N'Log Row Scan'
			when @physical_op = N'Merge Interval' then N'Merge Interval'
			when @physical_op = N'Merge Join' then MS_PerfDashboard.fn_ShowplanFormatMerge(@relop_children, @logical_op)
			when @physical_op = N'Nested Loops' then MS_PerfDashboard.fn_ShowplanFormatNestedLoops(@relop_children, @logical_op)
			when @physical_op = N'Online Index Insert' then N'Online Index Insert'
			when @physical_op = N'Parallelism' then MS_PerfDashboard.fn_ShowplanFormatParallelism(@relop_children, @logical_op)
			when @physical_op = N'Parameter Table Scan' then N'Parameter Table Scan'
			when @physical_op = N'Print' then N'Print'
			when @physical_op in (N'Remote Delete', N'Remote Insert', N'Remote Update') then MS_PerfDashboard.fn_ShowplanFormatRemoteModify(@relop_children, @logical_op)
			when @physical_op = N'Remote Scan' then MS_PerfDashboard.fn_ShowplanFormatRemoteScan(@relop_children)
			when @physical_op = N'Remote Query' then MS_PerfDashboard.fn_ShowplanFormatRemoteQuery(@relop_children)
			when @physical_op = N'RID Lookup' then N'RID Lookup'
			when @physical_op = N'Row Count Spool' then MS_PerfDashboard.fn_ShowplanFormatSpool(@relop_children, @physical_op)
			when @physical_op = N'Segment' then MS_PerfDashboard.fn_ShowplanFormatSegment(@relop_children)
			when @physical_op = N'Sequence' then N'Sequence'
			when @physical_op = N'Sequence Project' then MS_PerfDashboard.fn_ShowplanFormatComputeScalar(@relop_children.query('./sp:SequenceProject/*'), @physical_op)
			when @physical_op = N'Sort' then MS_PerfDashboard.fn_ShowplanFormatSort(@relop_children, @logical_op)
			when @physical_op = N'Split' then MS_PerfDashboard.fn_ShowplanFormatSplit(@relop_children)
			when @physical_op = N'Stream Aggregate' then MS_PerfDashboard.fn_ShowplanFormatStreamAggregate(@relop_children)
			when @physical_op = N'Switch' then N'Switch'
			when @physical_op = N'Table-valued function' then MS_PerfDashboard.fn_ShowplanFormatTVF(@relop_children)
			when @physical_op = N'Table Scan' then MS_PerfDashboard.fn_ShowplanFormatTableScan(@relop_children)
			when @physical_op = N'Table Spool' then MS_PerfDashboard.fn_ShowplanFormatSpool(@relop_children, @physical_op)
			when @physical_op = N'Top' then MS_PerfDashboard.fn_ShowplanFormatTop(@relop_children)
			when @physical_op = N'UDX' then MS_PerfDashboard.fn_ShowplanFormatUDX(@relop_children)
			else @physical_op + N'(' + @logical_op + N')'
		end	

	;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
	insert @node (
		node_id,
		stmt_text, 
		logical_op, 
		physical_op, 
		output_list, 
		avg_row_size, 
		est_cpu, 
		est_io, 
		est_rows, 
		est_rewinds, 
		est_rebinds, 
		est_subtree_cost,
		warnings)
	values (
		@relop_node.value('(./sp:RelOp/@NodeId)[1]', 'int'),
		@stmt_text, 
		@logical_op, 
		@physical_op, 
		MS_PerfDashboard.fn_ShowplanBuildColumnReferenceList(@relop_node.query('./sp:RelOp/sp:OutputList/sp:ColumnReference'), 0x1),
		@relop_node.value('(./sp:RelOp/@AvgRowSize)[1]', 'float'),
		@relop_node.value('(./sp:RelOp/@EstimateCPU)[1]', 'float'),
		@relop_node.value('(./sp:RelOp/@EstimateIO)[1]', 'float'),
		@relop_node.value('(./sp:RelOp/@EstimateRows)[1]', 'float'), 
		@relop_node.value('(./sp:RelOp/@EstimateRewinds)[1]', 'float'), 
		@relop_node.value('(./sp:RelOp/@EstimateRebinds)[1]', 'float'), 
		@relop_node.value('(./sp:RelOp/@EstimatedTotalSubtreeCost)[1]', 'float'),
		MS_PerfDashboard.fn_ShowplanBuildWarnings(@relop_node)
		);

	return;
end
go





































---------------------------------
--  SQL Job section
---------------------------------
 
/**************************************************************
Generated SQL - SYSaddjobs
For Server: SEAFRESQLDBA02 on Jul 24 2008  1:37:42:163PM
 
NOTE:  By default, jobs are scripted as disabled by
       this process.  To script jobs reflecting the current
       run status of enabled or disabled, use the input parm
       @leave_enabled = 'y', and re-script the jobs.
**************************************************************/
use [msdb]
go
 

 
/*************************************************************************************************
Create new job: MAINT - Daily Backup and DBCC
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'MAINT - Daily Backup and DBCC'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Database Maintenance' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'Database Maintenance'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'MAINT - Daily Backup and DBCC')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''MAINT - Daily Backup and DBCC'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'MAINT - Daily Backup and DBCC'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'MAINT - Daily Backup and DBCC'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'Daily Backup and DBCC process'
                                           ,@category_name = N'Database Maintenance'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb2  NVARCHAR(MAX)
  Select  @command_vrb2 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -Q"exec dbaadmin.dbo.dbasp_DBCCscripting @PlanName = ''''Mplan_user_all'''', @Process_mode = ''''daily''''" -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_user_daily.sql''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 1
  Select @save_sname = N'DBCC User Create Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb2
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb3  NVARCHAR(MAX)
  Select  @command_vrb3 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_user_daily.sql -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\DBCC_user_daily.log''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 2
  Select @save_sname = N'DBCC User Run Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb3
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb4  NVARCHAR(MAX)
  Select  @command_vrb4 = '
EXEC dbaadmin.dbo.dbasp_BackupDBs @PlanName = ''Mplan_user_full''
'
 
  -- Add job step 3
  Select @save_sname = N'Backup User Full'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb4
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 4
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb5  NVARCHAR(MAX)
  Select  @command_vrb5 = '
EXEC dbaadmin.dbo.dbasp_BackupDBs @PlanName = ''Mplan_user_simple''
'
 
  -- Add job step 4
  Select @save_sname = N'Backup User Simple'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 4
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb5
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 5
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb6  NVARCHAR(MAX)
  Select  @command_vrb6 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -Q"exec dbaadmin.dbo.dbasp_DBCCscripting @PlanName = ''''Mplan_sys_all'''', @Process_mode = ''''daily''''" -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_sys_daily.sql''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 5
  Select @save_sname = N'DBCC System Create Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 5
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb6
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 6
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb7  NVARCHAR(MAX)
  Select  @command_vrb7 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_sys_daily.sql -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\DBCC_sys_daily.log''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 6
  Select @save_sname = N'DBCC System Run Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 6
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb7
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 7
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb8  NVARCHAR(MAX)
  Select  @command_vrb8 = '
EXEC dbaadmin.dbo.dbasp_BackupDBs @PlanName = ''Mplan_sys_all''
'
 
  -- Add job step 7
  Select @save_sname = N'Backup System All'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 7
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb8
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 8
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb9  NVARCHAR(MAX)
  Select  @command_vrb9 = '
EXEC msdb.dbo.sp_start_job @job_name = ''UTIL - DBA Archive process''
'
 
  -- Add job step 8
  Select @save_sname = N'Run DBA Archive Process'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 8
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb9
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Daily Backup and DBCC'
                                                   ,@enabled = 1
                                                   ,@freq_type = 8
                                                   ,@active_start_date = 20060503
                                                   ,@active_start_time = 210000
                                                   ,@freq_interval = 95
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 1
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'MAINT - Daily Backup and DBCC')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'MAINT - Daily Backup and DBCC'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('MAINT - Daily Backup and DBCC', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:


   end
GO
 
/*************************************************************************************************
Create new job: MAINT - Daily Index Defrag
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'MAINT - Daily Index Defrag'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Database Maintenance' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'Database Maintenance'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'MAINT - Daily Index Defrag')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''MAINT - Daily Index Defrag'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'MAINT - Daily Index Defrag'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'MAINT - Daily Index Defrag'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'Daily Index Defrag process'
                                           ,@category_name = N'Database Maintenance'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_defrag_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_defrag_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb10  NVARCHAR(MAX)
  Select  @command_vrb10 = '
Declare @cmd nvarchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -Q"exec dbaadmin.dbo.dbasp_Indexmaint @PlanName = ''''Mplan_user_defrag''''" -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\daily_defrag.sql''
exec master.sys.xp_cmdshell @cmd
'
 
  -- Add job step 1
  Select @save_sname = N'Create Index Defrag Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb10
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_defrag_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_defrag_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb11  NVARCHAR(MAX)
  Select  @command_vrb11 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\Daily_defrag.sql -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\daily_defrag.log''
exec master.sys.xp_cmdshell @cmd

'
 
  -- Add job step 2
  Select @save_sname = N'Run Index Defrag'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb11
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_daily_defrag_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_daily_defrag_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb12  NVARCHAR(MAX)
  Select  @command_vrb12 = '
Declare @sqlcmd nvarchar(500)
Select @sqlcmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBA_sproc_recompiles.sql -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\DBA_sproc_recompiles.log''
exec master.sys.xp_cmdshell @sqlcmd
'
 
  -- Add job step 3
  Select @save_sname = N'Recompile Specific Sprocs'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb12
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'MAINT - Daily Index Defrag')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 0 where JobName = 'MAINT - Daily Index Defrag'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('MAINT - Daily Index Defrag', 0)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 
/*************************************************************************************************
Create new job: MAINT - TranLog Backup
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'MAINT - TranLog Backup'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Database Maintenance' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'Database Maintenance'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'MAINT - TranLog Backup')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''MAINT - TranLog Backup'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'MAINT - TranLog Backup'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'MAINT - TranLog Backup'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'TranLog Backup and DBCC'
                                           ,@category_name = N'Database Maintenance'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_tranlog_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_tranlog_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb13  NVARCHAR(MAX)
  Select  @command_vrb13 = '
EXEC dbaadmin.dbo.dbasp_Backup_Tranlog @PlanName = ''Mplan_user_tranlog''
'
 
  -- Add job step 1
  Select @save_sname = N'TranLog Backup'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb13
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 3
                                               ,@retry_interval = 2
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'TranLog Backup and DBCC'
                                                   ,@enabled = 1
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20060503
                                                   ,@active_start_time = 60000
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 8
                                                   ,@freq_subday_interval = 4
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 180559
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'MAINT - TranLog Backup')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'MAINT - TranLog Backup'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('MAINT - TranLog Backup', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 
/*************************************************************************************************
Create new job: MAINT - Weekly Backup and DBCC
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'MAINT - Weekly Backup and DBCC'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Database Maintenance' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'Database Maintenance'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'MAINT - Weekly Backup and DBCC')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''MAINT - Weekly Backup and DBCC'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'MAINT - Weekly Backup and DBCC'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'MAINT - Weekly Backup and DBCC'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'Weekly Backup and DBCC process'
                                           ,@category_name = N'Database Maintenance'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb14  NVARCHAR(MAX)
  Select  @command_vrb14 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -Q"exec dbaadmin.dbo.dbasp_Indexmaint @PlanName = ''''Mplan_user_defrag''''" -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\Weekly_defrag.sql''
exec master.sys.xp_cmdshell @cmd
'
 
  -- Add job step 1
  Select @save_sname = N'Create Index Defrag Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb14
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb15  NVARCHAR(MAX)
  Select  @command_vrb15 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\weekly_defrag.sql -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\weekly_defrag.log''
exec master.sys.xp_cmdshell @cmd

'
 
  -- Add job step 2
  Select @save_sname = N'Run Index Defrag'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb15
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb16  NVARCHAR(MAX)
  Select  @command_vrb16 = '
EXEC dbaadmin.dbo.dbasp_Backup_Tranlog @PlanName = ''Mplan_user_tranlog''
'
 
  -- Add job step 3
  Select @save_sname = N'Transaction Log Backup'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb16
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 3
                                               ,@retry_interval = 2
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 4
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb17  NVARCHAR(MAX)
  Select  @command_vrb17 = '
exec dbaadmin.dbo.dbasp_ShrinkLDFFiles
'
 
  -- Add job step 4
  Select @save_sname = N'Shrink LDF Files'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 4
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb17
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 5
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb18  NVARCHAR(MAX)
  Select  @command_vrb18 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -Q"exec dbaadmin.dbo.dbasp_DBCCscripting @PlanName = ''''Mplan_user_all'''', @Process_mode = ''''daily''''" -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_user_weekly.sql''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 5
  Select @save_sname = N'DBCC User Create Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 5
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb18
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 6
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb19  NVARCHAR(MAX)
  Select  @command_vrb19 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_user_weekly.sql -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\DBCC_user_weekly.txt''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 6
  Select @save_sname = N'DBCC User Run Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 6
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb19
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 7
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb20  NVARCHAR(MAX)
  Select  @command_vrb20 = '
EXEC dbaadmin.dbo.dbasp_BackupDBs @PlanName = ''Mplan_user_full''
'
 
  -- Add job step 7
  Select @save_sname = N'Backup User Full'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 7
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb20
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 8
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb21  NVARCHAR(MAX)
  Select  @command_vrb21 = '
EXEC dbaadmin.dbo.dbasp_BackupDBs @PlanName = ''Mplan_user_simple''
'
 
  -- Add job step 8
  Select @save_sname = N'Backup User Simple'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 8
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb21
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 9
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb22  NVARCHAR(MAX)
  Select  @command_vrb22 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -Q"exec dbaadmin.dbo.dbasp_DBCCscripting @PlanName = ''''Mplan_sys_all'''', @Process_mode = ''''daily''''" -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_sys_weekly.sql''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 9
  Select @save_sname = N'DBCC System Create Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 9
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb22
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 10
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb23  NVARCHAR(MAX)
  Select  @command_vrb23 = '
Declare @cmd varchar(500)
Select @cmd = ''sqlcmd -S'' + @@servername + '' -E -w265 -i\\' + @save_servername + '\' + @save_servername2 + '_dbasql\DBCC_sys_weekly.sql -o\\' + @save_servername + '\' + @save_servername2 + '_dbasql\dba_reports\DBCC_sys_weekly.txt''
exec master.sys.xp_cmdshell @cmd, no_output
'
 
  -- Add job step 10
  Select @save_sname = N'DBCC System Run Script'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 10
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb23
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 11
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb24  NVARCHAR(MAX)
  Select  @command_vrb24 = '
EXEC dbaadmin.dbo.dbasp_BackupDBs @PlanName = ''Mplan_sys_all''
'
 
  -- Add job step 11
  Select @save_sname = N'Backup System All'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 11
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb24
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 12
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\maint_weekly_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\maint_weekly_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb25  NVARCHAR(MAX)
  Select  @command_vrb25 = '
EXEC msdb.dbo.sp_start_job @job_name = ''UTIL - DBA Archive process''
'
 
  -- Add job step 12
  Select @save_sname = N'Run DBA Archive Process'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 12
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb25
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Weekly Backup and DBCC'
                                                   ,@enabled = 1
                                                   ,@freq_type = 8
                                                   ,@active_start_date = 20060503
                                                   ,@active_start_time = 210000
                                                   ,@freq_interval = 32
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 1
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'MAINT - Weekly Backup and DBCC')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'MAINT - Weekly Backup and DBCC'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('MAINT - Weekly Backup and DBCC', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

  end
GO
 
/*************************************************************************************************
Create new job: MON - SQL Performance Reporting
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'MON - SQL Performance Reporting'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'MON - SQL Performance Reporting')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''MON - SQL Performance Reporting'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'MON - SQL Performance Reporting'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'MON - SQL Performance Reporting'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'No description available.'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\mon_sql_performance_reports.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\mon_sql_performance_reports.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + '
Declare 
	 @cmd nvarchar(4000)
	,@outpath nvarchar(500)
	,@filename sysname
	,@charpos int
	,@DateStmp char(14)
	,@Hold_hhmmss varchar(8)
	,@save_servername sysname
	,@save_servername2 sysname
	,@save_servername3 sysname

Select @save_servername = @@servername
Select @save_servername2 = @@servername
Select @save_servername3 = @@servername

select @charpos = charindex(''\'', @save_servername2)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX(''\'', @@servername)-1))
	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, ''$'')
	select @save_servername3 = stuff(@save_servername3, @charpos, 1, ''('')
	select @save_servername3 = @save_servername3 + '')''
    end	

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @DateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

Select @filename = @save_servername3 + ''_REPORTtopblockers_'' + @DateStmp + ''.txt''
Select @outpath = ''\\'' + @save_servername + ''\'' + @save_servername2 + ''_dbasql\dba_reports''

SELECT @cmd = ''del '' + @outpath + ''\'' + @save_servername3 + ''_REPORTtopblockers_*.*''
Print @cmd
EXEC master.sys.xp_cmdshell @cmd

SELECT @cmd = ''sqlcmd -S'' + @@servername + '' -w265 -Q"exec dbaadmin.dbo.dbasp_REPORTtopblockers" -E -o'' + @outpath + ''\'' + @filename
Print @cmd
EXEC master.sys.xp_cmdshell @cmd

SELECT @cmd = ''dbaadmin.dbo.dbasp_File_Transit @source_name = '''''' + @filename + '''''', @source_path = '''''' +  @outpath + '''''', @target_env = ''''AMER'''', @target_server = ''''SEAFRESQLDBA01'''', @target_share = ''''SEAFRESQLDBA01_SQLPerfReports\'' + @save_servername2 + ''\TopBlockers''''''
Print @cmd
EXEC (@cmd)
'
 
  -- Add job step 1
  Select @save_sname = N'Create SQL Top Blockers Report'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
       ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\mon_sql_performance_reports.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\mon_sql_performance_reports.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb2  NVARCHAR(MAX)
  Select @command_vrb2 = ''
  Select  @command_vrb2 = @command_vrb2 + '
Declare 
	 @cmd nvarchar(4000)
	,@outpath nvarchar(500)
	,@filename sysname
	,@charpos int
	,@DateStmp char(14)
	,@Hold_hhmmss varchar(8)
	,@save_servername sysname
	,@save_servername2 sysname
	,@save_servername3 sysname

Select @save_servername = @@servername
Select @save_servername2 = @@servername
Select @save_servername3 = @@servername

select @charpos = charindex(''\'', @save_servername2)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX(''\'', @@servername)-1))
	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, ''$'')
	select @save_servername3 = stuff(@save_servername3, @charpos, 1, ''('')
	select @save_servername3 = @save_servername3 + '')''
    end	

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @DateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

Select @filename = @save_servername3 + ''_REPORTtopAvgTime_'' + @DateStmp + ''.txt''
Select @outpath = ''\\'' + @save_servername + ''\'' + @save_servername2 + ''_dbasql\dba_reports''

SELECT @cmd = ''del '' + @outpath + ''\'' + @save_servername3 + ''_REPORTtopAvgTime_*.*''
Print @cmd
EXEC master.sys.xp_cmdshell @cmd

SELECT @cmd = ''sqlcmd -S'' + @@servername + '' -w265 -Q"exec dbaadmin.dbo.dbasp_REPORTtopAvg_Time" -E -o'' + @outpath + ''\'' + @filename
Print @cmd
EXEC master.sys.xp_cmdshell @cmd

SELECT @cmd = ''dbaadmin.dbo.dbasp_File_Transit @source_name = '''''' + @filename + '''''', @source_path = '''''' +  @outpath + '''''', @target_env = ''''AMER'''', @target_server = ''''SEAFRESQLDBA01'''', @target_share = ''''SEAFRESQLDBA01_SQLPerfReports\'' + @save_servername2 + ''\TopAvgTime''''''
Print @cmd
EXEC (@cmd)
'
 
  -- Add job step 2
  Select @save_sname = N'Create SQL Top Elapsed Time and CPU Report'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb2
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
       ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\mon_sql_performance_reports.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\mon_sql_performance_reports.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb3  NVARCHAR(MAX)
  Select @command_vrb3 = ''
  Select  @command_vrb3 = @command_vrb3 + '
Declare 
	 @cmd nvarchar(4000)
	,@outpath nvarchar(500)
	,@filename sysname
	,@charpos int
	,@DateStmp char(14)
	,@Hold_hhmmss varchar(8)
	,@save_servername sysname
	,@save_servername2 sysname
	,@save_servername3 sysname

Select @save_servername = @@servername
Select @save_servername2 = @@servername
Select @save_servername3 = @@servername

select @charpos = charindex(''\'', @save_servername2)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX(''\'', @@servername)-1))
	Select @save_servername2 = stuff(@save_servername2, @charpos, 1, ''$'')
	select @save_servername3 = stuff(@save_servername3, @charpos, 1, ''('')
	select @save_servername3 = @save_servername3 + '')''
    end	

Set @Hold_hhmmss = convert(varchar(8), getdate(), 8)
Set @DateStmp = convert(char(8), getdate(), 112) + substring(@Hold_hhmmss, 1, 2) + substring(@Hold_hhmmss, 4, 2) + substring(@Hold_hhmmss, 7, 2) 

Select @filename = @save_servername3 + ''_REPORTtopExecCount_'' + @DateStmp + ''.txt''
Select @outpath = ''\\'' + @save_servername + ''\'' + @save_servername2 + ''_dbasql\dba_reports''

SELECT @cmd = ''del '' + @outpath + ''\'' + @save_servername3 + ''_REPORTtopExecCount_*.*''
Print @cmd
EXEC master.sys.xp_cmdshell @cmd

SELECT @cmd = ''sqlcmd -S'' + @@servername + '' -w265 -Q"exec dbaadmin.dbo.dbasp_REPORTtopExec_Count" -E -o'' + @outpath + ''\'' + @filename
Print @cmd
EXEC master.sys.xp_cmdshell @cmd

SELECT @cmd = ''dbaadmin.dbo.dbasp_File_Transit @source_name = '''''' + @filename + '''''', @source_path = '''''' +  @outpath + '''''', @target_env = ''''AMER'''', @target_server = ''''SEAFRESQLDBA01'''', @target_share = ''''SEAFRESQLDBA01_SQLPerfReports\'' + @save_servername2 + ''\TopExecCount''''''
Print @cmd
EXEC (@cmd)
'
 
  -- Add job step 3
  Select @save_sname = N'Create SQL Top Execution Count Report'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb3
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
       ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Weekly'
                                                   ,@enabled = 1
                                                   ,@freq_type = 8
                                                   ,@active_start_date = 20071011
                                                   ,@active_start_time = 500
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 1
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'MON - SQL Performance Reporting')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'MON - SQL Performance Reporting'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('MON - SQL Performance Reporting', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO


 
/*************************************************************************************************
Create new job: UTIL - DBA Archive process
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Archive process'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - DBA Archive process')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - DBA Archive process'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - DBA Archive process'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - DBA Archive process'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'DBA Archive process'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_DBA_Archive.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_DBA_Archive.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + 'exec dbaadmin.dbo.dbasp_runarchive ''\\' + @save_servername + '\' + @save_servername2 + '_dba_archive\''
'
 
  -- Add job step 1
  Select @save_sname = N'DBA Archive process'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Saturday Morning'
                                                   ,@enabled = 1
                                                   ,@freq_type = 8
                                                   ,@active_start_date = 20080724
                                                   ,@active_start_time = 50000
                                                   ,@freq_interval = 64
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 1
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Archive process')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Archive process'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Archive process', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 

 
/*************************************************************************************************
Create new job: UTIL - DBA Log Parser
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Log Parser'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - DBA Log Parser')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - DBA Log Parser'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - DBA Log Parser'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - DBA Log Parser'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'DBA - use log parser to extract data and place it on the central server'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 2
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  Select @save_output_filename = '\\SQLDEPLOYER02\SQLDEPLOYER02_log\SQLjob_logs\util_dba_LogParser.txt'
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + 'exec dbaadmin.dbo.dbasp_filescan_logparser'
 
  -- Add job step 1
  Select @save_sname = N'Run Filescan Log Parser'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 6
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Every 15 Minutes'
                                                   ,@enabled = 1
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20100112
                                                   ,@active_start_time = 0
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 4
                                                   ,@freq_subday_interval = 15
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Log Parser')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Log Parser'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Log Parser', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 
/*************************************************************************************************
Create new job: UTIL - DBA Check Misc process
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Check Misc process'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - DBA Check Misc process')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - DBA Check Misc process'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - DBA Check Misc process'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - DBA Check Misc process'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
         ,@description = N'DBA'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + '
exec dbaadmin.dbo.dbasp_Check_Jobs
'
 
  -- Add job step 1
  Select @save_sname = N'DBA Check Jobs step'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb2  NVARCHAR(MAX)
  Select @command_vrb2 = ''
  Select  @command_vrb2 = @command_vrb2 + '
exec dbaadmin.dbo.dbasp_Check_OpenJob
'
 
  -- Add job step 2
  Select @save_sname = N'DBA Check Open Jobs step'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb2
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb3  NVARCHAR(MAX)
  Select @command_vrb3 = ''
  Select  @command_vrb3 = @command_vrb3 + '
exec dbaadmin.dbo.dbasp_Check_Backups
'
 
  -- Add job step 3
  Select @save_sname = N'DBA Check Backups step'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb3
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 4
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb4  NVARCHAR(MAX)
  Select @command_vrb4 = ''
  Select  @command_vrb4 = @command_vrb4 + '
exec dbaadmin.dbo.dbasp_Check_Logins
'
 
  -- Add job step 4
  Select @save_sname = N'DBA Check Logins step'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 4
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb4
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 5
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb5  NVARCHAR(MAX)
  Select @command_vrb5 = ''
  Select  @command_vrb5 = @command_vrb5 + '
exec dbaadmin.dbo.dbasp_Check_DBUsers
'
 
  -- Add job step 5
  Select @save_sname = N'DBA Check Users step'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 5
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb5
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 6
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb6  NVARCHAR(MAX)
  Select @command_vrb6 = ''
  Select  @command_vrb6 = @command_vrb6 + 'declare @savesubject varchar(100)
select @savesubject = ''DBA Note: Deployment Jobs Being Removed from '' +  @@servername
If (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = ''ENVname'') = ''production''
   Begin
	If exists (select * from msdb.dbo.sysjobs where name like ''DEPL_RD%'' 
					and name not in (''DEPL_RD - Deployment Control''
						,''DEPL_RD - Process Update Files''
						,''DEPL_RD - Base Appl Info Updates''
						,''DEPL_RD - Gears Import'')
		)
	   begin
		If exists (select 1 from msdb.dbo.sysjobs where name = ''DEPL_RD - 00 - Deployment Start'')
		   begin
			exec msdb.dbo.sp_delete_job @job_name = N''DEPL_RD - 00 - Deployment Start''
		   end

		If exists (select 1 from msdb.dbo.sysjobs where name = ''DEPL_RD - 01 - Restore'')
		   begin
			exec msdb.dbo.sp_delete_job @job_name = N''DEPL_RD - 01 - Restore''
		   end

		If exists (select 1 from msdb.dbo.sysjobs where name = ''DEPL_RD - 51 - SQLDeploy'')
		   begin
			exec msdb.dbo.sp_delete_job @job_name = N''DEPL_RD - 51 - SQLDeploy''
		   end

		If exists (select 1 from msdb.dbo.sysjobs where name = ''DEPL_RD - 99 - Deployment End'')
		   begin
			exec msdb.dbo.sp_delete_job @job_name = N''DEPL_RD - 99 - Deployment End''
		   end


		Exec dbaadmin.dbo.dbasp_sendmail
		@recipients = ''tssqldba@gettyimages.com'',
		@subject = @savesubject,
		@message = ''DBA Note: DEPL_RD Jobs have been removed from this production server.''   
	   end
   End
'
 
  -- Add job step 6
  Select @save_sname = N'DBA Check for DEPL Jobs on Production'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 6
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb6
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 1
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 7
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb7  NVARCHAR(MAX)
  Select @command_vrb7 = ''
  Select  @command_vrb7 = @command_vrb7 + '
If (select datepart(dw, getdate())) in (5, 4, 3, 2) --Thur, Wed, Tue, Mon
   begin
	Exec dbaadmin.dbo.dbasp_depl_NXTcheck
   end
'
 
  -- Add job step 7
  Select @save_sname = N'DBA Check for DEPL NXT Files'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 7
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb7
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 1
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 8
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb8  NVARCHAR(MAX)
  Select @command_vrb8 = ''
  Select  @command_vrb8 = @command_vrb8 + 'declare @savesubject nvarchar(100)
declare @save_message nvarchar(500)

select @savesubject = ''DBA Warning: A Temp or Test user login exists on production server '' + @@servername
select @save_message =	''DBA Warning: A Temp or Test user login exists on a production server ('' + @@servername + ''). Clean up if necessary.''   

If (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = ''ENVname'') = ''production''
Begin
	If exists (select * from msdb.dbo.sysusers 
			where (name like ''%temp%'' or name like ''%test%'') 
			and name not in (select detail01 from dbaadmin.dbo.no_check where NoCheck_type = ''login'')
		)
	   begin
		Exec dbaadmin..dbasp_sendmail
		@recipients = ''tssqldba@gettyimages.com'',
		@subject = @savesubject,
		@message = @save_message   
	   end
End
'
 
  -- Add job step 8
  Select @save_sname = N'DBA Check for Temp or Test User Logins on Production'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 8
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb8
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 1
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 9
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb9  NVARCHAR(MAX)
  Select @command_vrb9 = ''
  Select  @command_vrb9 = @command_vrb9 + 'If (select env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = ''ENVname'') = ''production''
 and exists(select 1 from dbaadmin.dbo.no_check)
 and (select datepart(dw, getdate())) = 6 --Friday
   begin
	declare @message nvarchar(3000)
	declare @subject sysname
	declare @save_dbname sysname
	declare @save_type sysname
	declare @save_nocheckID int

	select @subject = ''DBA No_Check Report: '' + @@servername + '' '' + convert(varchar(20), getdate(), 101)
	select @message = ''The following rows are in the dbaadmin.dbo.no_check table for server '' + @@servername + ''.'' +char(13)+char(10)
	select @message = @message +char(13)+char(10)

	select @save_nocheckID = 0
	start01:
	select @save_nocheckID = (select top 1 nocheckID from dbaadmin.dbo.no_check where nocheckID > @save_nocheckID order by nocheckID)
	select @save_type = (select NoCheck_type from dbaadmin.dbo.no_check where nocheckID = @save_nocheckID)
	select @save_dbname = (select detail01 from dbaadmin.dbo.no_check where nocheckID = @save_nocheckID)
	select @message = @message + @save_type + ''     '' + @save_dbname +char(13)+char(10)
	If exists(select 1 from dbaadmin.dbo.no_check where nocheckID > @save_nocheckID)
	   begin
		goto start01
	   end

	exec dbaadmin.dbo.dbasp_sendmail @subject = @subject
					--,@recipients = ''jim.wilson@gettyimages.com''
					,@recipients = ''tssqldba@gettyimages.com''
					,@message = @message
   end'
 
  -- Add job step 9
  Select @save_sname = N'DBA Report No_Check for Production'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 9
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb9
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 1
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 10
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb10  NVARCHAR(MAX)
  Select @command_vrb10 = ''
  Select  @command_vrb10 = @command_vrb10 + '
exec dbaadmin.dbo.dbasp_check_defrag
'
 
  -- Add job step 10
  Select @save_sname = N'DBA Check for Defrag Run Latency'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 10
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb10
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 1
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 11
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb11  NVARCHAR(MAX)
  Select @command_vrb11 = ''
  Select  @command_vrb11 = @command_vrb11 + '
exec dbaadmin.dbo.dbasp_Check_Opentran
'
 
  -- Add job step 11
  Select @save_sname = N'DBA Check Open Trans step'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 11
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb11
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 3
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 12
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb12  NVARCHAR(MAX)
  Select @command_vrb12 = ''
  Select  @command_vrb12 = @command_vrb12 + '
exec dbaadmin.dbo.dbasp_Check_JoblogRename
'
 
  -- Add job step 12
  Select @save_sname = N'DBA Check SQL Job Log Rename'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 12
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb12
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 13
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Check_Misc.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Check_Misc.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb13  NVARCHAR(MAX)
  Select @command_vrb13 = ''
  Select  @command_vrb13 = @command_vrb13 + 'exec dbaadmin.dbo.dbasp_filescan_local_process'
 
  -- Add job step 13
  Select @save_sname = N'Local Filescan Process'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 13
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb13
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'DBA Check Misc process'
                                                   ,@enabled = 1
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20060601
                                                   ,@active_start_time = 54500
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
        ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Check Misc process')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Check Misc process'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Check Misc process', 1)
		     end
	     end
     end
 
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Check Misc process')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Check Misc process'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Check Misc process', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 
/*************************************************************************************************
Create new job: UTIL - DBA Errorlog Check
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Errorlog Check'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - DBA Errorlog Check')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - DBA Errorlog Check'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - DBA Errorlog Check'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - DBA Errorlog Check'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'No description available.'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\check_errorlog.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\check_errorlog.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb120  NVARCHAR(MAX)
  Select  @command_vrb120 = '
exec dbaadmin.dbo.dbasp_check_errorlog
'
 
  -- Add job step 1
  Select @save_sname = N'Check SQL Errorlog'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb120
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Check Errorlog'
                                                   ,@enabled = 1
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20060822
                                                   ,@active_start_time = 75900
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Errorlog Check')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Errorlog Check'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Errorlog Check', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 

 
/*************************************************************************************************
Create new job: UTIL - DBA Nightly Processing
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Nightly Processing'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - DBA Nightly Processing')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - DBA Nightly Processing'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - DBA Nightly Processing'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - DBA Nightly Processing'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
         ,@description = N'DBA Nightly Processing'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Nightly_Process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Nightly_Process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + '
exec dbaadmin.dbo.dbasp_capture_local_serverenviro
'
 
  -- Add job step 1
  Select @save_sname = N'Capture Local Server Info'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Nightly_Process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Nightly_Process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb2  NVARCHAR(MAX)
  Select @command_vrb2 = ''
  Select  @command_vrb2 = @command_vrb2 + '
exec dbaadmin.dbo.dbasp_Code_Updates
'
 
  -- Add job step 2
  Select @save_sname = N'Check for new dbaadmin release'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb2
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Nightly_Process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Nightly_Process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb3  NVARCHAR(MAX)
  Select @command_vrb3 = ''
  Select  @command_vrb3 = @command_vrb3 + 'DECLARE @cmd nvarchar(500)
DECLARE @central_server sysname

Select @central_server = env_detail from dbaadmin.dbo.Local_ServerEnviro where env_type = ''CentralServer''

Select @cmd = ''copy \\'' + @central_server + ''\'' + @central_server + ''_builds\dbaadmin\system32\*.*  %windir%\system32 /Y''
print @cmd
exec master.sys.xp_cmdshell @cmd

Select @cmd = ''if not exist c:\DBA_DiskCheck_DoNotDelete.txt (copy \\'' + @central_server + ''\'' + @central_server + ''_builds\dbaadmin\DBA_DiskCheck_DoNotDelete.txt  c:\ /Y)''
print @cmd
exec master.sys.xp_cmdshell @cmd
'
 
  -- Add job step 3
  Select @save_sname = N'Refresh ResKit Utilities to system32'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb3
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 4
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Nightly_Process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Nightly_Process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb4  NVARCHAR(MAX)
  Select @command_vrb4 = ''
  Select  @command_vrb4 = @command_vrb4 + '
DECLARE @RandomInteger int
SELECT @RandomInteger = 60 * RAND() + 1
Waitfor delay @RandomInteger

exec dbaadmin.dbo.dbasp_Self_Register
'
 
  -- Add job step 4
  Select @save_sname = N'Self Register to the Central Server'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 4
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb4
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 5
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Nightly_Process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Nightly_Process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb5  NVARCHAR(MAX)
  Select @command_vrb5 = ''
  Select  @command_vrb5 = @command_vrb5 + '
exec dbaadmin.dbo.dbasp_set_maintplans
'
 
  -- Add job step 5
  Select @save_sname = N'Reset Maintenance Plans'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 5
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb5
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 6
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Nightly_Process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Nightly_Process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb6  NVARCHAR(MAX)
  Select @command_vrb6 = ''
  Select  @command_vrb6 = @command_vrb6 + '
exec dbaadmin.dbo.dbasp_Check_JoblogRename
'
 
  -- Add job step 6
  Select @save_sname = N'SQL job log rename'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 6
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb6
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 7
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_Nightly_Process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_Nightly_Process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb7  NVARCHAR(MAX)
  Select @command_vrb7 = ''
  Select  @command_vrb7 = @command_vrb7 + '
--exec dbaadmin.dbo.dbasp_Check_BusWare
'
 
  -- Add job step 7
  Select @save_sname = N'Check BusinessWare Setup'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 7
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb7
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'DBA Nightly Processing'
                                                   ,@enabled = 1
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20060504
                                                   ,@active_start_time = 205000
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
                                       ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Nightly Processing')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Nightly Processing'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Nightly Processing', 1)
		     end
	     end
     end
 
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Nightly Processing')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Nightly Processing'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Nightly Processing', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO



/*************************************************************************************************
Create new job: UTIL - DBA Update Files
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Update Files'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - DBA Update Files')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - DBA Update Files'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - DBA Update Files'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - DBA Update Files'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
         ,@description = N'DBA'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\util_update_files_process.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\util_update_files_process.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + 'exec dbaadmin.dbo.dbasp_ProcessUpdateFiles'
 
  -- Add job step 1
  Select @save_sname = N'Process Update files'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Every 5 minutes'
                                                   ,@enabled = 1
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20090609
                                                   ,@active_start_time = 300
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 4
                                                   ,@freq_subday_interval = 5
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
        ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Update Files')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Update Files'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Update Files', 1)
		     end
	     end
     end
 
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Update Files')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Update Files'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Update Files', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO

 

 

 


/*************************************************************************************************
Create new job: UTIL - DBA Check Periodic
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Check Periodic'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - DBA Check Periodic')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - DBA Check Periodic'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - DBA Check Periodic'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - DBA Check Periodic'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'DBA'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\util_dba_check_periodic.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\util_dba_check_periodic.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + 'exec dbaadmin.dbo.dbasp_Check_Periodic'
 
  -- Add job step 1
  Select @save_sname = N'Periodic Check Process'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 1
                                               ,@retry_interval = 1
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'every 3 minutes'
                                                   ,@enabled = 1
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20100414
                                                   ,@active_start_time = 200
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 4
                                                   ,@freq_subday_interval = 3
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - DBA Check Periodic')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'UTIL - DBA Check Periodic'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - DBA Check Periodic', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 

 
/*************************************************************************************************
Create new job: UTIL - SQLTrace Process
**************************************************************************************************/
If not exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - SQLTrace Process'))
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'UTIL - SQLTrace Process')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''UTIL - SQLTrace Process'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'UTIL - SQLTrace Process'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'UTIL - SQLTrace Process'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'DBA SQL Trace Process'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\UTIL_SQLTrace.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\UTIL_SQLTrace.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb155  NVARCHAR(MAX)
  Select  @command_vrb155 = '
begin
exec dbaadmin.dbo.dbasp_SQLtrace
waitfor delay  ''00:58:30''
exec dbaadmin.dbo.dbasp_SQLtrace @stoponly = ''y''
end
'
 
  -- Add job step 1
  Select @save_sname = N'SQLTrace Process'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb155
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Sample Schedule'
                                                   ,@enabled = 0
                                                   ,@freq_type = 4
                                                   ,@active_start_date = 20080430
                                                   ,@active_start_time = 0
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 8
                                                   ,@freq_subday_interval = 1
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 0
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'UTIL - SQLTrace Process')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 0 where JobName = 'UTIL - SQLTrace Process'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('UTIL - SQLTrace Process', 0)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end
GO
 

/*************************************************************************************************
Create new job: BASE - Local Process
**************************************************************************************************/
--  This job is only for non-prod instances
declare @cmd nvarchar(500)
create table #DirectoryTempTable(cmdoutput nvarchar(255) null)
Select @cmd = 'whoami'

insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd--, no_output 
delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable

If not exists (select 1 from #DirectoryTempTable where cmdoutput like '%prod%' and cmdoutput not like '%stag%')
   and not exists (Select 1 from msdb.dbo.sysjobs where name = N'BASE - Local Process')
   and exists (select 1 from dbaadmin.dbo.db_sequence s, master.sys.databases d where s.db_name = d.name)
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'BASE - Local Process')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''BASE - Local Process'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'BASE - Local Process'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'BASE - Local Process'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
                                           ,@description = N'BASE'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\base_localprocess.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\base_localprocess.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + 'exec dbaadmin.dbo.dbasp_GetBuildInfo'
 
  -- Add job step 1
  Select @save_sname = N'Get Database Build Information'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\base_localprocess.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\base_localprocess.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb2  NVARCHAR(MAX)
  Select @command_vrb2 = ''
  Select  @command_vrb2 = @command_vrb2 + 'exec dbaadmin.dbo.dbasp_Base_cleanup'
 
  -- Add job step 2
  Select @save_sname = N'NXT share Cleanup'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb2
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\base_localprocess.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\base_localprocess.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb3  NVARCHAR(MAX)
  Select @command_vrb3 = ''
  Select  @command_vrb3 = @command_vrb3 + 'exec dbaadmin.dbo.dbasp_Base_pullSQB'
 
  -- Add job step 3
  Select @save_sname = N'Pull SQB files to NXT share'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb3
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 4
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\base_localprocess.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\base_localprocess.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb4  NVARCHAR(MAX)
  Select @command_vrb4 = ''
  Select  @command_vrb4 = @command_vrb4 + 'exec dbaadmin.dbo.dbasp_Base_AutoRestore_fromSQB'
 
  -- Add job step 4
  Select @save_sname = N'Create local NXT files'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 4
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb4
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the job schedules
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @JobID
                                                   ,@name = N'Sunday Morning'
                                                   ,@enabled = 1
                                                   ,@freq_type = 8
                                                   ,@active_start_date = 20090608
                                                   ,@active_start_time = 80000
                                                   ,@freq_interval = 1
                                                   ,@freq_subday_type = 1
                                                   ,@freq_subday_interval = 0
                                                   ,@freq_relative_interval = 0
                                                   ,@freq_recurrence_factor = 1
                                                   ,@active_end_date = 99991231
                                                   ,@active_end_time = 235959
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'BASE - Local Process')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 1 where JobName = 'BASE - Local Process'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('BASE - Local Process', 1)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:

   end

drop table #DirectoryTempTable


GO




/*************************************************************************************************
Create new job: SPCL - PreRelease Backups
**************************************************************************************************/
--  This job is only for prod instances
declare @cmd nvarchar(500)
create table #DirectoryTempTable(cmdoutput nvarchar(255) null)
Select @cmd = 'whoami'

insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd--, no_output 
delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable

If exists (select 1 from #DirectoryTempTable where cmdoutput like '%prod%')
   and exists (Select 1 from master.sys.databases d, dbaadmin.dbo.db_sequence s where d.name = s.db_name)
   begin
BEGIN TRANSACTION
  DECLARE @JobID BINARY(16)
  DECLARE @ReturnCode INT
  DECLARE @charpos INT
  DECLARE @miscprint nvarchar(500)
  DECLARE @save_servername sysname
  DECLARE @save_servername2 sysname
  DECLARE @save_servername3 sysname
  DECLARE @save_servername4b sysname
  DECLARE @save_output_filename sysname
  DECLARE @save_jname sysname
  DECLARE @save_sname sysname
  DECLARE @parm01 sysname
  DECLARE @logpath sysname
  Select  @ReturnCode = 0
 
  -- Set up the servername variables
  Select @save_servername = @@servername
  Select @save_servername2 = @@servername
  Select @save_servername3 = @@servername
  Select @save_servername4b = @@servername
 
  Select @charpos = charindex('\', @save_servername)
  IF @charpos <> 0
     begin
        Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
        Select @save_servername2 = stuff(@save_servername2, @charpos, 1, '$')
        Select @save_servername3 = stuff(@save_servername3, @charpos, 1, '(')
        Select @save_servername3 = @save_servername3 + ')'
        Select @save_servername4b = stuff(@save_servername4b, @charpos, 1, '_')
     end
 
  -- Set up the output file path variable
  Select @parm01 = @save_servername2 + '_SQLjob_logs'
  If exists(select 1 from master.sys.sysdatabases where name = 'dbaadmin')
     begin
        exec dbaadmin.dbo.dbasp_get_share_path @parm01, @logpath output
     end
 
  -- Verify the proper category exists
  IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
     begin
        EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'Job', @type=N'Local', @name=N'[Uncategorized (Local)]'
        IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
     end
 
  -- Delete the job with the same name (if it exists)
  Select @JobID = job_id
  from   msdb.dbo.sysjobs
  where (name = N'SPCL - PreRelease Backups')
  If (@JobID is not null)
     begin
        -- Check if the job is a multi-server job
        IF (exists (Select * From msdb.dbo.sysjobservers
                    Where (job_id = @JobID) and (server_id <> 0)))
           begin
              -- This is a mult server job, so abort the script
              Select @miscprint = 'Unable to delete job ''SPCL - PreRelease Backups'' since there is already a multi-server job with this name.'
              RAISERROR (@miscprint, 16, 1)
              GOTO QuitWithRollback
           end
        Else
           begin
              -- Delete the [local] job
              Select @miscprint = N'SPCL - PreRelease Backups'
              EXEC msdb.dbo.sp_delete_job @job_name = @miscprint
              Select @JobID = null
           end
     end
 
  -- Add the job
  Select @save_jname = N'SPCL - PreRelease Backups'
  EXEC @ReturnCode = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT
                                           ,@job_name = @save_jname
                                           ,@owner_login_name = N'sa'
         ,@description = N'DBA'
                                           ,@category_name = N'[Uncategorized (Local)]'
                                           ,@enabled = 0
                                           ,@notify_level_email = 0
                                           ,@notify_level_page = 0
                                           ,@notify_level_netsend = 0
                                           ,@notify_level_eventlog = 0
                                           ,@delete_level= 0
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 1
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\spcl_depl_rd_prerelease_backups.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\spcl_depl_rd_prerelease_backups.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb1  NVARCHAR(MAX)
  Select @command_vrb1 = ''
  Select  @command_vrb1 = @command_vrb1 + 'SET NOCOUNT ON

DECLARE  
	 @cmd		nvarchar(4000)
	,@save_DBname	sysname


declare @DBnames table	(name sysname)


Select @cmd = ''SELECT d.name from master.sys.databases d
				,dbaadmin.dbo.db_sequence s 
				where d.name = s.db_name''
delete from @DBnames
insert into @DBnames (name) exec (@cmd)
delete from @DBnames where name is null or name = ''''
delete from @DBnames where name in (select detail01 from dbaadmin.dbo.no_check where nocheck_type in (''backup''))
delete from @DBnames where name not in (select db_name from dbaadmin.dbo.db_sequence)
--select * from @DBnames

If (select count(*) from @DBnames) > 0
   begin
	start_dbnames:
	Select @save_DBname = (Select top 1 name from @DBnames order by name)

	Print ''Pre-release Backup starting for DB '' + @save_DBname + '':''
	Print ''exec dbaadmin.dbo.dbasp_BackupDBs @DBname = @save_DBname, @process_mode = ''''pre_release''''''
	raiserror('''', -1,-1) with nowait
	exec dbaadmin.dbo.dbasp_BackupDBs @DBname = @save_DBname, @process_mode = ''pre_release''

	delete from @DBnames where name = @save_DBname
	If (select count(*) from @DBnames) > 0
	   begin
		goto start_dbnames
	   end
   end'
 
  -- Add job step 1
  Select @save_sname = N'Backup Process'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 1
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb1
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 2
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\spcl_depl_rd_prerelease_backups.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\spcl_depl_rd_prerelease_backups.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb2  NVARCHAR(MAX)
  Select @command_vrb2 = ''
  Select  @command_vrb2 = @command_vrb2 + 'exec DEPLinfo.dbo.dpsp_auto_Script_DDL @run_type = ''PreDeploy'''
 
  -- Add job step 2
  Select @save_sname = N'Script (Before) DDL'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 2
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb2
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 3
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
 
  -- Preparation for job step 3
 
  -- Move the output file name and path to a variable
  If @logpath is not null
     begin
        Select @save_output_filename = @logpath + '\spcl_depl_rd_prerelease_backups.txt'
     end
  Else
     begin
        Select @save_output_filename = 'c:\spcl_depl_rd_prerelease_backups.txt'
     end
 
  -- Move the command syntax for this job step to a variable
  Declare @command_vrb3  NVARCHAR(MAX)
  Select @command_vrb3 = ''
  Select  @command_vrb3 = @command_vrb3 + 'exec DEPLinfo.dbo.dpsp_addjob_streamline'
 
  -- Add job step 3
  Select @save_sname = N'Create DEPL_RD Job Stream'
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @JobID
                                               ,@step_id = 3
                                               ,@step_name = @save_sname
                                               ,@command = @command_vrb3
                                               ,@database_name = N'master'
                                               ,@server = N''
                                               ,@database_user_name = N''
                                               ,@subsystem = N'TSQL'
                                               ,@cmdexec_success_code = 0
                                               ,@flags = 2
                                               ,@retry_attempts = 0
                                               ,@retry_interval = 0
                                               ,@os_run_priority = 0
                                               ,@output_file_name = @save_output_filename
                                               ,@on_success_step_id = 0
                                               ,@on_success_action = 1
                                               ,@on_fail_step_id = 0
                                               ,@on_fail_action = 2
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update the job start step
  EXECUTE @ReturnCode = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Add the Target Servers
  EXECUTE @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)'
  IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
 
  -- Update Production Job Status Info
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'SPCL - PreRelease Backups')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 0 where JobName = 'SPCL - PreRelease Backups'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('SPCL - PreRelease Backups', 0)
		     end
	     end
     end
 
  IF exists(select * from master.sys.sysdatabases where name = 'DEPLinfo')
     begin
	  IF exists(select * from DEPLinfo.sys.objects where name = 'ProdJobStatus')
	     begin
		  IF exists(select * from DEPLinfo.dbo.ProdJobStatus where JobName = 'SPCL - PreRelease Backups')
		     begin
			  update DEPLinfo.dbo.ProdJobStatus set JobStatus = 0 where JobName = 'SPCL - PreRelease Backups'
		     end
		  ELSE
		     begin
			  insert into DEPLinfo.dbo.ProdJobStatus (JobName, JobStatus) values ('SPCL - PreRelease Backups', 0)
		     end
	     end
     end
 
COMMIT TRANSACTION
GOTO   EndSave
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 
EndSave:
   end

drop table #DirectoryTempTable


GO

 


 


 


 

 


































---------------------------------
--  SQL Job Mods section
---------------------------------
use [msdb]
go




If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Check Contention'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Check Contention', @enabled = 0
   end
go


If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - SQL Perf Log Process'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - SQL Perf Log Process', @enabled = 0
   end
go

If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Check Periodic'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Check Periodic', @enabled = 1
   end
go



If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Check Misc process'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Check Misc process', @enabled = 1
   end
go

If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Errorlog Check'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Errorlog Check', @enabled = 1
   end
go

If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Nightly Processing'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Nightly Processing', @enabled = 1
   end
go

If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Weekly Processing'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Weekly Processing', @enabled = 1
   end
go

If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Update Files'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Update Files', @enabled = 1
   end
go


If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Archive process'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Archive process', @enabled = 1
   end
go


If exists (Select * from msdb.dbo.sysjobs where (name = N'UTIL - DBA Log Parser'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'UTIL - DBA Log Parser', @enabled = 1
   end
go


If exists (Select * from msdb.dbo.sysjobs where (name = N'BASE - Local Process'))
   begin
	exec msdb.dbo.sp_update_job @job_name = 'BASE - Local Process', @enabled = 1
   end
go




exec dbaadmin.dbo.dbasp_FixJobOutput
go




--*************************************************************************************************
-- Delete job: DBA - Test LogParser
--**************************************************************************************************
declare @job_id uniqueidentifier

select @job_id = (select top 1 job_id from msdb.dbo.sysjobs where name like '%DBA - Test LogParser%')

if @job_id is not null
   begin
	EXEC msdb.dbo.sp_delete_job @job_name = N'DBA - Test LogParser'
   end
go


--*************************************************************************************************
-- Delete job: UTIL - DBA Weekly Processing
--**************************************************************************************************
declare @job_id uniqueidentifier

select @job_id = (select top 1 job_id from msdb.dbo.sysjobs where name like '%UTIL - DBA Weekly Processing%')

if @job_id is not null
   begin
	EXEC msdb.dbo.sp_delete_job @job_name = N'UTIL - DBA Weekly Processing'
   end
go














































---------------------------------
--  Add Master Sprocs section
---------------------------------
use master
go




























use [dbaadmin]
go


If not exists (select 1 from [dbaadmin].sys.database_principals where name = 'role_guest' and type = 'R')
   begin
      CREATE ROLE [role_guest] AUTHORIZATION [dbo];
   end
go

sp_addrolemember 'role_guest', 'guest'
go

GRANT SELECT ON OBJECT::[dbo].Local_ServerEnviro to role_guest 
go
 
GRANT INSERT ON OBJECT::[dbo].Local_ServerEnviro to role_guest 
go



--  Create DBA logins in production, stage and staging  ---------------------------------------------
DECLARE
	 @len			int
	,@cmd			nvarchar(3000)
	,@save_servername	sysname
	,@save_domain		sysname
	,@save_sqlinstance	sysname
	,@charpos		int	
	,@isNMinstance		char(1)
	,@in_key		sysname
	,@in_path		sysname
	,@in_value		sysname
	,@result_value		nvarchar(500)

--  Create Temp Tables
Create table #loginconfig(name1 sysname null, config_value sysname null)
create table #DirectoryTempTable(cmdoutput nvarchar(255) null)


Select @save_domain = ' '
Select @save_servername = @@servername
Select @isNMinstance = 'n'

Select @charpos = charindex('\', @save_servername)
IF @charpos <> 0
   begin
	Select @save_servername = substring(@@servername, 1, (CHARINDEX('\', @@servername)-1))
	Select @save_sqlinstance = rtrim(substring(@@servername, @charpos+1, 100))
	Select @isNMinstance = 'y'
   end

--  Get the domain name and save it (Note:  We have to strip off the last byte from reg config_value because it's not printable)
Select @cmd = 'whoami'

insert into #DirectoryTempTable exec master.sys.xp_cmdshell @cmd
delete from #DirectoryTempTable where cmdoutput is null
--select * from #DirectoryTempTable

If (select count(*) from #DirectoryTempTable) > 0
   begin
	Select @result_value = (select top 1 cmdoutput from #DirectoryTempTable)
   end
Else
   begin
	If @isNMinstance = 'n'
	   begin
		select @in_key = 'HKLM'
		select @in_path = 'System\CurrentControlSet\Services\MSSQLServer'
		select @in_value = 'ObjectName'
		exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
	   end
	Else
	   begin
		select @in_key = 'HKLM'
		select @in_path = 'System\CurrentControlSet\Services\MSSQL$' + @save_sqlinstance
		select @in_value = 'ObjectName'
		exec dbaadmin.dbo.dbasp_regread @in_key, @in_path, @in_value, @result_value output
	   end
   end

Select @save_domain = @result_value

Select @charpos = charindex('\', @save_domain)
IF @charpos <> 0
   begin
	Select @save_domain = substring(@save_domain, 1, (CHARINDEX('\', @save_domain)-1))
   end
Else
   begin
	Insert into #loginconfig exec master.dbo.xp_loginconfig 'default domain'
	Select @save_domain = config_value from #loginconfig
	Select @len = len(@save_domain)
	Select @save_domain = substring(@save_domain, 1, (@len - 1))
   end

print @save_domain

If @save_domain in ('production', 'stage', 'staging')
   begin

	If exists (select * from master.sys.syslogins where name = N'DBAavarnes')
	    begin
		drop login DBAavarnes
	    end

	If not exists (select * from master.sys.syslogins where name =  N'DBAamoss')
	   Begin
		exec sp_addlogin @loginame = 'DBAamoss'
			,@passwd = 0x0100AF1E41481B7853BC9B26C5021CDB965EA721A810ECDB72782616E4572A4032A7C7F0BB1931BB8320CB082259
			,@defdb = 'master'
			,@deflanguage = 'us_english'
			,@sid = 0xE2FE4E3D5613E74CA9BB6FFDEF569221
			,@encryptopt = 'skip_encryption'
	   End



	If not exists (select * from master.sys.syslogins where name = N'DBAjbrown')
	   Begin
	      select @cmd = 'CREATE LOGIN DBAjbrown
	             WITH PASSWORD = ''' + nchar(1) + nchar(16712) + nchar(50095) + nchar(7392) + nchar(28889) + nchar(43229) + nchar(19442) + nchar(23777) + nchar(10434) + nchar(5843) + nchar(13141) + nchar(44910) + nchar(7771) + ''' HASHED
	                                 ,DEFAULT_DATABASE = [master]
	                                 ,DEFAULT_LANGUAGE = us_english
	                                 ,SID = 0xA2B870F76B5FA74D8F3BA4ABA724E94E'
	        Print @cmd
	        Exec (@cmd)
	   End

	If not exists (select * from master.sys.syslogins where name = N'DBAjimw')
	   Begin
	      select @cmd = 'CREATE LOGIN DBAjimw
	             WITH PASSWORD = ''' + nchar(1) + nchar(3163) + nchar(2744) + nchar(55157) + nchar(64104) + nchar(47261) + nchar(32982) + nchar(16772) + nchar(38560) + nchar(3993) + nchar(53163) + nchar(42032) + nchar(62280) + ''' HASHED
	                                 ,DEFAULT_DATABASE = [master]
	                                 ,DEFAULT_LANGUAGE = us_english
	                                 ,SID = 0xE99E26F2E1E2EC4CA5E6A0FCE8428E00'
	        Print @cmd
	        Exec (@cmd)	
	   End

	If not exists (select * from master.sys.syslogins where name = N'DBAnoc')
	   Begin
	      select @cmd = 'CREATE LOGIN DBAnoc
	             WITH PASSWORD = ''' + nchar(1) + nchar(56379) + nchar(20772) + nchar(60193) + nchar(19399) + nchar(34827) + nchar(36812) + nchar(58446) + nchar(54406) + nchar(38215) + nchar(36564) + nchar(40566) + nchar(32177) + ''' HASHED
	                                 ,DEFAULT_DATABASE = [master]
	                                 ,DEFAULT_LANGUAGE = us_english
	                                 ,SID = 0xC573A5B6A0656D4B9B9CC974D730481D'
	        Print @cmd
	        Exec (@cmd)
	   End


	If not exists (select * from master.sys.syslogins where name = N'DBAsledridge')
	   Begin     
	      select @cmd = 'CREATE LOGIN DBAsledridge
                     WITH PASSWORD = ''' + nchar(1) + nchar(41296) + nchar(1583) + nchar(21335) + nchar(19647) + nchar(46885) + nchar(65354) + nchar(29756) + nchar(267) + nchar(62150) + nchar(4889) + nchar(5188) + nchar(65052) + ''' HASHED
	                                 ,DEFAULT_DATABASE = [master]
	                                 ,DEFAULT_LANGUAGE = us_english
	                                 ,SID = 0xDA7051DE8E677C4BBF93D9D4693A80D4'
	        Print @cmd
	        Exec (@cmd)
	   End


	exec sp_addsrvrolemember 'DBAamoss', 'sysadmin';
 
	exec sp_addsrvrolemember 'DBAjbrown', 'sysadmin';

	exec sp_addsrvrolemember 'DBAjimw', 'sysadmin';
 
	exec sp_addsrvrolemember 'DBAsledridge', 'sysadmin';

	exec sp_addsrvrolemember 'DBAnoc', 'sysadmin';

   
   end

drop table #loginconfig
drop table #DirectoryTempTable

go














---------------------------------
--  Update Build Table
---------------------------------
use dbaadmin
go


EXEC dbo.dbasp_UpdateBuild 'dbaadmin', '20100521', 'dbaadmin_2008_release_20100521.sql'
go

